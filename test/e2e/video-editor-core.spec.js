/**
 * Video Editor Core E2E Tests
 *
 * Tests video editor window lifecycle, video info retrieval,
 * FFmpeg operations, and version management via IPC.
 *
 * Run:  npx playwright test test/e2e/video-editor-core.spec.js
 */

const { test, expect } = require('@playwright/test');
const fs = require('fs');
const path = require('path');
const {
  launchApp,
  closeApp,
  snapshotErrors,
  checkNewErrors,
  filterBenignErrors,
  sleep,
} = require('./helpers/electron-app');

let app;
let electronApp;
let mainWindow;
let errorSnapshot;

// Path to test video file (generated by fixtures)
const sampleVideo = path.join(__dirname, '../fixtures/media/sample.mp4');
const hasVideo = fs.existsSync(sampleVideo);

test.describe('Video Editor Core', () => {
  test.beforeAll(async () => {
    app = await launchApp();
    electronApp = app.electronApp;
    mainWindow = app.mainWindow;
    errorSnapshot = await snapshotErrors();
  });

  test.afterAll(async () => {
    await closeApp(app);
  });

  // ═══════════════════════════════════════════════════════════════════════════
  // Window Lifecycle
  // ═══════════════════════════════════════════════════════════════════════════

  test('video editor window closes cleanly without orphaned processes', async () => {
    // Try to open and close the video editor
    await mainWindow.evaluate(async () => {
      try {
        if (window.api?.invoke) {
          await window.api.invoke('open-video-editor').catch(() => null);
        }
      } catch {
        /* no-op */
      }
    });

    await sleep(1000);

    // Find and close any video editor windows
    const windows = await electronApp.windows();
    const videoPage = windows.find((p) => {
      try {
        return p.url().includes('video-editor');
      } catch {
        return false;
      }
    });

    if (videoPage) {
      await videoPage.close();
      await sleep(500);
    }

    // Verify no orphaned video editor windows
    const afterWindows = await electronApp.windows();
    const orphaned = afterWindows.find((p) => {
      try {
        return p.url().includes('video-editor');
      } catch {
        return false;
      }
    });
    expect(!orphaned).toBeTruthy();
  });

  // ═══════════════════════════════════════════════════════════════════════════
  // Video Info
  // ═══════════════════════════════════════════════════════════════════════════

  test('video info populates duration, resolution, FPS, codec, bitrate', async () => {
    test.skip(!hasVideo, 'No test video file available');

    const result = await mainWindow.evaluate(async (videoPath) => {
      try {
        if (window.api?.invoke) {
          const info = await window.api.invoke('video-editor:get-info', videoPath);
          return { success: true, info };
        }
        return { success: false, note: 'No IPC' };
      } catch (e) {
        return { success: false, error: e.message };
      }
    }, sampleVideo);

    if (result.success && result.info) {
      expect(result.info.duration || result.info.format?.duration).toBeDefined();
    }
  });

  // ═══════════════════════════════════════════════════════════════════════════
  // FFmpeg Operations
  // ═══════════════════════════════════════════════════════════════════════════

  test('trim with fade-in/fade-out applies effects correctly', async () => {
    test.skip(!hasVideo, 'No test video file available');

    const result = await mainWindow.evaluate(async (videoPath) => {
      try {
        if (window.api?.invoke) {
          const trimResult = await window.api.invoke('video-editor:trim', {
            input: videoPath,
            start: 0,
            end: 2,
            fadeIn: 0.5,
            fadeOut: 0.5,
          });
          return { success: !!trimResult, result: trimResult };
        }
        return { success: false };
      } catch (e) {
        return { success: false, error: e.message };
      }
    }, sampleVideo);

    expect(result).toBeDefined();
  });

  test('trim without fades uses stream copy (fast, no re-encode)', async () => {
    test.skip(!hasVideo, 'No test video file available');

    const result = await mainWindow.evaluate(async (videoPath) => {
      try {
        if (window.api?.invoke) {
          const trimResult = await window.api.invoke('video-editor:trim', {
            input: videoPath,
            start: 0,
            end: 2,
          });
          return { success: !!trimResult, result: trimResult };
        }
        return { success: false };
      } catch (e) {
        return { success: false, error: e.message };
      }
    }, sampleVideo);

    expect(result).toBeDefined();
  });

  test('conversion produces a valid output file', async () => {
    test.skip(!hasVideo, 'No test video file available');

    const result = await mainWindow.evaluate(async (videoPath) => {
      try {
        if (window.api?.invoke) {
          const convertResult = await window.api.invoke('video-editor:convert', {
            input: videoPath,
            format: 'mp4',
          });
          return { success: !!convertResult, result: convertResult };
        }
        return { success: false };
      } catch (e) {
        return { success: false, error: e.message };
      }
    }, sampleVideo);

    expect(result).toBeDefined();
  });

  test('extract audio produces an audio-only file', async () => {
    test.skip(!hasVideo, 'No test video file available');

    const result = await mainWindow.evaluate(async (videoPath) => {
      try {
        if (window.api?.invoke) {
          const audioResult = await window.api.invoke('video-editor:extract-audio', {
            input: videoPath,
          });
          return { success: !!audioResult, result: audioResult };
        }
        return { success: false };
      } catch (e) {
        return { success: false, error: e.message };
      }
    }, sampleVideo);

    expect(result).toBeDefined();
  });

  test('compress reduces file size', async () => {
    test.skip(!hasVideo, 'No test video file available');

    const result = await mainWindow.evaluate(async (videoPath) => {
      try {
        if (window.api?.invoke) {
          const compressResult = await window.api.invoke('video-editor:compress', {
            input: videoPath,
            quality: 'medium',
          });
          return { success: !!compressResult, result: compressResult };
        }
        return { success: false };
      } catch (e) {
        return { success: false, error: e.message };
      }
    }, sampleVideo);

    expect(result).toBeDefined();
  });

  test('generate thumbnails produces thumbnail images', async () => {
    test.skip(!hasVideo, 'No test video file available');

    const result = await mainWindow.evaluate(async (videoPath) => {
      try {
        if (window.api?.invoke) {
          const thumbResult = await window.api.invoke('video-editor:generate-thumbnails', {
            input: videoPath,
            count: 3,
          });
          return { success: !!thumbResult, result: thumbResult };
        }
        return { success: false };
      } catch (e) {
        return { success: false, error: e.message };
      }
    }, sampleVideo);

    expect(result).toBeDefined();
  });

  // ═══════════════════════════════════════════════════════════════════════════
  // Version Management
  // ═══════════════════════════════════════════════════════════════════════════

  test('create new version from current state', async () => {
    const result = await mainWindow.evaluate(async () => {
      try {
        if (window.api?.invoke) {
          const version = await window.api.invoke('video-editor:create-version', {
            label: 'test-version',
          });
          return { success: !!version, version };
        }
        return { success: false };
      } catch (e) {
        return { success: false, error: e.message };
      }
    });

    expect(result).toBeDefined();
  });

  test('create branch from version', async () => {
    const result = await mainWindow.evaluate(async () => {
      try {
        if (window.api?.invoke) {
          const branch = await window.api.invoke('video-editor:create-branch', {
            name: 'test-branch',
          });
          return { success: !!branch, branch };
        }
        return { success: false };
      } catch (e) {
        return { success: false, error: e.message };
      }
    });

    expect(result).toBeDefined();
  });

  test('switch between branches', async () => {
    const result = await mainWindow.evaluate(async () => {
      try {
        if (window.api?.invoke) {
          const branches = await window.api.invoke('video-editor:list-branches');
          return { success: true, branches };
        }
        return { success: false };
      } catch (e) {
        return { success: false, error: e.message };
      }
    });

    expect(result).toBeDefined();
  });

  test('project saves to Space with version metadata', async () => {
    const result = await mainWindow.evaluate(async () => {
      try {
        if (window.api?.invoke) {
          const saveResult = await window.api.invoke('video-editor:save-project', {
            spaceId: null,
            includeMetadata: true,
          });
          return { success: !!saveResult, result: saveResult };
        }
        return { success: false };
      } catch (e) {
        return { success: false, error: e.message };
      }
    });

    expect(result).toBeDefined();
  });

  // ═══════════════════════════════════════════════════════════════════════════
  // Error check
  // ═══════════════════════════════════════════════════════════════════════════

  test('no unexpected errors during video editor tests', async () => {
    const errors = await checkNewErrors(errorSnapshot);
    const genuine = filterBenignErrors(errors);
    if (genuine.length > 0) {
      console.log(
        'Video editor test errors:',
        genuine.map((e) => e.message)
      );
    }
    expect(genuine.length).toBeLessThanOrEqual(5);
  });
});
