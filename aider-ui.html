<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GSX Create</title>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: file:; object-src 'self' file:; frame-src 'self' file:; img-src 'self' data: blob: file: https:; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline';">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        :root {
            --bg-primary: #0d0d1a;
            --bg-secondary: #1a1a2e;
            --bg-tertiary: #16213e;
            --accent: #4f8cff;
            --accent-hover: #6ba3ff;
            --success: #4cd964;
            --warning: #ffcc00;
            --danger: #ff3b30;
            --text-primary: #e8e8e8;
            --text-secondary: #a0a0a0;
            --text-muted: #666;
            --border: rgba(255,255,255,0.08);
            --border-light: rgba(255,255,255,0.15);
        }
        
        body {
            font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
            background: var(--bg-primary);
            color: var(--text-primary);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        /* Header */
        .header {
            background: var(--bg-secondary);
            padding: 12px 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }
        
        .header h1 {
            font-size: 16px;
            font-weight: 500;
            color: var(--text-primary);
            letter-spacing: 0.5px;
        }
        
        .header-right {
            display: flex;
            align-items: center;
            gap: 16px;
        }
        
        .cost-display {
            display: none;
            align-items: center;
            gap: 4px;
            padding: 8px 14px 12px 14px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.2s;
            position: relative;
        }
        .cost-display:hover { background: rgba(79,140,255,0.15); }
        .cost-display.visible { display: flex; }
        
        .cost-badge {
            color: var(--success);
            font-weight: 600;
            font-size: 12px;
        }
        .cost-badge.warning { color: var(--warning); }
        .cost-badge.danger { color: var(--danger); }
        .cost-separator {
            color: var(--text-muted);
            font-size: 10px;
        }
        .budget-badge {
            color: var(--text-secondary);
            font-weight: 500;
            font-size: 11px;
        }
        .budget-progress {
            position: absolute;
            bottom: 4px;
            left: 10px;
            right: 10px;
            height: 3px;
            background: var(--bg-primary);
            border-radius: 2px;
            overflow: hidden;
        }
        .budget-fill {
            height: 100%;
            background: var(--success);
            transition: width 0.3s, background 0.3s;
            border-radius: 2px;
        }
        .budget-fill.warning { background: var(--warning); }
        .budget-fill.danger { background: var(--danger); }
        
        .status {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: var(--text-secondary);
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--danger);
        }
        .status-dot.active { background: var(--success); }
        
        /* Main Layout */
        .main-container {
            flex: 1;
            display: flex;
            overflow: hidden;
        }
        
        /* Sidebar */
        .sidebar-container {
            display: flex;
            flex-shrink: 0;
        }
        
        .sidebar {
            width: 260px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            overflow-x: hidden;
            transition: width 0.2s ease;
            position: relative;
        }
        
        .sidebar.collapsed {
            width: 0;
            border-right: none;
        }
        
        .sidebar-toggle {
            position: absolute;
            right: -24px;
            top: 50%;
            transform: translateY(-50%);
            width: 24px;
            height: 60px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-left: none;
            border-radius: 0 8px 8px 0;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            z-index: 100;
        }
        .sidebar-toggle:hover { 
            background: var(--accent); 
            color: #fff; 
        }
        
        .sidebar-section {
            padding: 12px;
            border-bottom: 1px solid var(--border);
        }
        
        .sidebar-section h3 {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-secondary);
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .badge {
            background: var(--accent);
            color: #fff;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
        }
        
        /* Episodic Memory Tabs */
        .episodic-tab {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            color: var(--text-secondary);
            transition: all 0.2s;
        }
        .episodic-tab:hover {
            background: var(--bg-primary);
        }
        .episodic-tab.active {
            background: var(--accent);
            border-color: var(--accent);
            color: #fff;
        }
        
        /* Space Selector */
        .space-selector {
            width: 100%;
            padding: 8px 10px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 12px;
            cursor: pointer;
        }
        .space-selector:focus { outline: none; border-color: var(--accent); }
        
        /* File List */
        .file-list {
            flex: 1;
            overflow-y: auto;
            padding: 8px 0;
            transition: all 0.2s ease;
            border: 2px dashed transparent;
            border-radius: 6px;
        }
        
        .file-list.drag-over {
            border-color: var(--accent);
            background: rgba(59, 130, 246, 0.1);
        }
        
        .file-item {
            padding: 6px 12px;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background 0.15s;
            color: var(--text-secondary);
        }
        .file-item:hover { background: rgba(255,255,255,0.05); }
        .file-item.in-context { 
            background: rgba(79,140,255,0.15); 
            color: var(--accent);
        }
        .file-item .icon { opacity: 0.6; }
        .file-item .preview-icon { 
            margin-left: auto; 
            opacity: 0.4; 
            font-size: 10px;
        }
        .file-item:hover .preview-icon { opacity: 0.8; }
        
        /* Center Area */
        .center-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
        }
        
        /* Setup Panel */
        .setup-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px;
            text-align: center;
        }
        
        .setup-panel.hidden { display: none; }
        
        .setup-hero {
            max-width: 500px;
        }
        
        .setup-hero img {
            width: 100%;
            max-width: 400px;
            margin-bottom: 24px;
            border-radius: 12px;
            opacity: 0.9;
        }
        
        .setup-hero h2 {
            font-size: 24px;
            font-weight: 500;
            margin-bottom: 12px;
            color: var(--text-primary);
        }
        
        .setup-hero p {
            color: var(--text-secondary);
            font-size: 14px;
            margin-bottom: 24px;
            line-height: 1.6;
        }
        
        .setup-form {
            display: flex;
            flex-direction: column;
            gap: 12px;
            width: 100%;
            max-width: 400px;
        }
        
        .form-group {
            text-align: left;
        }
        
        .form-group label {
            display: block;
            font-size: 11px;
            color: var(--text-secondary);
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .form-select, .form-input {
            width: 100%;
            padding: 10px 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 13px;
        }
        .form-select:focus, .form-input:focus { 
            outline: none; 
            border-color: var(--accent); 
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .btn-primary {
            background: var(--accent);
            color: #fff;
        }
        .btn-primary:hover { background: var(--accent-hover); }
        .btn-primary:disabled { opacity: 0.5; cursor: not-allowed; }
        
        .btn-test {
            background: linear-gradient(135deg, #8b5cf6 0%, #6366f1 100%);
            color: #fff;
            font-size: 16px;
            padding: 8px 12px;
            border-radius: 8px;
            transition: all 0.2s;
        }
        .btn-test:hover { 
            background: linear-gradient(135deg, #7c3aed 0%, #4f46e5 100%);
            transform: scale(1.05);
        }
        .btn-test:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-test.running {
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        
        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border);
        }
        .btn-secondary:hover { background: rgba(255,255,255,0.1); }
        
        .btn-sm {
            padding: 6px 12px;
            font-size: 11px;
        }
        
        /* Chat Area */
        .chat-area {
            flex: 1;
            display: none;
            flex-direction: column;
            overflow: hidden;
        }
        .chat-area.active { display: flex; }
        
        /* Chat Toolbar */
        .chat-toolbar {
            display: flex;
            gap: 8px;
            padding: 8px 12px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            flex-wrap: wrap;
        }
        .chat-toolbar .spacer {
            flex: 1;
        }
        
        /* Feed-style messages */
        .messages {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            font-family: 'SF Mono', 'Fira Code', monospace;
            font-size: 12px;
            line-height: 1.6;
            background: var(--bg-primary);
        }
        
        .message {
            padding: 8px 0;
            border-bottom: 1px solid var(--border);
            display: flex;
            gap: 12px;
        }
        
        .message-time {
            color: var(--text-muted);
            font-size: 10px;
            min-width: 60px;
            flex-shrink: 0;
        }
        
        .message-type {
            min-width: 40px;
            font-weight: 600;
            flex-shrink: 0;
        }
        .message-type.user { color: var(--accent); }
        .message-type.ai { color: var(--success); }
        .message-type.system { color: var(--warning); }
        .message-type.error { color: var(--danger); }
        
        .message-content {
            flex: 1;
            white-space: pre-wrap;
            word-break: break-word;
        }
        
        .message-files {
            margin-top: 8px;
            padding: 8px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            font-size: 11px;
        }
        
        /* Streaming message styles */
        .message-content.streaming {
            background: var(--bg-tertiary);
            padding: 12px;
            border-radius: 6px;
            border-left: 3px solid var(--accent);
        }
        .streaming-status {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: var(--bg-primary);
            border-radius: 6px;
            margin-bottom: 12px;
            font-size: 13px;
        }
        .streaming-status .status-icon {
            font-size: 16px;
        }
        .streaming-status .status-text {
            color: var(--accent);
            font-weight: 500;
            flex: 1;
        }
        .streaming-status .status-timer {
            color: var(--text-muted);
            font-size: 11px;
            font-family: monospace;
        }
        .thinking-indicator {
            color: var(--accent);
            font-style: italic;
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .stream-output {
            margin: 0;
            padding: 0;
            white-space: pre-wrap;
            word-break: break-word;
            font-family: inherit;
            font-size: inherit;
            background: transparent;
            max-height: 400px;
            overflow-y: auto;
        }
        
        /* Collapsible code blocks */
        .code-collapse {
            margin: 8px 0;
            border: 1px solid var(--border);
            border-radius: 6px;
            background: var(--bg-primary);
            overflow: hidden;
        }
        .code-collapse summary {
            padding: 8px 12px;
            cursor: pointer;
            font-size: 12px;
            color: var(--text-muted);
            background: var(--bg-secondary);
            user-select: none;
        }
        .code-collapse summary:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        .code-collapse[open] summary {
            border-bottom: 1px solid var(--border);
        }
        .collapsed-code {
            margin: 0;
            padding: 12px;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
            font-size: 11px;
            line-height: 1.5;
            max-height: 300px;
            overflow-y: auto;
            background: #1a1a1a;
            color: #d4d4d4;
        }
        
        /* Meta Learning Cycle Panel - Minimal */
        .cycle-panel {
            display: none;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            padding: 8px 16px;
            flex-shrink: 0;
        }
        .cycle-panel.visible { display: flex; align-items: center; gap: 16px; }
        .cycle-label {
            font-size: 10px;
            font-weight: 600;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .cycle-version {
            font-size: 10px;
            color: var(--text-muted);
            font-weight: 500;
            min-width: 24px;
        }
        
        /* Inline Phase Pipeline */
        .cycle-pipeline {
            display: flex;
            align-items: center;
            gap: 4px;
            flex: 1;
        }
        .phase-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--border);
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }
        .phase-dot:hover {
            transform: scale(1.3);
        }
        .phase-dot:hover::after {
            content: attr(data-label);
            position: absolute;
            bottom: 14px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 9px;
            color: var(--text-secondary);
            white-space: nowrap;
            background: var(--bg-tertiary);
            padding: 2px 6px;
            border-radius: 3px;
        }
        .phase-dot.active {
            background: var(--accent);
            box-shadow: 0 0 8px var(--accent);
            animation: pulse-dot 1.5s infinite;
        }
        .phase-dot.completed { background: var(--success); }
        .phase-dot.failed { background: var(--danger); }
        .phase-line {
            width: 20px;
            height: 1px;
            background: var(--border);
        }
        .phase-line.active { background: var(--accent); }
        .phase-line.completed { background: var(--success); }
        
        @keyframes pulse-dot {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        /* Compact Version Pills */
        .version-timeline {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .version-pill {
            padding: 2px 8px;
            background: transparent;
            border: 1px solid var(--border);
            border-radius: 10px;
            font-size: 9px;
            color: var(--text-muted);
            cursor: pointer;
            transition: all 0.2s;
        }
        .version-pill:hover {
            border-color: var(--accent);
            color: var(--text-primary);
        }
        .version-pill.current {
            background: var(--accent);
            border-color: var(--accent);
            color: #fff;
        }
        .version-pill.add {
            border-style: dashed;
            padding: 2px 6px;
        }
        
        /* Compact Progress */
        .cycle-progress {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 10px;
            color: var(--text-muted);
        }
        .progress-bar-mini {
            width: 40px;
            height: 3px;
            background: var(--bg-primary);
            border-radius: 2px;
            overflow: hidden;
        }
        .progress-fill-mini {
            height: 100%;
            background: var(--accent);
            transition: width 0.3s;
        }
        .progress-fill-mini.good { background: var(--success); }
        .progress-fill-mini.warning { background: var(--warning); }
        
        /* Cycle Control Button */
        .cycle-ctrl {
            width: 20px;
            height: 20px;
            border: none;
            border-radius: 50%;
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            font-size: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        .cycle-ctrl:hover {
            background: var(--accent);
            color: #fff;
        }
        .cycle-ctrl.running {
            background: var(--success);
            color: #000;
        }
        .cycle-ctrl.paused {
            background: var(--warning);
            color: #000;
        }
        .cycle-auto-toggle {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: transparent;
            color: var(--text-muted);
            border: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            margin-left: 6px;
            opacity: 0.5;
            flex-shrink: 0;
        }
        .cycle-auto-toggle:hover {
            opacity: 1;
            border-color: var(--text-secondary);
            color: var(--text-secondary);
        }
        .cycle-auto-toggle.active {
            background: var(--accent);
            color: #fff;
            border-color: var(--accent);
            opacity: 1;
        }
        .cycle-auto-toggle svg {
            width: 10px;
            height: 10px;
        }
        .cycle-help {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            font-size: 10px;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            margin-left: auto;
        }
        .cycle-help:hover {
            background: var(--accent);
            color: #fff;
        }
        .progress-label {
            color: var(--text-secondary);
        }
        .progress-bar {
            width: 120px;
            height: 6px;
            background: var(--bg-primary);
            border-radius: 3px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: var(--accent);
            border-radius: 3px;
            transition: width 0.3s;
        }
        .progress-fill.good { background: var(--success); }
        .progress-fill.warning { background: var(--warning); }
        .progress-fill.danger { background: var(--danger); }
        .progress-score {
            font-weight: 600;
            color: var(--text-primary);
        }
        .progress-target {
            color: var(--text-muted);
        }
        
        /* Test Agent Styles */
        .test-tab {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            color: var(--text-secondary);
        }
        .test-tab.active {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }
        .test-panel {
            display: none;
        }
        .test-panel.active {
            display: block;
        }
        .test-result-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 12px;
            background: var(--bg-tertiary);
            border-radius: 6px;
            margin-bottom: 8px;
        }
        .test-result-item.passed {
            border-left: 3px solid var(--success);
        }
        .test-result-item.failed {
            border-left: 3px solid var(--error);
        }
        .test-status-icon {
            font-size: 16px;
        }
        .test-name {
            flex: 1;
            font-size: 12px;
            color: var(--text-primary);
        }
        .test-duration {
            font-size: 11px;
            color: var(--text-muted);
        }
        .accessibility-issue {
            padding: 10px 12px;
            background: var(--bg-tertiary);
            border-radius: 6px;
            margin-bottom: 8px;
            font-size: 12px;
        }
        .accessibility-issue.error {
            border-left: 3px solid var(--error);
        }
        .accessibility-issue.warning {
            border-left: 3px solid #f59e0b;
        }
        .performance-metric {
            display: flex;
            justify-content: space-between;
            padding: 8px 12px;
            background: var(--bg-tertiary);
            border-radius: 6px;
            margin-bottom: 6px;
        }
        .performance-score {
            font-size: 48px;
            font-weight: 700;
            text-align: center;
            padding: 20px;
        }
        .performance-score.good { color: var(--success); }
        .performance-score.ok { color: #f59e0b; }
        .performance-score.bad { color: var(--error); }
        
        /* Code Tools */
        .code-tool-tab {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
        }
        .code-tool-tab.active {
            background: var(--accent);
            border-color: var(--accent);
            color: #fff;
        }
        .code-tool-panel {
            display: none;
        }
        .code-tool-panel.active {
            display: block;
        }
        .code-result-item {
            padding: 10px;
            border-bottom: 1px solid var(--border);
            cursor: pointer;
            transition: background 0.2s;
        }
        .code-result-item:hover {
            background: var(--bg-tertiary);
        }
        .code-result-file {
            color: var(--accent);
            font-weight: 600;
            margin-bottom: 4px;
        }
        .code-result-line {
            color: var(--text-muted);
            font-size: 10px;
        }
        .code-result-content {
            color: var(--text-primary);
            background: var(--bg-primary);
            padding: 6px 8px;
            border-radius: 4px;
            margin-top: 6px;
            overflow-x: auto;
        }
        
        .file-change {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 0;
        }
        .file-change.created { color: var(--success); }
        .file-change.modified { color: var(--warning); }
        
        /* Input Area */
        .input-area {
            padding: 12px 16px;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border);
            display: flex;
            gap: 12px;
            align-items: flex-end;
        }
        
        .input-wrapper {
            flex: 1;
            display: flex;
            align-items: center;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 0 12px;
        }
        
        .input-prefix {
            color: var(--accent);
            font-weight: bold;
            margin-right: 8px;
        }
        
        .input-wrapper textarea {
            flex: 1;
            background: transparent;
            border: none;
            color: var(--text-primary);
            font-family: inherit;
            font-size: 13px;
            padding: 10px 0;
            resize: none;
            min-height: 40px;
            max-height: 150px;
        }
        .input-wrapper textarea:focus { outline: none; }
        .input-wrapper textarea::placeholder { color: var(--text-muted); }
        
        /* Preview Panel */
        .preview-panel {
            width: 400px;
            min-width: 200px;
            max-width: 70%;
            background: var(--bg-secondary);
            border-left: 1px solid var(--border);
            display: none;
            flex-direction: column;
            flex-shrink: 0;
            position: relative;
        }
        .preview-panel.active { display: flex; }
        .preview-panel.collapsed { 
            width: 40px !important; 
            min-width: 40px !important; 
        }
        .preview-panel.collapsed .preview-content,
        .preview-panel.collapsed .preview-header > *:not(.preview-toggle) {
            display: none;
        }
        
        /* Resize handle for preview panel - left edge */
        .preview-resize-handle {
            position: absolute;
            left: -3px;
            top: 0;
            bottom: 0;
            width: 8px;
            cursor: ew-resize;
            background: transparent;
            z-index: 20;
        }
        .preview-resize-handle::after {
            content: '';
            position: absolute;
            left: 3px;
            top: 0;
            bottom: 0;
            width: 2px;
            background: transparent;
            transition: background 0.2s;
        }
        .preview-resize-handle:hover::after,
        .preview-resize-handle.dragging::after {
            background: var(--accent);
        }
        
        /* Preview toggle button */
        .preview-toggle {
            position: absolute;
            left: -20px;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
            height: 48px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-right: none;
            border-radius: 6px 0 0 6px;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            transition: background 0.2s;
            z-index: 15;
        }
        .preview-toggle:hover { 
            background: var(--accent); 
            color: #fff; 
        }
        
        .preview-header {
            padding: 10px 12px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }
        
        .preview-tabs {
            display: flex;
            gap: 4px;
        }
        
        .preview-tab {
            padding: 4px 10px;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 11px;
            cursor: pointer;
            border-radius: 4px;
        }
        .preview-tab.active {
            background: var(--accent);
            color: #fff;
        }
        
        .preview-actions {
            display: flex;
            gap: 4px;
        }
        
        .preview-actions button {
            padding: 4px 8px;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            color: var(--text-secondary);
            font-size: 10px;
            border-radius: 4px;
            cursor: pointer;
        }
        .preview-actions button:hover { 
            background: var(--accent); 
            color: #fff; 
            border-color: var(--accent);
        }
        
        .preview-content {
            flex: 1;
            overflow: hidden;
            background: var(--bg-primary);
            position: relative;
        }
        
        .preview-content iframe {
            width: 100%;
            height: 100%;
            border: none;
        }
        
        .preview-empty {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-muted);
            font-size: 12px;
        }
        
        /* Config Panel (collapsible) */
        .config-panel {
            padding: 12px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border);
            display: none;
        }
        .config-panel.active { display: block; }
        
        .config-row {
            display: flex;
            gap: 12px;
            margin-bottom: 10px;
        }
        
        .config-row:last-child { margin-bottom: 0; }
        
        .config-group {
            flex: 1;
        }
        
        .config-group label {
            display: block;
            font-size: 10px;
            color: var(--text-secondary);
            margin-bottom: 4px;
            text-transform: uppercase;
        }
        
        .config-group select,
        .config-group input {
            width: 100%;
            padding: 6px 8px;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 11px;
        }
        
        /* Global Instructions */
        .global-instructions {
            padding: 12px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border);
            display: none;
        }
        .global-instructions.active { display: block; }
        
        .global-instructions textarea {
            width: 100%;
            height: 80px;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 11px;
            padding: 8px;
            resize: vertical;
            font-family: inherit;
        }
        
        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        .modal.active { display: flex; }
        
        .modal-content {
            background: var(--bg-secondary);
            border-radius: 12px;
            width: 90%;
            max-width: 800px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            border: 1px solid var(--border);
        }
        
        .modal-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .modal-header h3 { font-size: 14px; font-weight: 500; }
        
        .modal-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 20px;
            cursor: pointer;
        }
        
        .modal-body {
            flex: 1;
            overflow-y: auto;
            padding: 16px 20px;
        }
        
        /* Error Analyzer Modal */
        .error-modal .modal-content {
            max-width: 700px;
            border-color: var(--danger);
        }
        .error-modal .modal-header {
            background: rgba(255, 59, 48, 0.1);
            border-bottom-color: var(--danger);
        }
        .error-modal .modal-header h3 {
            color: var(--danger);
        }
        .error-section {
            margin-bottom: 16px;
        }
        .error-section-title {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            margin-bottom: 8px;
        }
        .error-message {
            background: rgba(255, 59, 48, 0.1);
            border: 1px solid rgba(255, 59, 48, 0.3);
            border-radius: 6px;
            padding: 12px;
            font-family: 'SF Mono', monospace;
            font-size: 12px;
            color: #ff6b6b;
            white-space: pre-wrap;
            word-break: break-word;
        }
        .error-stack {
            background: var(--bg-tertiary);
            border-radius: 6px;
            padding: 12px;
            font-family: 'SF Mono', monospace;
            font-size: 10px;
            color: var(--text-secondary);
            max-height: 120px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        .error-ai-analysis {
            background: var(--bg-tertiary);
            border-radius: 6px;
            padding: 12px;
            font-size: 12px;
            line-height: 1.5;
        }
        .error-ai-analysis.loading {
            color: var(--text-muted);
            font-style: italic;
        }
        .error-location {
            display: flex;
            gap: 12px;
            font-size: 11px;
        }
        .error-location-item {
            background: var(--bg-tertiary);
            padding: 6px 10px;
            border-radius: 4px;
        }
        .error-location-label {
            color: var(--text-muted);
            margin-right: 4px;
        }
        .error-actions {
            display: flex;
            gap: 8px;
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid var(--border);
        }
        .error-actions button {
            padding: 8px 16px;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
        }
        .error-btn-fix {
            background: var(--accent);
            color: white;
        }
        .error-btn-log {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border) !important;
        }
        .error-btn-dismiss {
            background: transparent;
            color: var(--text-secondary);
            margin-left: auto;
        }
        
        /* Quick Log Modal */
        .quick-log-modal {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 400px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            z-index: 1001;
            display: none;
            animation: slideUp 0.2s ease;
        }
        .quick-log-modal.active { display: block; }
        @keyframes slideUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .quick-log-header {
            padding: 12px 16px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .quick-log-header h4 {
            font-size: 13px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .quick-log-type {
            font-size: 10px;
            padding: 2px 8px;
            border-radius: 10px;
            background: var(--bg-tertiary);
        }
        .quick-log-type.error { background: rgba(255,59,48,0.2); color: var(--danger); }
        .quick-log-type.warning { background: rgba(255,204,0,0.2); color: var(--warning); }
        .quick-log-type.info { background: rgba(79,140,255,0.2); color: var(--accent); }
        .quick-log-body {
            padding: 12px 16px;
        }
        .quick-log-field {
            margin-bottom: 12px;
        }
        .quick-log-field label {
            display: block;
            font-size: 10px;
            color: var(--text-muted);
            text-transform: uppercase;
            margin-bottom: 4px;
        }
        .quick-log-field textarea,
        .quick-log-field input {
            width: 100%;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 8px 10px;
            font-size: 12px;
            color: var(--text-primary);
            font-family: inherit;
            resize: vertical;
        }
        .quick-log-field textarea { min-height: 60px; }
        .quick-log-field textarea:focus,
        .quick-log-field input:focus {
            outline: none;
            border-color: var(--accent);
        }
        .quick-log-ai {
            background: var(--bg-tertiary);
            border-radius: 6px;
            padding: 10px;
            font-size: 11px;
            line-height: 1.5;
            max-height: 100px;
            overflow-y: auto;
        }
        .quick-log-ai.loading {
            color: var(--text-muted);
            font-style: italic;
        }
        .quick-log-actions {
            padding: 12px 16px;
            border-top: 1px solid var(--border);
            display: flex;
            gap: 8px;
            justify-content: flex-end;
        }
        .quick-log-actions button {
            padding: 6px 14px;
            border-radius: 6px;
            border: none;
            font-size: 12px;
            cursor: pointer;
        }
        .quick-log-save {
            background: var(--accent);
            color: white;
        }
        .quick-log-dismiss {
            background: transparent;
            color: var(--text-secondary);
        }
        
        /* Log Table */
        .log-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px;
        }
        
        .log-table th, .log-table td {
            padding: 8px 10px;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }
        
        .log-table th {
            background: var(--bg-tertiary);
            font-weight: 600;
            position: sticky;
            top: 0;
        }
        
        .log-table tr:hover { background: rgba(255,255,255,0.03); }
        
        /* Scrollbar */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: var(--bg-primary); }
        ::-webkit-scrollbar-thumb { background: var(--border-light); border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--text-muted); }
        
        /* No API Key Warning */
        .no-api-warning {
            background: rgba(255,59,48,0.1);
            border: 1px solid var(--danger);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: center;
        }
        .no-api-warning h3 { color: var(--danger); margin-bottom: 8px; }
        .no-api-warning p { color: var(--text-secondary); font-size: 13px; }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <h1>GSX Create</h1>
        <div class="header-right">
            <div class="cost-display" id="costDisplay" onclick="GSXCreate.showBudgetModal()">
                <span class="cost-badge" id="costBadge">$0.00</span>
                <span class="cost-separator">/</span>
                <span class="budget-badge" id="budgetBadge">‚àû</span>
                <div class="budget-progress" id="budgetProgress">
                    <div class="budget-fill" id="budgetFill" style="width: 0%"></div>
                </div>
            </div>
        <div class="status">
            <span class="status-dot" id="statusDot"></span>
            <span id="statusText">Not Connected</span>
            </div>
        </div>
    </div>
    
    <!-- Error Analyzer Modal -->
    <div class="modal error-modal" id="errorAnalyzerModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>‚ö†Ô∏è Error Detected</h3>
                <button class="modal-close" onclick="GSXCreate.closeErrorModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="error-section">
                    <div class="error-section-title">Error Message</div>
                    <div class="error-message" id="errorMessage">Loading...</div>
                </div>
                
                <div class="error-section">
                    <div class="error-section-title">Location</div>
                    <div class="error-location" id="errorLocation">
                        <div class="error-location-item">
                            <span class="error-location-label">File:</span>
                            <span id="errorFile">-</span>
                        </div>
                        <div class="error-location-item">
                            <span class="error-location-label">Line:</span>
                            <span id="errorLine">-</span>
                        </div>
                    </div>
                </div>
                
                <div class="error-section">
                    <div class="error-section-title">Stack Trace</div>
                    <div class="error-stack" id="errorStack">No stack trace available</div>
                </div>
                
                <div class="error-section">
                    <div class="error-section-title">AI Analysis</div>
                    <div class="error-ai-analysis loading" id="errorAIAnalysis">üîç Analyzing error...</div>
                </div>
                
                <div class="error-actions">
                    <button class="error-btn-fix" onclick="GSXCreate.fixError()" id="errorFixBtn" disabled>üîß Fix This Error</button>
                    <button class="error-btn-log" onclick="GSXCreate.saveErrorToLog()">üìù Save to Log</button>
                    <button class="error-btn-dismiss" onclick="GSXCreate.closeErrorModal()">Dismiss</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Quick Log Modal (for global logging) -->
    <div class="quick-log-modal" id="quickLogModal">
        <div class="quick-log-header">
            <h4>
                üìù Log Event
                <span class="quick-log-type" id="quickLogType">error</span>
            </h4>
            <button class="modal-close" onclick="GSXCreate.closeQuickLog()" style="background:none;border:none;color:var(--text-secondary);font-size:18px;cursor:pointer;">&times;</button>
        </div>
        <div class="quick-log-body">
            <div class="quick-log-field">
                <label>Summary</label>
                <input type="text" id="quickLogSummary" placeholder="Brief description of what happened">
            </div>
            <div class="quick-log-field">
                <label>AI Explanation</label>
                <div class="quick-log-ai loading" id="quickLogAI">üîç Generating explanation...</div>
            </div>
            <div class="quick-log-field">
                <label>Additional Notes (optional)</label>
                <textarea id="quickLogNotes" placeholder="Add any extra context or notes..."></textarea>
            </div>
        </div>
        <div class="quick-log-actions">
            <button class="quick-log-dismiss" onclick="GSXCreate.closeQuickLog()">Dismiss</button>
            <button class="quick-log-save" onclick="GSXCreate.saveQuickLog()">üíæ Save to Log</button>
        </div>
    </div>
    
    <!-- Meta Learning Cycle Panel - Minimal -->
    <div class="cycle-panel" id="cyclePanel">
        <span class="cycle-label">Meta Learning Cycle</span>
        <button class="cycle-ctrl" id="cycleCtrlBtn" onclick="GSXCreate.toggleCycle()" title="Start Meta Learning">‚ñ∂</button>
        <span class="cycle-version" id="cycleVersion">v1</span>
        
        <div class="cycle-pipeline">
            <div class="phase-dot" id="phase-evaluate" data-label="Evaluate" onclick="GSXCreate.goToPhase('evaluate')"></div>
            <div class="phase-line" id="line-0"></div>
            <div class="phase-dot" id="phase-research" data-label="Research" onclick="GSXCreate.goToPhase('research')"></div>
            <div class="phase-line" id="line-1"></div>
            <div class="phase-dot" id="phase-plan" data-label="Plan" onclick="GSXCreate.goToPhase('plan')"></div>
            <div class="phase-line" id="line-2"></div>
            <div class="phase-dot" id="phase-execute" data-label="Execute" onclick="GSXCreate.goToPhase('execute')"></div>
            <div class="phase-line" id="line-3"></div>
            <div class="phase-dot" id="phase-test" data-label="Test" onclick="GSXCreate.goToPhase('test')"></div>
            <div class="phase-line" id="line-4"></div>
            <div class="phase-dot" id="phase-improve" data-label="Improve" onclick="GSXCreate.goToPhase('improve')"></div>
            <div class="phase-line" id="line-5"></div>
            <div class="phase-dot" id="phase-finalize" data-label="Finalize" onclick="GSXCreate.goToPhase('finalize')"></div>
            <button class="cycle-auto-toggle" id="autoCycleBtn" onclick="GSXCreate.toggleAutoCycle()" title="Auto-cycle: Off (click to toggle)">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/>
                    <path d="M3 3v5h5"/>
                </svg>
            </button>
        </div>
        
        <div class="version-timeline" id="versionTimeline"></div>
        
        <div class="cycle-progress">
            <div class="progress-bar-mini">
                <div class="progress-fill-mini" id="cycleProgressFill" style="width: 0%"></div>
            </div>
            <span id="cycleScore">0%</span>
        </div>
        
        <div class="cycle-help" onclick="GSXCreate.showCycleHelp()">?</div>
    </div>
    
    <!-- Main Container -->
    <div class="main-container">
        <!-- Sidebar (hidden until session starts) -->
        <div class="sidebar-container" id="sidebarContainer" style="display: none;">
            <div class="sidebar" id="sidebar">
                <!-- Toggle button - positioned on right edge -->
                <button class="sidebar-toggle" id="sidebarToggle" onclick="GSXCreate.toggleSidebar()" title="Toggle sidebar">
                    <span id="sidebarToggleIcon">‚óÄ</span>
                </button>
                <!-- Space Selection -->
                <div class="sidebar-section">
                    <h3>Space</h3>
                    <select class="space-selector" id="spaceSelect" onchange="GSXCreate.selectSpace(this.value)">
                        <option value="">Select a space...</option>
                    </select>
                </div>
                
                <!-- Constitutional Memory (shown after space selected) -->
                <div class="sidebar-section" id="configSection" style="display: none;">
                    <h3 style="display: flex; align-items: center; justify-content: space-between; cursor: pointer;" onclick="GSXCreate.toggleConfigSection()">
                        <span>Constitutional Memory</span>
                        <span id="configToggleIcon" style="font-size: 10px; transition: transform 0.2s;">‚ñ∂</span>
                    </h3>
                    <div id="configSectionContent" style="display: none;">
                        <!-- Constitutional Files Status -->
                        <div id="constitutionalStatus" style="margin-bottom: 10px; font-size: 10px;">
                            <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 4px;">
                                <span id="styleGuideStatus" style="color: var(--text-muted);">‚óã</span>
                                <span>Style Guide</span>
                            </div>
                            <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 4px;">
                                <span id="journeyMapStatus" style="color: var(--text-muted);">‚óã</span>
                                <span>Journey Map</span>
                            </div>
                            <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 4px;">
                                <span id="criteriaStatus" style="color: var(--text-muted);">‚óã</span>
                                <span>Evaluation Criteria</span>
                            </div>
                        </div>
                        
                        <!-- Summary Status -->
                        <div id="summaryStatus" style="font-size: 10px; color: var(--text-muted); margin-bottom: 8px; padding: 6px; background: var(--bg-tertiary); border-radius: 4px;">
                            No summary loaded
                        </div>
                        
                        <div class="form-group" style="margin-bottom: 8px;">
                            <label>Style Guide</label>
                            <select class="form-select" id="styleGuideSelect" style="padding: 6px 8px; font-size: 11px;">
                                <option value="">None</option>
                            </select>
                        </div>
                        <div class="form-group" style="margin-bottom: 8px;">
                            <label>Journey Map</label>
                            <select class="form-select" id="journeyMapSelect" style="padding: 6px 8px; font-size: 11px;">
                                <option value="">None</option>
                            </select>
                        </div>
                        
                        <div style="display: flex; gap: 6px; margin-top: 8px;">
                            <button class="btn btn-primary btn-sm" style="flex: 1;" onclick="GSXCreate.startSession()" id="startBtn">
                                Start Session
                            </button>
                            <button class="btn btn-secondary btn-sm" onclick="GSXCreate.refreshConstitutionalMemory()" title="Refresh constitutional memory" style="padding: 6px 10px;">
                                üîÑ
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- Reference Memory -->
                <div class="sidebar-section">
                    <h3 style="display: flex; align-items: center; justify-content: space-between;">
                        <span>
                            Reference Memory
                            <span class="badge" id="fileCount">0</span>
                        </span>
                        <button class="btn btn-sm" onclick="GSXCreate.triggerFileUpload()" title="Upload file" style="padding: 2px 6px; font-size: 14px;">
                            +
                        </button>
                    </h3>
                    <input type="file" id="fileUploadInput" multiple style="display: none;" onchange="GSXCreate.handleFileUpload(event)">
                    <div class="file-list" id="fileList" style="max-height: 180px; overflow-y: auto;"
                         ondragover="GSXCreate.handleDragOver(event)" 
                         ondragleave="GSXCreate.handleDragLeave(event)" 
                         ondrop="GSXCreate.handleFileDrop(event)">
                        <div style="color: var(--text-muted); font-size: 11px; padding: 8px;">
                            Select a space to see files
                        </div>
                    </div>
                </div>
                
                <!-- Context Files -->
                <div class="sidebar-section">
                    <h3>
                        In Context
                        <span class="badge" id="contextCount">0</span>
                    </h3>
                    <div id="contextList" style="max-height: 120px; overflow-y: auto;">
                        <div style="color: var(--text-muted); font-size: 11px;">
                            Click files to add to context
                        </div>
                    </div>
                </div>
                
                <!-- Episodic Memory -->
                <div class="sidebar-section">
                    <h3 style="display: flex; align-items: center; justify-content: space-between;">
                        <span>Episodic Memory</span>
                        <button class="btn btn-sm" onclick="GSXCreate.showTransactionLogs()" title="View all history" style="padding: 2px 6px; font-size: 10px;">
                            ‚Üó
                        </button>
                    </h3>
                    
                    <!-- Episodic Memory Tabs -->
                    <div style="display: flex; gap: 4px; margin-bottom: 8px;">
                        <button class="btn btn-sm episodic-tab active" id="historyTab" onclick="GSXCreate.switchEpisodicTab('history')" style="flex: 1; padding: 4px 8px; font-size: 10px;">
                            üìú History <span class="badge" id="historyCount" style="font-size: 9px;">0</span>
                        </button>
                        <button class="btn btn-sm episodic-tab" id="planTab" onclick="GSXCreate.switchEpisodicTab('plan')" style="flex: 1; padding: 4px 8px; font-size: 10px;">
                            üìã Plan <span class="badge" id="planCount" style="font-size: 9px;">0</span>
                        </button>
                    </div>
                    
                    <!-- History Panel (what we did) -->
                    <div id="historyPanel" style="max-height: 140px; overflow-y: auto;">
                        <div id="episodicMemoryList">
                            <div style="color: var(--text-muted); font-size: 11px;">
                                No history yet
                            </div>
                        </div>
                    </div>
                    
                    <!-- Plan Panel (what we plan to do) -->
                    <div id="planPanel" style="display: none; max-height: 140px; overflow-y: auto;">
                        <div style="display: flex; gap: 4px; margin-bottom: 6px;">
                            <input type="text" id="newTodoInput" placeholder="Add task..." 
                                   style="flex: 1; padding: 4px 8px; font-size: 11px; background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 4px; color: var(--text-primary);"
                                   onkeypress="if(event.key==='Enter')GSXCreate.addTodo()">
                            <button class="btn btn-sm btn-primary" onclick="GSXCreate.addTodo()" style="padding: 4px 8px; font-size: 11px;">+</button>
                        </div>
                        <div id="todoList">
                            <div style="color: var(--text-muted); font-size: 11px;">
                                No tasks planned
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Center Area -->
        <div class="center-area">
        <!-- Setup Panel (shown initially) -->
        <div class="setup-panel" id="setupPanel">
                <div class="setup-hero">
                    <img src="assets/banner.png" alt="GSX Create" onerror="this.style.display='none'">
                    <h2>GSX Create</h2>
                    <p>AI-powered code generation integrated with your Spaces</p>
                    
                    <div id="noApiWarning" class="no-api-warning" style="display: none;">
                        <h3>API Key Required</h3>
                        <p>Please add an OpenAI or Anthropic API key in Settings to use GSX Create.</p>
                    </div>
                    
                    <!-- Space Selection - Primary Action -->
                    <div class="setup-form" id="mainSetupForm" style="margin-top: 32px;">
                        <div class="form-group">
                            <label style="font-size: 14px; font-weight: 500; margin-bottom: 12px; display: block; color: var(--text-primary);">
                                Select a Space
                            </label>
                            <select class="form-select" id="mainSpaceSelect" onchange="GSXCreate.selectSpaceFromMain(this.value)" 
                                    style="font-size: 15px; padding: 14px 16px; background: var(--bg-tertiary); border: 2px solid var(--border-light); border-radius: 8px;">
                                <option value="">Choose a space...</option>
                            </select>
                            <div style="text-align: center; margin: 16px 0; color: var(--text-muted); font-size: 12px;">‚Äî or ‚Äî</div>
                            <button class="btn btn-secondary" onclick="GSXCreate.createNewSpace()" 
                                    style="width: 100%; padding: 14px; border: 2px dashed var(--border-light); background: transparent;">
                                + Create New Space
            </button>
                        </div>
                        
                        <!-- Start Button - always visible, disabled until space selected -->
                        <div style="display: flex; gap: 8px; margin-top: 24px;">
                            <button class="btn btn-primary" disabled style="flex: 1; padding: 14px; opacity: 0.5; cursor: not-allowed;" onclick="GSXCreate.startSession()" id="mainStartBtn">
                                Start Session
                            </button>
                            <button class="btn btn-secondary" onclick="GSXCreate.showSettings()" title="Settings" style="padding: 14px 16px;">
                                ‚öôÔ∏è
                            </button>
                        </div>
                        <div style="text-align: center; margin-top: 8px; font-size: 11px; color: var(--text-muted);">
                            Model: <span id="currentModelDisplay">Claude Sonnet 4.5</span>
                        </div>
                        
                        <!-- Optional config - shown after space selected -->
                        <div id="spaceSelectedConfig" style="display: none; margin-top: 24px; padding-top: 24px; border-top: 1px solid var(--border);">
                            <label style="font-size: 12px; font-weight: 500; margin-bottom: 12px; display: block; color: var(--text-secondary);">
                                Constitutional Memory
                            </label>
                            
                            <!-- Main File Selection -->
                            <div class="form-group" style="margin-bottom: 12px;">
                                <label style="font-size: 11px;">Main File <span style="color: var(--text-muted);">(for preview & testing)</span></label>
                                <select class="form-select" id="mainFileSelect" style="padding: 10px;" onchange="GSXCreate.setMainFile(this.value)">
                                    <option value="">Auto-detect</option>
                </select>
            </div>
                            
                            <div style="display: flex; gap: 12px;">
                                <div class="form-group" style="flex: 1;">
                                    <label style="font-size: 11px;">Style Guide</label>
                                    <select class="form-select" id="mainStyleGuideSelect">
                                        <option value="">None</option>
                                    </select>
                                </div>
                                <div class="form-group" style="flex: 1;">
                                    <label style="font-size: 11px;">Journey Map</label>
                                    <select class="form-select" id="mainJourneyMapSelect">
                                        <option value="">None</option>
                                    </select>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Chat Area (shown after session starts) -->
            <div class="chat-area" id="chatArea">
                <!-- Chat Toolbar -->
                <div class="chat-toolbar">
                    <button class="btn btn-secondary btn-sm" onclick="GSXCreate.toggleGlobalInstructions()" title="Global instructions">
                        Instructions
            </button>
                    <button class="btn btn-secondary btn-sm" onclick="GSXCreate.toggleConfig()" title="Lint & test config">
                        Config
                    </button>
                    <button class="btn btn-secondary btn-sm" onclick="GSXCreate.showCodeTools()" title="Code intelligence tools">
                        üîç Code
                    </button>
                    <button class="btn btn-secondary btn-sm" onclick="GSXCreate.showTestAgent()" title="Automated testing with Puppeteer" style="background: var(--success);">
                        üß™ Test Agent
                    </button>
                    <button class="btn btn-secondary btn-sm" onclick="GSXCreate.showSettings()" title="Settings">
                        ‚öôÔ∏è
                    </button>
                    <div class="spacer"></div>
                    <button class="btn btn-secondary btn-sm" onclick="GSXCreate.runCodeTest()" title="Analyze code">
                        Test
                    </button>
                    <button class="btn btn-secondary btn-sm" onclick="GSXCreate.showVersionHistory()" title="Version history">
                        History
                    </button>
                    <button class="btn btn-secondary btn-sm" onclick="GSXCreate.showTransactionLogs()" title="Episodic Memory">
                        Episodic Memory
                    </button>
                </div>
                
                <!-- Global Instructions Panel -->
                <div class="global-instructions" id="globalInstructionsPanel">
                    <label style="font-size: 10px; color: var(--text-secondary); display: block; margin-bottom: 6px;">
                        GLOBAL INSTRUCTIONS (included with every prompt)
                    </label>
                    <textarea id="globalInstructions" placeholder="Enter instructions that should be included with every prompt..."></textarea>
                    <div style="margin-top: 8px; display: flex; gap: 8px;">
                        <button class="btn btn-sm btn-secondary" onclick="GSXCreate.saveGlobalInstructions()">Save</button>
                        <button class="btn btn-sm btn-secondary" onclick="GSXCreate.applyTemplate('typescript')">TypeScript</button>
                        <button class="btn btn-sm btn-secondary" onclick="GSXCreate.applyTemplate('react')">React</button>
                        <button class="btn btn-sm btn-secondary" onclick="GSXCreate.applyTemplate('python')">Python</button>
                    </div>
        </div>
        
                <!-- Config Panel -->
                <div class="config-panel" id="configPanel">
                    <div class="config-row">
                        <div class="config-group">
                            <label>Lint Command</label>
                            <input type="text" id="lintCmd" placeholder="e.g., npm run lint">
            </div>
                        <div class="config-group">
                            <label>Test Command</label>
                            <input type="text" id="testCmd" placeholder="e.g., npm test">
                        </div>
                        <button class="btn btn-sm btn-secondary" onclick="GSXCreate.detectTools()" style="align-self: flex-end;">
                            Auto-Detect
            </button>
                    </div>
        </div>
        
                <!-- Messages -->
            <div class="messages" id="messages">
                    <div class="message">
                        <span class="message-time">--:--</span>
                        <span class="message-type system">SYS</span>
                        <span class="message-content">Session started. Describe what you want to build or modify.</span>
                </div>
            </div>
            
                <!-- Input Area -->
            <div class="input-area">
                <div class="input-wrapper">
                        <span class="input-prefix">&gt;</span>
                        <textarea id="promptInput" placeholder="Describe what you want to build..." rows="1"></textarea>
                </div>
                    <button class="btn btn-test" onclick="GSXCreate.runQuickTest()" id="testBtn" title="Run AI Test & Fix">üß™</button>
                    <button class="btn btn-primary" onclick="GSXCreate.sendPrompt()" id="sendBtn">Send</button>
                </div>
            </div>
        </div>
        
        <!-- Preview Panel -->
        <div class="preview-panel" id="previewPanel">
            <div class="preview-resize-handle" id="previewResizeHandle"></div>
            <button class="preview-toggle" id="previewToggle" onclick="GSXCreate.collapsePreview()" title="Collapse/Expand">
                <span id="previewToggleIcon">‚ñ∂</span>
                </button>
            <div class="preview-header">
                <span class="preview-title" id="previewTitle">Preview</span>
                <div class="preview-actions">
                    <button onclick="GSXCreate.captureAndAnalyze()" title="Capture screenshot and send to AI for review" style="background: var(--accent);">üì∏ AI Review</button>
                    <button onclick="GSXCreate.refreshPreview()" title="Refresh">‚Üª</button>
                    <button onclick="GSXCreate.openInBrowser()" title="Open in browser">‚Üó</button>
                    <button onclick="GSXCreate.togglePreview()" title="Hide preview">√ó</button>
                </div>
            </div>
            <div class="preview-content" id="previewContent">
                <div class="preview-empty">Click a file to preview</div>
            </div>
        </div>
    </div>
    
    <!-- Transaction Log Modal -->
    <div class="modal" id="logModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Episodic Memory</h3>
                <button class="modal-close" onclick="GSXCreate.closeModal('logModal')">&times;</button>
            </div>
            <div class="modal-body">
                <table class="log-table">
                    <thead>
                        <tr>
                            <th>Time</th>
                            <th>Type</th>
                            <th>Model</th>
                            <th>Tokens</th>
                            <th>Cost</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody id="logTableBody">
                    </tbody>
                </table>
            </div>
        </div>
    </div>
    
    <!-- Version History Modal -->
    <div class="modal" id="historyModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Version History</h3>
                <button class="modal-close" onclick="GSXCreate.closeModal('historyModal')">&times;</button>
            </div>
            <div class="modal-body" id="historyModalBody">
            </div>
        </div>
    </div>
    
    <!-- Code Tools Modal -->
    <div class="modal" id="codeToolsModal">
        <div class="modal-content" style="max-width: 800px;">
            <div class="modal-header">
                <h3>üîç Code Intelligence</h3>
                <button class="modal-close" onclick="GSXCreate.closeModal('codeToolsModal')">&times;</button>
            </div>
            <div class="modal-body">
                <!-- Tool Tabs -->
                <div style="display: flex; gap: 8px; margin-bottom: 16px; border-bottom: 1px solid var(--border); padding-bottom: 12px;">
                    <button class="btn btn-sm code-tool-tab active" data-tool="search" onclick="GSXCreate.selectCodeTool('search')">Search Code</button>
                    <button class="btn btn-sm code-tool-tab" data-tool="definition" onclick="GSXCreate.selectCodeTool('definition')">Find Definition</button>
                    <button class="btn btn-sm code-tool-tab" data-tool="usages" onclick="GSXCreate.selectCodeTool('usages')">Find Usages</button>
                    <button class="btn btn-sm code-tool-tab" data-tool="repomap" onclick="GSXCreate.selectCodeTool('repomap')">Repo Map</button>
                </div>
                
                <!-- Search Code Panel -->
                <div id="codeToolSearch" class="code-tool-panel active">
                    <p style="font-size: 12px; color: var(--text-secondary); margin-bottom: 12px;">
                        Search for patterns in your codebase using regex
                    </p>
                    <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                        <input type="text" id="searchPattern" placeholder="Search pattern (regex)" style="flex: 2; padding: 10px; background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 6px; color: var(--text-primary);">
                        <input type="text" id="searchGlob" placeholder="File glob (e.g., *.js)" style="flex: 1; padding: 10px; background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 6px; color: var(--text-primary);">
                        <button class="btn btn-primary" onclick="GSXCreate.searchCode()">Search</button>
                    </div>
                    <div id="searchResults" style="max-height: 400px; overflow-y: auto; font-family: monospace; font-size: 12px;"></div>
                </div>
                
                <!-- Find Definition Panel -->
                <div id="codeToolDefinition" class="code-tool-panel">
                    <p style="font-size: 12px; color: var(--text-secondary); margin-bottom: 12px;">
                        Find where a function, class, or variable is defined
                    </p>
                    <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                        <input type="text" id="definitionSymbol" placeholder="Symbol name (e.g., handleSubmit, UserClass)" style="flex: 1; padding: 10px; background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 6px; color: var(--text-primary);">
                        <button class="btn btn-primary" onclick="GSXCreate.findDefinition()">Find</button>
                    </div>
                    <div id="definitionResults" style="max-height: 400px; overflow-y: auto; font-family: monospace; font-size: 12px;"></div>
                </div>
                
                <!-- Find Usages Panel -->
                <div id="codeToolUsages" class="code-tool-panel">
                    <p style="font-size: 12px; color: var(--text-secondary); margin-bottom: 12px;">
                        Find all places where a symbol is used
                    </p>
                    <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                        <input type="text" id="usagesSymbol" placeholder="Symbol name" style="flex: 1; padding: 10px; background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 6px; color: var(--text-primary);">
                        <button class="btn btn-primary" onclick="GSXCreate.findUsages()">Find Usages</button>
                    </div>
                    <div id="usagesResults" style="max-height: 400px; overflow-y: auto; font-family: monospace; font-size: 12px;"></div>
                </div>
                
                <!-- Repo Map Panel -->
                <div id="codeToolRepomap" class="code-tool-panel">
                    <p style="font-size: 12px; color: var(--text-secondary); margin-bottom: 12px;">
                        View the structure of your codebase - files, classes, and functions
                    </p>
                    <button class="btn btn-primary" onclick="GSXCreate.getRepoMap()" style="margin-bottom: 12px;">Generate Repo Map</button>
                    <div id="repomapResults" style="max-height: 400px; overflow-y: auto; font-family: monospace; font-size: 12px; white-space: pre-wrap;"></div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Settings Modal -->
    <div class="modal" id="settingsModal">
        <div class="modal-content" style="max-width: 450px;">
            <div class="modal-header">
                <h3>‚öôÔ∏è Settings</h3>
                <button class="modal-close" onclick="GSXCreate.closeModal('settingsModal')">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group" style="margin-bottom: 16px;">
                    <label style="font-size: 12px; font-weight: 500; margin-bottom: 8px; display: block; color: var(--text-primary);">
                        AI Model
                    </label>
                    <select class="form-select" id="settingsModelSelect" style="padding: 12px; font-size: 14px;">
                    </select>
                    <p style="font-size: 11px; color: var(--text-muted); margin-top: 6px;">
                        Claude Sonnet 4.5 is faster and more cost-effective. Claude Opus 4.5 is more capable for complex tasks.
                    </p>
                </div>
                
                <div style="border-top: 1px solid var(--border); padding-top: 16px; margin-top: 16px;">
                    <button class="btn btn-primary" onclick="GSXCreate.saveSettings()" style="width: 100%; padding: 12px;">
                        Save Settings
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Budget Modal -->
    <div class="modal" id="budgetModal">
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-header">
                <h3>üí∞ Budget & Costs</h3>
                <button class="modal-close" onclick="GSXCreate.closeModal('budgetModal')">&times;</button>
            </div>
            <div class="modal-body">
                <!-- Current Session Stats -->
                <div style="background: var(--bg-tertiary); padding: 16px; border-radius: 8px; margin-bottom: 16px;">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 12px;">
                        <span style="color: var(--text-secondary);">Current Cost</span>
                        <span id="budgetCurrentCost" style="font-weight: 600; color: var(--success);">$0.00</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-bottom: 12px;">
                        <span style="color: var(--text-secondary);">Budget</span>
                        <span id="budgetLimit" style="font-weight: 500;">‚àû (No limit)</span>
                    </div>
                    <div style="display: flex; justify-content: space-between;">
                        <span style="color: var(--text-secondary);">Usage</span>
                        <span id="budgetPercentage" style="font-weight: 500;">0%</span>
                    </div>
                    <div style="margin-top: 12px; height: 6px; background: var(--bg-primary); border-radius: 3px; overflow: hidden;">
                        <div id="budgetModalFill" style="height: 100%; width: 0%; background: var(--success); transition: all 0.3s;"></div>
                    </div>
                </div>
                
                <!-- Cycle Statistics -->
                <div style="background: var(--bg-tertiary); padding: 16px; border-radius: 8px; margin-bottom: 16px;">
                    <h4 style="margin: 0 0 12px 0; font-size: 12px; color: var(--text-primary);">üìä Cycle Statistics</h4>
                    <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                        <span style="color: var(--text-secondary); font-size: 11px;">Cycles Completed</span>
                        <span id="cyclesCompleted" style="font-size: 11px;">0</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                        <span style="color: var(--text-secondary); font-size: 11px;">Avg Cost / Cycle</span>
                        <span id="avgCostPerCycle" style="font-size: 11px; color: var(--accent);">$0.00</span>
                    </div>
                    <div style="display: flex; justify-content: space-between;">
                        <span style="color: var(--text-secondary); font-size: 11px;">Est. Cycles Remaining</span>
                        <span id="estCyclesRemaining" style="font-size: 11px;">‚àû</span>
                    </div>
                </div>
                
                <!-- Set Budget -->
                <div class="form-group" style="margin-bottom: 16px;">
                    <label style="font-size: 12px; font-weight: 500; margin-bottom: 8px; display: block; color: var(--text-primary);">
                        Set Budget Limit
                    </label>
                    <div style="display: flex; gap: 8px;">
                        <input type="number" id="budgetInput" placeholder="e.g. 5.00" step="0.50" min="0" 
                               style="flex: 1; padding: 10px; background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 6px; color: var(--text-primary); font-size: 14px;">
                        <button class="btn btn-primary" onclick="GSXCreate.setBudget()" style="padding: 10px 16px;">
                            Set
                        </button>
                    </div>
                    <p style="font-size: 10px; color: var(--text-muted); margin-top: 6px;">
                        Auto-cycle will pause when budget is reached. Leave empty for no limit.
                    </p>
                </div>
                
                <!-- Quick Budget Buttons -->
                <div style="display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 16px;">
                    <button class="btn btn-secondary btn-sm" onclick="GSXCreate.setQuickBudget(1)">$1</button>
                    <button class="btn btn-secondary btn-sm" onclick="GSXCreate.setQuickBudget(5)">$5</button>
                    <button class="btn btn-secondary btn-sm" onclick="GSXCreate.setQuickBudget(10)">$10</button>
                    <button class="btn btn-secondary btn-sm" onclick="GSXCreate.setQuickBudget(25)">$25</button>
                    <button class="btn btn-secondary btn-sm" onclick="GSXCreate.setQuickBudget(null)" style="color: var(--text-muted);">No Limit</button>
                </div>
                
                <div style="border-top: 1px solid var(--border); padding-top: 16px;">
                    <button class="btn btn-secondary" onclick="GSXCreate.showTransactionLogs()" style="width: 100%; padding: 10px;">
                        üìú View Transaction History
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Test Agent Modal -->
    <div class="modal" id="testAgentModal">
        <div class="modal-content" style="max-width: 900px; max-height: 85vh;">
            <div class="modal-header">
                <h3>üß™ Test Agent</h3>
                <button class="modal-close" onclick="GSXCreate.closeModal('testAgentModal')">&times;</button>
            </div>
            <div class="modal-body" style="overflow-y: auto;">
                <!-- Test Type Tabs -->
                <div style="display: flex; gap: 8px; margin-bottom: 16px; border-bottom: 1px solid var(--border); padding-bottom: 12px; flex-wrap: wrap;">
                    <button class="btn btn-sm test-tab active" data-test="functional" onclick="GSXCreate.selectTestTab('functional')">üéØ Functional</button>
                    <button class="btn btn-sm test-tab" data-test="visual" onclick="GSXCreate.selectTestTab('visual')">üëÅÔ∏è Visual</button>
                    <button class="btn btn-sm test-tab" data-test="accessibility" onclick="GSXCreate.selectTestTab('accessibility')">‚ôø Accessibility</button>
                    <button class="btn btn-sm test-tab" data-test="performance" onclick="GSXCreate.selectTestTab('performance')">‚ö° Performance</button>
                    <button class="btn btn-sm test-tab" data-test="interactive" onclick="GSXCreate.selectTestTab('interactive')">ü§ñ AI Interactive</button>
                </div>
                
                <!-- Functional Tests Panel -->
                <div id="testPanelFunctional" class="test-panel active">
                    <p style="font-size: 12px; color: var(--text-secondary); margin-bottom: 12px;">
                        Automatically test buttons, forms, links, and interactions using Playwright
                    </p>
                    <div style="display: flex; gap: 8px; margin-bottom: 16px; align-items: center; flex-wrap: wrap;">
                        <select id="browserSelect" style="padding: 8px; background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 6px; color: var(--text-primary);">
                            <option value="chromium">üåê Chrome</option>
                            <option value="firefox">ü¶ä Firefox</option>
                            <option value="webkit">üß≠ Safari</option>
                        </select>
                        <button class="btn btn-primary" onclick="GSXCreate.generateTestPlan()">üìã Generate Test Plan</button>
                        <button class="btn btn-success" onclick="GSXCreate.runFunctionalTests()" id="runTestsBtn" disabled>‚ñ∂Ô∏è Run Tests</button>
                        <label style="display: flex; align-items: center; gap: 6px; font-size: 12px; color: var(--text-secondary);">
                            <input type="checkbox" id="useAIForTests" checked> Use AI
                        </label>
                    </div>
                    
                    <!-- Test Plan Display -->
                    <div id="testPlanDisplay" style="margin-bottom: 16px; display: none;">
                        <h4 style="font-size: 13px; margin-bottom: 8px; color: var(--text-primary);">üìã Test Plan</h4>
                        <div id="testPlanList" style="background: var(--bg-tertiary); border-radius: 6px; padding: 12px; max-height: 200px; overflow-y: auto;"></div>
                    </div>
                    
                    <!-- Test Results -->
                    <div id="testResultsDisplay" style="display: none;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <h4 style="font-size: 13px; color: var(--text-primary);">üìä Results</h4>
                            <button class="btn btn-success btn-sm" onclick="GSXCreate.fixFailedTests()" id="fixFailedTestsBtn" disabled>üîß Fix Failed Tests</button>
                        </div>
                        <div id="testSummary" style="display: flex; gap: 16px; margin-bottom: 12px; padding: 12px; background: var(--bg-tertiary); border-radius: 6px;"></div>
                        <div id="testResultsList" style="max-height: 300px; overflow-y: auto;"></div>
                    </div>
                </div>
                
                <!-- Visual Tests Panel -->
                <div id="testPanelVisual" class="test-panel">
                    <p style="font-size: 12px; color: var(--text-secondary); margin-bottom: 12px;">
                        Capture screenshots and compare visual changes over time. Test across multiple browsers.
                    </p>
                    <div style="display: flex; gap: 8px; margin-bottom: 16px; flex-wrap: wrap;">
                        <button class="btn btn-primary" onclick="GSXCreate.captureBaseline()">üì∏ Capture Baseline</button>
                        <button class="btn btn-secondary" onclick="GSXCreate.compareVisual()">üîç Compare to Baseline</button>
                        <button class="btn btn-secondary" onclick="GSXCreate.runCrossBrowserTest()" style="background: linear-gradient(135deg, #4285f4, #ea4335, #fbbc05);">üåê Cross-Browser Test</button>
                    </div>
                    <div id="visualTestResults" style="display: flex; gap: 16px; flex-wrap: wrap;"></div>
                </div>
                
                <!-- Accessibility Tests Panel -->
                <div id="testPanelAccessibility" class="test-panel">
                    <p style="font-size: 12px; color: var(--text-secondary); margin-bottom: 12px;">
                        Check for accessibility issues: missing alt text, labels, keyboard navigation, etc.
                    </p>
                    <div style="display: flex; gap: 8px; margin-bottom: 16px;">
                        <button class="btn btn-primary" onclick="GSXCreate.runAccessibilityTest()">‚ôø Run Accessibility Audit</button>
                        <button class="btn btn-success" onclick="GSXCreate.fixAccessibilityIssues()" id="fixAccessibilityBtn" disabled>üîß Fix Issues</button>
                    </div>
                    <div id="accessibilityResults"></div>
                </div>
                
                <!-- Performance Tests Panel -->
                <div id="testPanelPerformance" class="test-panel">
                    <p style="font-size: 12px; color: var(--text-secondary); margin-bottom: 12px;">
                        Measure load time, DOM size, and resource usage
                    </p>
                    <div style="display: flex; gap: 8px; margin-bottom: 16px;">
                        <button class="btn btn-primary" onclick="GSXCreate.runPerformanceTest()">‚ö° Run Performance Test</button>
                        <button class="btn btn-success" onclick="GSXCreate.fixPerformanceIssues()" id="fixPerformanceBtn" disabled>üîß Optimize</button>
                    </div>
                    <div id="performanceResults"></div>
                </div>
                
                <!-- AI Interactive Tests Panel -->
                <div id="testPanelInteractive" class="test-panel">
                    <p style="font-size: 12px; color: var(--text-secondary); margin-bottom: 12px;">
                        Let AI analyze your UI, find bugs, and suggest fixes - then implement them automatically
                    </p>
                    <div style="display: flex; gap: 8px; margin-bottom: 16px;">
                        <button class="btn btn-primary" onclick="GSXCreate.runInteractiveTest()">ü§ñ AI Analyze & Test</button>
                        <button class="btn btn-success" onclick="GSXCreate.implementTestFixes()" id="implementFixesBtn" disabled>üîß Implement Fixes</button>
                    </div>
                    <div id="interactiveResults"></div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        const GSXCreate = {
            // State
            currentSpace: null,
            currentSpaceId: null,
            currentSpaceName: null,
            repoPath: null,
            files: [],
            projectFiles: [],
            contextFiles: [],
            apiConfig: null,
            costSummary: { totalCost: 0, totalCalls: 0 },
            currentPreviewFile: null,
            globalInstructionsText: '',
            styleGuides: [],
            journeyMaps: [],
            spaceItems: [],
            fileWatcher: null,
            
            // Cycle State
            cycleState: {
                active: false,
                paused: false,
                currentVersion: 1,
                currentPhase: null,
                phases: ['evaluate', 'research', 'plan', 'execute', 'test', 'improve', 'finalize'],
                versions: [],
                targetScore: 90,
                currentScore: 0,
                autoMode: false,
                autoCycle: false,          // Auto-restart cycle after completion
                cycleBudget: null,         // Max cost before stopping auto-cycle
                objective: null,           // Current iteration objective
                lastPrompt: null,          // Last user prompt for context
                todos: [],                 // Current todo list
                currentTodoIndex: 0,       // Which todo we're working on
                evaluationCriteria: [],    // Criteria from file
                evaluationScores: {},      // Scores for each criterion
                evaluation: null,          // Full evaluation data
                waitingForCriteria: false, // Waiting for criteria file creation
                pendingEvaluation: null,   // Evaluation data when paused
                // Supporting files (versioned per cycle)
                files: {
                    styleGuide: 'style-guide.md',
                    userFeedback: 'user-feedback.md',
                    journeyMap: 'journey-map.md',
                    researchNotes: 'research-notes-v{version}.md',
                    todoList: 'TODO-v{version}.md',
                    testResults: 'test-results-v{version}.md',
                    evaluationCriteria: 'evaluation-criteria.md'
                }
            },
            
            // Constitutional Memory State
            constitutionalMemory: {
                styleGuide: null,
                journeyMap: null,
                evaluationCriteria: null,
                currentSummary: null,
                lastTask: null,
                lastSummarizedAt: null
            },
            
            // Error Analyzer State
            errorAnalyzer: {
                enabled: true,
                currentError: null,
                errorLog: [],
                maxLogSize: 100,
                suppressedErrors: new Set()
            },
            
            // Initialize
            async init() {
                console.log('[GSX Create] Initializing...');
                // #region agent log
                fetch('http://127.0.0.1:7242/ingest/54746cc5-c924-4bb5-9e76-3f6b729e6870',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'aider-ui.html:init',message:'H1: GSX Create init started',data:{},timestamp:Date.now(),sessionId:'debug-session',hypothesisId:'H1'})}).catch(()=>{});
                // #endregion
                try {
                    await this.checkApiConfig();
                    // #region agent log
                    fetch('http://127.0.0.1:7242/ingest/54746cc5-c924-4bb5-9e76-3f6b729e6870',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'aider-ui.html:init:afterApiConfig',message:'H1: checkApiConfig completed',data:{hasApiKey:this.apiConfig?.hasApiKey,provider:this.apiConfig?.provider},timestamp:Date.now(),sessionId:'debug-session',hypothesisId:'H1'})}).catch(()=>{});
                    // #endregion
                    await this.loadSpaces();
                    // #region agent log
                    fetch('http://127.0.0.1:7242/ingest/54746cc5-c924-4bb5-9e76-3f6b729e6870',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'aider-ui.html:init:afterLoadSpaces',message:'H1: loadSpaces completed',data:{spaceCount:this.spaces?.length||0},timestamp:Date.now(),sessionId:'debug-session',hypothesisId:'H1'})}).catch(()=>{});
                    // #endregion
                    this.setupEventListeners();
                    this.restoreSidebarState();
                    this.setupErrorAnalyzer();
                    this.setupBehaviorTracking();
                    this.trackBehavior('session_start', { timestamp: new Date().toISOString() });
                    // #region agent log
                    fetch('http://127.0.0.1:7242/ingest/54746cc5-c924-4bb5-9e76-3f6b729e6870',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'aider-ui.html:init:complete',message:'H1: GSX Create init completed successfully',data:{},timestamp:Date.now(),sessionId:'debug-session',hypothesisId:'H1'})}).catch(()=>{});
                    // #endregion
                } catch (error) {
                    // #region agent log
                    fetch('http://127.0.0.1:7242/ingest/54746cc5-c924-4bb5-9e76-3f6b729e6870',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'aider-ui.html:init:error',message:'H1: GSX Create init FAILED',data:{error:error.message},timestamp:Date.now(),sessionId:'debug-session',hypothesisId:'H1'})}).catch(()=>{});
                    // #endregion
                    console.error('[GSX Create] Init error:', error);
                }
            },
            
            // Selected model (stored in settings)
            selectedModel: localStorage.getItem('gsxCreateModel') || 'claude-sonnet-4-5-20250929',
            
            // Check API Configuration
            async checkApiConfig() {
                try {
                    this.apiConfig = await window.aider.getApiConfig();
                    console.log('[GSX Create] API Config:', this.apiConfig);
                    
                    const settingsModelSelect = document.getElementById('settingsModelSelect');
                    const noApiWarning = document.getElementById('noApiWarning');
                    const mainSetupForm = document.getElementById('mainSetupForm');
                    
                    if (!this.apiConfig.hasApiKey) {
                        noApiWarning.style.display = 'block';
                        if (mainSetupForm) mainSetupForm.style.display = 'none';
                        return;
                    }
                    
                    noApiWarning.style.display = 'none';
                    if (mainSetupForm) mainSetupForm.style.display = 'block';
                    
                    // Model options HTML - Claude models only
                    const modelOptionsHtml = `
                        <option value="claude-sonnet-4-5-20250929">Claude Sonnet 4.5</option>
                        <option value="claude-opus-4-5-20250929">Claude Opus 4.5</option>
                    `;
                    
                    // Populate settings modal model select
                    if (settingsModelSelect) {
                        settingsModelSelect.innerHTML = modelOptionsHtml;
                        settingsModelSelect.value = this.selectedModel;
                    }
                    
                    // Update model display
                    this.updateModelDisplay();
                } catch (error) {
                    console.error('[GSX Create] API config error:', error);
                }
            },
            
            // Update model display text
            updateModelDisplay() {
                const display = document.getElementById('currentModelDisplay');
                if (display) {
                    display.textContent = this.getModelDisplayName(this.selectedModel);
                }
            },
            
            // Show Settings Modal
            showSettings() {
                const settingsModelSelect = document.getElementById('settingsModelSelect');
                if (settingsModelSelect) {
                    settingsModelSelect.value = this.selectedModel;
                }
                document.getElementById('settingsModal').classList.add('active');
            },
            
            // Save Settings
            saveSettings() {
                const settingsModelSelect = document.getElementById('settingsModelSelect');
                if (settingsModelSelect) {
                    this.selectedModel = settingsModelSelect.value;
                    localStorage.setItem('gsxCreateModel', this.selectedModel);
                }
                this.updateModelDisplay();
                this.closeModal('settingsModal');
                // Only show message if chat area is active
                if (document.getElementById('chatArea').classList.contains('active')) {
                    this.addMessage('system', `Settings saved. Model: ${this.getModelDisplayName(this.selectedModel)}`);
                }
            },
            
            // Get human-readable model name
            getModelDisplayName(modelId) {
                const names = {
                    'claude-sonnet-4-5-20250929': 'Claude Sonnet 4.5',
                    'claude-opus-4-5-20250929': 'Claude Opus 4.5'
                };
                return names[modelId] || modelId;
            },
            
            // Load Spaces
            async loadSpaces() {
                try {
                    const spaces = await window.aider.getSpaces();
                    console.log('[GSX Create] Loaded spaces:', spaces);
                    
                    // Populate sidebar select
                    const select = document.getElementById('spaceSelect');
                    if (select) {
                        select.innerHTML = '<option value="">Select a space...</option>';
                    }
                    
                    // Populate main setup select
                    const mainSelect = document.getElementById('mainSpaceSelect');
                    if (mainSelect) {
                        mainSelect.innerHTML = '<option value="">Choose a space...</option>';
                    }
                    
                    if (spaces && spaces.length > 0) {
                        spaces.forEach(space => {
                            if (space.path) {
                                // Sidebar select
                                if (select) {
                                    const option = document.createElement('option');
                                    option.value = space.id;
                                    option.textContent = `${space.name} (${space.itemCount || 0} items)`;
                                    option.dataset.path = space.path;
                                    option.dataset.name = space.name;
                                    select.appendChild(option);
                                }
                                
                                // Main setup select
                                if (mainSelect) {
                                    const option2 = document.createElement('option');
                                    option2.value = space.id;
                                    option2.textContent = `${space.name} (${space.itemCount || 0} items)`;
                                    option2.dataset.path = space.path;
                                    option2.dataset.name = space.name;
                                    mainSelect.appendChild(option2);
                                }
                            }
                        });
                    }
                } catch (error) {
                    console.error('[GSX Create] Load spaces error:', error);
                }
            },
            
            // Show a custom prompt modal (since prompt() is not supported in Electron)
            showPromptModal(title, placeholder = '') {
                return new Promise((resolve) => {
                    // Create modal overlay
                    const overlay = document.createElement('div');
                    overlay.style.cssText = `
                        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                        background: rgba(0,0,0,0.7); z-index: 10000;
                        display: flex; align-items: center; justify-content: center;
                    `;
                    
                    const modal = document.createElement('div');
                    modal.style.cssText = `
                        background: var(--bg-secondary, #1e1e1e); border-radius: 12px;
                        padding: 24px; min-width: 320px; max-width: 400px;
                        box-shadow: 0 8px 32px rgba(0,0,0,0.4);
                        border: 1px solid var(--border-color, #333);
                    `;
                    
                    modal.innerHTML = `
                        <h3 style="margin: 0 0 16px 0; color: var(--text-primary, #fff); font-size: 16px;">${title}</h3>
                        <input type="text" id="promptInput" placeholder="${placeholder}" style="
                            width: 100%; padding: 10px 12px; border-radius: 6px;
                            border: 1px solid var(--border-color, #444); background: var(--bg-primary, #121212);
                            color: var(--text-primary, #fff); font-size: 14px; box-sizing: border-box;
                        " autofocus>
                        <div style="display: flex; gap: 8px; margin-top: 16px; justify-content: flex-end;">
                            <button id="promptCancel" style="
                                padding: 8px 16px; border-radius: 6px; border: 1px solid var(--border-color, #444);
                                background: transparent; color: var(--text-secondary, #888); cursor: pointer;
                            ">Cancel</button>
                            <button id="promptOk" style="
                                padding: 8px 16px; border-radius: 6px; border: none;
                                background: var(--accent-color, #0066cc); color: #fff; cursor: pointer;
                            ">Create</button>
                        </div>
                    `;
                    
                    overlay.appendChild(modal);
                    document.body.appendChild(overlay);
                    
                    const input = modal.querySelector('#promptInput');
                    const okBtn = modal.querySelector('#promptOk');
                    const cancelBtn = modal.querySelector('#promptCancel');
                    
                    const cleanup = (value) => {
                        overlay.remove();
                        resolve(value);
                    };
                    
                    input.focus();
                    input.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') cleanup(input.value.trim() || null);
                        if (e.key === 'Escape') cleanup(null);
                    });
                    okBtn.addEventListener('click', () => cleanup(input.value.trim() || null));
                    cancelBtn.addEventListener('click', () => cleanup(null));
                    overlay.addEventListener('click', (e) => { if (e.target === overlay) cleanup(null); });
                });
            },
            
            // Create New Space
            async createNewSpace() {
                const spaceName = await this.showPromptModal('Create New Space', 'Enter space name...');
                if (!spaceName) {
                    return;
                }
                
                try {
                    console.log('[GSX Create] Creating new space:', spaceName);
                    this.trackBehavior('create_space_started', { name: spaceName });
                    
                    // #region agent log
                    // H5: Check if window.clipboard exists
                    console.log('[GSX-DEBUG] H5: window.clipboard exists:', !!window.clipboard);
                    console.log('[GSX-DEBUG] H5: window.clipboard.createSpace exists:', !!(window.clipboard && window.clipboard.createSpace));
                    if (!window.clipboard) {
                        throw new Error('H5: window.clipboard is undefined - preload not loaded correctly');
                    }
                    if (!window.clipboard.createSpace) {
                        throw new Error('H5: window.clipboard.createSpace is undefined');
                    }
                    // #endregion
                    
                    // Create the space via clipboard API
                    console.log('[GSX-DEBUG] H6: About to call window.clipboard.createSpace');
                    const result = await window.clipboard.createSpace({
                        name: spaceName,
                        icon: '‚óÜ',
                        notebook: {
                            description: `Project space for ${spaceName}`,
                            objective: '',
                            instructions: '',
                            tags: ['gsx-create'],
                            links: []
                        }
                    });
                    console.log('[GSX-DEBUG] H6: createSpace returned:', JSON.stringify(result));
                    
                    if (result && result.success) {
                        console.log('[GSX Create] Space created:', result.space);
                        this.trackBehavior('create_space_success', { spaceId: result.space.id, name: spaceName });
                        
                        // Reload spaces to update the dropdown
                        await this.loadSpaces();
                        
                        // Auto-select the new space
                        const mainSelect = document.getElementById('mainSpaceSelect');
                        if (mainSelect && result.space.id) {
                            mainSelect.value = result.space.id;
                            await this.selectSpaceFromMain(result.space.id);
                        }
                        
                        this.addMessage('system', `‚úÖ Space "${spaceName}" created successfully!`);
                    } else {
                        throw new Error(result?.error || 'Failed to create space');
                    }
                } catch (error) {
                    // #region agent log
                    console.error('[GSX-DEBUG] ERROR: Create space failed');
                    console.error('[GSX-DEBUG] Error name:', error.name);
                    console.error('[GSX-DEBUG] Error message:', error.message);
                    console.error('[GSX-DEBUG] Error stack:', error.stack);
                    // #endregion
                    console.error('[GSX Create] Create space error:', error);
                    this.trackBehavior('create_space_error', { name: spaceName, error: error.message });
                    this.addMessage('error', 'Failed to create space: ' + error.message);
                }
            },
            
            // Select Space from Main Setup
            async selectSpaceFromMain(spaceId) {
                const startBtn = document.getElementById('mainStartBtn');
                
                if (!spaceId) {
                    document.getElementById('spaceSelectedConfig').style.display = 'none';
                    // Disable start button
                startBtn.disabled = true;
                    startBtn.style.opacity = '0.5';
                    startBtn.style.cursor = 'not-allowed';
                    return;
                }
                
                const select = document.getElementById('mainSpaceSelect');
                const option = select.options[select.selectedIndex];
                
                this.currentSpaceId = spaceId;
                this.currentSpaceName = option.dataset.name;
                this.repoPath = option.dataset.path;
                this.currentSpace = {
                    id: spaceId,
                    name: option.dataset.name,
                    path: option.dataset.path
                };
                
                console.log('[GSX Create] Selected space from main:', this.currentSpace);
                this.trackBehavior('space_selected', { spaceId, name: this.currentSpaceName });
                
                // Enable start button
                startBtn.disabled = false;
                startBtn.style.opacity = '1';
                startBtn.style.cursor = 'pointer';
                
                // Show config options
                document.getElementById('spaceSelectedConfig').style.display = 'block';
                
                // Sync sidebar select
                const sidebarSelect = document.getElementById('spaceSelect');
                if (sidebarSelect) sidebarSelect.value = spaceId;
                
                // Load space data
                await Promise.all([
                    this.loadProjectFiles(),
                    this.loadSpaceItems(),
                    this.loadStyleGuidesForMain(),
                    this.loadJourneyMapsForMain(),
                    this.loadCostSummary(),
                    this.loadGlobalInstructions()
                ]);
                
                // Show sidebar config section too
                const configSection = document.getElementById('configSection');
                if (configSection) configSection.style.display = 'block';
            },
            
            async loadStyleGuidesForMain() {
                if (!this.currentSpaceId) return;
                
                try {
                    const result = await window.aider.getStyleGuides(this.currentSpaceId);
                    if (result.success) {
                        this.styleGuides = result.styleGuides || [];
                        
                        // Populate main select
                        const mainSelect = document.getElementById('mainStyleGuideSelect');
                        if (mainSelect) {
                            mainSelect.innerHTML = '<option value="">None</option>';
                            this.styleGuides.forEach(sg => {
                                const option = document.createElement('option');
                                option.value = sg.id;
                                option.textContent = sg.name;
                                mainSelect.appendChild(option);
                            });
                        }
                        
                        // Also populate sidebar select
                        this.renderStyleGuideSelect();
                    }
                } catch (error) {
                    console.error('[GSX Create] Load style guides error:', error);
                }
            },
            
            async loadJourneyMapsForMain() {
                if (!this.currentSpaceId) return;
                
                try {
                    const result = await window.aider.getJourneyMaps(this.currentSpaceId);
                    if (result.success) {
                        this.journeyMaps = result.journeyMaps || [];
                        
                        // Populate main select
                        const mainSelect = document.getElementById('mainJourneyMapSelect');
                        if (mainSelect) {
                            mainSelect.innerHTML = '<option value="">None</option>';
                            this.journeyMaps.forEach(jm => {
                                const option = document.createElement('option');
                                option.value = jm.id;
                                option.textContent = jm.name;
                                mainSelect.appendChild(option);
                            });
                        }
                        
                        // Also populate sidebar select
                        this.renderJourneyMapSelect();
                    }
                } catch (error) {
                    console.error('[GSX Create] Load journey maps error:', error);
                }
            },
            
            // Select Space
            async selectSpace(spaceId) {
                const sidebarContainer = document.getElementById('sidebarContainer');
                
                if (!spaceId) {
                    this.currentSpace = null;
                    this.currentSpaceId = null;
                    document.getElementById('configSection').style.display = 'none';
                    sidebarContainer.style.display = 'none';
                    return;
                }
                
                const select = document.getElementById('spaceSelect');
                const option = select.options[select.selectedIndex];
                
                this.currentSpaceId = spaceId;
                this.currentSpaceName = option.dataset.name;
                this.repoPath = option.dataset.path;
                this.currentSpace = {
                    id: spaceId,
                    name: option.dataset.name,
                    path: option.dataset.path
                };
                
                console.log('[GSX Create] Selected space:', this.currentSpace);
                
                // Show sidebar container and config section
                sidebarContainer.style.display = 'flex';
                document.getElementById('configSection').style.display = 'block';
                
                // Load space data
                await Promise.all([
                    this.loadProjectFiles(),
                    this.loadSpaceItems(),
                    this.loadStyleGuides(),
                    this.loadJourneyMaps(),
                    this.loadCostSummary(),
                    this.loadGlobalInstructions()
                ]);
            },
            
            // Load Reference Memory Files
            // ========== FILE UPLOAD ==========
            
            // Trigger file input click
            triggerFileUpload() {
                if (!this.repoPath) {
                    this.addMessage('error', 'Please select a space first');
                    return;
                }
                document.getElementById('fileUploadInput').click();
            },
            
            // Handle file input change
            async handleFileUpload(event) {
                const files = event.target.files;
                if (!files || files.length === 0) return;
                
                await this.uploadFiles(Array.from(files));
                event.target.value = ''; // Reset input
            },
            
            // Handle drag over
            handleDragOver(event) {
                event.preventDefault();
                event.stopPropagation();
                event.currentTarget.classList.add('drag-over');
            },
            
            // Handle drag leave
            handleDragLeave(event) {
                event.preventDefault();
                event.stopPropagation();
                event.currentTarget.classList.remove('drag-over');
            },
            
            // Handle file drop
            async handleFileDrop(event) {
                event.preventDefault();
                event.stopPropagation();
                event.currentTarget.classList.remove('drag-over');
                
                if (!this.repoPath) {
                    this.addMessage('error', 'Please select a space first');
                    return;
                }
                
                const files = event.dataTransfer.files;
                if (!files || files.length === 0) return;
                
                await this.uploadFiles(Array.from(files));
            },
            
            // Upload files to the space
            async uploadFiles(files) {
                if (!this.repoPath) return;
                
                this.addMessage('system', `Uploading ${files.length} file(s)...`);
                
                let uploaded = 0;
                let failed = 0;
                const uploadedFiles = [];
                
                for (const file of files) {
                    try {
                        const content = await this.readFileContent(file);
                        const filePath = this.repoPath + '/' + file.name;
                        
                        // Check if it's a binary file
                        if (this.isBinaryFile(file.name)) {
                            // For binary files, we need to save as base64 or use a different method
                            const result = await window.aider.writeFile(filePath, content);
                            if (result && result.success !== false) {
                                uploaded++;
                                uploadedFiles.push({ name: file.name, path: filePath, size: file.size, type: file.type });
                            } else {
                                failed++;
                                console.error('[Upload] Failed to write:', file.name);
                            }
                        } else {
                            // Text file
                            const result = await window.aider.writeFile(filePath, content);
                            if (result && result.success !== false) {
                                uploaded++;
                                uploadedFiles.push({ name: file.name, path: filePath, size: file.size, type: file.type });
                            } else {
                                failed++;
                            }
                        }
                    } catch (e) {
                        console.error('[Upload] Error uploading file:', file.name, e);
                        failed++;
                    }
                }
                
                // Save file metadata to unified space metadata
                if (this.currentSpaceId && uploadedFiles.length > 0) {
                    for (const uploadedFile of uploadedFiles) {
                        try {
                            await window.aider.setFileMetadata(this.currentSpaceId, uploadedFile.path, {
                                source: 'upload',
                                originalName: uploadedFile.name,
                                size: uploadedFile.size,
                                mimeType: uploadedFile.type,
                                uploadedAt: new Date().toISOString()
                            });
                        } catch (e) {
                            console.log('[Upload] Could not save file metadata:', e);
                        }
                    }
                }
                
                // Refresh file list
                await this.loadProjectFiles();
                
                if (failed === 0) {
                    this.addMessage('system', `‚úÖ Uploaded ${uploaded} file(s) successfully`);
                } else {
                    this.addMessage('system', `‚ö†Ô∏è Uploaded ${uploaded} file(s), ${failed} failed`);
                }
                
                // Add to context if session is active
                if (this.contextFiles && uploaded > 0) {
                    const newFiles = files.map(f => this.repoPath + '/' + f.name);
                    try {
                        await window.aider.addFiles(newFiles);
                        this.contextFiles = [...new Set([...this.contextFiles, ...newFiles])];
                        this.renderContextFiles();
                    } catch (e) {
                        console.log('[Upload] Could not add to context:', e);
                    }
                }
            },
            
            // Read file content
            readFileContent(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    
                    if (this.isBinaryFile(file.name)) {
                        // Read as data URL for binary files (images, etc.)
                        reader.onload = () => resolve(reader.result);
                        reader.onerror = reject;
                        reader.readAsDataURL(file);
                    } else {
                        // Read as text for text files
                        reader.onload = () => resolve(reader.result);
                        reader.onerror = reject;
                        reader.readAsText(file);
                    }
                });
            },
            
            // Check if file is binary
            isBinaryFile(fileName) {
                const binaryExtensions = [
                    'png', 'jpg', 'jpeg', 'gif', 'webp', 'ico', 'svg',
                    'pdf', 'doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx',
                    'zip', 'tar', 'gz', 'rar', '7z',
                    'mp3', 'mp4', 'wav', 'avi', 'mov', 'webm',
                    'ttf', 'otf', 'woff', 'woff2', 'eot'
                ];
                const ext = fileName.split('.').pop().toLowerCase();
                return binaryExtensions.includes(ext);
            },
            
            // ========== END FILE UPLOAD ==========
            
            async loadProjectFiles() {
                if (!this.repoPath) return;
                
                try {
                    const result = await window.aider.listProjectFiles(this.repoPath);
                    console.log('[GSX Create] Project files:', result);
                    
                    if (result.success) {
                        this.projectFiles = result.files || [];
                        this.renderProjectFiles();
                        this.populateMainFileSelect();
                    }
                } catch (error) {
                    console.error('[GSX Create] Load files error:', error);
                }
            },
            
            // Populate main file dropdown with HTML files
            populateMainFileSelect() {
                const select = document.getElementById('mainFileSelect');
                if (!select) return;
                
                const files = this.projectFiles.filter(f => !f.isDirectory);
                const htmlFiles = files.filter(f => 
                    f.name.toLowerCase().endsWith('.html') || 
                    f.name.toLowerCase().endsWith('.htm')
                );
                
                // Keep auto-detect option
                select.innerHTML = '<option value="">Auto-detect</option>';
                
                // Add HTML files
                htmlFiles.forEach(file => {
                    const option = document.createElement('option');
                    option.value = file.path;
                    option.textContent = file.name;
                    select.appendChild(option);
                });
                
                // If we have a saved main file, select it
                if (this.mainFile) {
                    select.value = this.mainFile;
                    } else {
                    // Auto-detect and set
                    this.autoDetectMainFile();
                }
            },
            
            // Auto-detect the main HTML file
            async autoDetectMainFile() {
                const mainFile = await this.findMainHtmlFile();
                if (mainFile) {
                    this.mainFile = mainFile;
                    const select = document.getElementById('mainFileSelect');
                    if (select) {
                        select.value = mainFile;
                    }
                    console.log('[GSX Create] Auto-detected main file:', mainFile);
                }
            },
            
            // Set the main file (called from dropdown)
            setMainFile(filePath) {
                this.mainFile = filePath || null;
                console.log('[GSX Create] Main file set to:', this.mainFile || 'Auto-detect');
                
                // If a file is selected, preview it
                if (filePath) {
                    this.previewFile(filePath);
                }
            },
            
            // Render Reference Memory Files
            renderProjectFiles() {
                const fileList = document.getElementById('fileList');
                const fileCount = document.getElementById('fileCount');
                
                const files = this.projectFiles.filter(f => !f.isDirectory);
                fileCount.textContent = files.length;
                
                if (files.length === 0) {
                    fileList.innerHTML = '<div style="color: var(--text-muted); font-size: 11px; padding: 8px;">No files yet</div>';
                    return;
                }
                
                fileList.innerHTML = files.map(file => {
                    const inContext = this.contextFiles.includes(file.path);
                    const icon = this.getFileIcon(file.name);
                    const ext = file.name.split('.').pop().toLowerCase();
                    const isPreviewable = ['html', 'htm', 'css', 'js', 'json', 'ts', 'txt', 'md'].includes(ext);
                    return `
                        <div class="file-item ${inContext ? 'in-context' : ''}" 
                             onclick="GSXCreate.selectFile('${file.path}')">
                            <span class="icon">${icon}</span>
                            <span>${file.name}</span>
                            ${isPreviewable ? '<span class="preview-icon" title="Click to preview">&#128065;</span>' : ''}
                        </div>
                    `;
                }).join('');
            },
            
            // Load Space Items
            async loadSpaceItems() {
                if (!this.currentSpaceId) return;
                
                try {
                    const result = await window.aider.getSpaceItems(this.currentSpaceId);
                    if (result.success) {
                        this.spaceItems = result.items || [];
                        console.log('[GSX Create] Space items:', this.spaceItems);
                    }
                } catch (error) {
                    console.error('[GSX Create] Load space items error:', error);
                }
            },
            
            // Load Style Guides
            async loadStyleGuides() {
                if (!this.currentSpaceId) return;
                
                try {
                    const result = await window.aider.getStyleGuides(this.currentSpaceId);
                    if (result.success) {
                        this.styleGuides = result.styleGuides || [];
                        this.renderStyleGuideSelect();
                    }
                } catch (error) {
                    console.error('[GSX Create] Load style guides error:', error);
                }
            },
            
            renderStyleGuideSelect() {
                const select = document.getElementById('styleGuideSelect');
                select.innerHTML = '<option value="">None</option>';
                
                this.styleGuides.forEach(sg => {
                    const option = document.createElement('option');
                    option.value = sg.id;
                    option.textContent = sg.name;
                    select.appendChild(option);
                });
            },
            
            // Load Journey Maps
            async loadJourneyMaps() {
                if (!this.currentSpaceId) return;
                
                try {
                    const result = await window.aider.getJourneyMaps(this.currentSpaceId);
                    if (result.success) {
                        this.journeyMaps = result.journeyMaps || [];
                        this.renderJourneyMapSelect();
                    }
                } catch (error) {
                    console.error('[GSX Create] Load journey maps error:', error);
                }
            },
            
            renderJourneyMapSelect() {
                const select = document.getElementById('journeyMapSelect');
                select.innerHTML = '<option value="">None</option>';
                
                this.journeyMaps.forEach(jm => {
                    const option = document.createElement('option');
                    option.value = jm.id;
                    option.textContent = jm.name;
                    select.appendChild(option);
                });
            },
            
            // Toggle File Context
            // Select file - adds to context AND previews
            async selectFile(filePath) {
                // Add to context if not already there
                if (!this.contextFiles.includes(filePath)) {
                    this.contextFiles.push(filePath);
                    await window.aider.addFiles([filePath]);
                    this.renderProjectFiles();
                    this.renderContextFiles();
                }
                
                // Preview the file
                this.previewFile(filePath);
            },
            
            async toggleFileContext(filePath) {
                const index = this.contextFiles.indexOf(filePath);
                const action = index > -1 ? 'removed' : 'added';
                
                this.trackBehavior('context_file_toggle', { 
                    file: filePath.split('/').pop(), 
                    action 
                });
                
                if (index > -1) {
                    this.contextFiles.splice(index, 1);
                    await window.aider.removeFiles([filePath]);
                } else {
                    this.contextFiles.push(filePath);
                    await window.aider.addFiles([filePath]);
                }
                
                this.renderProjectFiles();
                this.renderContextFiles();
            },
            
            renderContextFiles() {
                const contextList = document.getElementById('contextList');
                const contextCount = document.getElementById('contextCount');
                
                contextCount.textContent = this.contextFiles.length;
                
                if (this.contextFiles.length === 0) {
                    contextList.innerHTML = '<div style="color: var(--text-muted); font-size: 11px;">Click files to add</div>';
                    return;
                }
                
                contextList.innerHTML = this.contextFiles.map(path => {
                    const name = path.split('/').pop();
                    return `
                        <div class="file-item in-context" onclick="GSXCreate.toggleFileContext('${path}')">
                            <span>${name}</span>
                            <span style="margin-left: auto; opacity: 0.5;">√ó</span>
                        </div>
                    `;
                }).join('');
            },
            
            // Start Session
            async startSession() {
                // Get buttons (main or sidebar)
                const startBtn = document.getElementById('mainStartBtn') || document.getElementById('startBtn');
                const modelName = this.selectedModel;
                
                this.trackBehavior('session_starting', { 
                    space: this.currentSpaceName, 
                    model: modelName 
                });
                
                // Get style guide and journey map from main selects if available
                const styleGuideSelect = document.getElementById('mainStyleGuideSelect') || document.getElementById('styleGuideSelect');
                const journeyMapSelect = document.getElementById('mainJourneyMapSelect') || document.getElementById('journeyMapSelect');
                
                if (styleGuideSelect && styleGuideSelect.value) {
                    // Sync to sidebar
                    const sidebarSG = document.getElementById('styleGuideSelect');
                    if (sidebarSG) sidebarSG.value = styleGuideSelect.value;
                }
                if (journeyMapSelect && journeyMapSelect.value) {
                    const sidebarJM = document.getElementById('journeyMapSelect');
                    if (sidebarJM) sidebarJM.value = journeyMapSelect.value;
                }
                
                startBtn.disabled = true;
                startBtn.textContent = 'Starting...';
                
                try {
                    this.updateStatus('Starting...', false);
                    
                    const startResult = await window.aider.start();
                    if (!startResult.success) {
                        throw new Error(startResult.error || 'Failed to start');
                    }
                    
                    this.updateStatus('Initializing...', false);
                    
                    const result = await window.aider.initialize(this.repoPath, modelName);
                    
                    if (result.success) {
                        this.updateStatus('Connected', true);
                        
                        // Add all files to context automatically
                        const filePaths = this.projectFiles.filter(f => !f.isDirectory).map(f => f.path);
                        if (filePaths.length > 0) {
                            await window.aider.addFiles(filePaths);
                            this.contextFiles = filePaths;
                            this.renderContextFiles();
                        }
                        
                        // Show chat area and sidebar, hide setup
                        document.getElementById('setupPanel').classList.add('hidden');
                        document.getElementById('chatArea').classList.add('active');
                        document.getElementById('sidebarContainer').style.display = 'flex';
                        document.getElementById('costDisplay').classList.add('visible');
                        
                        // Initialize meta learning cycle panel
                        this.initCyclePanel();
                        
                        // Load episodic memory in sidebar
                        this.loadEpisodicMemory();
                        
                        // Load constitutional memory (persistent guidelines)
                        this.loadConstitutionalMemory();
                        
                        // Check if this is a new project that needs setup
                        const needsSetup = await this.checkIfNeedsSetup();
                        
                        if (needsSetup) {
                            // Start the setup wizard agent
                            await this.startSetupWizard();
                        } else {
                            this.addMessage('system', `Connected to ${this.currentSpaceName}. ${filePaths.length} files in context.`);
                        }
                    } else {
                        throw new Error(result.error || 'Initialization failed');
                    }
                } catch (error) {
                    console.error('[GSX Create] Start error:', error);
                    this.addMessage('error', error.message);
                    this.updateStatus('Error', false);
                } finally {
                    startBtn.disabled = false;
                    startBtn.textContent = 'Start Session';
                }
            },
            
            // ========== SETUP WIZARD AGENT ==========
            
            setupWizardActive: false,
            setupWizardPhase: null,
            setupWizardData: {},
            setupWizardAssets: [],
            setupWizardCurrentAsset: 0,
            setupWizardAwaitingApproval: false,
            
            // Asset types with metadata
            assetTypes: {
                'journey-map': {
                    name: 'Journey Map',
                    description: 'User flow and interaction paths',
                    fileName: 'journey-map.md',
                    icon: 'üó∫Ô∏è'
                },
                'style-guide': {
                    name: 'Style Guide',
                    description: 'Colors, typography, and design tokens',
                    fileName: 'style-guide.md',
                    icon: 'üé®'
                },
                'user-personas': {
                    name: 'User Personas',
                    description: 'Target user profiles and needs',
                    fileName: 'user-personas.md',
                    icon: 'üë§'
                },
                'requirements': {
                    name: 'Requirements',
                    description: 'Functional and non-functional requirements',
                    fileName: 'requirements.md',
                    icon: 'üìã'
                },
                'todo': {
                    name: 'Todo List',
                    description: 'Tasks for v1 implementation',
                    fileName: 'todo.md',
                    icon: '‚úÖ'
                },
                'evaluation-criteria': {
                    name: 'Evaluation Criteria',
                    description: 'How to measure success',
                    fileName: 'evaluation-criteria.md',
                    icon: 'üìä'
                }
            },
            
            // Check if the space needs initial setup
            async checkIfNeedsSetup() {
                // First check unified space metadata
                if (this.currentSpaceId) {
                    try {
                        const result = await window.aider.getSpaceMetadata(this.currentSpaceId);
                        if (result.success && result.metadata) {
                            const config = result.metadata.projectConfig;
                            if (config && config.setupComplete) {
                                console.log('[SetupWizard] Setup already complete (from space metadata)');
                                return false;
                            }
                        }
                    } catch (e) {
                        console.log('[SetupWizard] Could not read space metadata:', e);
                    }
                }
                
                // Fallback: Check for project-config.json
                const configFile = this.projectFiles.find(f => 
                    f.name === 'project-config.json'
                );
                
                if (configFile) {
                    try {
                        const content = await window.aider.readFile(configFile.path);
                        const config = JSON.parse(content);
                        if (config.setupComplete) {
                            return false;
                        }
                    } catch (e) {
                        console.log('[SetupWizard] Could not read config file:', e);
                    }
                }
                
                // Check for HTML files
                const htmlFiles = this.projectFiles.filter(f => 
                    !f.isDirectory && 
                    (f.name.toLowerCase().endsWith('.html') || f.name.toLowerCase().endsWith('.htm'))
                );
                
                if (htmlFiles.length === 0) {
                    return true;
                }
                
                // Check for essential assets
                const hasJourneyMap = this.projectFiles.find(f => f.name === 'journey-map.md');
                const hasStyleGuide = this.projectFiles.find(f => f.name === 'style-guide.md');
                
                if (!hasJourneyMap || !hasStyleGuide) {
                    return true;
                }
                
                return false;
            },
            
            // Start the setup wizard
            async startSetupWizard() {
                this.setupWizardActive = true;
                this.setupWizardPhase = 'welcome';
                this.setupWizardData = {
                    projectName: this.currentSpaceName,
                    description: null,
                    targetUsers: null,
                    keyFeatures: [],
                    stylePreference: null,
                    approvedAssets: {}
                };
                this.setupWizardAssets = [];
                this.setupWizardCurrentAsset = 0;
                this.setupWizardAwaitingApproval = false;
                
                this.addMessage('assistant', `üëã **Welcome to ${this.currentSpaceName}!**

I'll help you set up this project step by step. We'll create:

1. **Project Vision** - What you're building and for whom
2. **Journey Map** - How users will interact with your app
3. **Style Guide** - Colors, fonts, and design system
4. **MVP (v1)** - A working minimal version
5. **Todo List** - Tasks for future iterations

Let's start! **What would you like to build?**

Describe your idea in a sentence or two.`);
                
                this.setupWizardPhase = 'description';
            },
            
            // Process setup wizard responses
            async processSetupWizardInput(message) {
                if (!this.setupWizardActive) return false;
                
                // Handle approval responses
                if (this.setupWizardAwaitingApproval) {
                    return await this.handleAssetApproval(message);
                }
                
                switch (this.setupWizardPhase) {
                    case 'description':
                        this.setupWizardData.description = message;
                        await this.askTargetUsers();
                        return true;
                        
                    case 'target-users':
                        this.setupWizardData.targetUsers = message;
                        await this.askKeyFeatures();
                        return true;
                        
                    case 'features':
                        await this.processFeatures(message);
                        return true;
                        
                    case 'style':
                        this.setupWizardData.stylePreference = message;
                        await this.startAssetGeneration();
                        return true;
                        
                    case 'mvp-approval':
                        return await this.handleMVPApproval(message);
                        
                    default:
                        return false;
                }
            },
            
            // Ask about target users
            async askTargetUsers() {
                this.setupWizardPhase = 'target-users';
                this.addMessage('assistant', `Great! **Who is this for?**

Describe your target users:
‚Ä¢ Who will use this?
‚Ä¢ What problem does it solve for them?
‚Ä¢ Any specific needs or constraints?`);
            },
            
            // Ask about key features
            async askKeyFeatures() {
                this.setupWizardPhase = 'features';
                
                this.addMessage('assistant', `Thinking about key features...`);
                
                const prompt = `Based on this project, suggest 5-7 key features as a numbered list.

Project: ${this.setupWizardData.description}
Target Users: ${this.setupWizardData.targetUsers}

Return ONLY a numbered list of features with brief descriptions. Be specific and actionable.`;

                try {
                    const response = await this.callAIForSetup(prompt);
                    this.setupWizardData.suggestedFeatures = response;
                    
                    this.addMessage('assistant', `Here are the key features I'd suggest:

${response}

**Do these look right?**

Reply "yes" to continue, or list the features you'd prefer.`);
                } catch (e) {
                    this.addMessage('assistant', `What are the key features you want? List them out.`);
                }
            },
            
            // Process features response
            async processFeatures(message) {
                const lower = message.toLowerCase();
                if (lower === 'yes' || lower === 'looks good' || lower === 'perfect' || lower === 'ok') {
                    this.setupWizardData.keyFeatures = this.setupWizardData.suggestedFeatures;
                } else {
                    this.setupWizardData.keyFeatures = message;
                }
                
                await this.askStylePreference();
            },
            
            // Ask about style
            async askStylePreference() {
                this.setupWizardPhase = 'style';
                
                this.addMessage('assistant', `**What visual style fits your project?**

‚Ä¢ **Minimal** - Clean, lots of whitespace, subtle colors
‚Ä¢ **Bold** - Strong colors, high contrast, impactful
‚Ä¢ **Dark** - Dark backgrounds, easy on eyes
‚Ä¢ **Soft** - Rounded corners, pastels, friendly
‚Ä¢ **Professional** - Corporate, trustworthy, structured

Or describe your own style!`);
            },
            
            // Start generating assets
            async startAssetGeneration() {
                this.addMessage('assistant', `Perfect! Now I'll create your project assets one by one.

Each asset will appear in the preview panel. **Review it and type "approve" to continue**, or describe changes you'd like.

---

**Creating Journey Map...**`);
                
                // Define assets to create in order
                this.setupWizardAssets = [
                    'journey-map',
                    'style-guide',
                    'user-personas',
                    'requirements',
                    'evaluation-criteria'
                ];
                
                this.setupWizardCurrentAsset = 0;
                await this.generateNextAsset();
            },
            
            // Generate the next asset
            async generateNextAsset() {
                if (this.setupWizardCurrentAsset >= this.setupWizardAssets.length) {
                    // All assets done, create MVP
                    await this.createMVP();
                    return;
                }
                
                const assetKey = this.setupWizardAssets[this.setupWizardCurrentAsset];
                const asset = this.assetTypes[assetKey];
                
                this.addMessage('system', `${asset.icon} Creating ${asset.name}...`);
                
                const prompt = this.getAssetPrompt(assetKey);
                
                try {
                    const result = await window.aider.runPrompt(prompt);
                    
                    // Refresh files and preview the new asset
                    await this.loadProjectFiles();
                    const assetPath = this.repoPath + '/' + asset.fileName;
                    await this.previewFile(assetPath);
                    
                    // Save asset metadata
                    await this.saveAssetMetadata(assetKey, asset.fileName);
                    
                    this.addMessage('assistant', `${asset.icon} **${asset.name}** is ready!

I've opened it in the preview panel. Please review it.

**Type "approve" to continue**, or describe any changes you'd like.`);
                    
                    this.setupWizardAwaitingApproval = true;
                    
                } catch (e) {
                    console.error('[SetupWizard] Asset generation error:', e);
                    this.addMessage('error', `Failed to create ${asset.name}: ${e.message}`);
                    // Skip to next asset
                    this.setupWizardCurrentAsset++;
                    await this.generateNextAsset();
                }
            },
            
            // Get prompt for each asset type
            getAssetPrompt(assetKey) {
                const context = `
Project: ${this.setupWizardData.description}
Target Users: ${this.setupWizardData.targetUsers}
Key Features: ${this.setupWizardData.keyFeatures}
Style: ${this.setupWizardData.stylePreference}`;

                const prompts = {
                    'journey-map': `Create a journey-map.md file for this project:
${context}

Include:
1. User entry points (how users discover/access the app)
2. Key user flows (step-by-step paths through main features)
3. Decision points and branches
4. Success states and error states
5. Emotional journey notes

Format as clear Markdown with sections and diagrams using ASCII/text.`,

                    'style-guide': `Create a style-guide.md file for this project:
${context}

Include:
1. Color palette (primary, secondary, accent, semantic colors) with hex codes
2. Typography (font families, sizes, weights)
3. Spacing system (consistent spacing values)
4. Border radius and shadows
5. Component patterns (buttons, inputs, cards)
6. Dark/light mode considerations if applicable

Format as Markdown with CSS variable examples.`,

                    'user-personas': `Create a user-personas.md file for this project:
${context}

Include 2-3 personas with:
1. Name and brief bio
2. Goals and motivations
3. Pain points and frustrations
4. Technical comfort level
5. How they would use this app
6. Key quotes that represent their mindset

Format as clear Markdown with sections for each persona.`,

                    'requirements': `Create a requirements.md file for this project:
${context}

Include:
1. Functional requirements (what the app must do)
2. Non-functional requirements (performance, accessibility, etc.)
3. MVP scope (what's in v1 vs future versions)
4. Constraints and assumptions
5. Success metrics

Format as Markdown with clear sections and bullet points.`,

                    'evaluation-criteria': `Create an evaluation-criteria.md file for this project:
${context}

Include criteria for rating the app on:
1. Functionality (features work correctly)
2. User Experience (intuitive, easy to use)
3. Performance (fast, responsive)
4. Design (visually appealing, consistent)
5. Code Quality (clean, maintainable)
6. Accessibility (keyboard, screen reader support)

Each criterion should have:
- Description
- Rating scale (1-10)
- What constitutes each rating level

Format as Markdown with checkboxes for evaluation.`
                };
                
                return prompts[assetKey] || `Create a ${assetKey}.md file with relevant content for this project:\n${context}`;
            },
            
            // Handle asset approval
            async handleAssetApproval(message) {
                const lower = message.toLowerCase().trim();
                const assetKey = this.setupWizardAssets[this.setupWizardCurrentAsset];
                const asset = this.assetTypes[assetKey];
                
                if (lower === 'approve' || lower === 'approved' || lower === 'yes' || lower === 'ok' || lower === 'looks good') {
                    // Mark as approved
                    this.setupWizardData.approvedAssets[assetKey] = {
                        approved: true,
                        approvedAt: new Date().toISOString()
                    };
                    
                    await this.updateAssetMetadata(assetKey, { approved: true });
                    
                    this.addMessage('system', `‚úÖ ${asset.name} approved!`);
                    
                    // Move to next asset
                    this.setupWizardCurrentAsset++;
                    this.setupWizardAwaitingApproval = false;
                    await this.generateNextAsset();
                    
                } else {
                    // User wants changes
                    this.addMessage('assistant', `Making changes to ${asset.name}...`);
                    
                    const changePrompt = `Update the ${asset.fileName} file based on this feedback:

${message}

Keep the same format but incorporate the requested changes.`;

                    try {
                        await window.aider.runPrompt(changePrompt);
                        await this.loadProjectFiles();
                        
                        const assetPath = this.repoPath + '/' + asset.fileName;
                        await this.previewFile(assetPath);
                        
                        this.addMessage('assistant', `I've updated the ${asset.name}. Please review again.

**Type "approve" to continue**, or describe more changes.`);
                        
                    } catch (e) {
                        this.addMessage('error', `Failed to update: ${e.message}`);
                    }
                }
                
                return true;
            },
            
            // Save asset metadata (uses unified space metadata)
            async saveAssetMetadata(assetKey, fileName) {
                if (!this.currentSpaceId) return;
                
                try {
                    await window.aider.setAssetMetadata(this.currentSpaceId, assetKey, {
                        fileName: fileName,
                        approved: false,
                        version: 1
                    });
                    console.log('[SetupWizard] Asset metadata saved:', assetKey);
                } catch (e) {
                    console.error('[SetupWizard] Failed to save asset metadata:', e);
                }
            },
            
            // Update asset metadata (uses unified space metadata)
            async updateAssetMetadata(assetKey, updates) {
                if (!this.currentSpaceId) return;
                
                try {
                    // Get current metadata
                    const result = await window.aider.getSpaceMetadata(this.currentSpaceId);
                    if (result.success && result.metadata && result.metadata.assets[assetKey]) {
                        const currentAsset = result.metadata.assets[assetKey];
                        await window.aider.setAssetMetadata(this.currentSpaceId, assetKey, {
                            ...currentAsset,
                            ...updates
                        });
                    }
                    console.log('[SetupWizard] Asset metadata updated:', assetKey);
                } catch (e) {
                    console.error('[SetupWizard] Failed to update asset metadata:', e);
                }
            },
            
            // Create the MVP
            async createMVP() {
                this.setupWizardPhase = 'mvp-approval';
                
                this.addMessage('assistant', `üöÄ **All assets approved!**

Now I'll create the **MVP (v1)** - a minimal working version of your app.

This will be a fully functional HTML file with:
‚Ä¢ Core features implemented
‚Ä¢ Your chosen style applied
‚Ä¢ Sample data included

Creating MVP...`);
                
                const prompt = `Create a complete, working HTML file for this project.

Project: ${this.setupWizardData.description}
Target Users: ${this.setupWizardData.targetUsers}
Features: ${this.setupWizardData.keyFeatures}
Style: ${this.setupWizardData.stylePreference}

Requirements:
1. Single HTML file with embedded CSS and JavaScript
2. Implement the core MVP features
3. Apply the style guide colors and typography
4. Include realistic sample data
5. Make it fully interactive and functional
6. Responsive design
7. Clean, commented code

Name the file appropriately (e.g., app.html, calendar.html, dashboard.html).

Create the file now.`;

                try {
                    const result = await window.aider.runPrompt(prompt);
                    
                    await this.loadProjectFiles();
                    await this.autoDetectMainFile();
                    
                    if (this.mainFile) {
                        await this.previewFile(this.mainFile);
                    }
                    
                    this.addMessage('assistant', `üéâ **MVP Created!**

Your minimal viable product is ready in the preview panel.

**Please review it and type "approve"** to finalize setup, or describe any changes needed.`);
                    
                    this.setupWizardAwaitingApproval = true;
                    
                } catch (e) {
                    console.error('[SetupWizard] MVP creation error:', e);
                    this.addMessage('error', `Failed to create MVP: ${e.message}`);
                }
            },
            
            // Handle MVP approval
            async handleMVPApproval(message) {
                const lower = message.toLowerCase().trim();
                
                if (lower === 'approve' || lower === 'approved' || lower === 'yes' || lower === 'ok' || lower === 'looks good') {
                    await this.finishSetup();
                } else {
                    // User wants changes
                    this.addMessage('assistant', `Making changes to the MVP...`);
                    
                    try {
                        await window.aider.runPrompt(`Update the main HTML file based on this feedback:\n\n${message}`);
                        await this.loadProjectFiles();
                        
                        if (this.mainFile) {
                            await this.previewFile(this.mainFile);
                        }
                        
                        this.addMessage('assistant', `I've updated the MVP. Please review again.

**Type "approve" to finalize**, or describe more changes.`);
                        
                    } catch (e) {
                        this.addMessage('error', `Failed to update: ${e.message}`);
                    }
                }
                
                return true;
            },
            
            // Finish setup and create todo list
            async finishSetup() {
                this.addMessage('system', `‚úÖ MVP approved!`);
                this.addMessage('assistant', `Creating todo list for future iterations...`);
                
                // Create todo list
                const todoPrompt = `Create a todo.md file for this project's future development.

Project: ${this.setupWizardData.description}
Current MVP Features: ${this.setupWizardData.keyFeatures}

Include:
1. v2 Features (next iteration)
2. v3 Features (future)
3. Technical debt and improvements
4. Nice-to-have features

Format as Markdown with checkboxes [ ] for each item.`;

                try {
                    await window.aider.runPrompt(todoPrompt);
                    await this.loadProjectFiles();
                } catch (e) {
                    console.log('[SetupWizard] Todo creation error:', e);
                }
                
                // Update unified space metadata with project config
                if (this.currentSpaceId) {
                    try {
                        await window.aider.updateProjectConfig(this.currentSpaceId, {
                            setupComplete: true,
                            setupCompletedAt: new Date().toISOString(),
                            currentVersion: 1,
                            mainFile: this.mainFile,
                            description: this.setupWizardData.description,
                            targetUsers: this.setupWizardData.targetUsers,
                            stylePreference: this.setupWizardData.stylePreference
                        });
                        
                        // Add version to history
                        await window.aider.addVersion(this.currentSpaceId, {
                            description: 'v1 - Initial MVP from setup wizard',
                            mainFile: this.mainFile,
                            assets: Object.keys(this.setupWizardData.approvedAssets)
                        });
                        
                        console.log('[SetupWizard] Space metadata updated');
                    } catch (e) {
                        console.error('[SetupWizard] Failed to update space metadata:', e);
                    }
                }
                
                // Also save local project-config.json for backwards compatibility
                const config = {
                    projectName: this.setupWizardData.projectName,
                    description: this.setupWizardData.description,
                    targetUsers: this.setupWizardData.targetUsers,
                    stylePreference: this.setupWizardData.stylePreference,
                    setupComplete: true,
                    setupCompletedAt: new Date().toISOString(),
                    currentVersion: 1,
                    approvedAssets: this.setupWizardData.approvedAssets
                };
                
                await window.aider.writeFile(
                    this.repoPath + '/project-config.json',
                    JSON.stringify(config, null, 2)
                );
                
                // Save version
                await this.saveVersion('v1 - Initial MVP from setup wizard');
                
                // Complete wizard
                this.setupWizardActive = false;
                this.setupWizardPhase = null;
                this.setupWizardAwaitingApproval = false;
                
                await this.loadProjectFiles();
                
                this.addMessage('assistant', `üéä **Setup Complete!**

Your project is ready with:
‚Ä¢ ‚úÖ Journey Map
‚Ä¢ ‚úÖ Style Guide  
‚Ä¢ ‚úÖ User Personas
‚Ä¢ ‚úÖ Requirements
‚Ä¢ ‚úÖ Evaluation Criteria
‚Ä¢ ‚úÖ MVP (v1)
‚Ä¢ ‚úÖ Todo List

**What's next?**
‚Ä¢ Start the **Meta Learning Cycle** to iterate and improve
‚Ä¢ Or just tell me what changes you'd like to make

You're all set! üöÄ`);
            },
            
            // Simple AI call for setup suggestions
            async callAIForSetup(prompt) {
                const result = await window.aider.runPrompt(prompt);
                return result.response || '';
            },
            
            // ========== END SETUP WIZARD ==========
            
            // Store last visual analysis for context
            lastVisualAnalysis: null,
            lastVisualAnalysisTime: null,
            
            // Send Prompt with Streaming
            async sendPrompt() {
                const input = document.getElementById('promptInput');
                const sendBtn = document.getElementById('sendBtn');
                const message = input.value.trim();
                
                if (!message) return;
                
                // Track prompt
                this.trackBehavior('prompt_sent', { 
                    length: message.length, 
                    preview: message.substring(0, 50) 
                });
                
                // Store as last prompt for cycle context
                this.cycleState.lastPrompt = message;
                
                // Check if setup wizard is active
                if (this.setupWizardActive) {
                this.addMessage('user', message);
                input.value = '';
                    const handled = await this.processSetupWizardInput(message);
                    if (handled) return;
                }
                
                // Check if cycle is waiting for objective
                if (this.cycleState.waitingForObjective) {
                    this.cycleState.objective = message;
                    this.cycleState.waitingForObjective = false;
                    this.cycleState.paused = false;
                    this.addMessage('user', message);
                    input.value = '';
                    this.updateCycleUI();
                    // Resume the research phase with the objective
                    await this.runPhase('research');
                    return;
                }
                
                this.addMessage('user', message);
                input.value = '';
                
                sendBtn.disabled = true;
                sendBtn.textContent = 'Thinking...';
                
                // Create a streaming message element
                const streamingMsgId = 'streaming-' + Date.now();
                this.addStreamingMessage(streamingMsgId);
                
                try {
                    // Build full message with context
                    let fullMessage = '';
                    
                    // Check if user is asking to implement something and we have recent visual analysis
                    const implementKeywords = ['implement', 'impliment', 'apply', 'make these changes', 'fix these', 'do these', 'add these', 'update based on'];
                    const isImplementRequest = implementKeywords.some(kw => message.toLowerCase().includes(kw));
                    
                    // Include visual analysis if recent (within 5 minutes) and user is asking to implement
                    if (this.lastVisualAnalysis && isImplementRequest) {
                        const analysisAge = Date.now() - this.lastVisualAnalysisTime;
                        if (analysisAge < 5 * 60 * 1000) { // 5 minutes
                            fullMessage += `[Visual Analysis of Current UI - Please implement these improvements]\n${this.lastVisualAnalysis}\n\n`;
                            fullMessage += `[User Request]\n${message}\n\nPlease implement the improvements from the visual analysis above. Focus on the high priority items first.\n\n`;
                        } else {
                            fullMessage += message;
                        }
                    } else {
                        fullMessage += message;
                    }
                    
                    // Add global instructions
                    if (this.globalInstructionsText) {
                        fullMessage = `[Global Instructions]\n${this.globalInstructionsText}\n\n` + fullMessage;
                    }
                    
                    // Add style guide if selected
                    const styleGuideId = document.getElementById('styleGuideSelect').value;
                    if (styleGuideId) {
                        const sg = this.styleGuides.find(s => s.id === styleGuideId);
                        if (sg && sg.content) {
                            fullMessage += `[Style Guide: ${sg.name}]\n${sg.content}\n\n`;
                        }
                    }
                    
                    // Add journey map if selected
                    const journeyMapId = document.getElementById('journeyMapSelect').value;
                    if (journeyMapId) {
                        const jm = this.journeyMaps.find(j => j.id === journeyMapId);
                        if (jm && jm.content) {
                            fullMessage += `[Journey Map: ${jm.name}]\n${jm.content}\n\n`;
                        }
                    }
                    
                    fullMessage += message;
                    
                    // Use streaming to show thinking process
                    let lastRefresh = Date.now();
                    let streamedContent = ''; // Accumulate streamed content for token counting
                    
                    const result = await window.aider.runPromptStreaming(
                        fullMessage,
                        (token) => {
                            streamedContent += token; // Accumulate for cost calculation
                            this.appendToStreamingMessage(streamingMsgId, token);
                            
                            // Check for file modification indicators and refresh preview
                            // Refresh every 2 seconds if we're in the middle of edits
                            const now = Date.now();
                            if (now - lastRefresh > 2000) {
                                lastRefresh = now;
                                if (this.currentPreviewFile) {
                                    this.refreshPreview();
                                }
                            }
                        },
                        { include_thinking: true }
                    );
                    
                    // Final refresh after completion
                    if (this.currentPreviewFile) {
                        this.refreshPreview();
                    }
                    
                    // Finalize the streaming message
                    this.finalizeStreamingMessage(streamingMsgId, result);
                    
                    if (result.success) {
                        const fileDetails = result.file_details || [];
                        
                        // Parse actual token counts and cost from Aider's output
                        const model = document.getElementById('modelSelect').value;
                        let inputTokens = 0;
                        let outputTokens = 0;
                        let actualCost = 0;
                        
                        // Try to parse "Tokens: 15k sent, 2.1k received. Cost: $0.08 message"
                        const tokenMatch = streamedContent.match(/Tokens:\s*([\d.]+)k?\s*sent,\s*([\d.]+)k?\s*received/i);
                        const costMatch = streamedContent.match(/Cost:\s*\$([\d.]+)\s*message/i);
                        
                        if (tokenMatch) {
                            inputTokens = parseFloat(tokenMatch[1]) * (tokenMatch[1].includes('k') || streamedContent.includes('k sent') ? 1000 : 1);
                            outputTokens = parseFloat(tokenMatch[2]) * (tokenMatch[2].includes('k') || streamedContent.includes('k received') ? 1000 : 1);
                            // Handle "15k" format
                            if (streamedContent.match(/[\d.]+k\s*sent/i)) inputTokens = parseFloat(tokenMatch[1]) * 1000;
                            if (streamedContent.match(/[\d.]+k\s*received/i)) outputTokens = parseFloat(tokenMatch[2]) * 1000;
                        }
                        
                        if (costMatch) {
                            actualCost = parseFloat(costMatch[1]);
                        }
                        
                        // Fallback to estimates if parsing failed
                        if (inputTokens === 0) inputTokens = Math.ceil(fullMessage.length / 4);
                        if (outputTokens === 0) outputTokens = Math.ceil(streamedContent.length / 4);
                        
                        console.log('[GSX Create] Parsed tokens - input:', inputTokens, 'output:', outputTokens, 'actual cost:', actualCost);
                        
                        // Use actual cost if available, otherwise calculate
                        await this.recordApiCost(model, inputTokens, outputTokens, 'prompt', message, actualCost);
                        
                        // Register created/modified files
                        for (const file of fileDetails) {
                            try {
                                if (file.action === 'created') {
                                    await window.aider.registerCreatedFile({
                                        spaceId: this.currentSpaceId,
                                        filePath: file.path,
                                        description: file.description || result.summary,
                                        aiModel: model
                                    });
                                } else if (file.action === 'modified') {
                                    await window.aider.updateFileMetadata({
                                        spaceId: this.currentSpaceId,
                                        filePath: file.path,
                                        description: file.description || result.summary
                                    });
                                }
                            } catch (e) {
                                console.error('[GSX Create] File registration error:', e);
                            }
                        }
                        
                        // Refresh files and preview
                        await this.loadProjectFiles();
                        
                        // Auto-preview first HTML file
                        const htmlFile = fileDetails.find(f => f.path && f.path.endsWith('.html'));
                        if (htmlFile) {
                            setTimeout(() => this.previewFile(htmlFile.path), 500);
                        }
                    }
                } catch (error) {
                    console.error('[GSX Create] Prompt error:', error);
                    this.removeStreamingMessage(streamingMsgId);
                    this.addMessage('error', error.message);
                } finally {
                    sendBtn.disabled = false;
                    sendBtn.textContent = 'Send';
                    
                    // Notify any pending fix callbacks
                    if (this.onPromptComplete) {
                        this.onPromptComplete();
                    }
                }
            },
            
            // Callback for fix-one-by-one flow
            pendingFixCallback: null,
            
            // Streaming message helpers
            streamingPhase: '',
            streamingStartTime: null,
            
            addStreamingMessage(id) {
                const messages = document.getElementById('messages');
                const now = new Date();
                const time = now.toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit' });
                
                this.streamingStartTime = Date.now();
                this.streamingPhase = 'thinking';
                
                const msgDiv = document.createElement('div');
                msgDiv.className = 'message';
                msgDiv.id = id;
                msgDiv.innerHTML = `
                    <span class="message-time">${time}</span>
                    <span class="message-type ai">AI</span>
                    <div class="message-content streaming">
                        <div class="streaming-status" id="${id}-status">
                            <span class="status-icon">ü§î</span>
                            <span class="status-text">Thinking...</span>
                            <span class="status-timer">0s</span>
                        </div>
                        <pre class="stream-output"></pre>
                    </div>
                `;
                messages.appendChild(msgDiv);
                messages.scrollTop = messages.scrollHeight;
                
                // Start timer update
                this.updateStreamingTimer(id);
            },
            
            updateStreamingTimer(id) {
                const timerEl = document.querySelector(`#${id}-status .status-timer`);
                if (!timerEl || !this.streamingStartTime) return;
                
                const elapsed = Math.floor((Date.now() - this.streamingStartTime) / 1000);
                timerEl.textContent = elapsed + 's';
                
                if (document.getElementById(id)) {
                    setTimeout(() => this.updateStreamingTimer(id), 1000);
                }
            },
            
            updateStreamingStatus(id, phase, icon) {
                const statusEl = document.getElementById(`${id}-status`);
                if (!statusEl) return;
                
                this.streamingPhase = phase;
                statusEl.querySelector('.status-icon').textContent = icon;
                statusEl.querySelector('.status-text').textContent = phase;
            },
            
            // Track if we're inside a code block
            inCodeBlock: false,
            codeBlockContent: '',
            codeBlockCount: 0,
            
            appendToStreamingMessage(id, token) {
                const msgDiv = document.getElementById(id);
                if (!msgDiv) return;
                
                const output = msgDiv.querySelector('.stream-output');
                
                // Detect phase changes from the output
                if (token.includes('SEARCH/REPLACE') || token.includes('<<<<<<')) {
                    this.updateStreamingStatus(id, 'Editing files...', '‚úèÔ∏è');
                    this.inCodeBlock = true;
                    this.codeBlockCount++;
                } else if (token.includes('Applied edit') || token.includes('Wrote')) {
                    this.updateStreamingStatus(id, 'Files updated!', '‚úÖ');
                    this.inCodeBlock = false;
                } else if (token.includes('>>>>>>> REPLACE')) {
                    this.inCodeBlock = false;
                } else if (token.includes('Tokens:') && token.includes('Cost:')) {
                    this.updateStreamingStatus(id, 'Complete!', '‚úÖ');
                } else if (this.streamingPhase === 'thinking' && output && output.textContent.length > 50) {
                    this.updateStreamingStatus(id, 'Analyzing...', 'üîç');
                }
                
                if (output) {
                    // If we're in a code block, add to collapsed section
                    if (this.inCodeBlock || token.includes('<<<<<<') || token.includes('>>>>>>>')) {
                        // Check if we need to create a new collapsible
                        let codeSection = output.querySelector('.code-section-' + this.codeBlockCount);
                        if (!codeSection) {
                            const details = document.createElement('details');
                            details.className = 'code-collapse code-section-' + this.codeBlockCount;
                            details.innerHTML = `<summary>üìù Code change #${this.codeBlockCount} (click to expand)</summary><pre class="collapsed-code"></pre>`;
                            output.appendChild(details);
                            codeSection = details;
                        }
                        const codeContent = codeSection.querySelector('.collapsed-code');
                        if (codeContent) {
                            codeContent.textContent += token;
                        }
                    } else {
                        // Regular text - append directly
                        output.appendChild(document.createTextNode(token));
                    }
                    
                    const messages = document.getElementById('messages');
                    messages.scrollTop = messages.scrollHeight;
                }
            },
            
            finalizeStreamingMessage(id, result) {
                const msgDiv = document.getElementById(id);
                if (!msgDiv) return;
                
                const content = msgDiv.querySelector('.message-content');
                const statusEl = document.getElementById(`${id}-status`);
                
                // Calculate elapsed time
                const elapsed = this.streamingStartTime ? Math.floor((Date.now() - this.streamingStartTime) / 1000) : 0;
                
                // Update final status
                if (statusEl) {
                    const modifiedCount = result.modified_files ? result.modified_files.length : 0;
                    const fileDetails = result.file_details || [];
                    
                    let summaryText = '‚úÖ Complete';
                    if (modifiedCount > 0 || fileDetails.length > 0) {
                        const count = modifiedCount || fileDetails.length;
                        summaryText = `‚úÖ Done! ${count} file(s) modified`;
                    }
                    summaryText += ` (${elapsed}s)`;
                    
                    statusEl.innerHTML = `<span style="color: var(--success); font-weight: 600;">${summaryText}</span>`;
                }
                
                // Add file details if any
                const files = result.modified_files || result.file_details || [];
                if (files.length > 0) {
                    const filesDiv = document.createElement('div');
                    filesDiv.className = 'message-files';
                    filesDiv.style.marginTop = '12px';
                    filesDiv.innerHTML = `
                        <div style="color: var(--success); font-weight: 600; margin-bottom: 8px;">üìÅ Modified Files:</div>
                        ${files.map(f => {
                            const path = typeof f === 'string' ? f : (f.path || f.name);
                            const name = path.split('/').pop();
                            const action = f.action || 'modified';
                            return `<div style="padding: 4px 8px; background: var(--bg-primary); border-radius: 4px; margin: 4px 0; display: flex; justify-content: space-between;">
                                <span>${name}</span>
                                <span style="color: var(--text-muted); font-size: 10px;">${action}</span>
                            </div>`;
                        }).join('')}
                    `;
                    content.appendChild(filesDiv);
                }
                
                this.streamingStartTime = null;
            },
            
            removeStreamingMessage(id) {
                const msgDiv = document.getElementById(id);
                if (msgDiv) msgDiv.remove();
                this.streamingStartTime = null;
            },
            
            // Add Message
            addMessage(type, text, fileDetails = null, allowHtml = false) {
                const messages = document.getElementById('messages');
                const time = new Date().toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit' });
                
                const typeLabels = {
                    user: 'YOU',
                    ai: 'AI',
                    system: 'SYS',
                    error: 'ERR'
                };
                
                // Format text - convert markdown-like formatting
                let formattedText = allowHtml ? text : this.escapeHtml(text);
                formattedText = formattedText
                    .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
                    .replace(/\n/g, '<br>');
                
                let html = `
                    <div class="message">
                        <span class="message-time">${time}</span>
                        <span class="message-type ${type}">${typeLabels[type] || type.toUpperCase()}</span>
                        <span class="message-content">${formattedText}`;
                
                if (fileDetails && fileDetails.length > 0) {
                    html += '<div class="message-files">';
                    fileDetails.forEach(f => {
                        html += `<div class="file-change ${f.action}">${f.action === 'created' ? '+' : '~'} ${f.name}</div>`;
                    });
                    html += '</div>';
                }
                
                html += '</span></div>';
                
                messages.insertAdjacentHTML('beforeend', html);
                messages.scrollTop = messages.scrollHeight;
            },
            
            // Preview File
            async previewFile(filePath) {
                if (!filePath) return;
                
                this.trackBehavior('file_preview', { file: filePath.split('/').pop() });
                console.log('[GSX Create] Preview file:', filePath);
                const previewContent = document.getElementById('previewContent');
                const previewTitle = document.getElementById('previewTitle');
                const previewPanel = document.getElementById('previewPanel');
                
                try {
                    const content = await window.aider.readFile(filePath);
                    console.log('[GSX Create] File content length:', content ? content.length : 0);
                    
                    this.currentPreviewFile = filePath;
                    const ext = filePath.split('.').pop().toLowerCase();
                    const fileName = filePath.split('/').pop();
                    
                    // Update title
                    if (previewTitle) previewTitle.textContent = fileName;
                    
                    // Show preview panel
                    if (previewPanel) previewPanel.classList.add('active');
                    
                    if (!content) {
                        previewContent.innerHTML = '<div class="preview-empty">File is empty or could not be read</div>';
                        return;
                    }
                    
                    if (ext === 'html' || ext === 'htm') {
                        // Use file:// URL for HTML preview (most reliable in Electron)
                        const iframe = document.createElement('iframe');
                        iframe.style.cssText = 'width: 100%; height: 100%; border: none; background: white;';
                        iframe.src = 'file://' + filePath;
                        previewContent.innerHTML = '';
                        previewContent.appendChild(iframe);
                        console.log('[GSX Create] HTML preview rendered via file:// URL');
                    } else {
                        // Code preview
                        previewContent.innerHTML = '<pre style="padding: 16px; margin: 0; font-size: 12px; background: #1e1e1e; color: #d4d4d4; height: 100%; overflow: auto; white-space: pre-wrap; word-wrap: break-word;">' + this.escapeHtml(content) + '</pre>';
                    }
                    
                    // Start file watcher
                    this.startFileWatcher(filePath);
                } catch (error) {
                    console.error('[GSX Create] Preview error:', error);
                    previewContent.innerHTML = '<div class="preview-empty">Error loading file: ' + error.message + '</div>';
                }
            },
            
            // File Watcher
            async startFileWatcher(filePath) {
                if (this.fileWatcher) {
                    await window.aider.unwatchFile(this.fileWatcher);
                }
                this.fileWatcher = filePath;
                await window.aider.watchFile(filePath);
            },
            
            refreshPreview() {
                if (this.currentPreviewFile) {
                    this.previewFile(this.currentPreviewFile);
                }
            },
            
            togglePreview() {
                document.getElementById('previewPanel').classList.remove('active');
                this.trackBehavior('preview_closed', {});
            },
            
            collapsePreview() {
                const panel = document.getElementById('previewPanel');
                const icon = document.getElementById('previewToggleIcon');
                panel.classList.toggle('collapsed');
                const isCollapsed = panel.classList.contains('collapsed');
                icon.textContent = isCollapsed ? '‚óÄ' : '‚ñ∂';
                this.trackBehavior('preview_collapse', { collapsed: isCollapsed });
            },
            
            setPreviewMode(mode) {
                document.querySelectorAll('.preview-tab').forEach(t => t.classList.remove('active'));
                event.target.classList.add('active');
            },
            
            async openInBrowser() {
                if (this.currentPreviewFile) {
                    await window.aider.openFile(this.currentPreviewFile);
                }
            },
            
            // Screenshot and AI Review
            async captureAndAnalyze() {
                if (!this.currentPreviewFile) {
                    this.addMessage('error', 'No file is being previewed. Select a file first.');
                    return;
                }
                
                const ext = this.currentPreviewFile.split('.').pop().toLowerCase();
                if (ext !== 'html' && ext !== 'htm') {
                    this.addMessage('error', 'Screenshot capture only works with HTML files.');
                    return;
                }
                
                this.addMessage('system', 'üì∏ Capturing screenshot for AI review...');
                
                try {
                    // Read the HTML content
                    const htmlContent = await window.aider.readFile(this.currentPreviewFile);
                    
                    if (!htmlContent) {
                        this.addMessage('error', 'Could not read file content.');
                        return;
                    }
                    
                    // Capture screenshot (pass file path, not content)
                    const screenshotResult = await window.aider.capturePreviewScreenshot(this.currentPreviewFile);
                    
                    if (!screenshotResult.success) {
                        this.addMessage('error', 'Screenshot capture failed: ' + (screenshotResult.error || 'Unknown error'));
                        return;
                    }
                    
                    this.addMessage('system', 'üîç Sending screenshot to AI for visual analysis...');
                    
                    // Send to AI for analysis
                    const analysisPrompt = `Please analyze this screenshot of the UI and provide feedback on:
1. Visual design and aesthetics
2. Layout and spacing
3. Usability and UX issues
4. Any bugs or rendering problems you can see
5. Suggestions for improvement

Be specific about what you see in the image.`;
                    
                    const analysisResult = await window.aider.analyzeScreenshot(
                        screenshotResult.screenshot,
                        analysisPrompt
                    );
                    
                    if (analysisResult.success) {
                        // Store the analysis for later use with implement requests
                        this.lastVisualAnalysis = analysisResult.analysis;
                        this.lastVisualAnalysisTime = Date.now();
                        
                        // Create message with implement button
                        const analysisHtml = `üì∏ **Visual Analysis:**\n\n${analysisResult.analysis}\n\n<button class="btn btn-primary btn-sm" onclick="GSXCreate.implementVisualFixes()" style="margin-top: 12px;">üîß Implement These Changes</button>`;
                        this.addMessage('ai', analysisHtml, null, true);
                        
                        // Record cost if tokens provided
                        if (analysisResult.usage) {
                            const model = 'claude-sonnet-4-5-20250929'; // Vision model
                            await this.recordApiCost(
                                model,
                                analysisResult.usage.input_tokens || 0,
                                analysisResult.usage.output_tokens || 0,
                                'vision',
                                'Screenshot analysis'
                            );
                        }
                    } else {
                        this.addMessage('error', 'AI analysis failed: ' + (analysisResult.error || 'Unknown error'));
                    }
                } catch (error) {
                    console.error('[GSX Create] Screenshot analysis error:', error);
                    this.addMessage('error', 'Screenshot analysis failed: ' + error.message);
                }
            },
            
            // Implement Visual Fixes
            async implementVisualFixes() {
                if (!this.lastVisualAnalysis) {
                    this.addMessage('error', 'No visual analysis available. Run "üì∏ AI Review" first.');
                    return;
                }
                
                // Set the prompt and trigger send
                const input = document.getElementById('promptInput');
                input.value = 'Please implement ALL the improvements from the visual analysis. Start with the High Priority items, then Medium Priority. Make all necessary code changes to the HTML/CSS/JS.';
                this.sendPrompt();
            },
            
            // Code Intelligence Tools
            showCodeTools() {
                document.getElementById('codeToolsModal').classList.add('active');
            },
            
            selectCodeTool(tool) {
                // Update tabs
                document.querySelectorAll('.code-tool-tab').forEach(t => {
                    t.classList.toggle('active', t.dataset.tool === tool);
                });
                // Update panels
                document.querySelectorAll('.code-tool-panel').forEach(p => {
                    p.classList.toggle('active', p.id === 'codeTool' + tool.charAt(0).toUpperCase() + tool.slice(1));
                });
            },
            
            // ============================================
            // TEST AGENT
            // ============================================
            testPlan: null,
            testResults: null,
            visualBaseline: null,
            lastInteractiveAnalysis: null,
            
            showTestAgent() {
                if (!this.currentPreviewFile) {
                    this.addMessage('error', 'Please preview an HTML file first to run tests on it.');
                    return;
                }
                document.getElementById('testAgentModal').classList.add('active');
            },
            
            selectTestTab(tab) {
                document.querySelectorAll('.test-tab').forEach(t => {
                    t.classList.toggle('active', t.dataset.test === tab);
                });
                document.querySelectorAll('.test-panel').forEach(p => {
                    p.classList.toggle('active', p.id === 'testPanel' + tab.charAt(0).toUpperCase() + tab.slice(1));
                });
            },
            
            async generateTestPlan() {
                if (!this.currentPreviewFile) {
                    this.addMessage('error', 'No file to test. Preview an HTML file first.');
                    return;
                }
                
                const useAI = document.getElementById('useAIForTests').checked;
                const planList = document.getElementById('testPlanList');
                const planDisplay = document.getElementById('testPlanDisplay');
                
                planList.innerHTML = '<p style="color: var(--text-muted);">Generating test plan...</p>';
                planDisplay.style.display = 'block';
                
                try {
                    const result = await window.testAgent.generatePlan(this.currentPreviewFile, useAI);
                    
                    if (result.success && result.testPlan) {
                        this.testPlan = result.testPlan;
                        document.getElementById('runTestsBtn').disabled = false;
                        
                        planList.innerHTML = `
                            <div style="margin-bottom: 8px; color: var(--text-primary); font-weight: 600;">${result.testPlan.name}</div>
                            ${result.testPlan.tests.map((t, i) => `
                                <div style="padding: 6px 8px; background: var(--bg-secondary); border-radius: 4px; margin-bottom: 4px; font-size: 11px;">
                                    <span style="color: var(--text-muted);">#${i + 1}</span>
                                    <span style="margin-left: 8px;">${t.name}</span>
                                    <span style="float: right; color: var(--accent);">${t.action}</span>
                                </div>
                            `).join('')}
                        `;
                    } else {
                        planList.innerHTML = `<p style="color: var(--error);">Failed: ${result.error || 'Unknown error'}</p>`;
                    }
                } catch (error) {
                    planList.innerHTML = `<p style="color: var(--error);">Error: ${error.message}</p>`;
                }
            },
            
            async runFunctionalTests() {
                if (!this.currentPreviewFile || !this.testPlan) {
                    return;
                }
                
                const browser = document.getElementById('browserSelect').value;
                const resultsDisplay = document.getElementById('testResultsDisplay');
                const summaryDiv = document.getElementById('testSummary');
                const resultsList = document.getElementById('testResultsList');
                
                resultsDisplay.style.display = 'block';
                summaryDiv.innerHTML = `<p style="color: var(--text-muted);">Running tests in ${browser}...</p>`;
                resultsList.innerHTML = '';
                
                // Listen for progress updates
                window.testAgent.onProgress((result) => {
                    const statusIcon = result.status === 'passed' ? '‚úÖ' : '‚ùå';
                    resultsList.innerHTML += `
                        <div class="test-result-item ${result.status}">
                            <span class="test-status-icon">${statusIcon}</span>
                            <span class="test-name">${result.name}</span>
                            <span class="test-duration">${result.duration}ms</span>
                        </div>
                    `;
                });
                
                try {
                    const result = await window.testAgent.runTests(this.currentPreviewFile, { browser });
                    
                    if (result.success) {
                        this.testResults = result.results || [];
                        const summary = result.summary;
                        
                        // Enable fix button if there are failures
                        const fixBtn = document.getElementById('fixFailedTestsBtn');
                        if (fixBtn) fixBtn.disabled = summary.failed === 0;
                        
                        summaryDiv.innerHTML = `
                            <div style="text-align: center;">
                                <div style="font-size: 24px; font-weight: 700; color: ${summary.passRate >= 80 ? 'var(--success)' : summary.passRate >= 50 ? '#f59e0b' : 'var(--error)'};">
                                    ${summary.passRate}%
                                </div>
                                <div style="font-size: 11px; color: var(--text-muted);">Pass Rate</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="font-size: 24px; font-weight: 700; color: var(--success);">${summary.passed}</div>
                                <div style="font-size: 11px; color: var(--text-muted);">Passed</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="font-size: 24px; font-weight: 700; color: var(--error);">${summary.failed}</div>
                                <div style="font-size: 11px; color: var(--text-muted);">Failed</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="font-size: 24px; font-weight: 700; color: var(--text-primary);">${summary.duration}ms</div>
                                <div style="font-size: 11px; color: var(--text-muted);">Duration</div>
                            </div>
                        `;
                        
                        // Add to chat
                        this.addMessage('system', `üß™ Test Results: ${summary.passed}/${summary.total} passed (${summary.passRate}%) in ${summary.duration}ms`);
                    } else {
                        summaryDiv.innerHTML = `<p style="color: var(--error);">Tests failed: ${result.error}</p>`;
                    }
                } catch (error) {
                    summaryDiv.innerHTML = `<p style="color: var(--error);">Error: ${error.message}</p>`;
                }
            },
            
            async captureBaseline() {
                if (!this.currentPreviewFile) return;
                
                const resultsDiv = document.getElementById('visualTestResults');
                resultsDiv.innerHTML = '<p style="color: var(--text-muted);">Capturing baseline...</p>';
                
                try {
                    const result = await window.testAgent.runVisualTest(this.currentPreviewFile);
                    
                    if (result.success) {
                        this.visualBaseline = result.currentScreenshot;
                        resultsDiv.innerHTML = `
                            <div style="text-align: center;">
                                <p style="color: var(--success); margin-bottom: 12px;">‚úÖ Baseline captured!</p>
                                <img src="data:image/png;base64,${result.currentScreenshot}" 
                                     style="max-width: 100%; border-radius: 6px; border: 1px solid var(--border);">
                            </div>
                        `;
                    } else {
                        resultsDiv.innerHTML = `<p style="color: var(--error);">Failed: ${result.error}</p>`;
                    }
                } catch (error) {
                    resultsDiv.innerHTML = `<p style="color: var(--error);">Error: ${error.message}</p>`;
                }
            },
            
            async compareVisual() {
                if (!this.currentPreviewFile || !this.visualBaseline) {
                    document.getElementById('visualTestResults').innerHTML = 
                        '<p style="color: var(--text-muted);">Capture a baseline first</p>';
                    return;
                }
                
                const resultsDiv = document.getElementById('visualTestResults');
                resultsDiv.innerHTML = '<p style="color: var(--text-muted);">Comparing...</p>';
                
                try {
                    const result = await window.testAgent.runVisualTest(this.currentPreviewFile, this.visualBaseline);
                    
                    if (result.success) {
                        resultsDiv.innerHTML = `
                            <div style="display: flex; gap: 16px; flex-wrap: wrap;">
                                <div style="flex: 1; min-width: 300px;">
                                    <h4 style="font-size: 12px; margin-bottom: 8px;">Baseline</h4>
                                    <img src="data:image/png;base64,${this.visualBaseline}" 
                                         style="max-width: 100%; border-radius: 6px; border: 1px solid var(--border);">
                                </div>
                                <div style="flex: 1; min-width: 300px;">
                                    <h4 style="font-size: 12px; margin-bottom: 8px;">Current</h4>
                                    <img src="data:image/png;base64,${result.currentScreenshot}" 
                                         style="max-width: 100%; border-radius: 6px; border: 1px solid var(--border);">
                                </div>
                            </div>
                            <p style="margin-top: 12px; text-align: center; color: ${result.hasDifferences ? 'var(--error)' : 'var(--success)'};">
                                ${result.hasDifferences ? '‚ö†Ô∏è Visual differences detected!' : '‚úÖ No visual changes'}
                            </p>
                        `;
                    } else {
                        resultsDiv.innerHTML = `<p style="color: var(--error);">Failed: ${result.error}</p>`;
                    }
                } catch (error) {
                    resultsDiv.innerHTML = `<p style="color: var(--error);">Error: ${error.message}</p>`;
                }
            },
            
            async runCrossBrowserTest() {
                if (!this.currentPreviewFile) return;
                
                const resultsDiv = document.getElementById('visualTestResults');
                resultsDiv.innerHTML = '<p style="color: var(--text-muted);">üåê Testing across Chrome, Firefox, and Safari...</p>';
                
                try {
                    const result = await window.testAgent.runCrossBrowserTest(this.currentPreviewFile);
                    
                    if (result.success) {
                        const browsers = result.browsers;
                        resultsDiv.innerHTML = `
                            <div style="display: flex; gap: 16px; flex-wrap: wrap; width: 100%;">
                                ${Object.entries(browsers).map(([browser, data]) => `
                                    <div style="flex: 1; min-width: 250px;">
                                        <h4 style="font-size: 12px; margin-bottom: 8px; display: flex; align-items: center; gap: 6px;">
                                            ${browser === 'chromium' ? 'üåê' : browser === 'firefox' ? 'ü¶ä' : 'üß≠'}
                                            ${browser.charAt(0).toUpperCase() + browser.slice(1)}
                                            ${data.success ? '<span style="color: var(--success);">‚úì</span>' : '<span style="color: var(--error);">‚úó</span>'}
                                        </h4>
                                        ${data.success 
                                            ? `<img src="data:image/png;base64,${data.screenshot}" style="max-width: 100%; border-radius: 6px; border: 1px solid var(--border);">` 
                                            : `<p style="color: var(--error); font-size: 11px;">${data.error}</p>`
                                        }
                                    </div>
                                `).join('')}
                            </div>
                        `;
                        
                        this.addMessage('system', 'üåê Cross-browser test complete: Chrome, Firefox, Safari');
                    } else {
                        resultsDiv.innerHTML = `<p style="color: var(--error);">Failed: ${result.error}</p>`;
                    }
                } catch (error) {
                    resultsDiv.innerHTML = `<p style="color: var(--error);">Error: ${error.message}</p>`;
                }
            },
            
            async runAccessibilityTest() {
                if (!this.currentPreviewFile) return;
                
                const resultsDiv = document.getElementById('accessibilityResults');
                resultsDiv.innerHTML = '<p style="color: var(--text-muted);">Running accessibility audit...</p>';
                
                try {
                    const result = await window.testAgent.runAccessibilityTest(this.currentPreviewFile);
                    
                    if (result.success) {
                        // Store results for fixing
                        this.lastAccessibilityResults = result;
                        
                        // Enable fix button if there are issues
                        const fixBtn = document.getElementById('fixAccessibilityBtn');
                        if (fixBtn) fixBtn.disabled = result.issues.length === 0;
                        
                        if (result.issues.length === 0) {
                            resultsDiv.innerHTML = '<p style="color: var(--success);">‚úÖ No accessibility issues found!</p>';
                        } else {
                            resultsDiv.innerHTML = `
                                <div style="margin-bottom: 12px; padding: 12px; background: var(--bg-tertiary); border-radius: 6px;">
                                    <span style="color: var(--error); font-weight: 600;">${result.summary.errors} errors</span>
                                    <span style="margin-left: 12px; color: #f59e0b; font-weight: 600;">${result.summary.warnings} warnings</span>
                                </div>
                                ${result.issues.map(issue => `
                                    <div class="accessibility-issue ${issue.severity}">
                                        <div style="font-weight: 600; margin-bottom: 4px;">${issue.type}</div>
                                        <div style="color: var(--text-secondary);">${issue.message}</div>
                                        <code style="font-size: 10px; color: var(--text-muted); display: block; margin-top: 4px; word-break: break-all;">
                                            ${this.escapeHtml(issue.element || '')}
                                        </code>
                                    </div>
                                `).join('')}
                            `;
                        }
                        
                        this.addMessage('system', `‚ôø Accessibility: ${result.summary.errors} errors, ${result.summary.warnings} warnings`);
                    } else {
                        resultsDiv.innerHTML = `<p style="color: var(--error);">Failed: ${result.error}</p>`;
                    }
                } catch (error) {
                    resultsDiv.innerHTML = `<p style="color: var(--error);">Error: ${error.message}</p>`;
                }
            },
            
            async runPerformanceTest() {
                if (!this.currentPreviewFile) return;
                
                const resultsDiv = document.getElementById('performanceResults');
                resultsDiv.innerHTML = '<p style="color: var(--text-muted);">Running performance test...</p>';
                
                try {
                    const result = await window.testAgent.runPerformanceTest(this.currentPreviewFile);
                    
                    if (result.success) {
                        // Store results for fixing
                        this.lastPerformanceResults = result;
                        
                        // Enable optimize button if score is below threshold
                        const fixBtn = document.getElementById('fixPerformanceBtn');
                        if (fixBtn) fixBtn.disabled = result.score >= 80;
                        
                        const scoreClass = result.score >= 80 ? 'good' : result.score >= 50 ? 'ok' : 'bad';
                        
                        resultsDiv.innerHTML = `
                            <div class="performance-score ${scoreClass}">${result.score}</div>
                            <div style="text-align: center; margin-bottom: 16px; color: var(--text-muted);">Performance Score</div>
                            
                            <div class="performance-metric">
                                <span>Load Time</span>
                                <span style="font-weight: 600;">${result.loadTime}ms</span>
                            </div>
                            <div class="performance-metric">
                                <span>DOM Nodes</span>
                                <span style="font-weight: 600;">${result.domStats.nodeCount}</span>
                            </div>
                            <div class="performance-metric">
                                <span>Scripts</span>
                                <span style="font-weight: 600;">${result.domStats.scriptCount}</span>
                            </div>
                            <div class="performance-metric">
                                <span>Stylesheets</span>
                                <span style="font-weight: 600;">${result.domStats.styleCount}</span>
                            </div>
                            <div class="performance-metric">
                                <span>Images</span>
                                <span style="font-weight: 600;">${result.domStats.imageCount}</span>
                            </div>
                        `;
                        
                        this.addMessage('system', `‚ö° Performance: Score ${result.score}/100, Load time ${result.loadTime}ms`);
                    } else {
                        resultsDiv.innerHTML = `<p style="color: var(--error);">Failed: ${result.error}</p>`;
                    }
                } catch (error) {
                    resultsDiv.innerHTML = `<p style="color: var(--error);">Error: ${error.message}</p>`;
                }
            },
            
            async runInteractiveTest() {
                if (!this.currentPreviewFile) return;
                
                const resultsDiv = document.getElementById('interactiveResults');
                resultsDiv.innerHTML = '<p style="color: var(--text-muted);">ü§ñ AI is analyzing your UI...</p>';
                
                try {
                    const result = await window.testAgent.runInteractiveTest(this.currentPreviewFile);
                    
                    if (result.success) {
                        this.lastInteractiveAnalysis = result.aiAnalysis;
                        document.getElementById('implementFixesBtn').disabled = !result.aiAnalysis;
                        
                        let html = '';
                        
                        if (result.consoleErrors && result.consoleErrors.length > 0) {
                            html += `
                                <div style="margin-bottom: 16px; padding: 12px; background: rgba(239, 68, 68, 0.1); border-radius: 6px; border-left: 3px solid var(--error);">
                                    <div style="font-weight: 600; margin-bottom: 8px;">Console Errors (${result.consoleErrors.length})</div>
                                    ${result.consoleErrors.map(e => `<div style="font-size: 11px; color: var(--error);">${this.escapeHtml(e)}</div>`).join('')}
                                </div>
                            `;
                        }
                        
                        if (result.screenshot) {
                            html += `
                                <div style="margin-bottom: 16px;">
                                    <img src="data:image/png;base64,${result.screenshot}" 
                                         style="max-width: 100%; max-height: 200px; border-radius: 6px; border: 1px solid var(--border);">
                                </div>
                            `;
                        }
                        
                        if (result.aiAnalysis) {
                            html += `
                                <div style="padding: 12px; background: var(--bg-tertiary); border-radius: 6px; white-space: pre-wrap; font-size: 12px;">
                                    ${this.escapeHtml(result.aiAnalysis)}
                                </div>
                            `;
                        } else {
                            html += '<p style="color: var(--text-muted);">AI analysis not available (check API key)</p>';
                        }
                        
                        resultsDiv.innerHTML = html;
                    } else {
                        resultsDiv.innerHTML = `<p style="color: var(--error);">Failed: ${result.error}</p>`;
                    }
                } catch (error) {
                    resultsDiv.innerHTML = `<p style="color: var(--error);">Error: ${error.message}</p>`;
                }
            },
            
            // Store last test results for fixing
            lastTestResults: null,
            lastAccessibilityResults: null,
            lastPerformanceResults: null,
            
            // Test state
            testPlan: null,
            testResults: [],
            currentTestIndex: 0,
            fixQueue: [],
            
            // Quick Test - comprehensive AI-driven testing flow
            async runQuickTest() {
                if (!this.currentPreviewFile) {
                    this.addMessage('error', 'Please select a file to preview first');
                    return;
                }
                
                this.trackBehavior('test_run', { file: this.currentPreviewFile.split('/').pop() });
                
                const testBtn = document.getElementById('testBtn');
                testBtn.classList.add('running');
                testBtn.disabled = true;
                
                try {
                    // Phase 1: Generate Test Plan
                    this.addMessage('system', 'üß™ Phase 1: Generating test plan...');
                    const planResult = await window.testAgent.generatePlan(this.currentPreviewFile, true);
                    
                    if (planResult.success && planResult.testPlan) {
                        this.testPlan = planResult.testPlan;
                        const testCount = this.testPlan.tests?.length || 0;
                        this.addMessage('system', `üìã Test plan created: ${testCount} tests to run`);
                        
                        // Show test plan summary
                        if (testCount > 0) {
                            const planSummary = this.testPlan.tests.slice(0, 5).map((t, i) => 
                                `  ${i+1}. ${t.name} (${t.action})`
                            ).join('\n');
                            this.addMessage('system', `Tests:\n${planSummary}${testCount > 5 ? `\n  ...and ${testCount - 5} more` : ''}`);
                        }
                    }
                    
                    // Phase 2: Run Functional Tests
                    this.addMessage('system', 'üîÑ Phase 2: Running functional tests...');
                    const testResult = await window.testAgent.runTests(this.currentPreviewFile, { 
                        browser: 'chromium',
                        captureScreenshots: true 
                    });
                    
                    if (testResult.success) {
                        this.testResults = testResult.results || [];
                        const passed = testResult.summary?.passed || 0;
                        const failed = testResult.summary?.failed || 0;
                        const passRate = testResult.summary?.passRate || 0;
                        
                        const statusIcon = passRate >= 80 ? '‚úÖ' : passRate >= 50 ? '‚ö†Ô∏è' : '‚ùå';
                        this.addMessage('system', `${statusIcon} Functional tests: ${passed} passed, ${failed} failed (${passRate}%)`);
                        
                        // Show failed tests
                        const failedTests = this.testResults.filter(t => t.status === 'failed');
                        if (failedTests.length > 0) {
                            const failedSummary = failedTests.slice(0, 3).map(t => 
                                `  ‚ùå ${t.name}: ${t.error || 'Failed'}`
                            ).join('\n');
                            this.addMessage('error', `Failed tests:\n${failedSummary}`);
                        }
                    }
                    
                    // Phase 3: Visual Analysis with AI
                    this.addMessage('system', 'üì∏ Phase 3: Capturing screenshots for AI analysis...');
                    const visualResult = await window.testAgent.runInteractiveTest(this.currentPreviewFile);
                    
                    if (visualResult.success) {
                        // Show console errors if any
                        if (visualResult.consoleErrors && visualResult.consoleErrors.length > 0) {
                            this.addMessage('error', `‚ö†Ô∏è Console Errors (${visualResult.consoleErrors.length}):\n${visualResult.consoleErrors.slice(0, 3).join('\n')}`);
                        }
                        
                        if (visualResult.aiAnalysis) {
                            this.lastInteractiveAnalysis = visualResult.aiAnalysis;
                            this.lastVisualAnalysis = visualResult.aiAnalysis;
                            this.lastVisualAnalysisTime = Date.now();
                            
                            // Phase 4: Parse recommendations into fix queue
                            this.addMessage('system', 'üîç Phase 4: Analyzing recommendations...');
                            this.fixQueue = this.parseRecommendations(visualResult.aiAnalysis);
                            
                            // Show comprehensive results
                            const msgHtml = `
                                <div style="margin-bottom: 12px;">
                                    <strong>ü§ñ AI Analysis Complete</strong>
                                    <div style="font-size: 11px; color: var(--text-muted); margin-top: 4px;">
                                        Found ${this.fixQueue.length} issues to fix
                                    </div>
                                </div>
                                <div style="white-space: pre-wrap; font-size: 12px; max-height: 300px; overflow-y: auto; padding: 12px; background: var(--bg-tertiary); border-radius: 6px; margin-bottom: 12px;">
${this.escapeHtml(visualResult.aiAnalysis)}
                                </div>
                                <div style="display: flex; gap: 8px;">
                                    <button class="btn btn-success" onclick="GSXCreate.implementQuickFixes()" style="flex: 1;">
                                        üîß Fix All Issues
                                    </button>
                                    <button class="btn btn-primary" onclick="GSXCreate.implementFixesOneByOne()" style="flex: 1;">
                                        üîÑ Fix One-by-One
                                    </button>
                                </div>
                            `;
                            this.addMessage('ai', msgHtml, null, true);
                        } else {
                            this.addMessage('error', 'AI analysis not available. Check your API key in Config.');
                        }
                    } else {
                        this.addMessage('error', `Visual analysis failed: ${visualResult.error}`);
                    }
                    
                } catch (error) {
                    this.addMessage('error', `Test error: ${error.message}`);
                } finally {
                    testBtn.classList.remove('running');
                    testBtn.disabled = false;
                }
            },
            
            // Parse AI recommendations into actionable fix items
            parseRecommendations(analysis) {
                const fixes = [];
                const lines = analysis.split('\n');
                let currentCategory = '';
                let priority = 1;
                
                for (const line of lines) {
                    const trimmed = line.trim();
                    
                    // Detect category headers
                    if (trimmed.match(/^#+\s*\d*\.?\s*(bug|error|issue|fix|problem)/i)) {
                        currentCategory = 'bug';
                        priority = 1;
                    } else if (trimmed.match(/^#+\s*\d*\.?\s*(ux|usability|user experience)/i)) {
                        currentCategory = 'ux';
                        priority = 2;
                    } else if (trimmed.match(/^#+\s*\d*\.?\s*(visual|design|aesthetic|style)/i)) {
                        currentCategory = 'visual';
                        priority = 3;
                    } else if (trimmed.match(/^#+\s*\d*\.?\s*(access|a11y|accessibility)/i)) {
                        currentCategory = 'accessibility';
                        priority = 4;
                    } else if (trimmed.match(/^#+\s*\d*\.?\s*(suggest|improve|recommend)/i)) {
                        currentCategory = 'improvement';
                        priority = 5;
                    }
                    
                    // Detect list items as fixes
                    const listMatch = trimmed.match(/^[-*‚Ä¢]\s*(.+)$/) || trimmed.match(/^\d+\.\s*(.+)$/);
                    if (listMatch && listMatch[1].length > 10) {
                        fixes.push({
                            id: fixes.length + 1,
                            category: currentCategory || 'general',
                            priority,
                            description: listMatch[1],
                            status: 'pending'
                        });
                    }
                }
                
                // Sort by priority
                fixes.sort((a, b) => a.priority - b.priority);
                return fixes;
            },
            
            async implementQuickFixes() {
                if (!this.lastVisualAnalysis) {
                    this.addMessage('error', 'No analysis available. Run test first.');
                    return;
                }
                
                const input = document.getElementById('promptInput');
                input.value = `Please implement ALL the fixes and improvements from this analysis:

${this.lastVisualAnalysis}

Address each issue systematically:
1. Fix any bugs or errors first
2. Then address UX/usability issues  
3. Then visual/aesthetic improvements
4. Finally accessibility concerns

Make the changes directly to the file.`;
                
                this.sendPrompt();
            },
            
            // Fix issues one by one with testing after each
            async implementFixesOneByOne() {
                if (!this.fixQueue || this.fixQueue.length === 0) {
                    this.addMessage('error', 'No fixes in queue. Run test first.');
                    return;
                }
                
                this.currentTestIndex = 0;
                await this.implementNextFix();
            },
            
            async implementNextFix() {
                if (this.currentTestIndex >= this.fixQueue.length) {
                    this.addMessage('system', '‚úÖ All fixes implemented! Running final verification...');
                    // Run a final test to verify
                    await this.runQuickTest();
                    return;
                }
                
                const fix = this.fixQueue[this.currentTestIndex];
                const remaining = this.fixQueue.length - this.currentTestIndex;
                
                this.addMessage('system', `üîß Fixing issue ${this.currentTestIndex + 1}/${this.fixQueue.length}: ${fix.description.substring(0, 50)}...`);
                
                const input = document.getElementById('promptInput');
                input.value = `Please fix this specific issue:

Category: ${fix.category}
Issue: ${fix.description}

Make ONLY this change. After you're done, I'll test and move to the next issue.
There are ${remaining - 1} more issues to fix after this one.`;
                
                // Store callback for after fix is applied
                this.pendingFixCallback = async () => {
                    fix.status = 'completed';
                    this.currentTestIndex++;
                    
                    // Brief pause then continue
                    this.addMessage('system', `‚úÖ Fix applied. Testing...`);
                    
                    // Quick verification screenshot
                    try {
                        const verifyResult = await window.testAgent.runVisualTest(this.currentPreviewFile);
                        if (verifyResult.success) {
                            this.addMessage('system', `üì∏ Verified. Moving to next fix...`);
                        }
                    } catch (e) {
                        // Continue anyway
                    }
                    
                    // Continue to next fix
                    setTimeout(() => this.implementNextFix(), 1000);
                };
                
                this.sendPrompt();
            },
            
            // Called after prompt completes to continue fix chain
            onPromptComplete() {
                if (this.pendingFixCallback) {
                    const callback = this.pendingFixCallback;
                    this.pendingFixCallback = null;
                    callback();
                }
            },
            
            async implementTestFixes() {
                if (!this.lastInteractiveAnalysis) {
                    this.addMessage('error', 'No AI analysis available. Run "AI Analyze & Test" first.');
                    return;
                }
                
                // Store for sendPrompt to pick up
                this.lastVisualAnalysis = this.lastInteractiveAnalysis;
                this.lastVisualAnalysisTime = Date.now();
                
                // Close modal and trigger implementation
                this.closeModal('testAgentModal');
                
                const input = document.getElementById('promptInput');
                input.value = 'Please implement the fixes and improvements identified in the AI analysis. Address any bugs, UX issues, and suggested improvements.';
                this.sendPrompt();
            },
            
            async fixAccessibilityIssues() {
                if (!this.lastAccessibilityResults || !this.lastAccessibilityResults.issues) {
                    this.addMessage('error', 'No accessibility issues found. Run accessibility test first.');
                    return;
                }
                
                const issues = this.lastAccessibilityResults.issues;
                if (issues.length === 0) {
                    this.addMessage('system', '‚úÖ No accessibility issues to fix!');
                    return;
                }
                
                // Format issues for AI
                const issueList = issues.map((issue, i) => 
                    `${i + 1}. [${issue.severity.toUpperCase()}] ${issue.type}: ${issue.message}\n   Element: ${issue.element || 'N/A'}\n   Selector: ${issue.selector || 'N/A'}`
                ).join('\n\n');
                
                this.closeModal('testAgentModal');
                
                const prompt = `Please fix the following accessibility issues in the HTML file:

${issueList}

For each issue:
1. Find the element using the selector or element snippet
2. Apply the appropriate fix (add alt text, aria-label, tabindex, etc.)
3. Ensure the fix follows WCAG 2.1 guidelines

Focus on errors first, then warnings.`;
                
                const input = document.getElementById('promptInput');
                input.value = prompt;
                this.sendPrompt();
            },
            
            async fixPerformanceIssues() {
                if (!this.lastPerformanceResults) {
                    this.addMessage('error', 'No performance data. Run performance test first.');
                    return;
                }
                
                const perf = this.lastPerformanceResults;
                const issues = [];
                
                if (perf.loadTime > 3000) issues.push(`- Load time is ${perf.loadTime}ms (should be < 3000ms)`);
                if (perf.domStats?.nodeCount > 1500) issues.push(`- DOM has ${perf.domStats.nodeCount} nodes (should be < 1500)`);
                if (perf.domStats?.scriptCount > 10) issues.push(`- ${perf.domStats.scriptCount} script tags (consider bundling)`);
                if (perf.domStats?.styleCount > 5) issues.push(`- ${perf.domStats.styleCount} stylesheets (consider combining)`);
                
                if (issues.length === 0) {
                    this.addMessage('system', '‚úÖ No major performance issues to fix!');
                    return;
                }
                
                this.closeModal('testAgentModal');
                
                const prompt = `Please optimize the HTML file for better performance. Issues found:

${issues.join('\n')}

Current metrics:
- Load time: ${perf.loadTime}ms
- DOM nodes: ${perf.domStats?.nodeCount || 'N/A'}
- Scripts: ${perf.domStats?.scriptCount || 'N/A'}
- Stylesheets: ${perf.domStats?.styleCount || 'N/A'}
- Performance score: ${perf.score}/100

Suggestions:
1. Minimize DOM complexity where possible
2. Combine/minify CSS and JS
3. Defer non-critical scripts
4. Optimize images (lazy loading, proper sizing)
5. Remove unused CSS/JS`;
                
                const input = document.getElementById('promptInput');
                input.value = prompt;
                this.sendPrompt();
            },
            
            async fixFailedTests() {
                if (!this.testResults || this.testResults.length === 0) {
                    this.addMessage('error', 'No test results. Run functional tests first.');
                    return;
                }
                
                const failed = this.testResults.filter(t => t.status === 'failed');
                if (failed.length === 0) {
                    this.addMessage('system', '‚úÖ All tests passed! Nothing to fix.');
                    return;
                }
                
                const failedList = failed.map((t, i) => 
                    `${i + 1}. Test: ${t.name}\n   Error: ${t.error}\n   Selector: ${t.selector || 'N/A'}`
                ).join('\n\n');
                
                this.closeModal('testAgentModal');
                
                const prompt = `The following functional tests failed. Please fix the issues:

${failedList}

For each failed test:
1. Identify why the element or interaction failed
2. Fix the HTML/CSS/JS to make the test pass
3. Ensure the fix doesn't break other functionality`;
                
                const input = document.getElementById('promptInput');
                input.value = prompt;
                this.sendPrompt();
            },
            
            async searchCode() {
                const pattern = document.getElementById('searchPattern').value.trim();
                const glob = document.getElementById('searchGlob').value.trim() || null;
                const resultsDiv = document.getElementById('searchResults');
                
                if (!pattern) {
                    resultsDiv.innerHTML = '<p style="color: var(--text-muted);">Enter a search pattern</p>';
                    return;
                }
                
                resultsDiv.innerHTML = '<p>Searching...</p>';
                
                try {
                    const result = await window.aider.searchCode(pattern, glob);
                    console.log('[GSX Create] Search result:', result);
                    
                    if (result.success && result.matches && result.matches.length > 0) {
                        resultsDiv.innerHTML = result.matches.map(match => `
                            <div class="code-result-item" onclick="GSXCreate.previewFile('${match.file}')">
                                <div class="code-result-file">${match.file}</div>
                                <div class="code-result-line">Line ${match.line}</div>
                                <div class="code-result-content">${this.escapeHtml(match.content)}</div>
                            </div>
                        `).join('');
                    } else if (result.success) {
                        resultsDiv.innerHTML = '<p style="color: var(--text-muted);">No matches found</p>';
                    } else {
                        resultsDiv.innerHTML = '<p style="color: var(--danger);">Error: ' + (result.error || 'Search failed') + '</p>';
                    }
                } catch (error) {
                    console.error('[GSX Create] Search error:', error);
                    resultsDiv.innerHTML = '<p style="color: var(--danger);">Error: ' + error.message + '</p>';
                }
            },
            
            async findDefinition() {
                const symbol = document.getElementById('definitionSymbol').value.trim();
                const resultsDiv = document.getElementById('definitionResults');
                
                if (!symbol) {
                    resultsDiv.innerHTML = '<p style="color: var(--text-muted);">Enter a symbol name</p>';
                    return;
                }
                
                resultsDiv.innerHTML = '<p>Searching...</p>';
                
                try {
                    const result = await window.aider.findDefinition(symbol);
                    console.log('[GSX Create] Definition result:', result);
                    
                    if (result.success && result.definitions && result.definitions.length > 0) {
                        resultsDiv.innerHTML = result.definitions.map(def => `
                            <div class="code-result-item" onclick="GSXCreate.previewFile('${def.file}')">
                                <div class="code-result-file">${def.file}</div>
                                <div class="code-result-line">Line ${def.line}</div>
                                <div class="code-result-content">${this.escapeHtml(def.content)}</div>
                            </div>
                        `).join('');
                    } else if (result.success) {
                        resultsDiv.innerHTML = '<p style="color: var(--text-muted);">No definition found for "' + symbol + '"</p>';
                    } else {
                        resultsDiv.innerHTML = '<p style="color: var(--danger);">Error: ' + (result.error || 'Search failed') + '</p>';
                    }
                } catch (error) {
                    console.error('[GSX Create] Find definition error:', error);
                    resultsDiv.innerHTML = '<p style="color: var(--danger);">Error: ' + error.message + '</p>';
                }
            },
            
            async findUsages() {
                const symbol = document.getElementById('usagesSymbol').value.trim();
                const resultsDiv = document.getElementById('usagesResults');
                
                if (!symbol) {
                    resultsDiv.innerHTML = '<p style="color: var(--text-muted);">Enter a symbol name</p>';
                    return;
                }
                
                resultsDiv.innerHTML = '<p>Searching...</p>';
                
                try {
                    const result = await window.aider.findUsages(symbol);
                    console.log('[GSX Create] Usages result:', result);
                    
                    if (result.success && result.usages && result.usages.length > 0) {
                        resultsDiv.innerHTML = `
                            <p style="margin-bottom: 12px; color: var(--success);">Found ${result.usages.length} usage(s)</p>
                            ${result.usages.map(usage => `
                                <div class="code-result-item" onclick="GSXCreate.previewFile('${usage.file}')">
                                    <div class="code-result-file">${usage.file}</div>
                                    <div class="code-result-line">Line ${usage.line}</div>
                                    <div class="code-result-content">${this.escapeHtml(usage.content)}</div>
                                </div>
                            `).join('')}
                        `;
                    } else if (result.success) {
                        resultsDiv.innerHTML = '<p style="color: var(--text-muted);">No usages found for "' + symbol + '"</p>';
                    } else {
                        resultsDiv.innerHTML = '<p style="color: var(--danger);">Error: ' + (result.error || 'Search failed') + '</p>';
                    }
                } catch (error) {
                    console.error('[GSX Create] Find usages error:', error);
                    resultsDiv.innerHTML = '<p style="color: var(--danger);">Error: ' + error.message + '</p>';
                }
            },
            
            async getRepoMap() {
                const resultsDiv = document.getElementById('repomapResults');
                
                resultsDiv.innerHTML = '<p>Generating repository map...</p>';
                
                try {
                    const result = await window.aider.getRepoMap();
                    console.log('[GSX Create] Repo map result:', result);
                    
                    if (result.success && result.repo_map) {
                        resultsDiv.innerHTML = `<pre style="margin: 0; color: var(--text-primary);">${this.escapeHtml(result.repo_map)}</pre>`;
                    } else if (result.success) {
                        resultsDiv.innerHTML = '<p style="color: var(--text-muted);">No repository map available</p>';
                    } else {
                        resultsDiv.innerHTML = '<p style="color: var(--danger);">Error: ' + (result.error || 'Failed to generate map') + '</p>';
                    }
                } catch (error) {
                    console.error('[GSX Create] Repo map error:', error);
                    resultsDiv.innerHTML = '<p style="color: var(--danger);">Error: ' + error.message + '</p>';
                }
            },
            
            // Cost Tracking
            async loadCostSummary() {
                try {
                    console.log('[GSX Create] Loading cost summary for space:', this.currentSpaceId);
                    const result = await window.aider.txdbGetSummary(this.currentSpaceId, 30);
                    console.log('[GSX Create] Cost summary result:', result);
                    if (result.success) {
                        this.costSummary = result.summary || { totalCost: 0, totalCalls: 0 };
                        this.updateCostDisplay();
                    } else {
                        console.error('[GSX Create] Cost summary failed:', result.error);
                    }
                } catch (error) {
                    console.error('[GSX Create] Cost load error:', error);
                }
            },
            
            updateCostDisplay() {
                const costBadge = document.getElementById('costBadge');
                const budgetBadge = document.getElementById('budgetBadge');
                const budgetFill = document.getElementById('budgetFill');
                
                if (!costBadge) return;
                
                const total = this.costSummary.totalCost || 0;
                const budget = this.cycleState.cycleBudget;
                
                console.log('[GSX Create] Updating cost display:', total, 'budget:', budget);
                
                // Update cost badge
                costBadge.textContent = '$' + total.toFixed(2);
                costBadge.classList.remove('warning', 'danger');
                
                // Update budget badge
                if (budgetBadge) {
                    budgetBadge.textContent = budget ? '$' + budget.toFixed(2) : '‚àû';
                }
                
                // Update progress bar
                if (budgetFill) {
                    if (budget && budget > 0) {
                        const percentage = Math.min((total / budget) * 100, 100);
                        budgetFill.style.width = percentage + '%';
                        budgetFill.classList.remove('warning', 'danger');
                        
                        if (percentage >= 90) {
                            budgetFill.classList.add('danger');
                            costBadge.classList.add('danger');
                        } else if (percentage >= 70) {
                            budgetFill.classList.add('warning');
                            costBadge.classList.add('warning');
                        }
                    } else {
                        budgetFill.style.width = '0%';
                    }
                }
            },
            
            // Show budget modal
            showBudgetModal() {
                const modal = document.getElementById('budgetModal');
                modal.classList.add('active');
                
                // Update current values
                const total = this.costSummary.totalCost || 0;
                const budget = this.cycleState.cycleBudget;
                
                document.getElementById('budgetCurrentCost').textContent = '$' + total.toFixed(4);
                document.getElementById('budgetLimit').textContent = budget ? '$' + budget.toFixed(2) : '‚àû (No limit)';
                
                // Calculate percentage
                let percentage = 0;
                if (budget && budget > 0) {
                    percentage = Math.min((total / budget) * 100, 100);
                }
                document.getElementById('budgetPercentage').textContent = budget ? percentage.toFixed(1) + '%' : 'N/A';
                document.getElementById('budgetModalFill').style.width = percentage + '%';
                
                // Set input value
                document.getElementById('budgetInput').value = budget || '';
                
                // Calculate cycle statistics
                this.updateCycleStatistics();
            },
            
            // Update cycle statistics in budget modal
            async updateCycleStatistics() {
                const cyclesCompleted = this.cycleState.currentVersion - 1;
                const totalCost = this.costSummary.totalCost || 0;
                const budget = this.cycleState.cycleBudget;
                
                document.getElementById('cyclesCompleted').textContent = cyclesCompleted;
                
                // Calculate average cost per cycle
                let avgCost = 0;
                if (cyclesCompleted > 0) {
                    avgCost = totalCost / cyclesCompleted;
                }
                document.getElementById('avgCostPerCycle').textContent = '$' + avgCost.toFixed(4);
                
                // Estimate remaining cycles
                let estRemaining = '‚àû';
                if (budget && avgCost > 0) {
                    const remaining = (budget - totalCost) / avgCost;
                    estRemaining = remaining > 0 ? Math.floor(remaining).toString() : '0';
                }
                document.getElementById('estCyclesRemaining').textContent = estRemaining;
            },
            
            // Set budget from input
            setBudget() {
                const input = document.getElementById('budgetInput');
                const value = parseFloat(input.value);
                
                if (isNaN(value) || value <= 0) {
                    this.cycleState.cycleBudget = null;
                    this.addMessage('system', 'üí∞ Budget limit removed (unlimited)');
                } else {
                    this.cycleState.cycleBudget = value;
                    this.addMessage('system', `üí∞ Budget set to $${value.toFixed(2)}`);
                }
                
                this.updateCostDisplay();
                this.closeModal('budgetModal');
            },
            
            // Set quick budget
            setQuickBudget(amount) {
                this.cycleState.cycleBudget = amount;
                document.getElementById('budgetInput').value = amount || '';
                
                if (amount) {
                    this.addMessage('system', `üí∞ Budget set to $${amount.toFixed(2)}`);
                } else {
                    this.addMessage('system', 'üí∞ Budget limit removed (unlimited)');
                }
                
                this.updateCostDisplay();
                this.showBudgetModal(); // Refresh the modal display
            },
            
            async recordApiCost(model, inputTokens, outputTokens, type, promptPreview, actualCost = null) {
                let cost = actualCost;
                
                // If no actual cost provided, calculate from tokens
                if (!cost || cost === 0) {
                    const costs = {
                        // Claude 4.5 models
                        'claude-sonnet-4-5-20250929': { input: 3/1000000, output: 15/1000000 },
                        'claude-opus-4-5-20250929': { input: 15/1000000, output: 75/1000000 }
                    };
                    
                    const modelCosts = costs[model] || { input: 3/1000000, output: 15/1000000 };
                    cost = (inputTokens * modelCosts.input) + (outputTokens * modelCosts.output);
                }
                
                console.log('[GSX Create] Recording cost:', { model, inputTokens, outputTokens, cost, wasActual: actualCost !== null });
                
                try {
                    const result = await window.aider.txdbRecord({
                        spaceId: this.currentSpaceId,
                        spaceName: this.currentSpaceName,
                        type, model, inputTokens, outputTokens, cost,
                        status: 'success',
                        promptPreview: promptPreview ? promptPreview.substring(0, 200) : ''
                    });
                    
                    console.log('[GSX Create] Cost record result:', result);
                    
                    this.costSummary.totalCost = (this.costSummary.totalCost || 0) + cost;
                    this.costSummary.totalCalls = (this.costSummary.totalCalls || 0) + 1;
                    this.updateCostDisplay();
                    this.loadEpisodicMemory(); // Refresh sidebar
                } catch (error) {
                    console.error('[GSX Create] Cost record error:', error);
                }
            },
            
            async showTransactionLogs() {
                const modal = document.getElementById('logModal');
                const tbody = document.getElementById('logTableBody');
                
                modal.classList.add('active');
                tbody.innerHTML = '<tr><td colspan="6">Loading...</td></tr>';
                
                try {
                    const result = await window.aider.txdbGetTransactions({ spaceId: this.currentSpaceId, limit: 100 });
                    
                    if (result.success && result.transactions.length > 0) {
                        tbody.innerHTML = result.transactions.map(tx => `
                            <tr>
                                <td>${new Date(tx.timestamp).toLocaleString()}</td>
                                <td>${tx.type}</td>
                                <td>${tx.model || '-'}</td>
                                <td>${tx.input_tokens || 0}/${tx.output_tokens || 0}</td>
                                <td>$${(tx.cost || 0).toFixed(6)}</td>
                                <td style="color: ${tx.status === 'success' ? 'var(--success)' : 'var(--danger)'}">${tx.status}</td>
                            </tr>
                        `).join('');
                    } else {
                        tbody.innerHTML = '<tr><td colspan="6" style="text-align: center;">No transactions yet</td></tr>';
                    }
                } catch (error) {
                    tbody.innerHTML = `<tr><td colspan="6" style="color: var(--danger);">Error: ${error.message}</td></tr>`;
                }
            },
            
            // Episodic Memory - Todo list state
            todos: [],
            
            // Load Episodic Memory for sidebar (History tab)
            async loadEpisodicMemory() {
                const listEl = document.getElementById('episodicMemoryList');
                const countEl = document.getElementById('historyCount');
                
                if (!listEl) return;
                
                try {
                    const result = await window.aider.txdbGetTransactions({ spaceId: this.currentSpaceId, limit: 10 });
                    
                    if (result.success && result.transactions && result.transactions.length > 0) {
                        if (countEl) countEl.textContent = result.transactions.length;
                        
                        listEl.innerHTML = result.transactions.map(tx => {
                            const time = new Date(tx.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                            const statusIcon = tx.status === 'success' ? '‚úì' : '‚úó';
                            const statusColor = tx.status === 'success' ? 'var(--success)' : 'var(--danger)';
                            const cost = tx.cost ? `$${tx.cost.toFixed(4)}` : '';
                            const typeLabel = tx.type === 'chat' ? 'üí¨' : tx.type === 'code' ? 'üíª' : 'üìù';
                            
                            return `
                                <div class="episodic-item" style="padding: 6px 8px; margin-bottom: 4px; background: var(--bg-tertiary); border-radius: 4px; font-size: 10px; cursor: pointer;" onclick="GSXCreate.showTransactionLogs()">
                                    <div style="display: flex; justify-content: space-between; align-items: center;">
                                        <span>${typeLabel} <span style="color: ${statusColor};">${statusIcon}</span></span>
                                        <span style="color: var(--text-muted);">${time}</span>
                                    </div>
                                    <div style="display: flex; justify-content: space-between; margin-top: 2px; color: var(--text-secondary);">
                                        <span>${tx.input_tokens || 0}/${tx.output_tokens || 0} tokens</span>
                                        <span style="color: var(--accent);">${cost}</span>
                                    </div>
                                </div>
                            `;
                        }).join('');
                    } else {
                        if (countEl) countEl.textContent = '0';
                        listEl.innerHTML = '<div style="color: var(--text-muted); font-size: 11px;">No history yet</div>';
                    }
                } catch (error) {
                    console.error('[GSX Create] Load episodic memory error:', error);
                    listEl.innerHTML = '<div style="color: var(--text-muted); font-size: 11px;">No history yet</div>';
                }
                
                // Also load todos
                this.loadTodos();
            },
            
            // Switch between History and Plan tabs
            switchEpisodicTab(tab) {
                const historyPanel = document.getElementById('historyPanel');
                const planPanel = document.getElementById('planPanel');
                const historyTab = document.getElementById('historyTab');
                const planTab = document.getElementById('planTab');
                
                if (tab === 'history') {
                    historyPanel.style.display = 'block';
                    planPanel.style.display = 'none';
                    historyTab.classList.add('active');
                    planTab.classList.remove('active');
                } else {
                    historyPanel.style.display = 'none';
                    planPanel.style.display = 'block';
                    historyTab.classList.remove('active');
                    planTab.classList.add('active');
                }
            },
            
            // Load todos from storage
            loadTodos() {
                const storageKey = `gsx-todos-${this.currentSpaceId || 'default'}`;
                const stored = localStorage.getItem(storageKey);
                this.todos = stored ? JSON.parse(stored) : [];
                this.renderTodos();
            },
            
            // Save todos to storage
            saveTodos() {
                const storageKey = `gsx-todos-${this.currentSpaceId || 'default'}`;
                localStorage.setItem(storageKey, JSON.stringify(this.todos));
            },
            
            // Add a new todo
            addTodo() {
                const input = document.getElementById('newTodoInput');
                const text = input.value.trim();
                
                if (!text) return;
                
                this.todos.unshift({
                    id: Date.now(),
                    text: text,
                    done: false,
                    created: new Date().toISOString()
                });
                
                input.value = '';
                this.saveTodos();
                this.renderTodos();
            },
            
            // Toggle todo completion
            toggleTodo(id) {
                const todo = this.todos.find(t => t.id === id);
                if (todo) {
                    todo.done = !todo.done;
                    if (todo.done) {
                        todo.completed = new Date().toISOString();
                    }
                    this.saveTodos();
                    this.renderTodos();
                }
            },
            
            // Remove a todo
            removeTodo(id) {
                this.todos = this.todos.filter(t => t.id !== id);
                this.saveTodos();
                this.renderTodos();
            },
            
            // Render todos list
            renderTodos() {
                const listEl = document.getElementById('todoList');
                const countEl = document.getElementById('planCount');
                
                if (!listEl) return;
                
                const pendingCount = this.todos.filter(t => !t.done).length;
                if (countEl) countEl.textContent = pendingCount;
                
                if (this.todos.length === 0) {
                    listEl.innerHTML = '<div style="color: var(--text-muted); font-size: 11px;">No tasks planned</div>';
                    return;
                }
                
                listEl.innerHTML = this.todos.map(todo => {
                    const cycleIndicator = todo.fromCycle ? '<span style="color: var(--accent); margin-right: 4px;" title="From Meta Learning Cycle">üîÑ</span>' : '';
                    return `
                    <div class="todo-item" style="padding: 4px 6px; margin-bottom: 3px; background: var(--bg-tertiary); border-radius: 4px; font-size: 10px; display: flex; align-items: center; gap: 6px; ${todo.done ? 'opacity: 0.5;' : ''} ${todo.fromCycle ? 'border-left: 2px solid var(--accent);' : ''}">
                        <input type="checkbox" ${todo.done ? 'checked' : ''} onchange="GSXCreate.toggleTodo(${todo.id})" style="margin: 0; cursor: pointer;">
                        <span style="flex: 1; ${todo.done ? 'text-decoration: line-through;' : ''}">${cycleIndicator}${todo.text}</span>
                        <button onclick="GSXCreate.removeTodo(${todo.id})" style="background: none; border: none; color: var(--text-muted); cursor: pointer; padding: 0; font-size: 12px;" title="Remove">√ó</button>
                    </div>
                `}).join('');
            },
            
            // Mark a cycle task as complete in Episodic Memory
            markCycleTaskComplete(taskText) {
                const todo = this.todos.find(t => t.text === taskText && !t.done);
                if (todo) {
                    todo.done = true;
                    todo.completed = new Date().toISOString();
                    this.saveTodos();
                    this.renderTodos();
                }
            },
            
            // Show event logs (errors, warnings, info)
            async showEventLogs() {
                try {
                    const result = await window.aider.txdbGetEventLogs({ limit: 50 });
                    
                    if (!result.success || !result.logs || result.logs.length === 0) {
                        this.addMessage('system', 'üìã No event logs found');
                        return;
                    }
                    
                    // Build HTML for logs
                    const logsHtml = result.logs.map(log => {
                        const typeIcon = log.type === 'error' ? 'üî¥' : log.type === 'warning' ? 'üü°' : 'üîµ';
                        const time = new Date(log.timestamp).toLocaleString();
                        const summary = log.summary || log.message?.substring(0, 50) || 'No summary';
                        
                        return `
                            <div style="padding: 10px; margin-bottom: 8px; background: var(--bg-tertiary); border-radius: 6px; border-left: 3px solid ${log.type === 'error' ? 'var(--danger)' : log.type === 'warning' ? 'var(--warning)' : 'var(--accent)'};">
                                <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                                    <span style="font-weight: 500;">${typeIcon} ${summary}</span>
                                    <span style="font-size: 10px; color: var(--text-muted);">${time}</span>
                                </div>
                                ${log.aiSummary ? `<div style="font-size: 11px; color: var(--text-secondary); margin-top: 6px;">${log.aiSummary.substring(0, 200)}...</div>` : ''}
                                ${log.userNotes ? `<div style="font-size: 11px; color: var(--accent); margin-top: 4px;">üìù ${log.userNotes}</div>` : ''}
                            </div>
                        `;
                    }).join('');
                    
                    // Show in a modal or chat
                    const html = `
                        <div style="max-height: 400px; overflow-y: auto;">
                            <div style="font-size: 13px; font-weight: 600; margin-bottom: 12px;">üìã Event Logs (${result.logs.length})</div>
                            ${logsHtml}
                        </div>
                    `;
                    
                    this.addMessage('system', html, null, true);
                    
                } catch (error) {
                    console.error('[GSX Create] Show event logs error:', error);
                    this.addMessage('error', `Failed to load event logs: ${error.message}`);
                }
            },
            
            // Global Instructions
            async loadGlobalInstructions() {
                const key = `gsx-global-instructions-${this.currentSpaceId}`;
                this.globalInstructionsText = localStorage.getItem(key) || '';
                document.getElementById('globalInstructions').value = this.globalInstructionsText;
            },
            
            saveGlobalInstructions() {
                const text = document.getElementById('globalInstructions').value;
                this.globalInstructionsText = text;
                const key = `gsx-global-instructions-${this.currentSpaceId}`;
                localStorage.setItem(key, text);
                this.addMessage('system', 'Global instructions saved');
            },
            
            toggleGlobalInstructions() {
                document.getElementById('globalInstructionsPanel').classList.toggle('active');
            },
            
            toggleConfig() {
                document.getElementById('configPanel').classList.toggle('active');
            },
            
            applyTemplate(type) {
                const templates = {
                    typescript: 'Use TypeScript with strict types. Prefer interfaces over types. Use async/await. Add JSDoc comments.',
                    react: 'Use functional components with hooks. Use TypeScript. Follow React best practices. Use CSS modules or styled-components.',
                    python: 'Use Python 3.10+. Add type hints. Follow PEP 8. Use docstrings. Handle exceptions properly.'
                };
                document.getElementById('globalInstructions').value = templates[type] || '';
            },
            
            // Snapshot
            async takeSnapshot() {
                if (!this.currentPreviewFile) {
                    this.addMessage('system', 'No file being previewed');
                    return;
                }
                
                try {
                    const content = await window.aider.readFile(this.currentPreviewFile);
                    this.addMessage('system', `Snapshot taken: ${this.currentPreviewFile.split('/').pop()}`);
                    
                    // Store snapshot for context
                    if (!this.snapshots) this.snapshots = [];
                    this.snapshots.push({
                        file: this.currentPreviewFile,
                        content: content,
                        time: new Date().toISOString()
                    });
                } catch (error) {
                    this.addMessage('error', 'Failed to take snapshot: ' + error.message);
                }
            },
            
            // Version History
            async showVersionHistory() {
                if (!this.currentPreviewFile) {
                    this.addMessage('system', 'No file selected');
                    return;
                }
                
                const modal = document.getElementById('historyModal');
                const body = document.getElementById('historyModalBody');
                
                modal.classList.add('active');
                body.innerHTML = '<p>Loading...</p>';
                
                try {
                    const result = await window.aider.getFileVersions(this.repoPath, this.currentPreviewFile);
                    
                    if (result.success && result.versions.length > 0) {
                        body.innerHTML = result.versions.map(v => `
                            <div style="padding: 10px; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <div style="font-size: 12px;">${new Date(v.timestamp).toLocaleString()}</div>
                                    <div style="font-size: 11px; color: var(--text-secondary);">${v.description || 'No description'}</div>
                                </div>
                                <button class="btn btn-sm btn-secondary" onclick="GSXCreate.rollbackToVersion('${v.id}')">Restore</button>
                            </div>
                        `).join('');
                    } else {
                        body.innerHTML = '<p style="text-align: center; color: var(--text-muted);">No version history available</p>';
                    }
                } catch (error) {
                    body.innerHTML = `<p style="color: var(--danger);">Error: ${error.message}</p>`;
                }
            },
            
            async rollbackToVersion(versionId) {
                try {
                    await window.aider.rollbackFile(this.repoPath, this.currentPreviewFile, versionId);
                    this.addMessage('system', 'File restored to previous version');
                    this.refreshPreview();
                    this.closeModal('historyModal');
                } catch (error) {
                    this.addMessage('error', 'Rollback failed: ' + error.message);
                }
            },
            
            // Tools Detection
            async detectTools() {
                try {
                    const result = await window.aider.detectProjectTools(this.repoPath);
                    if (result.success) {
                        if (result.lintCmd) document.getElementById('lintCmd').value = result.lintCmd;
                        if (result.testCmd) document.getElementById('testCmd').value = result.testCmd;
                        this.addMessage('system', 'Detected tools: ' + (result.lintCmd || 'none') + ', ' + (result.testCmd || 'none'));
                    }
                } catch (error) {
                    console.error('[GSX Create] Detect tools error:', error);
                }
            },
            
            // UI Helpers
            updateStatus(text, connected) {
                document.getElementById('statusText').textContent = text;
                document.getElementById('statusDot').classList.toggle('active', connected);
            },
            
            toggleSidebar() {
                const sidebar = document.getElementById('sidebar');
                const icon = document.getElementById('sidebarToggleIcon');
                
                sidebar.classList.toggle('collapsed');
                const isCollapsed = sidebar.classList.contains('collapsed');
                icon.textContent = isCollapsed ? '‚ñ∂' : '‚óÄ';
                
                this.trackBehavior('sidebar_toggle', { collapsed: isCollapsed });
                localStorage.setItem('gsx-sidebar-collapsed', isCollapsed);
            },
            
            restoreSidebarState() {
                const collapsed = localStorage.getItem('gsx-sidebar-collapsed') === 'true';
                if (collapsed) {
                    document.getElementById('sidebar').classList.add('collapsed');
                    document.getElementById('sidebarToggleIcon').textContent = '‚ñ∂';
                }
            },
            
            // Toggle Configuration section collapse/expand
            toggleConfigSection() {
                const content = document.getElementById('configSectionContent');
                const icon = document.getElementById('configToggleIcon');
                const isHidden = content.style.display === 'none';
                
                content.style.display = isHidden ? 'block' : 'none';
                icon.style.transform = isHidden ? 'rotate(90deg)' : 'rotate(0deg)';
            },
            
            closeModal(id) {
                document.getElementById(id).classList.remove('active');
            },
            
            // ========== ERROR ANALYZER & GLOBAL LOGGING ==========
            
            // Console log buffer for context
            consoleLogBuffer: [],
            maxLogBufferSize: 100,
            
            // Setup error interceptors and console capture
            setupErrorAnalyzer() {
                if (!this.errorAnalyzer.enabled) return;
                
                // Intercept ALL console methods to build context buffer
                const self = this;
                ['log', 'info', 'warn', 'error', 'debug'].forEach(method => {
                    const original = console[method];
                    console[method] = function(...args) {
                        original.apply(console, args);
                        
                        // Add to buffer
                        const message = args.map(a => {
                            if (a instanceof Error) return `${a.name}: ${a.message}`;
                            if (typeof a === 'object') {
                                try { return JSON.stringify(a).substring(0, 200); }
                                catch { return String(a); }
                            }
                            return String(a);
                        }).join(' ');
                        
                        self.consoleLogBuffer.push({
                            type: method,
                            message: message.substring(0, 500),
                            timestamp: new Date().toISOString()
                        });
                        
                        // Trim buffer
                        if (self.consoleLogBuffer.length > self.maxLogBufferSize) {
                            self.consoleLogBuffer.shift();
                        }
                        
                        // Capture errors
                        if (method === 'error' && self.isSignificantError(message)) {
                            self.captureError('console.error', message, new Error().stack);
                        }
                    };
                });
                
                // Intercept unhandled errors
                window.addEventListener('error', (event) => {
                    if (this.isSignificantError(event.message)) {
                        this.captureError('uncaught', event.message, event.error?.stack, {
                            file: event.filename,
                            line: event.lineno,
                            col: event.colno
                        });
                    }
                });
                
                // Intercept unhandled promise rejections
                window.addEventListener('unhandledrejection', (event) => {
                    const message = event.reason?.message || String(event.reason);
                    if (this.isSignificantError(message)) {
                        this.captureError('promise', message, event.reason?.stack);
                    }
                });
                
                // Listen for main process errors via IPC
                if (window.aider && window.aider.onMainProcessError) {
                    window.aider.onMainProcessError((error) => {
                        this.captureError('main-process', error.message, error.stack, {
                            file: error.file,
                            line: error.line
                        });
                    });
                }
                
                // Add error count badge to UI
                this.updateErrorBadge();
                
                // Expose global logging function
                window.logEvent = this.logEvent.bind(this);
                window.logError = (error, context) => this.logEvent('error', error, context);
                window.logWarning = (message, context) => this.logEvent('warning', message, context);
                window.logInfo = (message, context) => this.logEvent('info', message, context);
                
                console.log('[ErrorAnalyzer] Initialized with console capture');
            },
            
            // ========== GLOBAL LOG EVENT FUNCTION ==========
            // Call from anywhere: window.logEvent('error', error, { context })
            
            async logEvent(type, errorOrMessage, context = {}) {
                const isError = errorOrMessage instanceof Error;
                const message = isError ? errorOrMessage.message : String(errorOrMessage);
                const stack = isError ? errorOrMessage.stack : new Error().stack;
                
                // Get recent console logs for context
                const recentLogs = this.consoleLogBuffer.slice(-20);
                
                // Build log entry
                const logEntry = {
                    id: Date.now(),
                    type: type, // 'error', 'warning', 'info'
                    message: message,
                    stack: stack,
                    context: {
                        ...context,
                        currentFile: this.currentPreviewFile,
                        phase: this.cycleState?.currentPhase,
                        version: this.cycleState?.currentVersion,
                        recentLogs: recentLogs
                    },
                    timestamp: new Date().toISOString(),
                    aiSummary: null,
                    userNotes: ''
                };
                
                // Store for quick log modal
                this.pendingLogEntry = logEntry;
                
                // Show quick log modal
                this.showQuickLogModal(logEntry);
                
                // Generate AI summary in background
                this.generateLogSummary(logEntry);
            },
            
            // Show quick log modal
            showQuickLogModal(entry) {
                const modal = document.getElementById('quickLogModal');
                const typeEl = document.getElementById('quickLogType');
                const summaryEl = document.getElementById('quickLogSummary');
                const aiEl = document.getElementById('quickLogAI');
                const notesEl = document.getElementById('quickLogNotes');
                
                // Set type badge
                typeEl.textContent = entry.type;
                typeEl.className = `quick-log-type ${entry.type}`;
                
                // Pre-fill summary with error message
                summaryEl.value = entry.message.substring(0, 100);
                
                // Reset AI and notes
                aiEl.textContent = 'üîç Analyzing with recent console logs...';
                aiEl.classList.add('loading');
                notesEl.value = '';
                
                modal.classList.add('active');
            },
            
            // Close quick log modal
            closeQuickLog() {
                document.getElementById('quickLogModal').classList.remove('active');
                this.pendingLogEntry = null;
            },
            
            // Generate AI summary with console log context
            async generateLogSummary(entry) {
                const aiEl = document.getElementById('quickLogAI');
                
                try {
                    // Format recent logs for AI
                    const logsContext = entry.context.recentLogs
                        .map(l => `[${l.type}] ${l.message}`)
                        .join('\n');
                    
                    const prompt = `Analyze this ${entry.type} and provide a brief, human-readable summary:

**${entry.type.toUpperCase()}:** ${entry.message}

**Recent Console Logs (for context):**
${logsContext || 'No recent logs'}

**Stack Trace:**
${entry.stack?.substring(0, 500) || 'No stack trace'}

**Current Context:**
- File: ${entry.context.currentFile || 'None'}
- Phase: ${entry.context.phase || 'None'}

Please provide:
1. A one-sentence summary of what happened
2. The likely cause
3. Suggested action (if applicable)

Keep it concise and actionable.`;

                    const result = await window.aider.analyzeScreenshot(null, prompt);
                    
                    if (result.success && result.analysis) {
                        entry.aiSummary = result.analysis;
                        aiEl.innerHTML = this.formatAIAnalysis(result.analysis);
                        aiEl.classList.remove('loading');
                        
                        // Auto-update summary field with AI's one-liner
                        const firstLine = result.analysis.split('\n')[0].replace(/^\d+\.\s*/, '').substring(0, 100);
                        if (firstLine) {
                            document.getElementById('quickLogSummary').value = firstLine;
                        }
                    } else {
                        aiEl.textContent = 'AI analysis unavailable';
                        aiEl.classList.remove('loading');
                    }
                } catch (e) {
                    aiEl.textContent = `Analysis failed: ${e.message}`;
                    aiEl.classList.remove('loading');
                }
            },
            
            // Save quick log entry
            async saveQuickLog() {
                const entry = this.pendingLogEntry;
                if (!entry) return;
                
                // Get user inputs
                entry.summary = document.getElementById('quickLogSummary').value;
                entry.userNotes = document.getElementById('quickLogNotes').value;
                
                // Save to transaction DB
                try {
                    await window.aider.txdbLogEvent({
                        type: entry.type,
                        summary: entry.summary,
                        message: entry.message,
                        aiSummary: entry.aiSummary,
                        userNotes: entry.userNotes,
                        context: JSON.stringify(entry.context),
                        stack: entry.stack,
                        timestamp: entry.timestamp
                    });
                    
                    this.addMessage('system', `üìù Logged: ${entry.summary.substring(0, 50)}...`);
                } catch (e) {
                    console.error('[LogEvent] Save failed:', e);
                    this.addMessage('error', 'Failed to save log entry');
                }
                
                this.closeQuickLog();
            },
            
            // Get recent console logs (for external use)
            getRecentLogs(count = 20) {
                return this.consoleLogBuffer.slice(-count);
            },
            
            // ========== USER BEHAVIOR TRACKING ==========
            
            // Track user behavior for debugging
            trackBehavior(action, details = {}) {
                const event = {
                    action,
                    details,
                    timestamp: new Date().toISOString(),
                    context: {
                        currentFile: this.currentPreviewFile,
                        spaceId: this.currentSpaceId,
                        phase: this.cycleState?.currentPhase,
                        version: this.cycleState?.currentVersion
                    }
                };
                
                // Add to console log buffer for context
                this.consoleLogBuffer.push({
                    type: 'behavior',
                    message: `[USER] ${action}: ${JSON.stringify(details).substring(0, 100)}`,
                    timestamp: event.timestamp
                });
                
                // Trim buffer
                if (this.consoleLogBuffer.length > this.maxLogBufferSize) {
                    this.consoleLogBuffer.shift();
                }
                
                // Log to console in dev mode
                console.log(`[Behavior] ${action}`, details);
                
                // Optionally save to database (for important actions)
                if (this.shouldPersistBehavior(action)) {
                    this.persistBehavior(event);
                }
            },
            
            // Determine if behavior should be persisted to database
            shouldPersistBehavior(action) {
                const persistActions = [
                    'session_start', 'session_end',
                    'space_selected', 'space_created',
                    'cycle_started', 'cycle_completed', 'cycle_stopped',
                    'phase_completed', 'phase_failed',
                    'prompt_sent', 'prompt_completed',
                    'test_run', 'test_completed',
                    'file_created', 'file_edited',
                    'error_fixed', 'settings_changed'
                ];
                return persistActions.includes(action);
            },
            
            // Persist behavior to database
            async persistBehavior(event) {
                try {
                    await window.aider.txdbLogEvent({
                        type: 'behavior',
                        summary: `${event.action}: ${JSON.stringify(event.details).substring(0, 50)}`,
                        message: event.action,
                        context: JSON.stringify(event),
                        timestamp: event.timestamp
                    });
                } catch (e) {
                    // Silent fail - don't interrupt user
                }
            },
            
            // Setup behavior tracking on UI elements
            setupBehaviorTracking() {
                // Track all button clicks
                document.addEventListener('click', (e) => {
                    const target = e.target.closest('button, .btn, [onclick]');
                    if (target) {
                        const action = target.textContent?.trim().substring(0, 30) || 
                                       target.getAttribute('onclick')?.substring(0, 30) ||
                                       target.className;
                        this.trackBehavior('button_click', { 
                            text: action,
                            id: target.id,
                            class: target.className?.substring(0, 50)
                        });
                    }
                });
                
                // Track select changes
                document.addEventListener('change', (e) => {
                    if (e.target.tagName === 'SELECT') {
                        this.trackBehavior('select_change', {
                            id: e.target.id,
                            value: e.target.value?.substring(0, 50)
                        });
                    }
                });
                
                // Track keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    if (e.metaKey || e.ctrlKey) {
                        this.trackBehavior('keyboard_shortcut', {
                            key: e.key,
                            meta: e.metaKey,
                            ctrl: e.ctrlKey,
                            shift: e.shiftKey
                        });
                    }
                });
                
                // Track visibility changes (tab switches)
                document.addEventListener('visibilitychange', () => {
                    this.trackBehavior('visibility_change', {
                        hidden: document.hidden
                    });
                });
                
                // Track window focus
                window.addEventListener('focus', () => {
                    this.trackBehavior('window_focus', {});
                });
                
                window.addEventListener('blur', () => {
                    this.trackBehavior('window_blur', {});
                });
                
                console.log('[BehaviorTracking] Initialized');
            },
            
            // ========== END USER BEHAVIOR TRACKING ==========
            
            // ========== GSX FRAMEWORK INTEGRATION ==========
            
            // Telemetry data received from preview
            previewTelemetry: {
                errors: [],
                events: [],
                consoleLogs: []
            },
            
            // Setup listener for telemetry from preview iframe
            setupPreviewTelemetryListener() {
                window.addEventListener('message', (event) => {
                    if (event.data?.source === 'gsx-telemetry') {
                        this.handlePreviewTelemetry(event.data);
                    }
                });
                console.log('[GSX Framework] Preview telemetry listener active');
            },
            
            // Handle telemetry data from preview
            handlePreviewTelemetry(data) {
                var type = data.type;
                var payload = data.data;
                var sid = data.sid;
                var ts = data.ts;
                
                switch (type) {
                    case 'error':
                        this.previewTelemetry.errors.push(payload);
                        this.trackBehavior('preview_error', { 
                            message: payload.message ? payload.message.substring(0, 50) : 'Unknown error',
                            type: payload.type || 'error'
                        });
                        // Show error in chat
                        this.addMessage('error', 'üî¥ Preview Error: ' + (payload.message || 'Unknown error'));
                        // Update error badge
                        this.updateErrorBadge();
                        // Auto-save error with session context to logs
                        this.saveErrorWithSession(payload);
                        break;
                        
                    case 'start':
                        console.log('[GSX Telemetry] Preview session started:', sid);
                        this.previewTelemetry = { 
                            errors: [], 
                            events: [], 
                            clicks: [],
                            rrEvents: [],
                            sessionId: sid,
                            startTime: ts
                        };
                        break;
                        
                    case 'session':
                        console.log('[GSX Telemetry] Session data received:', payload.errors?.length, 'errors,', payload.rrEvents?.length, 'rrweb events');
                        // Store full session data including rrweb events
                        this.previewTelemetry.errors = payload.errors || [];
                        this.previewTelemetry.clicks = payload.clicks || [];
                        this.previewTelemetry.rrEvents = payload.rrEvents || [];
                        // Save session to logs if there were errors
                        if (payload.errors && payload.errors.length > 0) {
                            this.saveSessionToLogs(payload);
                        }
                        break;
                        
                    default:
                        // Store other events
                        if (payload) {
                            this.previewTelemetry.events.push({ type: type, payload: payload, ts: ts });
                        }
                }
            },
            
            // Save error with session context to event logs
            async saveErrorWithSession(error) {
                try {
                    var sessionContext = {
                        recentClicks: this.previewTelemetry.clicks ? this.previewTelemetry.clicks.slice(-10) : [],
                        rrEventCount: this.previewTelemetry.rrEvents ? this.previewTelemetry.rrEvents.length : 0,
                        sessionId: this.previewTelemetry.sessionId
                    };
                    
                    await window.aider.txdbLogEvent({
                        type: 'error',
                        summary: 'Preview Error: ' + (error.message || 'Unknown').substring(0, 100),
                        message: error.message,
                        context: JSON.stringify({
                            error: error,
                            session: sessionContext,
                            file: this.currentPreviewFile
                        }),
                        timestamp: new Date().toISOString()
                    });
                    console.log('[GSX Telemetry] Error saved to logs with session context');
                } catch (e) {
                    console.warn('[GSX Telemetry] Could not save error to logs:', e);
                }
            },
            
            // Save full session to logs (for debugging)
            async saveSessionToLogs(session) {
                try {
                    // Compress rrweb events for storage (keep last 500)
                    var compressedSession = {
                        sid: session.sid,
                        errors: session.errors,
                        clicks: session.clicks,
                        rrEventCount: session.rrEvents ? session.rrEvents.length : 0,
                        // Store subset of rrweb events around errors
                        rrEventsPreview: session.rrEvents ? session.rrEvents.slice(-100) : []
                    };
                    
                    await window.aider.txdbLogEvent({
                        type: 'session',
                        summary: 'Session with ' + session.errors.length + ' errors, ' + (session.rrEvents ? session.rrEvents.length : 0) + ' recorded events',
                        message: 'Full session recording available',
                        context: JSON.stringify(compressedSession),
                        timestamp: new Date().toISOString()
                    });
                    console.log('[GSX Telemetry] Session saved to logs');
                } catch (e) {
                    console.warn('[GSX Telemetry] Could not save session to logs:', e);
                }
            },
            
            // Get AI instructions for including framework
            getFrameworkInstructions() {
                return 'IMPORTANT: All HTML files should include error tracking.\n' +
                    'Add window.onerror and window.onunhandledrejection handlers to capture errors.\n' +
                    'The GSX framework will be auto-injected during build.';
            },
            
            // Inject framework into HTML content
            injectFrameworkIntoHtml(html) {
                // Skip if already has framework
                if (html.includes('__GSX_TELEMETRY_INITIALIZED__') || html.includes('GSX Telemetry')) {
                    return html;
                }
                
                // Full telemetry script with rrweb session recording
                var telemetryScript = this.getFullTelemetryScript();
                
                // Use <\/script> to avoid breaking HTML parser
                var scriptTag = '<!-- GSX Telemetry --><script>' + telemetryScript + '<' + '/script>';
                
                if (html.includes('</head>')) {
                    return html.replace('</head>', scriptTag + '</head>');
                } else if (html.indexOf('<body') !== -1) {
                    return html.replace(/<body[^>]*>/, function(match) { return match + scriptTag; });
                }
                return scriptTag + html;
            },
            
            // Get the full telemetry script (built dynamically to avoid escaping issues)
            getFullTelemetryScript() {
                // This script includes: error tracking, click tracking, rrweb loading, and session recording
                return [
                    '(function(w,d){',
                    'if(w.__GSX_TELEMETRY_INITIALIZED__)return;',
                    'w.__GSX_TELEMETRY_INITIALIZED__=true;',
                    'var T={',
                    '  sid:"gsx_"+Date.now().toString(36),',
                    '  events:[],',
                    '  errors:[],',
                    '  clicks:[],',
                    '  rrEvents:[],',
                    '  rrStop:null,',
                    '  report:function(type,data){',
                    '    try{w.parent.postMessage({source:"gsx-telemetry",type:type,data:data,sid:this.sid,ts:Date.now()},"*");}catch(e){}',
                    '  },',
                    '  error:function(msg,file,line,col,err){',
                    '    var e={message:msg,filename:file,lineno:line,colno:col,stack:err?err.stack:"",ts:Date.now()};',
                    '    this.errors.push(e);',
                    '    this.report("error",e);',
                    '  },',
                    '  click:function(el){',
                    '    var c={tag:el.tagName,id:el.id,class:el.className,text:(el.textContent||"").substring(0,30),ts:Date.now()};',
                    '    this.clicks.push(c);',
                    '    if(this.clicks.length>100)this.clicks.shift();',
                    '  },',
                    '  loadRrweb:function(){',
                    '    var s=d.createElement("script");',
                    '    s.src="https://cdn.jsdelivr.net/npm/rrweb@2.0.0-alpha.11/dist/rrweb.min.js";',
                    '    s.onload=function(){T.startRecording();};',
                    '    d.head.appendChild(s);',
                    '  },',
                    '  startRecording:function(){',
                    '    if(!w.rrweb)return;',
                    '    try{',
                    '      this.rrStop=w.rrweb.record({',
                    '        emit:function(ev){',
                    '          T.rrEvents.push(ev);',
                    '          if(T.rrEvents.length>5000)T.rrEvents=T.rrEvents.slice(-5000);',
                    '        },',
                    '        sampling:{mousemove:false,scroll:150,input:"last"},',
                    '        blockClass:"gsx-no-record",',
                    '        maskAllInputs:false,',
                    '        maskInputOptions:{password:true}',
                    '      });',
                    '      console.log("[GSX] rrweb recording started");',
                    '    }catch(e){console.warn("[GSX] rrweb error:",e);}',
                    '  },',
                    '  getSession:function(){',
                    '    return{sid:this.sid,errors:this.errors,clicks:this.clicks.slice(-20),rrEvents:this.rrEvents.slice(-1000)};',
                    '  }',
                    '};',
                    'w.onerror=function(m,f,l,c,e){T.error(m,f,l,c,e);};',
                    'w.onunhandledrejection=function(e){T.error("Promise: "+(e.reason?e.reason.message:e.reason),"",0,0,e.reason);};',
                    'd.addEventListener("click",function(e){',
                    '  var t=e.target.closest("button,a,[onclick],input[type=submit]");',
                    '  if(t)T.click(t);',
                    '},{passive:true});',
                    'w.addEventListener("beforeunload",function(){T.report("session",T.getSession());});',
                    'T.loadRrweb();',
                    'T.report("start",{url:location.href,ua:navigator.userAgent});',
                    'w.GSXTelemetry=T;',
                    'console.log("[GSX Telemetry] Active with rrweb");',
                    '})(window,document);'
                ].join('');
            },
            
            // Get preview telemetry summary for evaluation
            getPreviewTelemetrySummary() {
                return {
                    errorCount: this.previewTelemetry.errors.length,
                    errors: this.previewTelemetry.errors.slice(-10),
                    eventCount: this.previewTelemetry.events.length,
                    consoleErrors: this.previewTelemetry.consoleLogs.filter(function(l) { return l.level === 'error'; }),
                    consoleWarnings: this.previewTelemetry.consoleLogs.filter(function(l) { return l.level === 'warn'; })
                };
            },
            
            // ========== END GSX FRAMEWORK INTEGRATION ==========
            
            // Check if error is significant (not noise)
            isSignificantError(message) {
                if (!message) return false;
                
                const noisePatterns = [
                    'ResizeObserver',
                    'Script error',
                    'Autofill',
                    'Extension context',
                    'chrome-extension',
                    'moz-extension',
                    'net::ERR_',
                    'favicon.ico',
                    'Loading module',
                    'DevTools',
                    'Violation'
                ];
                
                return !noisePatterns.some(pattern => message.includes(pattern));
            },
            
            // Update error count badge in UI
            updateErrorBadge() {
                const errorCount = this.errorAnalyzer.errorLog.filter(e => !e.fixed).length;
                let badge = document.getElementById('errorBadge');
                
                if (!badge) {
                    // Create badge next to status
                    const statusDiv = document.querySelector('.status');
                    if (statusDiv) {
                        badge = document.createElement('span');
                        badge.id = 'errorBadge';
                        badge.style.cssText = 'display: none; background: var(--danger); color: white; font-size: 10px; padding: 2px 6px; border-radius: 10px; margin-left: 8px; cursor: pointer;';
                        badge.onclick = () => this.showEventLogs();
                        statusDiv.appendChild(badge);
                    }
                }
                
                if (badge) {
                    if (errorCount > 0) {
                        badge.textContent = `${errorCount} error${errorCount > 1 ? 's' : ''}`;
                        badge.style.display = 'inline';
                    } else {
                        badge.style.display = 'none';
                    }
                }
            },
            
            // Show error log (in-memory session errors)
            showErrorLog() {
                const errors = this.errorAnalyzer.errorLog.slice(0, 10);
                if (errors.length === 0) {
                    this.addMessage('system', 'No errors in current session. Click the error badge to view saved logs.');
                    return;
                }
                
                const errorList = errors.map((e, i) => 
                    `${i + 1}. [${e.type}] ${e.message.substring(0, 50)}... ${e.fixed ? '‚úì' : ''}`
                ).join('\n');
                
                this.addMessage('system', `üìã Session Errors:\n${errorList}\n\nüí° Tip: Use window.logError(error) to save errors permanently.`);
            },
            
            // Capture and analyze an error
            async captureError(type, message, stack, location = {}) {
                // Skip if this error is suppressed
                const errorKey = `${type}:${message}`;
                if (this.errorAnalyzer.suppressedErrors.has(errorKey)) return;
                
                // Skip certain noise errors
                if (message.includes('ResizeObserver') || 
                    message.includes('Script error') ||
                    message.includes('Autofill')) return;
                
                const error = {
                    id: Date.now(),
                    type,
                    message,
                    stack: stack || 'No stack trace',
                    file: location.file || this.parseFileFromStack(stack),
                    line: location.line || this.parseLineFromStack(stack),
                    timestamp: new Date().toISOString(),
                    context: {
                        currentFile: this.currentPreviewFile,
                        phase: this.cycleState.currentPhase,
                        version: this.cycleState.currentVersion
                    },
                    aiAnalysis: null,
                    suggestedFix: null
                };
                
                // Add to log
                this.errorAnalyzer.errorLog.unshift(error);
                if (this.errorAnalyzer.errorLog.length > this.errorAnalyzer.maxLogSize) {
                    this.errorAnalyzer.errorLog.pop();
                }
                
                // Store current error
                this.errorAnalyzer.currentError = error;
                
                // Update error badge
                this.updateErrorBadge();
                
                // Show modal
                this.showErrorModal(error);
                
                // Analyze with AI
                await this.analyzeErrorWithAI(error);
            },
            
            // Parse file from stack trace
            parseFileFromStack(stack) {
                if (!stack) return 'Unknown';
                const match = stack.match(/at\s+.*?\s+\(?(.*?):(\d+):(\d+)\)?/);
                if (match) {
                    return match[1].split('/').pop();
                }
                return 'Unknown';
            },
            
            // Parse line from stack trace
            parseLineFromStack(stack) {
                if (!stack) return '-';
                const match = stack.match(/at\s+.*?\s+\(?(.*?):(\d+):(\d+)\)?/);
                if (match) {
                    return match[2];
                }
                return '-';
            },
            
            // Show error modal
            showErrorModal(error) {
                const modal = document.getElementById('errorAnalyzerModal');
                const msgEl = document.getElementById('errorMessage');
                const fileEl = document.getElementById('errorFile');
                const lineEl = document.getElementById('errorLine');
                const stackEl = document.getElementById('errorStack');
                const analysisEl = document.getElementById('errorAIAnalysis');
                const fixBtn = document.getElementById('errorFixBtn');
                
                msgEl.textContent = error.message;
                fileEl.textContent = error.file || 'Unknown';
                lineEl.textContent = error.line || '-';
                stackEl.textContent = error.stack || 'No stack trace';
                analysisEl.textContent = 'üîç Analyzing error...';
                analysisEl.classList.add('loading');
                fixBtn.disabled = true;
                
                modal.classList.add('active');
            },
            
            // Close error modal
            closeErrorModal() {
                document.getElementById('errorAnalyzerModal').classList.remove('active');
            },
            
            // Analyze error with AI
            async analyzeErrorWithAI(error) {
                const analysisEl = document.getElementById('errorAIAnalysis');
                const fixBtn = document.getElementById('errorFixBtn');
                
                try {
                    const prompt = `Analyze this JavaScript error and provide:
1. A clear explanation of what caused it
2. The likely root cause
3. A specific fix suggestion

Error Type: ${error.type}
Error Message: ${error.message}
File: ${error.file}
Line: ${error.line}
Stack Trace:
${error.stack}

Context:
- Current file being edited: ${error.context.currentFile || 'None'}
- Development phase: ${error.context.phase || 'None'}

Please provide a concise analysis and actionable fix.`;

                    // Use the vision API for analysis (it can handle text too)
                    const result = await window.aider.analyzeScreenshot(null, prompt);
                    
                    if (result.success && result.analysis) {
                        error.aiAnalysis = result.analysis;
                        error.suggestedFix = this.extractFixFromAnalysis(result.analysis);
                        
                        analysisEl.innerHTML = this.formatAIAnalysis(result.analysis);
                        analysisEl.classList.remove('loading');
                        
                        if (error.suggestedFix) {
                            fixBtn.disabled = false;
                        }
                    } else {
                        analysisEl.textContent = 'AI analysis unavailable. Check API configuration.';
                        analysisEl.classList.remove('loading');
                    }
                } catch (e) {
                    console.log('[ErrorAnalyzer] AI analysis failed:', e);
                    analysisEl.textContent = `AI analysis failed: ${e.message}`;
                    analysisEl.classList.remove('loading');
                }
            },
            
            // Format AI analysis for display
            formatAIAnalysis(analysis) {
                // Simple markdown-like formatting
                return analysis
                    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                    .replace(/`(.*?)`/g, '<code style="background: var(--bg-primary); padding: 2px 6px; border-radius: 3px;">$1</code>')
                    .replace(/\n/g, '<br>');
            },
            
            // Extract fix suggestion from analysis
            extractFixFromAnalysis(analysis) {
                // Look for code blocks or fix suggestions
                const codeMatch = analysis.match(/```[\s\S]*?```/);
                if (codeMatch) {
                    return codeMatch[0].replace(/```\w*\n?/g, '').trim();
                }
                
                // Look for "fix:" or "solution:" patterns
                const fixMatch = analysis.match(/(?:fix|solution|change|replace):\s*(.+?)(?:\n|$)/i);
                if (fixMatch) {
                    return fixMatch[1].trim();
                }
                
                return null;
            },
            
            // Fix the error using Aider
            async fixError() {
                const error = this.errorAnalyzer.currentError;
                if (!error || !error.aiAnalysis) return;
                
                this.closeErrorModal();
                
                // Add message to chat
                this.addMessage('system', `üîß Fixing error: ${error.message.substring(0, 50)}...`);
                
                // Create fix prompt
                const fixPrompt = `Please fix this error in the code:

Error: ${error.message}
File: ${error.file}
Line: ${error.line}

AI Analysis:
${error.aiAnalysis}

Please make the necessary code changes to fix this error.`;
                
                // Send to Aider
                try {
                    await this.executeTask(fixPrompt);
                    this.addMessage('system', '‚úì Fix applied');
                    
                    // Mark as addressed in error log
                    error.fixed = true;
                    error.fixedAt = new Date().toISOString();
                } catch (e) {
                    this.addMessage('error', `Fix failed: ${e.message}`);
                }
            },
            
            // Save error to log file
            async saveErrorToLog() {
                const error = this.errorAnalyzer.currentError;
                if (!error) return;
                
                // Format error for log
                const logEntry = `
## Error - ${new Date(error.timestamp).toLocaleString()}

**Type:** ${error.type}
**Message:** ${error.message}
**File:** ${error.file}
**Line:** ${error.line}

### Stack Trace
\`\`\`
${error.stack}
\`\`\`

### AI Analysis
${error.aiAnalysis || 'Not analyzed'}

---
`;
                
                // Append to error log file
                const logFile = `${this.repoPath}/error-log.md`;
                try {
                    let existingLog = await this.loadCycleFile('errorLog', false) || '# Error Log\n\n';
                    existingLog += logEntry;
                    await this.executeTask(`Update error-log.md with this error entry:\n\n${logEntry}`);
                    this.addMessage('system', 'üìù Error saved to error-log.md');
                } catch (e) {
                    console.error('[ErrorAnalyzer] Save failed:', e);
                }
                
                this.closeErrorModal();
            },
            
            // Suppress an error (don't show again)
            suppressError() {
                const error = this.errorAnalyzer.currentError;
                if (error) {
                    const errorKey = `${error.type}:${error.message}`;
                    this.errorAnalyzer.suppressedErrors.add(errorKey);
                }
                this.closeErrorModal();
            },
            
            // ========== END ERROR ANALYZER ==========
            
            getFileIcon(filename) {
                const ext = filename.split('.').pop().toLowerCase();
                const icons = { html: 'üåê', css: 'üé®', js: 'üìú', ts: 'üìò', py: 'üêç', json: 'üìã', md: 'üìù' };
                return icons[ext] || 'üìÑ';
            },
            
            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            },
            
            setupEventListeners() {
                const input = document.getElementById('promptInput');
                
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        this.sendPrompt();
                    }
                });
                
                input.addEventListener('input', function() {
                    this.style.height = 'auto';
                    this.style.height = Math.min(this.scrollHeight, 120) + 'px';
                });
                
                // File change listener - refresh preview when files change
                if (window.aider.onFileChanged) {
                    window.aider.onFileChanged((filePath) => {
                        console.log('[GSX Create] File changed:', filePath);
                        // Refresh preview if it's the current file
                        if (this.currentPreviewFile && filePath === this.currentPreviewFile) {
                            this.refreshPreview();
                        }
                        // Also refresh file list
                        this.loadProjectFiles();
                    });
                }
                
                // Resize handle for preview panel
                this.setupResizeHandle();
            },
            
            setupResizeHandle() {
                // Preview panel resize only
                const previewHandle = document.getElementById('previewResizeHandle');
                const previewPanel = document.getElementById('previewPanel');
                
                if (!previewHandle || !previewPanel) return;
                
                let isResizing = false;
                let startX, startWidth;
                
                // Create overlay to prevent iframe from capturing mouse events
                const overlay = document.createElement('div');
                overlay.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; z-index: 9999; cursor: ew-resize; display: none;';
                document.body.appendChild(overlay);
                
                const stopResize = () => {
                    if (isResizing) {
                        isResizing = false;
                        previewHandle.classList.remove('dragging');
                        overlay.style.display = 'none';
                        document.body.style.userSelect = '';
                    }
                };
                
                previewHandle.addEventListener('mousedown', (e) => {
                    isResizing = true;
                    startX = e.clientX;
                    startWidth = previewPanel.offsetWidth;
                    previewHandle.classList.add('dragging');
                    overlay.style.display = 'block';
                    document.body.style.userSelect = 'none';
                    e.preventDefault();
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (!isResizing) return;
                    // Dragging left edge - moving left increases width
                    const diff = startX - e.clientX;
                    const newWidth = Math.max(200, Math.min(startWidth + diff, window.innerWidth * 0.7));
                    previewPanel.style.width = newWidth + 'px';
                });
                
                document.addEventListener('mouseup', stopResize);
            },
            
            // ========== META LEARNING CYCLE METHODS ==========
            
            // Required files for each phase
            phaseRequiredFiles: {
                evaluate: [
                    { name: 'evaluation-criteria.md', description: 'Evaluation criteria for rating the app' },
                    { name: 'user-feedback.md', description: 'User feedback (end-user, advocate, AI-generated)' }
                ],
                research: [
                    { name: 'research-notes.md', description: 'Research findings and insights' }
                ],
                plan: [
                    { name: 'todo.md', description: 'Task list for current iteration' }
                ],
                execute: [
                    { name: 'style-guide.md', description: 'Style guide for consistent design' }
                ],
                test: [
                    { name: 'TEST-PLAN.md', description: 'Test plan tracking all tests' }
                ],
                improve: []
            },
            
            // Check and create required files for a phase
            async checkPhaseRequiredFiles(phaseName) {
                var requiredFiles = this.phaseRequiredFiles[phaseName] || [];
                if (requiredFiles.length === 0) return true;
                
                this.addMessage('system', '‚Üí Checking required files for ' + phaseName + ' phase...');
                
                var missingFiles = [];
                var existingFiles = [];
                
                for (var i = 0; i < requiredFiles.length; i++) {
                    var file = requiredFiles[i];
                    var filePath = this.repoPath + '/' + file.name;
                    try {
                        var content = await window.aider.readFile(filePath);
                        if (content && content.trim().length > 0) {
                            existingFiles.push(file);
                        } else {
                            missingFiles.push(file);
                        }
                    } catch (e) {
                        missingFiles.push(file);
                    }
                }
                
                for (var i = 0; i < existingFiles.length; i++) {
                    this.addMessage('system', '   ‚úì ' + existingFiles[i].name);
                }
                
                if (missingFiles.length > 0) {
                    this.addMessage('system', '');
                    this.addMessage('system', '‚ö†Ô∏è Missing required files:');
                    for (var i = 0; i < missingFiles.length; i++) {
                        this.addMessage('system', '   ‚Ä¢ ' + missingFiles[i].name + ' - ' + missingFiles[i].description);
                    }
                    this.addMessage('system', '');
                    
                    for (var i = 0; i < missingFiles.length; i++) {
                        await this.createRequiredFile(missingFiles[i]);
                    }
                    return false;
                }
                return true;
            },
            
            // Create a required file with template
            async createRequiredFile(file) {
                var filePath = this.repoPath + '/' + file.name;
                var template = this.getFileTemplate(file.name);
                
                try {
                    await window.aider.writeFile(filePath, template);
                    this.addMessage('system', 'üìù Created: ' + file.name);
                    
                    // Refresh the file list so new file appears in sidebar
                    await this.loadProjectFiles();
                    
                    // Show preview
                    this.addMessage('system', '‚îÄ'.repeat(40));
                    var lines = template.split('\n').slice(0, 10);
                    for (var i = 0; i < lines.length; i++) {
                        this.addMessage('system', '   ' + lines[i]);
                    }
                    if (template.split('\n').length > 10) {
                        this.addMessage('system', '   ... (more content)');
                    }
                    this.addMessage('system', '‚îÄ'.repeat(40));
                } catch (e) {
                    this.addMessage('system', '‚ùå Failed to create ' + file.name + ': ' + e.message);
                }
            },
            
            // Get template for a file
            getFileTemplate(fileName) {
                var templates = {
                    'evaluation-criteria.md': '# Evaluation Criteria\n\nRate each criterion from 1-10 (10 = excellent)\n\n## Functionality\n- [ ] Core features work as expected\n- [ ] No JavaScript errors in console\n- [ ] Forms submit correctly\n- [ ] Navigation works properly\n\n## User Experience\n- [ ] Intuitive and easy to use\n- [ ] Clear visual hierarchy\n- [ ] Responsive design\n- [ ] Accessible (keyboard, screen reader)\n\n## Performance\n- [ ] Loads quickly (< 3 seconds)\n- [ ] Smooth animations\n- [ ] No lag or stuttering\n\n## Code Quality\n- [ ] Clean, readable code\n- [ ] Proper error handling\n- [ ] No deprecated APIs\n\n## Design\n- [ ] Visually appealing\n- [ ] Consistent styling\n- [ ] Good use of color and typography\n\n---\n*Edit this file to customize evaluation criteria for your project*\n',
                    
                    'user-feedback.md': '# User Feedback\n\n## End-User Feedback\n<!-- Feedback from actual users -->\n\n### Unaddressed\n- (No feedback yet)\n\n### Addressed\n- (None)\n\n---\n\n## Advocate Feedback\n<!-- Feedback from stakeholders -->\n\n### Unaddressed\n- (No feedback yet)\n\n### Addressed\n- (None)\n\n---\n\n## AI-Generated Feedback\n<!-- Feedback from Meta Learning Agent -->\n\n### Unaddressed\n- (Will be populated during Evaluate phase)\n\n### Addressed\n- (None)\n\n---\n*Add feedback in the appropriate section. Mark as addressed after fixed.*\n',
                    
                    'research-notes.md': '# Research Notes\n\n## Version History\n| Version | Date | Focus Area |\n|---------|------|------------|\n| v1 | ' + new Date().toISOString().split('T')[0] + ' | Initial research |\n\n---\n\n## Current Research (v1)\n\n### Problem Statement\n(What issues need to be addressed?)\n\n### Findings\n(Research findings go here)\n\n### Recommendations\n(Recommended solutions)\n\n### Resources\n- (Links and references)\n\n---\n*Updated each cycle with new research findings*\n',
                    
                    'todo.md': '# Todo List\n\n## Version: v1\n**Status:** Planning\n\n---\n\n## Tasks\n\n### Pending\n- [ ] (Tasks will be added during Plan phase)\n\n### In Progress\n- (None)\n\n### Completed\n- (None)\n\n---\n\n## Notes\n(Additional notes)\n\n---\n*Updated during Plan and Execute phases*\n',
                    
                    'style-guide.md': '# Style Guide\n\n## Colors\n\n### Primary\n- Primary: #3b82f6 (Blue)\n- Primary Light: #60a5fa\n- Primary Dark: #2563eb\n\n### Neutral\n- Background: #ffffff\n- Surface: #f8fafc\n- Border: #e2e8f0\n- Text: #1e293b\n\n### Semantic\n- Success: #22c55e\n- Warning: #f59e0b\n- Error: #ef4444\n\n---\n\n## Typography\n\n### Fonts\n- Headings: System UI, sans-serif\n- Body: System UI, sans-serif\n- Code: Menlo, Monaco, monospace\n\n### Sizes\n- h1: 2rem\n- h2: 1.5rem\n- h3: 1.25rem\n- body: 1rem\n\n---\n\n## Spacing\n- sm: 0.5rem\n- md: 1rem\n- lg: 1.5rem\n- xl: 2rem\n\n---\n*Customize this for your project*\n',
                    
                    'TEST-PLAN.md': '# Test Plan\n\n## Overview\n| Metric | Count |\n|--------|-------|\n| Total Tests | 0 |\n| Passing | 0 |\n| Failing | 0 |\n\n---\n\n## UI Tests\n| Test | Status | Last Run |\n|------|--------|----------|\n| (Tests will be added) | - | - |\n\n---\n\n## API Tests\n| Endpoint | Method | Status |\n|----------|--------|--------|\n| (API tests will be added) | - | - |\n\n---\n\n## Integration Tests\n| Test | Status |\n|------|--------|\n| (Integration tests will be added) | - |\n\n---\n*Auto-updated by Meta Learning Agent*\n'
                };
                return templates[fileName] || '# ' + fileName + '\n\n(Content goes here)\n';
            },
            
            // Wait for user approval of created files
            async waitForFileApproval() {
                var self = this;
                return new Promise(function(resolve) {
                    self.addMessage('system', '');
                    self.addMessage('system', '‚è∏Ô∏è **Review the created files above**');
                    self.addMessage('system', '');
                    self.addMessage('system', '   Edit these files in the sidebar to customize them.');
                    self.addMessage('system', '   When ready, click ‚ñ∂ to continue.');
                    self.addMessage('system', '');
                    
                    self.cycleState.paused = true;
                    self.cycleState.waitingForApproval = true;
                    self.cycleState.approvalCallback = resolve;
                    self.updateCycleUI();
                });
            },
            
            // Initialize cycle panel (call after session starts)
            initCyclePanel() {
                const cyclePanel = document.getElementById('cyclePanel');
                cyclePanel.classList.add('visible');
                this.renderVersionTimeline();
                this.updateCycleUI();
            },
            
            // Render version timeline pills
            renderVersionTimeline() {
                const timeline = document.getElementById('versionTimeline');
                if (!timeline) return;
                
                const versions = [];
                for (let i = 1; i <= Math.max(this.cycleState.currentVersion, 1); i++) {
                    versions.push(i);
                }
                
                timeline.innerHTML = versions.map(v => `
                    <div class="version-pill ${v === this.cycleState.currentVersion ? 'active' : ''}" 
                         onclick="GSXCreate.goToVersion(${v})"
                         title="Version ${v}">
                        v${v}
                    </div>
                `).join('');
            },
            
            // Update cycle UI state
            updateCycleUI() {
                // Update play/pause button
                const playBtn = document.getElementById('cyclePlayBtn');
                const pauseBtn = document.getElementById('cyclePauseBtn');
                
                if (playBtn && pauseBtn) {
                    if (this.cycleState.active && !this.cycleState.paused) {
                        playBtn.style.display = 'none';
                        pauseBtn.style.display = 'inline-flex';
                    } else {
                        playBtn.style.display = 'inline-flex';
                        pauseBtn.style.display = 'none';
                    }
                }
                
                // Update score display
                const scoreEl = document.getElementById('cycleScore');
                if (scoreEl) {
                    scoreEl.textContent = `${this.cycleState.currentScore || 0}%`;
                }
                
                // Update progress bar
                const progressFill = document.getElementById('cycleProgressFill');
                if (progressFill) {
                    progressFill.style.width = `${this.cycleState.currentScore || 0}%`;
                }
                
                // Update version display
                const versionLabel = document.getElementById('versionLabel');
                if (versionLabel) {
                    versionLabel.textContent = `v${this.cycleState.currentVersion}`;
                }
                
                // Re-render version timeline
                this.renderVersionTimeline();
            },
            
            // Go to specific version
            goToVersion(version) {
                this.cycleState.currentVersion = version;
                this.updateCycleUI();
                this.addMessage('system', `Switched to version ${version}`);
            },
            
            // Log cycle event to event database
            async logCycleEvent(action, details = {}) {
                const eventData = {
                    type: 'cycle',
                    summary: `[Cycle] ${action}`,
                    message: action,
                    context: JSON.stringify({
                        ...details,
                        version: this.cycleState.currentVersion,
                        phase: this.cycleState.currentPhase,
                        score: this.cycleState.currentScore,
                        objective: this.cycleState.objective
                    }),
                    timestamp: new Date().toISOString()
                };
                
                try {
                    await window.aider.txdbLogEvent(eventData);
                } catch (e) {
                    console.log('[Cycle] Event log error:', e);
                }
                
                // Also track behavior for UI
                this.trackBehavior(`cycle_${action.toLowerCase().replace(/\s+/g, '_')}`, details);
            },
            
            // Start meta learning cycle
            async startCycle() {
                if (this.cycleState.active) return;
                
                await this.logCycleEvent('Cycle Started', { version: this.cycleState.currentVersion });
                
                this.cycleState.active = true;
                this.cycleState.paused = false;
                this.cycleState.objective = null;  // Reset objective for new cycle
                this.cycleState.waitingForObjective = false;
                
                // Create initial version if none exists
                if (this.cycleState.versions.length === 0) {
                    await this.createVersion('Initial version');
                }
                
                this.updateCycleUI();
                this.addMessage('system', 'üîÑ Meta Learning Cycle started');
                
                // Start the cycle with evaluate phase
                await this.runPhase('evaluate');
            },
            
            // Pause cycle
            pauseCycle() {
                this.cycleState.paused = true;
                this.updateCycleUI();
                this.addMessage('system', '‚è∏Ô∏è Meta learning cycle paused.');
            },
            
            // Resume cycle
            resumeCycle() {
                // Check if waiting for file selection
                if (this.cycleState.waitingForFile) {
                    if (!this.currentPreviewFile) {
                        this.addMessage('system', '‚ö†Ô∏è Please select a file first');
                        return;
                    }
                    this.cycleState.waitingForFile = false;
                }
                
                // Check if waiting for file approval
                if (this.cycleState.waitingForApproval) {
                    this.cycleState.waitingForApproval = false;
                    if (this.cycleState.approvalCallback) {
                        var callback = this.cycleState.approvalCallback;
                        this.cycleState.approvalCallback = null;
                        this.cycleState.paused = false;
                        this.updateCycleUI();
                        this.addMessage('system', '‚úì Files approved. Continuing...');
                        callback(); // Resume the phase
                        return;
                    }
                }
                
                this.cycleState.paused = false;
                this.updateCycleUI();
                this.addMessage('system', '‚ñ∂Ô∏è Meta learning cycle resumed.');
                
                // Continue from current phase
                if (this.cycleState.currentPhase) {
                    this.runPhase(this.cycleState.currentPhase);
                }
            },
            
            // Stop cycle
            stopCycle() {
                this.logCycleEvent('Cycle Stopped', { 
                    version: this.cycleState.currentVersion,
                    phase: this.cycleState.currentPhase,
                    score: this.cycleState.currentScore
                });
                
                this.cycleState.active = false;
                this.cycleState.paused = false;
                this.cycleState.currentPhase = null;
                this.updateCycleUI();
                this.addMessage('system', '‚èπÔ∏è Meta learning cycle stopped.');
            },
            
            // Run a specific phase
            async runPhase(phase) {
                if (!this.cycleState.active || this.cycleState.paused) return;
                
                await this.logCycleEvent('Phase Started', { phase });
                
                this.cycleState.currentPhase = phase;
                this.updateCycleUI();
                
                // Phase icons and names for display
                const phaseInfo = {
                    evaluate: { icon: 'üìä', name: 'Evaluate' },
                    research: { icon: 'üîç', name: 'Research' },
                    plan: { icon: 'üìã', name: 'Plan' },
                    execute: { icon: '‚ö°', name: 'Execute' },
                    test: { icon: 'üß™', name: 'Test' },
                    improve: { icon: '‚ú®', name: 'Improve' },
                    finalize: { icon: 'üéØ', name: 'Finalize' }
                };
                
                const info = phaseInfo[phase];
                this.addMessage('system', `‚îÅ‚îÅ‚îÅ ${info.icon} ${info.name.toUpperCase()} PHASE ‚îÅ‚îÅ‚îÅ`);
                
                const phaseNode = document.getElementById(`phase-${phase}`);
                if (phaseNode) {
                    document.querySelectorAll('.phase-dot').forEach(n => n.classList.remove('active'));
                    phaseNode.classList.add('active');
                }
                
                try {
                    switch (phase) {
                        case 'evaluate':
                            await this.phaseEvaluate();
                            break;
                        case 'research':
                            await this.phaseResearch();
                            break;
                        case 'plan':
                            await this.phasePlan();
                            break;
                        case 'execute':
                            await this.phaseExecute();
                            break;
                        case 'test':
                            await this.phaseTest();
                            break;
                        case 'improve':
                            await this.phaseImprove();
                            break;
                        case 'finalize':
                            await this.phaseFinalize();
                            break;
                    }
                    
                    // Only mark complete if not paused (waiting for user input)
                    if (!this.cycleState.paused) {
                        if (phaseNode) phaseNode.classList.add('completed');
                        this.addMessage('system', `‚úì ${info.name} phase complete`);
                        await this.logCycleEvent('Phase Completed', { phase });
                    }
                    
                } catch (error) {
                    console.error(`[Cycle] Phase ${phase} error:`, error);
                    if (phaseNode) phaseNode.classList.add('failed');
                    this.addMessage('error', `‚úó ${info.name} phase failed: ${error.message}`);
                    await this.logCycleEvent('Phase Failed', { phase, error: error.message });
                }
            },
            
            // Evaluate Phase - Comprehensive evaluation with tests, logs, and feedback
            async phaseEvaluate() {
                // Check required files for this phase
                var filesReady = await this.checkPhaseRequiredFiles('evaluate');
                if (!filesReady) {
                    await this.waitForFileApproval();
                }
                
                // If no file selected, try to auto-select main HTML file
                if (!this.currentPreviewFile) {
                    this.addMessage('system', '‚Üí No file selected, looking for main HTML file...');
                    
                    // Try to find an HTML file in the project
                    const htmlFile = await this.findMainHtmlFile();
                    
                    if (htmlFile) {
                        this.addMessage('system', `   ‚úì Found: ${htmlFile.split('/').pop()}`);
                        await this.previewFile(htmlFile);
                        await this.delay(500);
                    } else {
                        // Pause and ask user to select a file
                        this.addMessage('system', '‚Üí No HTML file found. Please select a file to evaluate.');
                        this.addMessage('system', '   Click a file in the sidebar, then press ‚ñ∂ to continue.');
                        this.cycleState.paused = true;
                        this.cycleState.waitingForFile = true;
                        this.updateCycleUI();
                        return;
                    }
                }
                
                const evaluation = {
                    screenshot: null,
                    testResults: null,
                    consoleLogs: [],
                    feedback: { endUser: [], advocate: [], generated: [] },
                    criteria: [],
                    scores: {}
                };
                
                // Step 1: Screenshot
                this.addMessage('system', '‚Üí Capturing screenshot...');
                try {
                    const screenshotResult = await window.aider.capturePreviewScreenshot(this.currentPreviewFile);
                    if (screenshotResult.success) {
                        evaluation.screenshot = screenshotResult.screenshot;
                        this.addMessage('system', `   ‚úì Screenshot captured (${Math.round(screenshotResult.size / 1024)}KB)`);
                        await this.logCycleEvent('Screenshot Captured', { size: screenshotResult.size, file: this.currentPreviewFile });
                    } else {
                        this.addMessage('system', `   ‚ö†Ô∏è Screenshot failed: ${screenshotResult.error || 'Unknown error'}`);
                        await this.logCycleEvent('Screenshot Failed', { error: screenshotResult.error });
                    }
                } catch (e) {
                    console.error('[Cycle] Screenshot error:', e);
                    this.addMessage('system', `   ‚ö†Ô∏è Screenshot failed: ${e.message}`);
                    await this.logCycleEvent('Screenshot Error', { error: e.message });
                }
                await this.delay(300);
                
                // Step 2: Run Playwright tests
                this.addMessage('system', '‚Üí Running Playwright tests...');
                try {
                    const testResult = await window.testAgent.runTests(this.currentPreviewFile, { 
                        browser: 'chromium',
                        captureScreenshots: false 
                    });
                    if (testResult.success) {
                        evaluation.testResults = testResult;
                        const passed = testResult.summary?.passed || 0;
                        const failed = testResult.summary?.failed || 0;
                        this.addMessage('system', `   ‚úì Tests: ${passed} passed, ${failed} failed`);
                        await this.logCycleEvent('Tests Completed', { passed, failed });
                    }
                } catch (e) {
                    this.addMessage('system', '   ‚ö†Ô∏è Tests skipped: ' + e.message);
                    await this.logCycleEvent('Tests Skipped', { error: e.message });
                }
                await this.delay(300);
                
                // Step 3: Check console logs
                this.addMessage('system', '‚Üí Checking console logs...');
                try {
                    const interactiveResult = await window.testAgent.runInteractiveTest(this.currentPreviewFile);
                    if (interactiveResult.success) {
                        evaluation.consoleLogs = interactiveResult.consoleErrors || [];
                        const errorCount = evaluation.consoleLogs.length;
                        if (errorCount > 0) {
                            this.addMessage('system', `   ‚ö†Ô∏è ${errorCount} console error(s) found`);
                            await this.logCycleEvent('Console Errors Found', { errorCount, errors: evaluation.consoleLogs.slice(0, 5) });
                        } else {
                            this.addMessage('system', '   ‚úì No console errors');
                            await this.logCycleEvent('Console Check Passed', { errorCount: 0 });
                        }
                        // Store AI analysis
                        if (interactiveResult.aiAnalysis) {
                            evaluation.aiAnalysis = interactiveResult.aiAnalysis;
                        }
                    }
                } catch (e) {
                    this.addMessage('system', '   ‚ö†Ô∏è Console check failed');
                    await this.logCycleEvent('Console Check Failed', { error: e.message });
                }
                await this.delay(300);
                
                // Step 4: Load feedback from file
                this.addMessage('system', '‚Üí Loading user feedback...');
                const feedbackFile = `${this.repoPath}/user-feedback.md`;
                const feedback = await this.loadUserFeedback(feedbackFile);
                
                if (!feedback) {
                    // Create feedback file if it doesn't exist
                    this.addMessage('system', '   ‚Üí Creating user-feedback.md...');
                    await this.createFeedbackFile(feedbackFile);
                    evaluation.feedback = { endUser: [], advocate: [], generated: [] };
                } else {
                    evaluation.feedback = feedback;
                    const totalFeedback = feedback.endUser.length + feedback.advocate.length + feedback.generated.length;
                    const pendingFeedback = [...feedback.endUser, ...feedback.advocate, ...feedback.generated]
                        .filter(f => f.status === 'pending').length;
                    this.addMessage('system', `   ‚úì ${totalFeedback} feedback items (${pendingFeedback} pending)`);
                }
                await this.delay(300);
                
                // Step 5: Generate AI feedback and save to file
                this.addMessage('system', '‚Üí Generating AI feedback...');
                if (evaluation.aiAnalysis) {
                    const aiFeedback = this.parseAIFeedbackForEval(evaluation.aiAnalysis);
                    evaluation.feedback.generated = aiFeedback;
                    this.addMessage('system', `   ‚úì ${aiFeedback.length} AI suggestions generated`);
                    
                    // Add to feedback file
                    await this.addGeneratedFeedback(evaluation.aiAnalysis);
                }
                await this.delay(300);
                
                // Step 6: Review Journey Map alignment
                this.addMessage('system', '‚Üí Reviewing Journey Map alignment...');
                evaluation.journeyMapAnalysis = null;
                try {
                    // Get selected journey map or find one in project
                    const journeyMapSelect = document.getElementById('journeyMapSelect');
                    let journeyMapContent = null;
                    let journeyMapName = null;
                    
                    if (journeyMapSelect && journeyMapSelect.value) {
                        const jm = this.journeyMaps.find(j => j.id === journeyMapSelect.value);
                        if (jm && jm.content) {
                            journeyMapContent = jm.content;
                            journeyMapName = jm.name;
                        }
                    }
                    
                    // Also check for journey-map.md file in project
                    if (!journeyMapContent) {
                        const journeyMapFile = `${this.repoPath}/journey-map.md`;
                        try {
                            const fileContent = await window.aider.readFile(journeyMapFile);
                            if (fileContent) {
                                journeyMapContent = fileContent;
                                journeyMapName = 'journey-map.md';
                            }
                        } catch (e) {
                            // File doesn't exist, that's ok
                        }
                    }
                    
                    if (journeyMapContent && evaluation.screenshot) {
                        this.addMessage('system', `   ‚úì Found: ${journeyMapName}`);
                        
                        // Analyze screenshot against journey map
                        const journeyPrompt = `Analyze this UI screenshot against the following Journey Map. 
                        
Identify:
1. Which journey map steps/flows are visible in the UI
2. Any missing UI elements needed for the journey
3. UX issues that could block user flows
4. Alignment score (0-100) of UI to journey map

Journey Map:
${journeyMapContent}

Respond with a brief analysis.`;

                        const journeyAnalysis = await window.aider.analyzeScreenshot(evaluation.screenshot, journeyPrompt);
                        if (journeyAnalysis.success && journeyAnalysis.analysis) {
                            evaluation.journeyMapAnalysis = {
                                name: journeyMapName,
                                analysis: journeyAnalysis.analysis
                            };
                            this.addMessage('system', `   ‚úì Journey Map alignment analyzed`);
                            await this.logCycleEvent('Journey Map Analyzed', { journeyMap: journeyMapName });
                        }
                    } else if (!journeyMapContent) {
                        this.addMessage('system', '   ‚ö†Ô∏è No Journey Map found - skipping alignment check');
                        this.addMessage('system', '   üí° Select a Journey Map or create journey-map.md');
                        await this.logCycleEvent('Journey Map Not Found', {});
                    } else {
                        this.addMessage('system', '   ‚ö†Ô∏è No screenshot for Journey Map analysis');
                    }
                } catch (e) {
                    console.error('[Cycle] Journey Map analysis error:', e);
                    this.addMessage('system', '   ‚ö†Ô∏è Journey Map analysis failed');
                    await this.logCycleEvent('Journey Map Analysis Failed', { error: e.message });
                }
                await this.delay(300);
                
                // Step 7: Load criteria
                const criteriaFile = `${this.repoPath}/evaluation-criteria.md`;
                let criteria = await this.loadEvaluationCriteria(criteriaFile);
                
                if (!criteria || criteria.length === 0) {
                    this.addMessage('system', '‚Üí No evaluation criteria found');
                    this.showCreateCriteriaUI(criteriaFile);
                    this.cycleState.paused = true;
                    this.cycleState.waitingForCriteria = true;
                    this.cycleState.pendingEvaluation = evaluation;
                    this.updateCycleUI();
                    return;
                }
                
                evaluation.criteria = criteria;
                
                // Step 7: Calculate scores
                this.addMessage('system', '‚Üí Calculating scores...');
                evaluation.scores = this.calculateEvaluationScores(evaluation);
                
                // Store evaluation
                this.cycleState.evaluation = evaluation;
                this.cycleState.evaluationScores = evaluation.scores;
                
                // Show comprehensive results
                this.showComprehensiveEvaluationResults(evaluation);
                
                // Calculate overall score
                const scoreValues = Object.values(evaluation.scores);
                const avgScore = scoreValues.length > 0 
                    ? scoreValues.reduce((a, b) => a + b, 0) / scoreValues.length 
                    : 50;
                this.cycleState.currentScore = Math.round(avgScore);
                this.updateScoreDisplay();
                
                // Log evaluation results
                await this.logCycleEvent('Evaluation Completed', {
                    scores: evaluation.scores,
                    overallScore: this.cycleState.currentScore,
                    testsPassed: evaluation.testResults?.summary?.passed || 0,
                    testsFailed: evaluation.testResults?.summary?.failed || 0,
                    consoleErrors: evaluation.consoleLogs?.length || 0,
                    feedbackItems: (evaluation.feedback?.endUser?.length || 0) + 
                                   (evaluation.feedback?.advocate?.length || 0) + 
                                   (evaluation.feedback?.generated?.length || 0)
                });
                
                this.addMessage('system', `‚îÅ‚îÅ‚îÅ Overall Score: ${this.cycleState.currentScore}% ‚îÅ‚îÅ‚îÅ`);
                await this.delay(500);
                
                await this.runPhase('research');
            },
            
            // Load user feedback from file
            async loadUserFeedback(filePath) {
                try {
                    const content = await window.aider.readFile(filePath);
                    if (!content) return null;
                    
                    const feedback = { endUser: [], advocate: [], generated: [] };
                    let currentBucket = null;
                    
                    const lines = content.split('\n');
                    for (const line of lines) {
                        // Check for bucket headers
                        if (line.includes('## End User Feedback')) currentBucket = 'endUser';
                        else if (line.includes('## Advocate Feedback')) currentBucket = 'advocate';
                        else if (line.includes('## Generated Feedback')) currentBucket = 'generated';
                        
                        // Parse feedback items: - [ ] or - [x] feedback text
                        const match = line.match(/^[\s]*-\s*\[([ x])\]\s*(.+)$/i);
                        if (match && currentBucket) {
                            feedback[currentBucket].push({
                                text: match[2].trim(),
                                status: match[1].toLowerCase() === 'x' ? 'addressed' : 'pending'
                            });
                        }
                    }
                    
                    return feedback;
                } catch (e) {
                    console.log('[Cycle] Load feedback error:', e);
                    return null;
                }
            },
            
            // Create feedback file
            async createFeedbackFile(filePath) {
                const template = `# User Feedback

Track feedback from different sources. Mark items as [x] when addressed.

## End User Feedback
<!-- Feedback from actual end users -->
- [ ] Example: Button text is hard to read

## Advocate Feedback  
<!-- Feedback from internal advocates/testers -->
- [ ] Example: Navigation could be more intuitive

## Generated Feedback
<!-- AI-generated feedback (auto-populated during evaluation) -->
- [ ] Waiting for AI analysis...

---
*Edit this file to add feedback. Items marked [x] are considered addressed.*
`;
                
                try {
                    await this.executeTask(`Create a new file called user-feedback.md with this content:\n\n${template}`);
                } catch (e) {
                    console.log('[Cycle] Create feedback file error:', e);
                }
            },
            
            // Parse AI analysis into feedback items (for Evaluate phase)
            parseAIFeedbackForEval(aiAnalysis) {
                const feedback = [];
                const lines = aiAnalysis.split('\n');
                
                for (const line of lines) {
                    // Look for bullet points or numbered items that suggest improvements
                    const match = line.match(/^[\s]*[-*‚Ä¢]\s*(.+)$/) || line.match(/^\d+\.\s*(.+)$/);
                    if (match) {
                        const text = match[1].trim();
                        // Filter for actionable feedback
                        if (text.length > 10 && text.length < 150 && (
                            text.toLowerCase().includes('should') ||
                            text.toLowerCase().includes('could') ||
                            text.toLowerCase().includes('consider') ||
                            text.toLowerCase().includes('add') ||
                            text.toLowerCase().includes('improve') ||
                            text.toLowerCase().includes('fix') ||
                            text.toLowerCase().includes('issue') ||
                            text.toLowerCase().includes('missing')
                        )) {
                            feedback.push({ text, status: 'pending' });
                        }
                    }
                }
                
                return feedback.slice(0, 10); // Limit to 10 items
            },
            
            // Calculate scores based on all evaluation data
            calculateEvaluationScores(evaluation) {
                const scores = {};
                
                // Test score
                if (evaluation.testResults?.summary) {
                    const passRate = evaluation.testResults.summary.passRate || 0;
                    scores['Functional Tests'] = passRate;
                }
                
                // Console errors score
                const errorCount = evaluation.consoleLogs?.length || 0;
                scores['Console Errors'] = errorCount === 0 ? 100 : Math.max(0, 100 - (errorCount * 20));
                
                // Feedback score (based on pending vs addressed)
                const allFeedback = [
                    ...evaluation.feedback.endUser,
                    ...evaluation.feedback.advocate,
                    ...evaluation.feedback.generated
                ];
                if (allFeedback.length > 0) {
                    const addressed = allFeedback.filter(f => f.status === 'addressed').length;
                    scores['Feedback Addressed'] = Math.round((addressed / allFeedback.length) * 100);
                }
                
                // Criteria scores (from AI analysis)
                if (evaluation.criteria && evaluation.aiAnalysis) {
                    const analysis = evaluation.aiAnalysis.toLowerCase();
                    evaluation.criteria.forEach(criterion => {
                        let score = 70;
                        if (analysis.includes('excellent') || analysis.includes('great')) score = 90;
                        else if (analysis.includes('good')) score = 80;
                        else if (analysis.includes('needs improvement')) score = 60;
                        else if (analysis.includes('poor') || analysis.includes('broken')) score = 40;
                        scores[criterion] = score;
                    });
                }
                
                return scores;
            },
            
            // Show comprehensive evaluation results
            showComprehensiveEvaluationResults(evaluation) {
                // Scores section
                const scoresHtml = Object.entries(evaluation.scores).map(([key, score]) => {
                    const color = score >= 80 ? 'var(--success)' : score >= 60 ? 'var(--warning)' : 'var(--danger)';
                    const icon = score >= 80 ? '‚úì' : score >= 60 ? '‚óã' : '‚úó';
                    return `
                        <div style="display: flex; align-items: center; gap: 8px; padding: 4px 0;">
                            <span style="color: ${color}; width: 14px; font-size: 10px;">${icon}</span>
                            <span style="flex: 1; font-size: 10px;">${key}</span>
                            <span style="font-size: 10px; font-weight: 600; color: ${color};">${score}%</span>
                        </div>
                    `;
                }).join('');
                
                // Pending feedback section
                const pendingFeedback = [
                    ...evaluation.feedback.endUser.filter(f => f.status === 'pending').map(f => ({ ...f, type: 'üë§' })),
                    ...evaluation.feedback.advocate.filter(f => f.status === 'pending').map(f => ({ ...f, type: 'üéØ' })),
                    ...evaluation.feedback.generated.filter(f => f.status === 'pending').map(f => ({ ...f, type: 'ü§ñ' }))
                ].slice(0, 5);
                
                const feedbackHtml = pendingFeedback.length > 0 
                    ? pendingFeedback.map(f => `
                        <div style="display: flex; gap: 6px; padding: 4px 0; font-size: 10px;">
                            <span>${f.type}</span>
                            <span style="color: var(--text-secondary);">${f.text.substring(0, 60)}${f.text.length > 60 ? '...' : ''}</span>
                        </div>
                    `).join('')
                    : '<div style="font-size: 10px; color: var(--text-muted);">No pending feedback</div>';
                
                // Journey Map analysis section
                let journeyMapHtml = '';
                if (evaluation.journeyMapAnalysis) {
                    const analysis = evaluation.journeyMapAnalysis.analysis;
                    const preview = analysis.length > 150 ? analysis.substring(0, 150) + '...' : analysis;
                    journeyMapHtml = `
                        <div style="border-top: 1px solid var(--border); margin-top: 8px; padding-top: 8px;">
                            <div style="font-size: 11px; font-weight: 600; margin-bottom: 6px;">üó∫Ô∏è Journey Map Alignment</div>
                            <div style="font-size: 10px; color: var(--text-secondary);">${preview}</div>
                        </div>
                    `;
                }
                
                const html = `
                    <div style="margin: 8px 0; background: var(--bg-tertiary); padding: 12px; border-radius: 6px;">
                        <div style="font-size: 11px; font-weight: 600; margin-bottom: 8px;">üìä Evaluation Scores</div>
                        ${scoresHtml}
                        <div style="border-top: 1px solid var(--border); margin-top: 8px; padding-top: 8px;">
                            <div style="font-size: 11px; font-weight: 600; margin-bottom: 6px;">üìù Pending Feedback</div>
                            ${feedbackHtml}
                        </div>
                        ${journeyMapHtml}
                    </div>
                `;
                
                this.addMessage('system', html, null, true);
            },
            
            // Load evaluation criteria from file
            async loadEvaluationCriteria(filePath) {
                try {
                    const content = await window.aider.readFile(filePath);
                    if (!content) return null;
                    
                    const lines = content.split('\n');
                    const criteria = [];
                    
                    for (const line of lines) {
                        const match = line.match(/^[\s]*[-*][\s]+(.+)$/) || line.match(/^[\s]*\d+\.[\s]+(.+)$/);
                        if (match) {
                            const text = match[1].trim();
                            if (text && !text.startsWith('#') && !text.startsWith('[')) {
                                criteria.push(text);
                            }
                        }
                    }
                    
                    return criteria;
                } catch (e) {
                    console.log('[Cycle] Load criteria error:', e);
                    return null;
                }
            },
            
            // Show UI to create criteria file
            showCreateCriteriaUI(filePath) {
                const defaultCriteria = [
                    'Visual design is clean and professional',
                    'UI is responsive on different screen sizes',
                    'Navigation is intuitive',
                    'Interactive elements work correctly',
                    'Error states handled gracefully',
                    'Accessibility standards met',
                    'Performance is acceptable',
                    'No console errors'
                ];
                
                const html = `
                    <div style="margin: 12px 0;">
                        <div style="font-size: 11px; color: var(--text-muted); margin-bottom: 8px;">
                            Create evaluation-criteria.md?
                        </div>
                        <div style="display: flex; gap: 8px;">
                            <button onclick="GSXCreate.createDefaultCriteria('${filePath}')" 
                                    style="flex: 1; padding: 8px; background: var(--success); color: #000; border: none; border-radius: 6px; cursor: pointer; font-size: 12px;">
                                ‚úì Create & Continue
                            </button>
                            <button onclick="GSXCreate.skipEvaluation()" 
                                    style="padding: 8px 12px; background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border); border-radius: 6px; cursor: pointer; font-size: 11px;">
                                Skip
                            </button>
                        </div>
                    </div>
                `;
                
                this.addMessage('system', html, null, true);
            },
            
            // Create default criteria file
            async createDefaultCriteria(filePath) {
                const content = `# Evaluation Criteria

## Visual & UX
1. Visual design is clean and professional
2. UI is responsive on different screen sizes
3. Navigation is intuitive
4. Color scheme and typography are consistent

## Functionality
5. Interactive elements work correctly
6. Error states handled gracefully
7. Loading states shown appropriately
8. Forms validate input properly

## Technical
9. Accessibility standards met
10. Performance is acceptable
11. Code is well-organized
12. No console errors

---
*Edit to customize criteria*
`;
                
                try {
                    await this.executeTask(`Create evaluation-criteria.md with:\n\n${content}`);
                    this.addMessage('system', '‚úì Created evaluation-criteria.md');
                    
                    this.cycleState.paused = false;
                    this.cycleState.waitingForCriteria = false;
                    this.updateCycleUI();
                    
                    await this.runPhase('evaluate');
                } catch (e) {
                    this.addMessage('error', 'Failed: ' + e.message);
                }
            },
            
            // Skip evaluation
            skipEvaluation() {
                this.addMessage('system', '‚Üí Skipping evaluation');
                this.cycleState.paused = false;
                this.cycleState.waitingForCriteria = false;
                this.updateCycleUI();
                this.runPhase('research');
            },
            
            // ========== CONSTITUTIONAL MEMORY MANAGEMENT ==========
            
            // Load all constitutional memory files
            async loadConstitutionalMemory() {
                console.log('[Constitutional] Loading constitutional memory...');
                
                try {
                    // Load style guide
                    const styleGuide = await this.loadCycleFile('styleGuide', false);
                    this.constitutionalMemory.styleGuide = styleGuide;
                    
                    // Load journey map
                    const journeyMap = await this.loadCycleFile('journeyMap', false);
                    this.constitutionalMemory.journeyMap = journeyMap;
                    
                    // Load evaluation criteria
                    const criteria = await this.loadCycleFile('evaluationCriteria', false);
                    this.constitutionalMemory.evaluationCriteria = criteria;
                    
                    console.log('[Constitutional] Loaded:', {
                        hasStyleGuide: !!styleGuide,
                        hasJourneyMap: !!journeyMap,
                        hasCriteria: !!criteria
                    });
                    
                    // Update sidebar status display
                    this.updateConstitutionalStatus();
                    
                    return true;
                } catch (error) {
                    console.error('[Constitutional] Load error:', error);
                    return false;
                }
            },
            
            // Summarize constitutional memory for a specific task
            async summarizeConstitutionalMemory(task) {
                console.log('[Constitutional] Summarizing for task:', task);
                
                // Check if we need to re-summarize
                const needsResummarize = !this.constitutionalMemory.currentSummary || 
                                         this.constitutionalMemory.lastTask !== task;
                
                if (!needsResummarize) {
                    console.log('[Constitutional] Using cached summary');
                    return this.constitutionalMemory.currentSummary;
                }
                
                // Ensure constitutional files are loaded
                if (!this.constitutionalMemory.styleGuide && !this.constitutionalMemory.journeyMap) {
                    await this.loadConstitutionalMemory();
                }
                
                // Build context from all constitutional sources
                let constitutionalContext = '';
                
                if (this.constitutionalMemory.styleGuide) {
                    constitutionalContext += '=== STYLE GUIDE ===\n' + this.constitutionalMemory.styleGuide + '\n\n';
                }
                
                if (this.constitutionalMemory.journeyMap) {
                    constitutionalContext += '=== JOURNEY MAP ===\n' + this.constitutionalMemory.journeyMap + '\n\n';
                }
                
                if (this.constitutionalMemory.evaluationCriteria) {
                    constitutionalContext += '=== EVALUATION CRITERIA ===\n' + this.constitutionalMemory.evaluationCriteria + '\n\n';
                }
                
                // If no constitutional data exists, return empty
                if (!constitutionalContext.trim()) {
                    console.log('[Constitutional] No constitutional data found');
                    this.constitutionalMemory.currentSummary = '';
                    return '';
                }
                
                // Generate task-specific summary using AI
                try {
                    const summaryPrompt = `You are summarizing project guidelines for a specific task. 
                    
CURRENT TASK: ${task}

CONSTITUTIONAL MEMORY (project guidelines, standards, and principles):
${constitutionalContext}

Create a BRIEF, FOCUSED summary (max 200 words) that:
1. Extracts ONLY the guidelines relevant to this specific task
2. Prioritizes actionable rules and constraints
3. Highlights any specific patterns or conventions to follow
4. Omits irrelevant sections entirely

Format as a concise bullet list. Start directly with the bullets, no preamble.`;

                    const result = await window.aider.chat(summaryPrompt);
                    
                    if (result.success && result.response) {
                        this.constitutionalMemory.currentSummary = result.response;
                        this.constitutionalMemory.lastTask = task;
                        this.constitutionalMemory.lastSummarizedAt = new Date().toISOString();
                        
                        // Update sidebar status
                        this.updateConstitutionalStatus();
                        
                        console.log('[Constitutional] Summary generated:', result.response.substring(0, 100) + '...');
                        return result.response;
                    }
                } catch (error) {
                    console.error('[Constitutional] Summary generation error:', error);
                }
                
                // Fallback: return truncated raw content
                const fallback = constitutionalContext.substring(0, 500) + '...';
                this.constitutionalMemory.currentSummary = fallback;
                return fallback;
            },
            
            // Get constitutional context for inclusion in prompts
            // Combines: Constitutional Memory (feature reduced) + User's Global Instructions
            getConstitutionalContext() {
                let systemPrompt = '';
                
                // Add Constitutional Memory summary (feature reduced)
                if (this.constitutionalMemory.currentSummary) {
                    systemPrompt += `=== PROJECT GUIDELINES (Constitutional Memory) ===
${this.constitutionalMemory.currentSummary}
=== END GUIDELINES ===

`;
                }
                
                // Append User's Global Instructions
                if (this.globalInstructionsText && this.globalInstructionsText.trim()) {
                    systemPrompt += `=== USER INSTRUCTIONS ===
${this.globalInstructionsText}
=== END USER INSTRUCTIONS ===

`;
                }
                
                return systemPrompt;
            },
            
            // Force refresh of constitutional memory
            async refreshConstitutionalMemory() {
                this.constitutionalMemory.currentSummary = null;
                this.constitutionalMemory.lastTask = null;
                await this.loadConstitutionalMemory();
                this.updateConstitutionalStatus();
                this.addMessage('system', 'üèõÔ∏è Constitutional memory refreshed');
            },
            
            // Log the dynamic system prompt for debugging/transparency
            async logDynamicSystemPrompt(task, systemPrompt) {
                // Log to console
                console.log('[Constitutional] Dynamic System Prompt for task:', task);
                console.log('[Constitutional] System Prompt Content:\n', systemPrompt);
                
                // Log to cycle events (Episodic Memory)
                await this.logCycleEvent('Dynamic System Prompt Generated', {
                    task: task,
                    promptLength: systemPrompt.length,
                    hasConstitutional: systemPrompt.includes('PROJECT GUIDELINES'),
                    hasUserInstructions: systemPrompt.includes('USER INSTRUCTIONS'),
                    preview: systemPrompt.substring(0, 300) + (systemPrompt.length > 300 ? '...' : '')
                });
                
                // Show collapsible preview in chat
                if (systemPrompt.trim()) {
                    const previewHtml = `
                        <details style="margin: 4px 0; font-size: 11px;">
                            <summary style="cursor: pointer; color: var(--text-muted);">
                                üìã Dynamic System Prompt (${systemPrompt.length} chars) - click to expand
                            </summary>
                            <pre style="margin: 8px 0; padding: 8px; background: var(--bg-tertiary); border-radius: 4px; font-size: 10px; white-space: pre-wrap; max-height: 200px; overflow-y: auto;">${this.escapeHtml(systemPrompt)}</pre>
                        </details>
                    `;
                    this.addMessage('system', previewHtml, null, true);
                }
            },
            
            // Escape HTML for safe display
            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            },
            
            // Update Constitutional Memory status display in sidebar
            updateConstitutionalStatus() {
                // Update file status indicators
                const styleStatus = document.getElementById('styleGuideStatus');
                const journeyStatus = document.getElementById('journeyMapStatus');
                const criteriaStatus = document.getElementById('criteriaStatus');
                const summaryStatus = document.getElementById('summaryStatus');
                
                if (styleStatus) {
                    styleStatus.textContent = this.constitutionalMemory.styleGuide ? '‚óè' : '‚óã';
                    styleStatus.style.color = this.constitutionalMemory.styleGuide ? 'var(--success)' : 'var(--text-muted)';
                }
                
                if (journeyStatus) {
                    journeyStatus.textContent = this.constitutionalMemory.journeyMap ? '‚óè' : '‚óã';
                    journeyStatus.style.color = this.constitutionalMemory.journeyMap ? 'var(--success)' : 'var(--text-muted)';
                }
                
                if (criteriaStatus) {
                    criteriaStatus.textContent = this.constitutionalMemory.evaluationCriteria ? '‚óè' : '‚óã';
                    criteriaStatus.style.color = this.constitutionalMemory.evaluationCriteria ? 'var(--success)' : 'var(--text-muted)';
                }
                
                if (summaryStatus) {
                    if (this.constitutionalMemory.currentSummary) {
                        const task = this.constitutionalMemory.lastTask || 'general';
                        const time = this.constitutionalMemory.lastSummarizedAt 
                            ? new Date(this.constitutionalMemory.lastSummarizedAt).toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'})
                            : '';
                        summaryStatus.innerHTML = `<span style="color: var(--success);">‚úì</span> Summary ready<br><span style="font-size: 9px;">Task: ${task.substring(0, 30)}${task.length > 30 ? '...' : ''}</span>`;
                    } else {
                        summaryStatus.textContent = 'No summary loaded';
                    }
                }
            },
            
            // ========== CYCLE FILE MANAGEMENT ==========
            
            // Get versioned file path
            getCycleFilePath(fileKey) {
                const version = this.cycleState.currentVersion;
                const template = this.cycleState.files[fileKey];
                if (!template) return null;
                return `${this.repoPath}/${template.replace('{version}', version)}`;
            },
            
            // Get non-versioned file path (persistent across cycles)
            getPersistentFilePath(fileKey) {
                const template = this.cycleState.files[fileKey];
                if (!template) return null;
                // Remove version placeholder for persistent files
                return `${this.repoPath}/${template.replace('-v{version}', '')}`;
            },
            
            // Load a cycle file
            async loadCycleFile(fileKey, versioned = true) {
                const filePath = versioned ? this.getCycleFilePath(fileKey) : this.getPersistentFilePath(fileKey);
                try {
                    const content = await window.aider.readFile(filePath);
                    return content || null;
                } catch (e) {
                    return null;
                }
            },
            
            // Save a cycle file via Aider
            async saveCycleFile(fileKey, content, versioned = true) {
                const filePath = versioned ? this.getCycleFilePath(fileKey) : this.getPersistentFilePath(fileKey);
                const fileName = filePath.split('/').pop();
                try {
                    await this.executeTask(`Update ${fileName} with this content:\n\n${content}`);
                    return true;
                } catch (e) {
                    console.log(`[Cycle] Save ${fileKey} error:`, e);
                    return false;
                }
            },
            
            // Update user feedback file - mark items as addressed
            async updateFeedbackFile(addressedItems = []) {
                const filePath = this.getPersistentFilePath('userFeedback');
                let content = await this.loadCycleFile('userFeedback', false);
                
                if (!content) {
                    // Create initial feedback file
                    content = this.generateFeedbackTemplate();
                }
                
                // Mark addressed items
                for (const item of addressedItems) {
                    // Replace [ ] with [x] for matching items
                    const escapedItem = item.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    const regex = new RegExp(`- \\[ \\] ${escapedItem}`, 'gi');
                    content = content.replace(regex, `- [x] ${item}`);
                }
                
                await this.saveCycleFile('userFeedback', content, false);
            },
            
            // Generate feedback file template
            generateFeedbackTemplate() {
                const version = this.cycleState.currentVersion;
                return `# User Feedback
*Last updated: v${version} - ${new Date().toLocaleDateString()}*

## End User Feedback
<!-- Feedback from actual end users -->
- [ ] No end user feedback yet

## Advocate Feedback
<!-- Feedback from internal advocates/testers -->
- [ ] No advocate feedback yet

## Generated Feedback (AI)
<!-- AI-generated feedback from evaluation -->
- [ ] Waiting for AI evaluation...

---
**Legend:** [ ] = Pending, [x] = Addressed
`;
            },
            
            // Generate style guide template
            generateStyleGuideTemplate() {
                return `# Style Guide
*Version: ${this.cycleState.currentVersion}*

## Colors
- Primary: #4A90E2
- Secondary: #2C3E50
- Background: #1a1a2e
- Text: #E8E8E8

## Typography
- Headings: System UI, -apple-system
- Body: 14px, line-height 1.5

## Components
- Buttons: Rounded corners, hover states
- Cards: Subtle shadows, consistent padding
- Forms: Clear labels, validation states

## Spacing
- Base unit: 8px
- Sections: 24px gap
- Components: 16px gap

---
*Update this guide as the design evolves*
`;
            },
            
            // Generate journey map template
            generateJourneyMapTemplate() {
                return `# User Journey Map
*Version: ${this.cycleState.currentVersion}*

## Primary User Flow

### 1. Entry
- User lands on the page
- First impression: [describe]

### 2. Discovery
- User explores features
- Key actions: [list]

### 3. Engagement
- User interacts with core features
- Pain points: [identify]

### 4. Completion
- User achieves goal
- Exit points: [describe]

## Pain Points
- [ ] None identified yet

## Opportunities
- [ ] None identified yet

---
*Update after each cycle based on testing*
`;
            },
            
            // Generate research notes template
            generateResearchTemplate(objective, feedback) {
                const version = this.cycleState.currentVersion;
                const feedbackList = feedback.length > 0 
                    ? feedback.map(f => `- ${f.text}`).join('\n')
                    : '- No pending feedback';
                    
                return `# Research Notes - v${version}
*Date: ${new Date().toLocaleDateString()}*
*Objective: ${objective}*

## Feedback to Address
${feedbackList}

## Research Findings
<!-- AI will populate this section -->

## Proposed Solutions
<!-- AI will populate this section -->

## Resources
<!-- Links and references -->

## Next Steps
<!-- Action items for Plan phase -->

---
*This file is auto-generated and updated by the Research phase*
`;
            },
            
            // Generate test results template
            generateTestResultsTemplate(results) {
                const version = this.cycleState.currentVersion;
                return `# Test Results - v${version}
*Date: ${new Date().toLocaleDateString()}*

## Summary
- Total Tests: ${results.total || 0}
- Passed: ${results.passed || 0}
- Failed: ${results.failed || 0}
- Score: ${results.score || 0}%

## Console Errors
${results.consoleErrors?.length > 0 
    ? results.consoleErrors.map(e => `- ‚ùå ${e}`).join('\n')
    : '- ‚úì No console errors'}

## Failed Tests
${results.failedTests?.length > 0
    ? results.failedTests.map(t => `- ‚ùå ${t}`).join('\n')
    : '- ‚úì All tests passed'}

## AI Analysis
${results.aiAnalysis || 'No AI analysis available'}

---
*Auto-generated by Test phase*
`;
            },
            
            // Update TODO file with completion status
            async updateTodoFile(completedTasks = []) {
                const filePath = this.getCycleFilePath('todoList');
                let content = await this.loadCycleFile('todoList', true);
                
                if (!content) return;
                
                // Mark completed tasks
                for (const task of completedTasks) {
                    const escapedTask = task.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    const regex = new RegExp(`- \\[ \\] ${escapedTask}`, 'gi');
                    content = content.replace(regex, `- [x] ${task}`);
                }
                
                await this.saveCycleFile('todoList', content, true);
            },
            
            // Update cycle files with completed work
            async updateCycleFiles() {
                const version = this.cycleState.currentVersion;
                
                // Get completed todos
                const completedTasks = (this.cycleState.todos || [])
                    .filter(t => t.completed)
                    .map(t => t.task);
                
                if (completedTasks.length > 0) {
                    this.addMessage('system', `‚Üí Updating TODO file...`);
                    await this.updateTodoFileWithCompleted(completedTasks);
                }
                
                // Update feedback file - mark addressed items
                const addressedFeedback = (this.cycleState.pendingFeedback || [])
                    .filter(f => completedTasks.some(t => 
                        t.toLowerCase().includes(f.text.toLowerCase().substring(0, 20))
                    ))
                    .map(f => f.text);
                
                if (addressedFeedback.length > 0) {
                    this.addMessage('system', `‚Üí Updating feedback file (${addressedFeedback.length} addressed)...`);
                    await this.updateFeedbackFile(addressedFeedback);
                }
                
                // Add AI-generated feedback from this cycle
                if (this.lastVisualAnalysis) {
                    await this.addGeneratedFeedback(this.lastVisualAnalysis);
                }
            },
            
            // Update TODO file with completed tasks
            async updateTodoFileWithCompleted(completedTasks) {
                const filePath = this.getCycleFilePath('todoList');
                let content = await this.loadCycleFile('todoList', true);
                
                if (!content) return;
                
                for (const task of completedTasks) {
                    // Escape special regex characters
                    const escapedTask = task.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    // Match the task with checkbox
                    const regex = new RegExp(`- \\[ \\] ${escapedTask}`, 'gi');
                    content = content.replace(regex, `- [x] ${task}`);
                }
                
                await this.saveCycleFile('todoList', content, true);
            },
            
            // Add AI-generated feedback to feedback file
            async addGeneratedFeedback(aiAnalysis) {
                const filePath = this.getPersistentFilePath('userFeedback');
                let content = await this.loadCycleFile('userFeedback', false);
                
                if (!content) return;
                
                // Parse new feedback items from AI analysis
                const newFeedback = this.parseAIFeedback(aiAnalysis);
                if (newFeedback.length === 0) return;
                
                // Find the Generated Feedback section
                const generatedSection = content.indexOf('## Generated Feedback');
                if (generatedSection === -1) return;
                
                // Find the next section or end
                const nextSection = content.indexOf('##', generatedSection + 20);
                const endPos = nextSection > -1 ? nextSection : content.indexOf('---', generatedSection);
                
                // Build new feedback items
                const newItems = newFeedback
                    .slice(0, 5) // Limit to 5 new items
                    .map(f => `- [ ] ${f.text}`)
                    .join('\n');
                
                // Insert after the section header
                const insertPos = content.indexOf('\n', generatedSection) + 1;
                const beforeInsert = content.substring(0, insertPos);
                const afterInsert = content.substring(insertPos);
                
                // Check if we need to add (avoid duplicates)
                if (!content.includes(newFeedback[0]?.text?.substring(0, 30))) {
                    content = beforeInsert + newItems + '\n' + afterInsert;
                    await this.saveCycleFile('userFeedback', content, false);
                    this.addMessage('system', `   ‚úì Added ${newFeedback.length} AI suggestions to feedback`);
                }
            },
            
            // Parse AI feedback (helper)
            parseAIFeedback(aiAnalysis) {
                const feedback = [];
                const lines = aiAnalysis.split('\n');
                
                for (const line of lines) {
                    const match = line.match(/^[\s]*[-*‚Ä¢]\s*(.+)$/) || line.match(/^\d+\.\s*(.+)$/);
                    if (match) {
                        const text = match[1].trim();
                        if (text.length > 10 && text.length < 100 && (
                            text.toLowerCase().includes('should') ||
                            text.toLowerCase().includes('could') ||
                            text.toLowerCase().includes('consider') ||
                            text.toLowerCase().includes('add') ||
                            text.toLowerCase().includes('improve') ||
                            text.toLowerCase().includes('fix') ||
                            text.toLowerCase().includes('missing')
                        )) {
                            feedback.push({ text, status: 'pending' });
                        }
                    }
                }
                
                return feedback.slice(0, 10);
            },
            
            // Finalize cycle - update all persistent files with current version
            async finalizeCycle() {
                const version = this.cycleState.currentVersion;
                const score = this.cycleState.currentScore;
                const date = new Date().toLocaleDateString();
                const timestamp = new Date().toISOString();
                
                this.addMessage('system', `‚Üí Finalizing v${version} files...`);
                
                // Update style guide with version
                let styleGuide = await this.loadCycleFile('styleGuide', false);
                if (styleGuide) {
                    styleGuide = styleGuide.replace(/\*Version: \d+\*/, `*Version: ${version}*`);
                    await this.saveCycleFile('styleGuide', styleGuide, false);
                }
                
                // Update journey map with version
                let journeyMap = await this.loadCycleFile('journeyMap', false);
                if (journeyMap) {
                    journeyMap = journeyMap.replace(/\*Version: \d+\*/, `*Version: ${version}*`);
                    await this.saveCycleFile('journeyMap', journeyMap, false);
                }
                
                // Update feedback file timestamp
                let feedback = await this.loadCycleFile('userFeedback', false);
                if (feedback) {
                    feedback = feedback.replace(
                        /\*Last updated:.*\*/,
                        `*Last updated: v${version} - ${date}*`
                    );
                    await this.saveCycleFile('userFeedback', feedback, false);
                }
                
                this.addMessage('system', `   ‚úì Files updated to v${version}`);
                
                // Generate Release Notes
                this.addMessage('system', `‚Üí Generating release notes...`);
                await this.generateReleaseNotes(version, score);
                
                // Update README/Documentation
                this.addMessage('system', `‚Üí Updating documentation...`);
                await this.updateDocumentation(version, score);
            },
            
            // Generate release notes for a version
            async generateReleaseNotes(version, score) {
                const date = new Date().toLocaleDateString();
                const timestamp = new Date().toISOString();
                const releaseNotesPath = `${this.repoPath}/RELEASE-NOTES.md`;
                
                // Gather information for release notes
                const objective = this.cycleState.objective || 'No objective specified';
                const completedTodos = this.cycleState.todos.filter(t => t.status === 'completed');
                const versions = this.cycleState.versions || [];
                
                // Build the release entry
                let releaseEntry = `
## v${version} - ${date}

**Score:** ${score}%  
**Objective:** ${objective}

### Changes
${completedTodos.length > 0 
    ? completedTodos.map(t => `- ‚úì ${t.text || t.description || 'Task completed'}`).join('\n')
    : '- Initial release'}

### Files Modified
${this.projectFiles.slice(0, 10).map(f => `- \`${f.name}\``).join('\n')}

### Quality Metrics
- Evaluation Score: ${score}%
- Target Score: ${this.cycleState.targetScore}%
- Iterations: ${version}

---
`;

                try {
                    // Read existing release notes or create new
                    let existingNotes = '';
                    try {
                        existingNotes = await window.aider.readFile(releaseNotesPath);
                    } catch (e) {
                        // File doesn't exist yet
                    }
                    
                    if (existingNotes) {
                        // Prepend new release after the header
                        const headerMatch = existingNotes.match(/^#[^\n]+\n/);
                        if (headerMatch) {
                            existingNotes = headerMatch[0] + releaseEntry + existingNotes.substring(headerMatch[0].length);
                        } else {
                            existingNotes = `# Release Notes\n${releaseEntry}\n${existingNotes}`;
                        }
                    } else {
                        existingNotes = `# Release Notes

*Auto-generated by GSX Create Meta Learning Cycle*

${releaseEntry}`;
                    }
                    
                    await window.aider.writeFile(releaseNotesPath, existingNotes);
                    this.addMessage('system', `   ‚úì Release notes created: RELEASE-NOTES.md`);
                } catch (error) {
                    console.error('[Cycle] Release notes error:', error);
                    this.addMessage('system', `   ‚ö†Ô∏è Could not create release notes`);
                }
            },
            
            // Update project documentation
            async updateDocumentation(version, score) {
                const readmePath = `${this.repoPath}/README.md`;
                const date = new Date().toLocaleDateString();
                
                try {
                    let readme = '';
                    try {
                        readme = await window.aider.readFile(readmePath);
                    } catch (e) {
                        // File doesn't exist
                    }
                    
                    // Create or update version badge section
                    const versionBadge = `**Version:** v${version} | **Score:** ${score}% | **Updated:** ${date}`;
                    
                    if (readme) {
                        // Update existing version info
                        if (readme.includes('**Version:**')) {
                            readme = readme.replace(/\*\*Version:\*\*[^\n]+/, versionBadge);
                        } else {
                            // Add version after first heading
                            const firstHeadingEnd = readme.indexOf('\n');
                            if (firstHeadingEnd > 0) {
                                readme = readme.substring(0, firstHeadingEnd + 1) + 
                                         `\n${versionBadge}\n` + 
                                         readme.substring(firstHeadingEnd + 1);
                            }
                        }
                        
                        // Update or add changelog section
                        const changelogEntry = `\n### v${version} (${date})\n- ${this.cycleState.objective || 'Updates and improvements'}\n`;
                        
                        if (readme.includes('## Changelog') || readme.includes('## Version History')) {
                            // Add to existing changelog
                            readme = readme.replace(
                                /(## Changelog|## Version History)\n/,
                                `$1\n${changelogEntry}`
                            );
                        } else {
                            // Add changelog section at the end
                            readme += `\n\n## Changelog\n${changelogEntry}`;
                        }
                        
                        await window.aider.writeFile(readmePath, readme);
                        this.addMessage('system', `   ‚úì README.md updated`);
                    } else {
                        // Create a basic README
                        const projectName = this.currentSpaceName || 'Project';
                        const newReadme = `# ${projectName}

${versionBadge}

## Overview

${this.cycleState.objective || 'A project created with GSX Create.'}

## Getting Started

1. Open the main HTML file in your browser
2. Or run a local server in this directory

## Files

${this.projectFiles.slice(0, 10).map(f => `- \`${f.name}\` - ${f.type || 'file'}`).join('\n')}

## Changelog

### v${version} (${date})
- Initial release
- ${this.cycleState.objective || 'Project setup complete'}

---

*Generated by GSX Create Meta Learning Cycle*
`;
                        await window.aider.writeFile(readmePath, newReadme);
                        this.addMessage('system', `   ‚úì README.md created`);
                    }
                } catch (error) {
                    console.error('[Cycle] Documentation update error:', error);
                    this.addMessage('system', `   ‚ö†Ô∏è Could not update documentation`);
                }
            },
            
            // ========== END CYCLE FILE MANAGEMENT ==========
            
            // Research Phase - Define objective and analyze requirements
            async phaseResearch() {
                // Check required files for this phase
                var filesReady = await this.checkPhaseRequiredFiles('research');
                if (!filesReady) {
                    await this.waitForFileApproval();
                }
                
                // Always ask for objective if not set
                if (!this.cycleState.objective) {
                    // Pause and ask for objective
                    this.addMessage('system', '‚Üí Waiting for objective...');
                    this.addMessage('system', '   Type your goal and press Send');
                    this.cycleState.paused = true;
                    this.cycleState.waitingForObjective = true;
                    await this.logCycleEvent('Waiting for Objective', {});
                    this.updateCycleUI();
                    return;
                }
                
                // Display the objective
                this.addMessage('system', `‚Üí Objective: "${this.cycleState.objective}"`);
                await this.logCycleEvent('Objective Set', { objective: this.cycleState.objective });
                await this.delay(300);
                
                // Step 1: Load pending feedback from user-feedback.md
                this.addMessage('system', `‚Üí Loading pending feedback...`);
                const feedbackContent = await this.loadCycleFile('userFeedback', false);
                const pendingFeedback = this.parsePendingFeedback(feedbackContent);
                
                if (pendingFeedback.length > 0) {
                    this.addMessage('system', `   ‚úì ${pendingFeedback.length} pending items found`);
                    this.cycleState.pendingFeedback = pendingFeedback;
                } else {
                    this.addMessage('system', `   ‚Üí No pending feedback`);
                    this.cycleState.pendingFeedback = [];
                }
                await this.delay(300);
                
                // Step 2: Analyze current state
                if (this.currentPreviewFile) {
                    const fileName = this.currentPreviewFile.split('/').pop();
                    this.addMessage('system', `‚Üí Analyzing ${fileName}...`);
                    
                    try {
                        const result = await window.testAgent.runInteractiveTest(this.currentPreviewFile);
                        if (result.success && result.aiAnalysis) {
                            this.lastVisualAnalysis = result.aiAnalysis;
                            this.addMessage('system', `   ‚úì AI analysis complete`);
                        }
                    } catch (e) {
                        this.addMessage('system', `   ‚ö†Ô∏è Analysis skipped`);
                    }
                }
                await this.delay(300);
                
                // Step 3: Generate research notes
                this.addMessage('system', `‚Üí Creating research notes...`);
                const researchContent = await this.generateResearchNotes();
                await this.saveCycleFile('researchNotes', researchContent, true);
                this.addMessage('system', `   ‚úì research-notes-v${this.cycleState.currentVersion}.md created`);
                await this.delay(300);
                
                // Ensure persistent files exist
                await this.ensurePersistentFiles();
                
                await this.runPhase('plan');
            },
            
            // Parse pending feedback items from feedback file
            parsePendingFeedback(content) {
                if (!content) return [];
                const pending = [];
                const lines = content.split('\n');
                let currentBucket = '';
                
                for (const line of lines) {
                    if (line.includes('## End User')) currentBucket = 'endUser';
                    else if (line.includes('## Advocate')) currentBucket = 'advocate';
                    else if (line.includes('## Generated')) currentBucket = 'generated';
                    
                    // Match unchecked items: - [ ] text
                    const match = line.match(/^[\s]*-\s*\[ \]\s*(.+)$/);
                    if (match && currentBucket) {
                        const text = match[1].trim();
                        if (text && !text.includes('No ') && !text.includes('Waiting for')) {
                            pending.push({ text, bucket: currentBucket });
                        }
                    }
                }
                
                return pending;
            },
            
            // Generate research notes with AI
            async generateResearchNotes() {
                const version = this.cycleState.currentVersion;
                const objective = this.cycleState.objective;
                const feedback = this.cycleState.pendingFeedback || [];
                const analysis = this.lastVisualAnalysis || '';
                
                // Create base template
                let notes = `# Research Notes - v${version}
*Date: ${new Date().toLocaleDateString()}*
*Objective: ${objective}*

## Pending Feedback to Address
${feedback.length > 0 
    ? feedback.map(f => `- [${f.bucket}] ${f.text}`).join('\n')
    : '- No pending feedback'}

## Current State Analysis
${analysis ? analysis.substring(0, 500) + '...' : 'No visual analysis available'}

## Research Findings
*To be populated by AI research...*

## Proposed Approach
Based on the objective and feedback, the recommended approach is:
1. Address pending feedback items first
2. Implement the main objective
3. Validate changes against evaluation criteria

## Files to Modify
- ${this.currentPreviewFile ? this.currentPreviewFile.split('/').pop() : 'TBD'}

---
*Auto-generated by Research phase*
`;
                
                return notes;
            },
            
            // Ensure persistent files exist (style guide, journey map, feedback)
            async ensurePersistentFiles() {
                // Check style guide
                const styleGuide = await this.loadCycleFile('styleGuide', false);
                if (!styleGuide) {
                    this.addMessage('system', `‚Üí Creating style-guide.md...`);
                    await this.saveCycleFile('styleGuide', this.generateStyleGuideTemplate(), false);
                }
                
                // Check journey map
                const journeyMap = await this.loadCycleFile('journeyMap', false);
                if (!journeyMap) {
                    this.addMessage('system', `‚Üí Creating journey-map.md...`);
                    await this.saveCycleFile('journeyMap', this.generateJourneyMapTemplate(), false);
                }
                
                // Check feedback file
                const feedback = await this.loadCycleFile('userFeedback', false);
                if (!feedback) {
                    this.addMessage('system', `‚Üí Creating user-feedback.md...`);
                    await this.saveCycleFile('userFeedback', this.generateFeedbackTemplate(), false);
                }
            },
            
            // Helper for delays
            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            },
            
            // Find main HTML file in project
            async findMainHtmlFile() {
                // If main file is already set, use it
                if (this.mainFile) {
                    console.log('[Cycle] Using configured main file:', this.mainFile);
                    return this.mainFile;
                }
                
                // Refresh project files first to ensure we have latest
                if (this.repoPath) {
                    try {
                        await this.loadProjectFiles();
                    } catch (e) {
                        console.log('[Cycle] Could not refresh project files:', e);
                    }
                }
                
                // Get files array - handle both array and object formats
                var files = [];
                if (Array.isArray(this.projectFiles)) {
                    files = this.projectFiles.filter(f => !f.isDirectory).map(f => f.path);
                } else if (this.projectFiles && this.projectFiles.files) {
                    files = this.projectFiles.files;
                }
                
                if (files.length === 0) {
                    console.log('[Cycle] No project files available');
                    return null;
                }
                
                console.log('[Cycle] Looking for HTML file in:', files);
                
                // Priority order for main files
                const priorities = ['index.html', 'main.html', 'app.html', 'home.html', 'calendar.html'];
                
                // First, check for priority files
                for (const priority of priorities) {
                    const found = files.find(f => {
                        const fileName = (f.path || f).split('/').pop().toLowerCase();
                        return fileName === priority;
                    });
                    if (found) {
                        const filePath = found.path || found;
                        console.log('[Cycle] Found priority HTML file:', filePath);
                        this.mainFile = filePath; // Save for future use
                        return filePath;
                    }
                }
                
                // Then, find any HTML file
                const htmlFile = files.find(f => {
                    const path = f.path || f;
                    return path.toLowerCase().endsWith('.html') || path.toLowerCase().endsWith('.htm');
                });
                if (htmlFile) {
                    const filePath = htmlFile.path || htmlFile;
                    console.log('[Cycle] Found HTML file:', filePath);
                    this.mainFile = filePath; // Save for future use
                    return filePath;
                }
                
                console.log('[Cycle] No HTML file found');
                return null;
            },
            
            // Plan Phase - Generate tasks and show checkboxes for user approval
            async phasePlan() {
                // Check required files for this phase
                var filesReady = await this.checkPhaseRequiredFiles('plan');
                if (!filesReady) {
                    await this.waitForFileApproval();
                }
                
                if (!this.cycleState.objective) {
                    this.addMessage('error', 'No objective set. Cannot create plan.');
                    await this.logCycleEvent('Plan Skipped - No Objective', {});
                    await this.runPhase('execute');
                    return;
                }
                
                this.addMessage('system', `‚Üí Generating task breakdown...`);
                
                // Generate tasks using AI
                const tasks = await this.generateTaskBreakdown();
                
                if (tasks.length === 0) {
                    // Fallback to single task
                    tasks.push({ task: this.cycleState.objective, approved: true });
                }
                
                // Store tasks
                this.cycleState.proposedTasks = tasks;
                await this.logCycleEvent('Tasks Generated', { taskCount: tasks.length, tasks: tasks.map(t => t.task) });
                
                // Show tasks with checkboxes
                this.showTaskApprovalUI(tasks);
                
                // Pause and wait for user to approve
                this.cycleState.paused = true;
                this.cycleState.waitingForApproval = true;
                await this.logCycleEvent('Waiting for Task Approval', { taskCount: tasks.length });
                this.updateCycleUI();
            },
            
            // Generate task breakdown from objective
            async generateTaskBreakdown() {
                const objective = this.cycleState.objective;
                const tasks = [];
                
                // Simple breakdown - split by common patterns or use AI
                // For now, create logical subtasks based on objective
                const keywords = objective.toLowerCase();
                
                if (keywords.includes(' and ')) {
                    // Split by "and"
                    const parts = objective.split(/ and /i);
                    parts.forEach(p => tasks.push({ task: p.trim(), approved: true }));
                } else if (keywords.includes(',')) {
                    // Split by comma
                    const parts = objective.split(',');
                    parts.forEach(p => tasks.push({ task: p.trim(), approved: true }));
                } else {
                    // Single task with common subtasks
                    tasks.push({ task: `Analyze current code for: ${objective}`, approved: true });
                    tasks.push({ task: `Implement: ${objective}`, approved: true });
                    tasks.push({ task: `Add error handling and edge cases`, approved: true });
                    tasks.push({ task: `Update styles if needed`, approved: false });
                    tasks.push({ task: `Add comments and documentation`, approved: false });
                }
                
                return tasks;
            },
            
            // Show task approval UI with checkboxes
            showTaskApprovalUI(tasks) {
                const taskListHtml = tasks.map((t, i) => `
                    <div style="display: flex; align-items: center; gap: 8px; padding: 8px; background: var(--bg-tertiary); border-radius: 6px; margin: 4px 0;">
                        <input type="checkbox" id="task-${i}" ${t.approved ? 'checked' : ''} 
                               onchange="GSXCreate.toggleTaskApproval(${i})"
                               style="width: 16px; height: 16px; cursor: pointer;">
                        <label for="task-${i}" style="flex: 1; cursor: pointer; font-size: 12px;">${t.task}</label>
                    </div>
                `).join('');
                
                const approvalHtml = `
                    <div style="margin: 12px 0;">
                        <div style="font-size: 11px; color: var(--text-muted); margin-bottom: 8px;">
                            Select tasks to execute:
                        </div>
                        ${taskListHtml}
                        <div style="display: flex; gap: 8px; margin-top: 12px;">
                            <button onclick="GSXCreate.approveSelectedTasks()" 
                                    style="flex: 1; padding: 8px; background: var(--success); color: #000; border: none; border-radius: 6px; cursor: pointer; font-size: 12px;">
                                ‚úì Approve & Execute
                            </button>
                            <button onclick="GSXCreate.selectAllTasks(true)" 
                                    style="padding: 8px 12px; background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border); border-radius: 6px; cursor: pointer; font-size: 11px;">
                                All
                            </button>
                            <button onclick="GSXCreate.selectAllTasks(false)" 
                                    style="padding: 8px 12px; background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border); border-radius: 6px; cursor: pointer; font-size: 11px;">
                                None
                            </button>
                        </div>
                    </div>
                `;
                
                this.addMessage('system', approvalHtml, null, true);
            },
            
            // Toggle task approval
            toggleTaskApproval(index) {
                if (this.cycleState.proposedTasks && this.cycleState.proposedTasks[index]) {
                    this.cycleState.proposedTasks[index].approved = !this.cycleState.proposedTasks[index].approved;
                }
            },
            
            // Select/deselect all tasks
            selectAllTasks(select) {
                if (this.cycleState.proposedTasks) {
                    this.cycleState.proposedTasks.forEach((t, i) => {
                        t.approved = select;
                        const checkbox = document.getElementById(`task-${i}`);
                        if (checkbox) checkbox.checked = select;
                    });
                }
            },
            
            // Approve selected tasks and continue
            approveSelectedTasks() {
                const approvedTasks = this.cycleState.proposedTasks.filter(t => t.approved);
                
                if (approvedTasks.length === 0) {
                    this.addMessage('error', 'Please select at least one task');
                    return;
                }
                
                // Convert to todos
                this.cycleState.todos = approvedTasks.map(t => ({
                    task: t.task,
                    status: 'pending',
                    created: new Date().toISOString()
                }));
                
                // Sync to Episodic Memory Plan tab
                this.syncCycleTodosToEpisodicMemory();
                
                this.addMessage('system', `‚úì ${approvedTasks.length} task(s) approved`);
                
                // Resume cycle
                this.cycleState.paused = false;
                this.cycleState.waitingForApproval = false;
                this.updateCycleUI();
                
                // Continue to execute
                this.runPhase('execute');
            },
            
            // Sync cycle todos to Episodic Memory Plan tab
            syncCycleTodosToEpisodicMemory() {
                // Add cycle tasks to the sidebar todo list
                const cycleTasks = this.cycleState.todos || [];
                
                // Merge with existing todos (avoid duplicates)
                cycleTasks.forEach(ct => {
                    const exists = this.todos.some(t => t.text === ct.task);
                    if (!exists) {
                        this.todos.unshift({
                            id: Date.now() + Math.random(),
                            text: ct.task,
                            done: ct.status === 'completed',
                            created: ct.created,
                            fromCycle: true // Mark as from meta learning cycle
                        });
                    }
                });
                
                this.saveTodos();
                this.renderTodos();
                
                // Switch to Plan tab to show the new tasks
                this.switchEpisodicTab('plan');
            },
            
            // Placeholder for future AI-based todo generation
            async generateTodosLegacy() {
                // This was causing issues because Aider executes code when given prompts
                // For now, we use the objective directly as a single task
                return [{
                    task: this.cycleState.objective,
                    status: 'pending',
                    created: new Date().toISOString()
                }];
            },
            
            // Save todos to a file in the space
            async saveTodoFile(todos) {
                if (!this.repoPath) return;
                
                const version = this.cycleState.currentVersion;
                const timestamp = new Date().toISOString().split('T')[0];
                const fileName = `TODO-v${version}.md`;
                const filePath = `${this.repoPath}/${fileName}`;
                
                // Format as markdown
                let content = `# Todo List - v${version}\n`;
                content += `**Objective:** ${this.cycleState.objective}\n`;
                content += `**Created:** ${timestamp}\n\n`;
                content += `## Tasks\n\n`;
                
                todos.forEach((t, i) => {
                    const checkbox = t.status === 'completed' ? '[x]' : '[ ]';
                    content += `${i + 1}. ${checkbox} ${t.task}\n`;
                });
                
                content += '\n---\n*Generated by GSX Create Meta Learning*\n';
                
                try {
                    // Use Aider to create the file
                    await window.aider.runPrompt(`Create a new file called ${fileName} with this exact content:\n\n${content}`);
                    this.addMessage('system', `üíæ Saved: ${fileName}`);
                } catch (e) {
                    console.log('[Cycle] Save todo file error:', e);
                }
            },
            
            // Execute Phase - Work through todos one by one (fully automatic)
            async phaseExecute() {
                // Check required files for this phase
                var filesReady = await this.checkPhaseRequiredFiles('execute');
                if (!filesReady) {
                    await this.waitForFileApproval();
                }
                
                const todos = this.cycleState.todos || [];
                const pendingTodos = todos.filter(t => t.status === 'pending');
                
                if (pendingTodos.length === 0) {
                    // Check for fixes from previous test
                    if (this.fixQueue && this.fixQueue.length > 0) {
                        const fix = this.fixQueue.shift();
                        this.addMessage('system', `‚ö° Fixing: ${fix.description.substring(0, 50)}...`);
                        await this.logCycleEvent('Applying Fix', { fix: fix.description.substring(0, 100) });
                        await this.executeTask(`Fix this issue: ${fix.description}`);
                    } else {
                        this.addMessage('system', '‚úÖ All tasks completed');
                        await this.logCycleEvent('All Tasks Completed', { totalTasks: todos.length });
                    }
                    await this.runPhase('test');
                    return;
                }
                
                // Get next pending todo
                const currentTodo = pendingTodos[0];
                const todoIndex = todos.indexOf(currentTodo);
                const taskNum = todos.length - pendingTodos.length + 1;
                await this.logCycleEvent('Executing Task', { taskNum, totalTasks: todos.length, task: currentTodo.task });
                
                this.addMessage('system', `‚ö° Task ${taskNum}/${todos.length}: ${currentTodo.task}`);
                
                // Execute the todo using AI (automatic - no user input needed)
                try {
                    // Step 1: Summarize Constitutional Memory for this specific task
                    this.addMessage('system', `   üèõÔ∏è Loading constitutional context...`);
                    await this.summarizeConstitutionalMemory(currentTodo.task);
                    const constitutionalContext = this.getConstitutionalContext();
                    
                    // Log the dynamic system prompt
                    await this.logDynamicSystemPrompt(currentTodo.task, constitutionalContext);
                    
                    // Check if task involves data persistence
                    const needsApi = this.detectApiNeed(currentTodo.task);
                    
                    // Build prompt with Constitutional Memory context
                    var prompt = '';
                    
                    // Add Constitutional Memory summary first (guiding principles)
                    if (constitutionalContext) {
                        prompt += constitutionalContext;
                    }
                    
                    prompt += 'Complete this task: ' + currentTodo.task + '\n\n' +
                        'Context:\n' +
                        '- Objective: ' + this.cycleState.objective + '\n' +
                        '- File: ' + (this.currentPreviewFile ? this.currentPreviewFile.split('/').pop() : 'current project') + '\n\n';
                    
                    if (needsApi) {
                        prompt += 'IMPORTANT - Data Persistence:\n' +
                            'This task involves saving/loading data. Follow these rules:\n' +
                            '1. Create API calls using a stub pattern: AppAPI.methodName(data)\n' +
                            '2. Use localStorage as temporary storage until backend is ready\n' +
                            '3. Structure data with: id, createdAt, updatedAt fields\n' +
                            '4. Handle loading states and errors gracefully\n' +
                            '5. DO NOT hardcode data - always use the API pattern\n\n';
                    }
                    
                    prompt += 'Follow the project guidelines above. Implement the changes needed to complete this specific task.';

                    await this.executeTask(prompt);
                    
                    // After task, check if we need to generate API requirements
                    if (needsApi) {
                        await this.generateApiRequirements(currentTodo.task);
                    }
                    
                    // Mark todo as completed
                    todos[todoIndex].status = 'completed';
                    await this.updateTodoFile();
                    
                    // Sync to Episodic Memory
                    this.markCycleTaskComplete(currentTodo.task);
                    
                    // Brief pause then continue with next todo
                    await new Promise(function(r) { setTimeout(r, 500); });
                    
                    // Continue with next todo or move to test
                    var stillPending = todos.filter(function(t) { return t.status === 'pending'; });
                    if (stillPending.length > 0) {
                        await this.phaseExecute();
                    } else {
                        this.addMessage('system', '‚úÖ All tasks completed');
                        // Generate consolidated API requirements if any were detected
                        await this.finalizeApiRequirements();
                        await this.runPhase('test');
                    }
                } catch (e) {
                    console.log('[Cycle] Execute error:', e);
                    this.addMessage('error', 'Task failed: ' + e.message);
                    // Mark as failed but continue
                    todos[todoIndex].status = 'failed';
                    await this.updateTodoFile();
                    
                    var stillPending = todos.filter(function(t) { return t.status === 'pending'; });
                    if (stillPending.length > 0) {
                        await this.phaseExecute();
                    } else {
                        await this.runPhase('test');
                    }
                }
            },
            
            // Detect if a task needs API/persistence
            detectApiNeed(taskDescription) {
                var keywords = [
                    'save', 'store', 'persist', 'database', 'storage',
                    'create', 'update', 'delete', 'remove', 'add',
                    'user', 'account', 'login', 'register', 'auth',
                    'submit', 'form', 'data', 'record',
                    'order', 'cart', 'checkout', 'payment',
                    'booking', 'reservation', 'appointment', 'event',
                    'message', 'comment', 'post', 'upload',
                    'settings', 'preferences', 'profile'
                ];
                var lowerTask = taskDescription.toLowerCase();
                for (var i = 0; i < keywords.length; i++) {
                    if (lowerTask.indexOf(keywords[i]) !== -1) {
                        return true;
                    }
                }
                return false;
            },
            
            // Track detected API endpoints during execution
            detectedApiEndpoints: [],
            
            // API docs folder name
            apiDocsFolder: 'api-specs',
            
            // Generate API requirements for a task
            async generateApiRequirements(taskDescription) {
                this.addMessage('system', 'üìã Detecting API requirements...');
                
                // Ask AI to identify the data model and endpoints needed
                var prompt = 'Based on this task: "' + taskDescription + '"\n\n' +
                    'Identify the API requirements. Respond in this exact JSON format:\n' +
                    '{\n' +
                    '  "resourceName": "the main resource (e.g., Event, User, Order)",\n' +
                    '  "resourceDescription": "what this resource represents",\n' +
                    '  "fields": [\n' +
                    '    {"name": "fieldName", "type": "string|number|boolean|date|array|object", "required": true/false, "description": "what this field is for"}\n' +
                    '  ],\n' +
                    '  "operations": [\n' +
                    '    {"name": "operationName", "type": "create|read|update|delete|list|search|custom", "description": "what this operation does", "inputFields": ["field1"], "outputFields": ["field1", "field2"]}\n' +
                    '  ],\n' +
                    '  "businessRules": ["rule 1", "rule 2"],\n' +
                    '  "relatedResources": ["OtherResource"]\n' +
                    '}\n\n' +
                    'Only output the JSON, no other text.';
                
                try {
                    var response = await this.executeTaskSilent(prompt);
                    
                    // Parse the JSON from response
                    var jsonMatch = response.match(/\{[\s\S]*\}/);
                    if (jsonMatch) {
                        var apiSpec = JSON.parse(jsonMatch[0]);
                        apiSpec.appVersion = this.cycleState.currentVersion;
                        apiSpec.detectedAt = new Date().toISOString();
                        apiSpec.sourceTask = taskDescription;
                        
                        // Check if this resource already exists
                        var existingIndex = -1;
                        for (var i = 0; i < this.detectedApiEndpoints.length; i++) {
                            if (this.detectedApiEndpoints[i].resourceName === apiSpec.resourceName) {
                                existingIndex = i;
                                break;
                            }
                        }
                        
                        if (existingIndex >= 0) {
                            // Merge with existing - add new operations
                            var existing = this.detectedApiEndpoints[existingIndex];
                            if (apiSpec.operations) {
                                existing.operations = existing.operations || [];
                                for (var j = 0; j < apiSpec.operations.length; j++) {
                                    var op = apiSpec.operations[j];
                                    var opExists = existing.operations.some(function(e) { return e.name === op.name; });
                                    if (!opExists) {
                                        existing.operations.push(op);
                                    }
                                }
                            }
                            if (apiSpec.fields) {
                                existing.fields = existing.fields || [];
                                for (var j = 0; j < apiSpec.fields.length; j++) {
                                    var field = apiSpec.fields[j];
                                    var fieldExists = existing.fields.some(function(f) { return f.name === field.name; });
                                    if (!fieldExists) {
                                        existing.fields.push(field);
                                    }
                                }
                            }
                            existing.appVersion = apiSpec.appVersion;
                            this.addMessage('system', '  ‚Üí Updated: ' + apiSpec.resourceName + ' API');
                        } else {
                            this.detectedApiEndpoints.push(apiSpec);
                            this.addMessage('system', '  ‚Üí Found: ' + apiSpec.resourceName + ' (' + (apiSpec.operations ? apiSpec.operations.length : 0) + ' operations)');
                        }
                    }
                } catch (e) {
                    console.log('[Execute] API detection error:', e);
                }
            },
            
            // Execute task without UI streaming (for internal queries)
            async executeTaskSilent(prompt) {
                var response = '';
                try {
                    await window.aider.runPromptStreaming(prompt, function(chunk) {
                        response += chunk;
                    });
                    return response;
                } catch (e) {
                    throw e;
                }
            },
            
            // Generate individual API requirement documents
            async finalizeApiRequirements() {
                if (this.detectedApiEndpoints.length === 0) {
                    return;
                }
                
                this.addMessage('system', 'üìÑ Generating API Requirement Documents...');
                
                // Ensure api-specs folder exists
                var specsFolderPath = this.repoPath + '/' + this.apiDocsFolder;
                try {
                    await window.aider.createDirectory(specsFolderPath);
                } catch (e) {
                    // Folder may already exist
                }
                
                // Generate individual doc for each resource
                for (var i = 0; i < this.detectedApiEndpoints.length; i++) {
                    var spec = this.detectedApiEndpoints[i];
                    await this.saveApiSpecDoc(spec);
                }
                
                // Generate index/manifest file
                await this.saveApiManifest();
                
                // Generate the stub client
                await this.generateApiStubClient();
                
                // Check for sync issues
                await this.checkApiSync();
                
                // Generate test harness for APIs
                await this.generateApiTestHarness();
                
                // Update test plan
                await this.updateTestPlan();
                
                // Log API changes
                await this.logApiChanges();
                
                // Clear for next cycle
                this.detectedApiEndpoints = [];
            },
            
            // API change log
            apiChangeLog: [],
            
            // Log API changes for tracking
            async logApiChanges() {
                if (this.detectedApiEndpoints.length === 0) return;
                
                var version = this.cycleState.currentVersion;
                var timestamp = new Date().toISOString();
                
                for (var i = 0; i < this.detectedApiEndpoints.length; i++) {
                    var spec = this.detectedApiEndpoints[i];
                    var changeEntry = {
                        resource: spec.resourceName,
                        version: version,
                        timestamp: timestamp,
                        operations: spec.operations ? spec.operations.map(function(o) { return o.type; }) : [],
                        fields: spec.fields ? spec.fields.length : 0,
                        action: spec.isUpdate ? 'updated' : 'created'
                    };
                    this.apiChangeLog.push(changeEntry);
                    
                    // Also log to event database
                    try {
                        await window.aider.txdbLogEvent({
                            type: 'api_change',
                            summary: 'API ' + changeEntry.action + ': ' + spec.resourceName + ' (v' + version + ')',
                            message: spec.resourceName + ' API ' + changeEntry.action,
                            context: JSON.stringify(changeEntry),
                            timestamp: timestamp
                        });
                    } catch (e) {
                        console.log('[Execute] Log API change error:', e);
                    }
                }
            },
            
            // Generate test harness for all detected APIs
            async generateApiTestHarness() {
                if (this.detectedApiEndpoints.length === 0) return;
                
                this.addMessage('system', 'üß™ Generating Playwright API test harness...');
                
                var version = this.cycleState.currentVersion;
                var appName = (this.currentSpaceName || 'App').replace(/[^a-zA-Z0-9]/g, '');
                
                // Ensure test folder exists
                var testFolderPath = this.repoPath + '/tests';
                try {
                    await window.aider.createDirectory(testFolderPath);
                } catch (e) { /* may exist */ }
                
                // Generate Playwright config
                await this.generatePlaywrightConfig(version, appName);
                
                // Generate Playwright test file for each API
                for (var i = 0; i < this.detectedApiEndpoints.length; i++) {
                    var spec = this.detectedApiEndpoints[i];
                    await this.generatePlaywrightApiTests(spec, version, appName);
                }
                
                // Generate combined test runner
                await this.generatePlaywrightTestRunner(version, appName);
                
                // Also generate browser-based tests for stub mode
                for (var i = 0; i < this.detectedApiEndpoints.length; i++) {
                    var spec = this.detectedApiEndpoints[i];
                    await this.generateApiTests(spec, version, appName);
                }
                await this.generateTestRunner(version, appName);
            },
            
            // Generate Playwright config for API testing
            async generatePlaywrightConfig(version, appName) {
                var filePath = this.repoPath + '/playwright.config.js';
                
                var code = '// Playwright Configuration for ' + appName + '\n';
                code += '// Version: ' + version + '\n';
                code += '// Generated by GSX Create Meta Learning\n\n';
                
                code += 'const { defineConfig } = require("@playwright/test");\n\n';
                
                code += 'module.exports = defineConfig({\n';
                code += '    testDir: "./tests",\n';
                code += '    timeout: 30000,\n';
                code += '    retries: 1,\n';
                code += '    use: {\n';
                code += '        // Base URL for API tests (set when backend ready)\n';
                code += '        baseURL: process.env.API_BASE_URL || "http://localhost:3000",\n';
                code += '        extraHTTPHeaders: {\n';
                code += '            "Accept": "application/json",\n';
                code += '            "Content-Type": "application/json"\n';
                code += '        }\n';
                code += '    },\n';
                code += '    reporter: [\n';
                code += '        ["list"],\n';
                code += '        ["json", { outputFile: "test-results.json" }]\n';
                code += '    ],\n';
                code += '    projects: [\n';
                code += '        {\n';
                code += '            name: "api",\n';
                code += '            testMatch: "**/*.api.spec.js"\n';
                code += '        },\n';
                code += '        {\n';
                code += '            name: "ui",\n';
                code += '            testMatch: "**/*.ui.spec.js",\n';
                code += '            use: { browserName: "chromium" }\n';
                code += '        }\n';
                code += '    ]\n';
                code += '});\n';
                
                try {
                    await window.aider.writeFile(filePath, code);
                    this.addMessage('system', '  ‚Üí playwright.config.js');
                } catch (e) {
                    console.log('[Execute] Save playwright config error:', e);
                }
            },
            
            // Generate Playwright API tests for a resource
            async generatePlaywrightApiTests(spec, version, appName) {
                var resource = spec.resourceName;
                var resourceLower = resource.toLowerCase();
                var fileName = resourceLower + '.api.spec.js';
                var filePath = this.repoPath + '/tests/' + fileName;
                
                var code = '// @ts-check\n';
                code += 'const { test, expect } = require("@playwright/test");\n\n';
                
                code += '/**\n';
                code += ' * ' + resource + ' API Tests\n';
                code += ' * Version: ' + version + '\n';
                code += ' * Spec: api-specs/' + resourceLower + '-api.md\n';
                code += ' * \n';
                code += ' * Run: npx playwright test ' + fileName + '\n';
                code += ' */\n\n';
                
                code += 'test.describe("' + resource + ' API", () => {\n';
                code += '    const endpoint = "/' + resourceLower + 's";\n';
                code += '    let createdId;\n\n';
                
                // Test data
                code += '    const testData = ' + JSON.stringify(this.generateTestData(spec), null, 8).replace(/\n/g, '\n    ') + ';\n\n';
                
                // Create test
                code += '    test("POST ' + endpoint + ' - create ' + resourceLower + '", async ({ request }) => {\n';
                code += '        const response = await request.post(endpoint, {\n';
                code += '            data: testData\n';
                code += '        });\n';
                code += '        \n';
                code += '        expect(response.ok()).toBeTruthy();\n';
                code += '        \n';
                code += '        const body = await response.json();\n';
                code += '        expect(body.id).toBeDefined();\n';
                code += '        expect(body.createdAt).toBeDefined();\n';
                
                // Assert required fields
                if (spec.fields) {
                    for (var j = 0; j < spec.fields.length; j++) {
                        var f = spec.fields[j];
                        if (f.required) {
                            code += '        expect(body.' + f.name + ').toBeDefined();\n';
                        }
                    }
                }
                
                code += '        \n';
                code += '        createdId = body.id;\n';
                code += '    });\n\n';
                
                // Read test
                code += '    test("GET ' + endpoint + '/:id - get ' + resourceLower + '", async ({ request }) => {\n';
                code += '        test.skip(!createdId, "No id from create test");\n';
                code += '        \n';
                code += '        const response = await request.get(`${endpoint}/${createdId}`);\n';
                code += '        \n';
                code += '        expect(response.ok()).toBeTruthy();\n';
                code += '        \n';
                code += '        const body = await response.json();\n';
                code += '        expect(body.id).toBe(createdId);\n';
                code += '    });\n\n';
                
                // List test
                code += '    test("GET ' + endpoint + ' - list ' + resourceLower + 's", async ({ request }) => {\n';
                code += '        const response = await request.get(endpoint);\n';
                code += '        \n';
                code += '        expect(response.ok()).toBeTruthy();\n';
                code += '        \n';
                code += '        const body = await response.json();\n';
                code += '        expect(Array.isArray(body.items) || Array.isArray(body)).toBeTruthy();\n';
                code += '    });\n\n';
                
                // Update test
                code += '    test("PUT ' + endpoint + '/:id - update ' + resourceLower + '", async ({ request }) => {\n';
                code += '        test.skip(!createdId, "No id from create test");\n';
                code += '        \n';
                code += '        const updateData = { updatedField: "test_update_" + Date.now() };\n';
                code += '        const response = await request.put(`${endpoint}/${createdId}`, {\n';
                code += '            data: updateData\n';
                code += '        });\n';
                code += '        \n';
                code += '        expect(response.ok()).toBeTruthy();\n';
                code += '        \n';
                code += '        const body = await response.json();\n';
                code += '        expect(body.updatedAt).toBeDefined();\n';
                code += '    });\n\n';
                
                // Delete test
                code += '    test("DELETE ' + endpoint + '/:id - delete ' + resourceLower + '", async ({ request }) => {\n';
                code += '        test.skip(!createdId, "No id from create test");\n';
                code += '        \n';
                code += '        const response = await request.delete(`${endpoint}/${createdId}`);\n';
                code += '        \n';
                code += '        expect(response.ok()).toBeTruthy();\n';
                code += '        \n';
                code += '        // Verify deleted\n';
                code += '        const getResponse = await request.get(`${endpoint}/${createdId}`);\n';
                code += '        expect(getResponse.status()).toBe(404);\n';
                code += '    });\n\n';
                
                // Error handling tests
                code += '    test("GET ' + endpoint + '/:id - 404 for non-existent", async ({ request }) => {\n';
                code += '        const response = await request.get(`${endpoint}/nonexistent123`);\n';
                code += '        \n';
                code += '        expect(response.status()).toBe(404);\n';
                code += '    });\n\n';
                
                code += '    test("POST ' + endpoint + ' - 400 for invalid data", async ({ request }) => {\n';
                code += '        const response = await request.post(endpoint, {\n';
                code += '            data: {} // Empty/invalid data\n';
                code += '        });\n';
                code += '        \n';
                code += '        // Should return 400 for validation error\n';
                code += '        expect([400, 422].includes(response.status())).toBeTruthy();\n';
                code += '    });\n';
                
                code += '});\n';
                
                try {
                    await window.aider.writeFile(filePath, code);
                    this.addMessage('system', '  ‚Üí tests/' + fileName);
                } catch (e) {
                    console.log('[Execute] Save Playwright API tests error:', e);
                }
            },
            
            // Generate Playwright test runner script
            async generatePlaywrightTestRunner(version, appName) {
                var filePath = this.repoPath + '/tests/run-api-tests.js';
                
                var code = '#!/usr/bin/env node\n';
                code += '/**\n';
                code += ' * ' + appName + ' API Test Runner\n';
                code += ' * Version: ' + version + '\n';
                code += ' * \n';
                code += ' * Usage:\n';
                code += ' *   node tests/run-api-tests.js [baseUrl]\n';
                code += ' *   npx playwright test --project=api\n';
                code += ' * \n';
                code += ' * Generated by GSX Create Meta Learning\n';
                code += ' */\n\n';
                
                code += 'const { exec } = require("child_process");\n\n';
                
                code += 'const baseUrl = process.argv[2] || process.env.API_BASE_URL || "http://localhost:3000";\n\n';
                
                code += 'console.log("\\n========================================");\n';
                code += 'console.log("  ' + appName + ' API Tests (v' + version + ')");\n';
                code += 'console.log("  Base URL:", baseUrl);\n';
                code += 'console.log("========================================\\n");\n\n';
                
                code += 'const cmd = `API_BASE_URL=${baseUrl} npx playwright test --project=api`;\n\n';
                
                code += 'exec(cmd, (error, stdout, stderr) => {\n';
                code += '    console.log(stdout);\n';
                code += '    if (stderr) console.error(stderr);\n';
                code += '    if (error) {\n';
                code += '        console.error("Tests failed:", error.message);\n';
                code += '        process.exit(1);\n';
                code += '    }\n';
                code += '});\n';
                
                try {
                    await window.aider.writeFile(filePath, code);
                    this.addMessage('system', '  ‚Üí tests/run-api-tests.js');
                } catch (e) {
                    console.log('[Execute] Save Playwright runner error:', e);
                }
            },
            
            // Generate tests for a single API
            async generateApiTests(spec, version, appName) {
                var resource = spec.resourceName;
                var resourceLower = resource.toLowerCase();
                var fileName = resourceLower + '-api.test.js';
                var filePath = this.repoPath + '/tests/' + fileName;
                
                var code = '/**\n';
                code += ' * ' + resource + ' API Tests\n';
                code += ' * Version: ' + version + '\n';
                code += ' * Generated by GSX Create Meta Learning\n';
                code += ' * \n';
                code += ' * These tests validate the ' + resource + ' API operations.\n';
                code += ' * Run with: TestRunner.run' + resource + 'Tests()\n';
                code += ' */\n\n';
                
                code += 'var ' + resource + 'Tests = {\n';
                code += '    name: "' + resource + ' API",\n';
                code += '    version: ' + version + ',\n';
                code += '    results: [],\n\n';
                
                code += '    // Test utilities\n';
                code += '    assert: function(condition, message) {\n';
                code += '        if (!condition) throw new Error(message);\n';
                code += '    },\n\n';
                
                code += '    log: function(status, test, message) {\n';
                code += '        this.results.push({ status: status, test: test, message: message, timestamp: new Date().toISOString() });\n';
                code += '        console.log("[" + status + "] " + test + ": " + message);\n';
                code += '    },\n\n';
                
                code += '    // Run all tests\n';
                code += '    runAll: async function() {\n';
                code += '        this.results = [];\n';
                code += '        console.log("\\n=== ' + resource + ' API Tests (v' + version + ') ===\\n");\n';
                code += '        \n';
                code += '        await this.testCreate();\n';
                code += '        await this.testRead();\n';
                code += '        await this.testUpdate();\n';
                code += '        await this.testDelete();\n';
                code += '        await this.testList();\n';
                
                // Add custom operation tests
                if (spec.operations) {
                    for (var j = 0; j < spec.operations.length; j++) {
                        var op = spec.operations[j];
                        if (['create', 'read', 'update', 'delete', 'list'].indexOf(op.type) === -1) {
                            code += '        await this.test' + this.capitalize(op.name || op.type) + '();\n';
                        }
                    }
                }
                
                code += '        \n';
                code += '        return this.getSummary();\n';
                code += '    },\n\n';
                
                // Create test
                code += '    testCreate: async function() {\n';
                code += '        try {\n';
                code += '            var testData = ' + JSON.stringify(this.generateTestData(spec)) + ';\n';
                code += '            var result = await ' + appName + 'API.create' + resource + '(testData);\n';
                code += '            \n';
                code += '            this.assert(result.id, "Should return id");\n';
                code += '            this.assert(result.createdAt, "Should have createdAt");\n';
                
                // Assert required fields
                if (spec.fields) {
                    for (var j = 0; j < spec.fields.length; j++) {
                        var f = spec.fields[j];
                        if (f.required) {
                            code += '            this.assert(result.' + f.name + ' !== undefined, "Should have ' + f.name + '");\n';
                        }
                    }
                }
                
                code += '            \n';
                code += '            this._createdId = result.id; // Save for other tests\n';
                code += '            this.log("PASS", "Create ' + resource + '", "Created with id: " + result.id);\n';
                code += '        } catch (e) {\n';
                code += '            this.log("FAIL", "Create ' + resource + '", e.message);\n';
                code += '        }\n';
                code += '    },\n\n';
                
                // Read test
                code += '    testRead: async function() {\n';
                code += '        try {\n';
                code += '            if (!this._createdId) throw new Error("No id from create test");\n';
                code += '            \n';
                code += '            var result = await ' + appName + 'API.get' + resource + '(this._createdId);\n';
                code += '            \n';
                code += '            this.assert(result.id === this._createdId, "Should return correct item");\n';
                code += '            this.log("PASS", "Read ' + resource + '", "Retrieved successfully");\n';
                code += '        } catch (e) {\n';
                code += '            this.log("FAIL", "Read ' + resource + '", e.message);\n';
                code += '        }\n';
                code += '    },\n\n';
                
                // Update test
                code += '    testUpdate: async function() {\n';
                code += '        try {\n';
                code += '            if (!this._createdId) throw new Error("No id from create test");\n';
                code += '            \n';
                code += '            var updateData = { updatedField: "test_update_" + Date.now() };\n';
                code += '            var result = await ' + appName + 'API.update' + resource + '(this._createdId, updateData);\n';
                code += '            \n';
                code += '            this.assert(result.updatedAt, "Should have updatedAt");\n';
                code += '            this.log("PASS", "Update ' + resource + '", "Updated successfully");\n';
                code += '        } catch (e) {\n';
                code += '            this.log("FAIL", "Update ' + resource + '", e.message);\n';
                code += '        }\n';
                code += '    },\n\n';
                
                // List test
                code += '    testList: async function() {\n';
                code += '        try {\n';
                code += '            var result = await ' + appName + 'API.list' + resource + 's();\n';
                code += '            \n';
                code += '            this.assert(Array.isArray(result.items), "Should return items array");\n';
                code += '            this.assert(typeof result.total === "number", "Should return total count");\n';
                code += '            this.log("PASS", "List ' + resource + 's", "Found " + result.total + " items");\n';
                code += '        } catch (e) {\n';
                code += '            this.log("FAIL", "List ' + resource + 's", e.message);\n';
                code += '        }\n';
                code += '    },\n\n';
                
                // Delete test
                code += '    testDelete: async function() {\n';
                code += '        try {\n';
                code += '            if (!this._createdId) throw new Error("No id from create test");\n';
                code += '            \n';
                code += '            var result = await ' + appName + 'API.delete' + resource + '(this._createdId);\n';
                code += '            \n';
                code += '            this.assert(result.success, "Should return success");\n';
                code += '            \n';
                code += '            // Verify deleted\n';
                code += '            try {\n';
                code += '                await ' + appName + 'API.get' + resource + '(this._createdId);\n';
                code += '                this.log("FAIL", "Delete ' + resource + '", "Item still exists after delete");\n';
                code += '            } catch (e) {\n';
                code += '                this.log("PASS", "Delete ' + resource + '", "Deleted successfully");\n';
                code += '            }\n';
                code += '        } catch (e) {\n';
                code += '            this.log("FAIL", "Delete ' + resource + '", e.message);\n';
                code += '        }\n';
                code += '    },\n\n';
                
                // Summary
                code += '    getSummary: function() {\n';
                code += '        var passed = this.results.filter(function(r) { return r.status === "PASS"; }).length;\n';
                code += '        var failed = this.results.filter(function(r) { return r.status === "FAIL"; }).length;\n';
                code += '        return {\n';
                code += '            name: this.name,\n';
                code += '            version: this.version,\n';
                code += '            passed: passed,\n';
                code += '            failed: failed,\n';
                code += '            total: this.results.length,\n';
                code += '            results: this.results\n';
                code += '        };\n';
                code += '    }\n';
                code += '};\n';
                
                try {
                    await window.aider.writeFile(filePath, code);
                    this.addMessage('system', '  ‚Üí tests/' + fileName);
                } catch (e) {
                    console.log('[Execute] Save API tests error:', e);
                }
            },
            
            // Generate test data based on spec
            generateTestData(spec) {
                var data = {};
                if (spec.fields) {
                    for (var i = 0; i < spec.fields.length; i++) {
                        var f = spec.fields[i];
                        data[f.name] = this.getExampleValue(f.type, f.name);
                    }
                }
                return data;
            },
            
            // Capitalize first letter
            capitalize(str) {
                return str.charAt(0).toUpperCase() + str.slice(1);
            },
            
            // Generate test runner that runs all API tests
            async generateTestRunner(version, appName) {
                var filePath = this.repoPath + '/tests/test-runner.js';
                
                var code = '/**\n';
                code += ' * ' + appName + ' Test Runner\n';
                code += ' * Version: ' + version + '\n';
                code += ' * Generated by GSX Create Meta Learning\n';
                code += ' */\n\n';
                
                code += 'var TestRunner = {\n';
                code += '    version: ' + version + ',\n';
                code += '    results: [],\n\n';
                
                code += '    // Run all API tests\n';
                code += '    runAllApiTests: async function() {\n';
                code += '        console.log("\\n========================================");\n';
                code += '        console.log("  ' + appName + ' API Test Suite (v' + version + ')");\n';
                code += '        console.log("========================================\\n");\n';
                code += '        \n';
                code += '        this.results = [];\n';
                code += '        var testSuites = [\n';
                
                for (var i = 0; i < this.detectedApiEndpoints.length; i++) {
                    var spec = this.detectedApiEndpoints[i];
                    code += '            ' + spec.resourceName + 'Tests,\n';
                }
                
                code += '        ];\n';
                code += '        \n';
                code += '        for (var i = 0; i < testSuites.length; i++) {\n';
                code += '            try {\n';
                code += '                var result = await testSuites[i].runAll();\n';
                code += '                this.results.push(result);\n';
                code += '            } catch (e) {\n';
                code += '                console.error("Test suite error:", e);\n';
                code += '            }\n';
                code += '        }\n';
                code += '        \n';
                code += '        return this.getSummary();\n';
                code += '    },\n\n';
                
                code += '    // Get overall summary\n';
                code += '    getSummary: function() {\n';
                code += '        var totalPassed = 0;\n';
                code += '        var totalFailed = 0;\n';
                code += '        \n';
                code += '        for (var i = 0; i < this.results.length; i++) {\n';
                code += '            totalPassed += this.results[i].passed;\n';
                code += '            totalFailed += this.results[i].failed;\n';
                code += '        }\n';
                code += '        \n';
                code += '        console.log("\\n========================================");\n';
                code += '        console.log("  SUMMARY: " + totalPassed + " passed, " + totalFailed + " failed");\n';
                code += '        console.log("========================================\\n");\n';
                code += '        \n';
                code += '        return {\n';
                code += '            version: this.version,\n';
                code += '            passed: totalPassed,\n';
                code += '            failed: totalFailed,\n';
                code += '            total: totalPassed + totalFailed,\n';
                code += '            suites: this.results,\n';
                code += '            success: totalFailed === 0\n';
                code += '        };\n';
                code += '    }\n';
                code += '};\n';
                
                try {
                    await window.aider.writeFile(filePath, code);
                    this.addMessage('system', '  ‚Üí tests/test-runner.js');
                } catch (e) {
                    console.log('[Execute] Save test runner error:', e);
                }
            },
            
            // Update or create test plan document
            async updateTestPlan() {
                this.addMessage('system', 'üìã Updating test plan...');
                
                var version = this.cycleState.currentVersion;
                var filePath = this.repoPath + '/TEST-PLAN.md';
                
                // Try to load existing test plan
                var existingPlan = null;
                try {
                    existingPlan = await window.aider.readFile(filePath);
                } catch (e) { /* doesn't exist */ }
                
                var doc = '# Test Plan\n\n';
                doc += '| Property | Value |\n';
                doc += '|----------|-------|\n';
                doc += '| App | ' + (this.currentSpaceName || 'App') + ' |\n';
                doc += '| Version | v' + version + ' |\n';
                doc += '| Last Updated | ' + new Date().toISOString().split('T')[0] + ' |\n\n';
                
                doc += '---\n\n';
                doc += '## Test Categories\n\n';
                
                // API Tests
                doc += '### 1. API Tests\n\n';
                doc += 'Automated tests for all API operations.\n\n';
                doc += '| Resource | Tests | Status | File |\n';
                doc += '|----------|-------|--------|------|\n';
                
                for (var i = 0; i < this.detectedApiEndpoints.length; i++) {
                    var spec = this.detectedApiEndpoints[i];
                    var testCount = 5; // CRUD + list
                    if (spec.operations) {
                        testCount = spec.operations.length;
                    }
                    doc += '| ' + spec.resourceName + ' | ' + testCount + ' | ‚è≥ Pending | `tests/' + spec.resourceName.toLowerCase() + '-api.test.js` |\n';
                }
                
                doc += '\n**Run:** `TestRunner.runAllApiTests()`\n\n';
                
                // UI Tests
                doc += '### 2. UI Tests\n\n';
                doc += 'Visual and interaction tests.\n\n';
                doc += '| Test | Description | Status |\n';
                doc += '|------|-------------|--------|\n';
                doc += '| Page Load | Page loads without errors | ‚è≥ Pending |\n';
                doc += '| Responsive | Works on mobile/tablet/desktop | ‚è≥ Pending |\n';
                doc += '| Accessibility | Meets WCAG guidelines | ‚è≥ Pending |\n';
                doc += '| Forms | All forms submit correctly | ‚è≥ Pending |\n';
                doc += '| Navigation | All links/buttons work | ‚è≥ Pending |\n\n';
                
                // Integration Tests
                doc += '### 3. Integration Tests\n\n';
                doc += 'End-to-end user flow tests.\n\n';
                doc += '| Flow | Steps | Status |\n';
                doc += '|------|-------|--------|\n';
                
                // Generate flows based on detected resources
                for (var i = 0; i < this.detectedApiEndpoints.length; i++) {
                    var spec = this.detectedApiEndpoints[i];
                    doc += '| Create ' + spec.resourceName + ' | Open form ‚Üí Fill data ‚Üí Submit ‚Üí Verify | ‚è≥ Pending |\n';
                }
                
                doc += '\n';
                
                // Error Handling
                doc += '### 4. Error Handling Tests\n\n';
                doc += '| Scenario | Expected | Status |\n';
                doc += '|----------|----------|--------|\n';
                doc += '| Invalid input | Show validation error | ‚è≥ Pending |\n';
                doc += '| Network failure | Show retry option | ‚è≥ Pending |\n';
                doc += '| Not found | Show 404 message | ‚è≥ Pending |\n';
                doc += '| Server error | Show error + log | ‚è≥ Pending |\n\n';
                
                // Test History
                doc += '---\n\n';
                doc += '## Test History\n\n';
                doc += '| Version | Date | Passed | Failed | Notes |\n';
                doc += '|---------|------|--------|--------|-------|\n';
                doc += '| v' + version + ' | ' + new Date().toISOString().split('T')[0] + ' | - | - | Tests generated |\n';
                
                // Parse existing history if available
                if (existingPlan) {
                    var historyMatch = existingPlan.match(/## Test History[\s\S]*?\n\n([\s\S]*?)(?=\n---|\n##|$)/);
                    if (historyMatch) {
                        var lines = historyMatch[1].split('\n').filter(function(l) { 
                            return l.startsWith('|') && !l.includes('Version') && !l.includes('---'); 
                        });
                        for (var i = 0; i < lines.length; i++) {
                            if (lines[i].indexOf('v' + version) === -1) {
                                doc += lines[i] + '\n';
                            }
                        }
                    }
                }
                
                doc += '\n---\n\n';
                doc += '## Running Tests\n\n';
                doc += '### In Browser Console\n';
                doc += '```javascript\n';
                doc += '// Run all API tests\n';
                doc += 'TestRunner.runAllApiTests().then(console.log);\n';
                doc += '\n';
                doc += '// Run specific resource tests\n';
                for (var i = 0; i < this.detectedApiEndpoints.length; i++) {
                    var spec = this.detectedApiEndpoints[i];
                    doc += spec.resourceName + 'Tests.runAll().then(console.log);\n';
                }
                doc += '```\n\n';
                
                doc += '### In Meta Learning Cycle\n';
                doc += 'Tests run automatically during the **Test** phase.\n\n';
                
                doc += '---\n\n';
                doc += '*Generated by GSX Create Meta Learning*\n';
                
                try {
                    await window.aider.writeFile(filePath, doc);
                    this.addMessage('system', '  ‚Üí TEST-PLAN.md');
                } catch (e) {
                    console.log('[Execute] Save test plan error:', e);
                }
            },
            
            // Save individual API spec document
            async saveApiSpecDoc(spec) {
                var version = this.cycleState.currentVersion;
                var resourceName = spec.resourceName;
                var fileName = resourceName.toLowerCase() + '-api.md';
                var filePath = this.repoPath + '/' + this.apiDocsFolder + '/' + fileName;
                
                var doc = '# ' + resourceName + ' API\n\n';
                doc += '| Property | Value |\n';
                doc += '|----------|-------|\n';
                doc += '| App Version | v' + version + ' |\n';
                doc += '| Last Updated | ' + new Date().toISOString().split('T')[0] + ' |\n';
                doc += '| Status | Active |\n\n';
                
                doc += '---\n\n';
                doc += '## Overview\n\n';
                doc += spec.resourceDescription + '\n\n';
                
                // Data Model
                doc += '---\n\n';
                doc += '## Data Model\n\n';
                doc += '### ' + resourceName + '\n\n';
                doc += '| Field | Type | Required | Description |\n';
                doc += '|-------|------|----------|-------------|\n';
                doc += '| id | string | Yes | Unique identifier (auto-generated) |\n';
                
                if (spec.fields) {
                    for (var j = 0; j < spec.fields.length; j++) {
                        var f = spec.fields[j];
                        doc += '| ' + f.name + ' | ' + f.type + ' | ' + (f.required ? 'Yes' : 'No') + ' | ' + f.description + ' |\n';
                    }
                }
                
                doc += '| createdAt | datetime | Yes | Creation timestamp (auto-generated) |\n';
                doc += '| updatedAt | datetime | Yes | Last update timestamp (auto-generated) |\n\n';
                
                // Example JSON
                doc += '### Example\n\n';
                doc += '```json\n';
                var example = { id: 'abc123' };
                if (spec.fields) {
                    for (var j = 0; j < spec.fields.length; j++) {
                        var f = spec.fields[j];
                        example[f.name] = this.getExampleValue(f.type, f.name);
                    }
                }
                example.createdAt = '2024-01-15T10:30:00Z';
                example.updatedAt = '2024-01-15T10:30:00Z';
                doc += JSON.stringify(example, null, 2) + '\n';
                doc += '```\n\n';
                
                // Operations
                doc += '---\n\n';
                doc += '## Operations\n\n';
                
                if (spec.operations) {
                    for (var j = 0; j < spec.operations.length; j++) {
                        var op = spec.operations[j];
                        doc += '### ' + this.formatOperationName(op.name, op.type, resourceName) + '\n\n';
                        doc += '**Purpose:** ' + op.description + '\n\n';
                        doc += '**Type:** ' + op.type.toUpperCase() + '\n\n';
                        
                        if (op.inputFields && op.inputFields.length > 0) {
                            doc += '**Input Fields:** ' + op.inputFields.join(', ') + '\n\n';
                        }
                        
                        if (op.outputFields && op.outputFields.length > 0) {
                            doc += '**Output Fields:** ' + op.outputFields.join(', ') + '\n\n';
                        }
                        
                        // Standard behavior based on type
                        doc += '**Expected Behavior:**\n';
                        switch (op.type) {
                            case 'create':
                                doc += '- Validate all required fields\n';
                                doc += '- Generate unique id\n';
                                doc += '- Set createdAt and updatedAt timestamps\n';
                                doc += '- Return created object\n';
                                break;
                            case 'read':
                                doc += '- Accept id parameter\n';
                                doc += '- Return single object or 404 if not found\n';
                                break;
                            case 'update':
                                doc += '- Accept id and partial object\n';
                                doc += '- Update only provided fields\n';
                                doc += '- Update updatedAt timestamp\n';
                                doc += '- Return updated object or 404\n';
                                break;
                            case 'delete':
                                doc += '- Accept id parameter\n';
                                doc += '- Remove object from storage\n';
                                doc += '- Return success or 404\n';
                                break;
                            case 'list':
                                doc += '- Support pagination (limit, offset)\n';
                                doc += '- Support sorting (sortBy, order)\n';
                                doc += '- Return array with total count\n';
                                break;
                            case 'search':
                                doc += '- Accept search query parameters\n';
                                doc += '- Return matching objects with relevance\n';
                                break;
                            default:
                                doc += '- Implement custom logic as described\n';
                        }
                        doc += '\n';
                    }
                }
                
                // Business Rules
                if (spec.businessRules && spec.businessRules.length > 0) {
                    doc += '---\n\n';
                    doc += '## Business Rules\n\n';
                    for (var j = 0; j < spec.businessRules.length; j++) {
                        doc += (j + 1) + '. ' + spec.businessRules[j] + '\n';
                    }
                    doc += '\n';
                }
                
                // Related Resources
                if (spec.relatedResources && spec.relatedResources.length > 0) {
                    doc += '---\n\n';
                    doc += '## Related APIs\n\n';
                    for (var j = 0; j < spec.relatedResources.length; j++) {
                        var related = spec.relatedResources[j];
                        doc += '- [' + related + ' API](./' + related.toLowerCase() + '-api.md)\n';
                    }
                    doc += '\n';
                }
                
                // Footer
                doc += '---\n\n';
                doc += '*This specification is for GSX Studio API Builder Agent.*\n';
                doc += '*Do not include implementation code - focus on requirements.*\n\n';
                doc += '**Sync Check:** This document matches app version v' + version + '\n';
                
                try {
                    await window.aider.writeFile(filePath, doc);
                    this.addMessage('system', '  ‚Üí ' + fileName + ' (v' + version + ')');
                } catch (e) {
                    console.log('[Execute] Save API spec error:', e);
                }
            },
            
            // Format operation name for display
            formatOperationName(name, type, resource) {
                if (name) return name;
                switch (type) {
                    case 'create': return 'Create ' + resource;
                    case 'read': return 'Get ' + resource;
                    case 'update': return 'Update ' + resource;
                    case 'delete': return 'Delete ' + resource;
                    case 'list': return 'List ' + resource + 's';
                    case 'search': return 'Search ' + resource + 's';
                    default: return type + ' ' + resource;
                }
            },
            
            // Get example value for a field type
            getExampleValue(type, name) {
                switch (type.toLowerCase()) {
                    case 'string': 
                        if (name.toLowerCase().includes('email')) return 'user@example.com';
                        if (name.toLowerCase().includes('name')) return 'Example Name';
                        if (name.toLowerCase().includes('title')) return 'Example Title';
                        if (name.toLowerCase().includes('description')) return 'A brief description';
                        if (name.toLowerCase().includes('url')) return 'https://example.com';
                        return 'example string';
                    case 'number': return 42;
                    case 'boolean': return true;
                    case 'date': 
                    case 'datetime': return '2024-01-15T10:30:00Z';
                    case 'array': return [];
                    case 'object': return {};
                    default: return null;
                }
            },
            
            // Save API manifest (index of all APIs)
            async saveApiManifest() {
                var version = this.cycleState.currentVersion;
                var filePath = this.repoPath + '/' + this.apiDocsFolder + '/API-MANIFEST.md';
                
                var doc = '# API Manifest\n\n';
                doc += '| Property | Value |\n';
                doc += '|----------|-------|\n';
                doc += '| App | ' + (this.currentSpaceName || 'App') + ' |\n';
                doc += '| Version | v' + version + ' |\n';
                doc += '| Generated | ' + new Date().toISOString() + ' |\n';
                doc += '| Total APIs | ' + this.detectedApiEndpoints.length + ' |\n\n';
                
                doc += '---\n\n';
                doc += '## API Index\n\n';
                doc += '| Resource | Operations | Status | Doc |\n';
                doc += '|----------|------------|--------|-----|\n';
                
                for (var i = 0; i < this.detectedApiEndpoints.length; i++) {
                    var spec = this.detectedApiEndpoints[i];
                    var opCount = spec.operations ? spec.operations.length : 0;
                    var docLink = './' + spec.resourceName.toLowerCase() + '-api.md';
                    doc += '| ' + spec.resourceName + ' | ' + opCount + ' | ‚úÖ Synced | [View](' + docLink + ') |\n';
                }
                
                doc += '\n---\n\n';
                doc += '## Version History\n\n';
                doc += '| Version | Date | Changes |\n';
                doc += '|---------|------|----------|\n';
                doc += '| v' + version + ' | ' + new Date().toISOString().split('T')[0] + ' | Current version |\n';
                
                doc += '\n---\n\n';
                doc += '## Sync Status\n\n';
                doc += 'All API specifications are in sync with app version v' + version + '.\n\n';
                doc += 'To check for drift:\n';
                doc += '1. Run the Meta Learning Cycle\n';
                doc += '2. Compare manifest version with app version\n';
                doc += '3. Review any ‚ö†Ô∏è warnings in the index\n';
                
                try {
                    await window.aider.writeFile(filePath, doc);
                    this.addMessage('system', '  ‚Üí API-MANIFEST.md (index)');
                } catch (e) {
                    console.log('[Execute] Save manifest error:', e);
                }
            },
            
            // Check if API docs are in sync with app version
            async checkApiSync() {
                var currentVersion = this.cycleState.currentVersion;
                var outOfSync = [];
                
                // Read existing API docs and check versions
                try {
                    var specsFolderPath = this.repoPath + '/' + this.apiDocsFolder;
                    var files = await window.aider.listFiles(specsFolderPath);
                    
                    if (files && files.length > 0) {
                        for (var i = 0; i < files.length; i++) {
                            var file = files[i];
                            if (file.endsWith('-api.md') && file !== 'API-MANIFEST.md') {
                                var content = await window.aider.readFile(specsFolderPath + '/' + file);
                                if (content) {
                                    // Check for version in content
                                    var versionMatch = content.match(/App Version \| v(\d+)/);
                                    if (versionMatch) {
                                        var docVersion = parseInt(versionMatch[1]);
                                        if (docVersion < currentVersion) {
                                            outOfSync.push({
                                                file: file,
                                                docVersion: docVersion,
                                                appVersion: currentVersion
                                            });
                                        }
                                    }
                                }
                            }
                        }
                    }
                } catch (e) {
                    console.log('[Execute] Sync check error:', e);
                }
                
                if (outOfSync.length > 0) {
                    this.addMessage('warning', '‚ö†Ô∏è API Docs Out of Sync:');
                    for (var i = 0; i < outOfSync.length; i++) {
                        var item = outOfSync[i];
                        this.addMessage('warning', '  ‚Ä¢ ' + item.file + ' (v' + item.docVersion + ' ‚Üí v' + item.appVersion + ')');
                    }
                    this.addMessage('system', '  ‚Üí Run another cycle to update these docs');
                }
            },
            
            // Generate API stub client for frontend
            async generateApiStubClient() {
                if (this.detectedApiEndpoints.length === 0) return;
                
                var appName = (this.currentSpaceName || 'App').replace(/[^a-zA-Z0-9]/g, '');
                var version = this.cycleState.currentVersion;
                var fileName = appName.toLowerCase() + '-api.js';
                var filePath = this.repoPath + '/' + fileName;
                
                var code = '/**\n';
                code += ' * ' + appName + ' API Client\n';
                code += ' * Version: ' + version + '\n';
                code += ' * \n';
                code += ' * Stub implementation using localStorage.\n';
                code += ' * Replace baseUrl when backend API is ready.\n';
                code += ' * \n';
                code += ' * Generated by GSX Create Meta Learning\n';
                code += ' * Sync with: api-specs/API-MANIFEST.md\n';
                code += ' */\n\n';
                
                code += 'var ' + appName + 'API = {\n';
                code += '    version: ' + version + ',\n';
                code += '    baseUrl: null, // Set when backend ready\n';
                code += '    storagePrefix: "' + appName.toLowerCase() + '_",\n\n';
                
                code += '    // Check if using stub mode\n';
                code += '    isStubMode: function() { return !this.baseUrl; },\n\n';
                
                code += '    // Generate unique ID\n';
                code += '    generateId: function() {\n';
                code += '        return Date.now().toString(36) + Math.random().toString(36).substr(2);\n';
                code += '    },\n\n';
                
                code += '    // Storage helpers\n';
                code += '    getStorage: function(key) {\n';
                code += '        try {\n';
                code += '            var data = localStorage.getItem(this.storagePrefix + key);\n';
                code += '            return data ? JSON.parse(data) : null;\n';
                code += '        } catch(e) { return null; }\n';
                code += '    },\n\n';
                
                code += '    setStorage: function(key, value) {\n';
                code += '        try {\n';
                code += '            localStorage.setItem(this.storagePrefix + key, JSON.stringify(value));\n';
                code += '            return true;\n';
                code += '        } catch(e) { return false; }\n';
                code += '    },\n\n';
                
                // Generate CRUD methods for each resource
                for (var i = 0; i < this.detectedApiEndpoints.length; i++) {
                    var spec = this.detectedApiEndpoints[i];
                    var resource = spec.resourceName.toLowerCase();
                    var Resource = spec.resourceName;
                    
                    code += '    // === ' + Resource + ' Methods (see: api-specs/' + resource + '-api.md) ===\n\n';
                    
                    // List
                    code += '    list' + Resource + 's: function(options) {\n';
                    code += '        options = options || {};\n';
                    code += '        var items = this.getStorage("' + resource + 's") || [];\n';
                    code += '        var start = options.offset || 0;\n';
                    code += '        var end = start + (options.limit || items.length);\n';
                    code += '        return Promise.resolve({ items: items.slice(start, end), total: items.length });\n';
                    code += '    },\n\n';
                    
                    // Get
                    code += '    get' + Resource + ': function(id) {\n';
                    code += '        var items = this.getStorage("' + resource + 's") || [];\n';
                    code += '        var item = items.find(function(i) { return i.id === id; });\n';
                    code += '        if (!item) return Promise.reject(new Error("' + Resource + ' not found"));\n';
                    code += '        return Promise.resolve(item);\n';
                    code += '    },\n\n';
                    
                    // Create
                    code += '    create' + Resource + ': function(data) {\n';
                    code += '        var items = this.getStorage("' + resource + 's") || [];\n';
                    code += '        var newItem = Object.assign({}, data, {\n';
                    code += '            id: this.generateId(),\n';
                    code += '            createdAt: new Date().toISOString(),\n';
                    code += '            updatedAt: new Date().toISOString()\n';
                    code += '        });\n';
                    code += '        items.push(newItem);\n';
                    code += '        this.setStorage("' + resource + 's", items);\n';
                    code += '        return Promise.resolve(newItem);\n';
                    code += '    },\n\n';
                    
                    // Update
                    code += '    update' + Resource + ': function(id, data) {\n';
                    code += '        var items = this.getStorage("' + resource + 's") || [];\n';
                    code += '        var index = items.findIndex(function(i) { return i.id === id; });\n';
                    code += '        if (index === -1) return Promise.reject(new Error("' + Resource + ' not found"));\n';
                    code += '        items[index] = Object.assign({}, items[index], data, {\n';
                    code += '            updatedAt: new Date().toISOString()\n';
                    code += '        });\n';
                    code += '        this.setStorage("' + resource + 's", items);\n';
                    code += '        return Promise.resolve(items[index]);\n';
                    code += '    },\n\n';
                    
                    // Delete
                    code += '    delete' + Resource + ': function(id) {\n';
                    code += '        var items = this.getStorage("' + resource + 's") || [];\n';
                    code += '        var index = items.findIndex(function(i) { return i.id === id; });\n';
                    code += '        if (index === -1) return Promise.reject(new Error("' + Resource + ' not found"));\n';
                    code += '        items.splice(index, 1);\n';
                    code += '        this.setStorage("' + resource + 's", items);\n';
                    code += '        return Promise.resolve({ success: true });\n';
                    code += '    },\n\n';
                }
                
                code += '};\n';
                
                try {
                    await window.aider.writeFile(filePath, code);
                    this.addMessage('system', '  ‚Üí ' + fileName + ' (v' + version + ')');
                } catch (e) {
                    console.log('[Execute] Save API stub error:', e);
                }
            },
            
            // Execute a single task automatically (no UI interaction)
            async executeTask(prompt) {
                // Create streaming message for output
                const msgId = 'task-' + Date.now();
                this.addStreamingMessage(msgId);
                
                let response = '';
                try {
                    await window.aider.runPromptStreaming(prompt, (chunk) => {
                        response += chunk;
                        this.appendToStreamingMessage(msgId, chunk);
                    });
                    
                    this.finalizeStreamingMessage(msgId);
                    
                    // Refresh preview after changes
                    if (this.currentPreviewFile) {
                        setTimeout(() => this.refreshPreview(), 500);
                    }
                    
                    return response;
                } catch (e) {
                    this.finalizeStreamingMessage(msgId);
                    throw e;
                }
            },
            
            // Update the todo file with current status
            async updateTodoFile() {
                if (!this.repoPath || !this.cycleState.todos) return;
                
                const todos = this.cycleState.todos;
                const version = this.cycleState.currentVersion;
                const fileName = `TODO-v${version}.md`;
                
                let content = `# Todo List - v${version}\n`;
                content += `**Objective:** ${this.cycleState.objective}\n`;
                content += `**Updated:** ${new Date().toISOString()}\n\n`;
                content += `## Tasks\n\n`;
                
                todos.forEach((t, i) => {
                    const checkbox = t.status === 'completed' ? '[x]' : '[ ]';
                    content += `${i + 1}. ${checkbox} ${t.task}\n`;
                });
                
                const completed = todos.filter(t => t.status === 'completed').length;
                content += `\n**Progress:** ${completed}/${todos.length} completed\n`;
                content += '\n---\n*Updated by GSX Create Meta Learning*\n';
                
                try {
                    await window.aider.runPrompt(`Update the file ${fileName} with this content:\n\n${content}`);
                } catch (e) {
                    console.log('[Cycle] Update todo file error:', e);
                }
            },
            
            // Test Phase - Run tests and evaluate
            async phaseTest() {
                // Check required files for this phase
                var filesReady = await this.checkPhaseRequiredFiles('test');
                if (!filesReady) {
                    await this.waitForFileApproval();
                }
                
                const testResults = {
                    total: 0,
                    passed: 0,
                    failed: 0,
                    score: 0,
                    consoleErrors: [],
                    failedTests: [],
                    apiTestResults: null,
                    aiAnalysis: ''
                };
                
                if (!this.currentPreviewFile) {
                    this.addMessage('system', '‚ö†Ô∏è No file selected for testing - skipping');
                    return testResults;
                }
                
                // Run basic tests
                this.addMessage('system', 'üß™ Running tests...');
                return testResults;
            }
        };
        
        // Initialize on load - handle case where DOMContentLoaded already fired
        // #region agent log
        console.log('[GSX-DEBUG] H1: Script executing, readyState:', document.readyState);
        fetch('http://127.0.0.1:7242/ingest/54746cc5-c924-4bb5-9e76-3f6b729e6870',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'aider-ui.html:script-start',message:'H1: Script executing',data:{readyState:document.readyState},timestamp:Date.now(),sessionId:'debug-session',hypothesisId:'H1'})}).catch(()=>{});
        // #endregion
        
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                // #region agent log
                console.log('[GSX-DEBUG] H1: DOMContentLoaded fired, calling GSXCreate.init()');
                fetch('http://127.0.0.1:7242/ingest/54746cc5-c924-4bb5-9e76-3f6b729e6870',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'aider-ui.html:DOMContentLoaded',message:'H1: DOMContentLoaded fired',data:{},timestamp:Date.now(),sessionId:'debug-session',hypothesisId:'H1'})}).catch(()=>{});
                // #endregion
                GSXCreate.init();
            });
        } else {
            // DOM already loaded, call init immediately
            // #region agent log
            console.log('[GSX-DEBUG] H1: DOM already loaded, calling GSXCreate.init() immediately');
            fetch('http://127.0.0.1:7242/ingest/54746cc5-c924-4bb5-9e76-3f6b729e6870',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'aider-ui.html:immediate-init',message:'H1: DOM already loaded, calling init immediately',data:{readyState:document.readyState},timestamp:Date.now(),sessionId:'debug-session',hypothesisId:'H1'})}).catch(()=>{});
            // #endregion
            GSXCreate.init();
        }
    </script>
</body>
</html>
