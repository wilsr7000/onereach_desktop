<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GSX Create</title>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: file:; object-src 'self' file:; frame-src 'self' file:; img-src 'self' data: blob: file: https:; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline';">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        :root {
            --bg-primary: #0d0d1a;
            --bg-secondary: #1a1a2e;
            --bg-tertiary: #16213e;
            --accent: #4f8cff;
            --accent-hover: #6ba3ff;
            --success: #4cd964;
            --warning: #ffcc00;
            --danger: #ff3b30;
            --text-primary: #e8e8e8;
            --text-secondary: #a0a0a0;
            --text-muted: #666;
            --border: rgba(255,255,255,0.08);
            --border-light: rgba(255,255,255,0.15);
        }
        
        body {
            font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
            background: var(--bg-primary);
            color: var(--text-primary);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        /* Header */
        .header {
            background: var(--bg-secondary);
            padding: 12px 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }
        
        .header h1 {
            font-size: 16px;
            font-weight: 500;
            color: var(--text-primary);
            letter-spacing: 0.5px;
        }
        
        .header-right {
            display: flex;
            align-items: center;
            gap: 16px;
        }
        
        .cost-display {
            display: none;
            align-items: center;
            gap: 4px;
            padding: 8px 14px 12px 14px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.2s;
            position: relative;
        }
        .cost-display:hover { background: rgba(79,140,255,0.15); }
        .cost-display.visible { display: flex; }
        
        .cost-badge {
            color: var(--success);
            font-weight: 600;
            font-size: 12px;
        }
        .cost-badge.warning { color: var(--warning); }
        .cost-badge.danger { color: var(--danger); }
        .cost-separator {
            color: var(--text-muted);
            font-size: 10px;
        }
        .budget-badge {
            color: var(--text-secondary);
            font-weight: 500;
            font-size: 11px;
        }
        .budget-progress {
            position: absolute;
            bottom: 4px;
            left: 10px;
            right: 10px;
            height: 3px;
            background: var(--bg-primary);
            border-radius: 2px;
            overflow: hidden;
        }
        .budget-fill {
            height: 100%;
            background: var(--success);
            transition: width 0.3s, background 0.3s;
            border-radius: 2px;
        }
        .budget-fill.warning { background: var(--warning); }
        .budget-fill.danger { background: var(--danger); }
        
        .status {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: var(--text-secondary);
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--danger);
        }
        .status-dot.active { background: var(--success); }
        
        /* ===== Tab Navigation Bar ===== */
        .tab-bar {
            display: flex;
            align-items: flex-end;
            gap: 4px;
            padding: 8px 16px 0;
            background: linear-gradient(180deg, var(--bg-secondary) 0%, rgba(26,26,46,0.95) 100%);
            border-bottom: 1px solid var(--border);
            height: 44px;
            flex-shrink: 0;
            overflow-x: auto;
            scrollbar-width: none;
            position: relative;
            z-index: 5;
        }
        .tab-bar::-webkit-scrollbar { display: none; }
        
        .tab-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            font-size: 12px;
            color: var(--text-secondary);
            background: linear-gradient(180deg, rgba(255,255,255,0.02) 0%, transparent 100%);
            border: 1px solid var(--border);
            border-bottom: none;
            border-radius: 10px 10px 0 0;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            white-space: nowrap;
            position: relative;
            min-width: 120px;
            backdrop-filter: blur(8px);
            z-index: 10;
        }
        .tab-item::before {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: transparent;
            transition: background 0.2s;
        }
        .tab-item:hover {
            background: linear-gradient(180deg, rgba(79,140,255,0.08) 0%, rgba(79,140,255,0.02) 100%);
            color: var(--text-primary);
            border-color: rgba(79,140,255,0.3);
            transform: translateY(-1px);
        }
        .tab-item.active {
            background: linear-gradient(180deg, var(--bg-primary) 0%, var(--bg-primary) 100%);
            color: var(--text-primary);
            font-weight: 500;
            border-color: var(--border-light);
            box-shadow: 0 -2px 12px rgba(0,0,0,0.2);
        }
        .tab-item.active::before {
            background: var(--accent);
        }
        .tab-item.active::after {
            content: '';
            position: absolute;
            bottom: -1px;
            left: 0;
            right: 0;
            height: 2px;
            background: var(--bg-primary);
        }
        
        /* Main Overview Tab - Special Styling */
        .tab-item.main-tab {
            background: linear-gradient(135deg, rgba(79,140,255,0.1) 0%, rgba(99,102,241,0.1) 100%);
            border-color: rgba(79,140,255,0.2);
            min-width: 100px;
        }
        .tab-item.main-tab .tab-icon {
            background: linear-gradient(135deg, var(--accent) 0%, #6366f1 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .tab-item.main-tab .tab-label {
            background: linear-gradient(135deg, var(--accent) 0%, #6366f1 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 600;
        }
        .tab-item.main-tab.active {
            background: linear-gradient(180deg, var(--bg-primary) 0%, var(--bg-primary) 100%);
            border-color: rgba(79,140,255,0.3);
        }
        .tab-item.main-tab.active::before {
            background: linear-gradient(90deg, var(--accent) 0%, #6366f1 100%);
        }
        
        /* Tab Content Layout */
        .tab-content-wrapper {
            display: flex;
            flex-direction: column;
            flex: 1;
        }
        .tab-icon {
            font-size: 14px;
            flex-shrink: 0;
        }
        .tab-label {
            font-size: 12px;
            font-weight: 500;
        }
        .tab-version {
            font-size: 9px;
            padding: 2px 6px;
            background: rgba(79,140,255,0.15);
            color: var(--accent);
            border-radius: 10px;
            font-weight: 600;
            letter-spacing: 0.3px;
        }
        .tab-item.active .tab-version {
            background: var(--accent);
            color: #fff;
        }
        
        /* Tab Status Indicator */
        .tab-status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--text-muted);
            flex-shrink: 0;
            position: relative;
        }
        .tab-status-indicator.idle {
            background: var(--text-muted);
        }
        .tab-status-indicator.running {
            background: var(--accent);
            box-shadow: 0 0 8px var(--accent);
            animation: tab-pulse 1.5s ease-in-out infinite;
        }
        .tab-status-indicator.success {
            background: var(--success);
            box-shadow: 0 0 6px var(--success);
        }
        .tab-status-indicator.error {
            background: var(--danger);
            box-shadow: 0 0 6px var(--danger);
        }
        @keyframes tab-pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.6; transform: scale(0.9); }
        }
        
        /* Tab Close Button */
        .tab-close {
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            font-size: 12px;
            opacity: 0;
            transition: all 0.15s;
            margin-left: auto;
            color: var(--text-muted);
        }
        .tab-item:hover .tab-close {
            opacity: 0.7;
        }
        .tab-close:hover {
            opacity: 1 !important;
            background: rgba(255,59,48,0.2);
            color: var(--danger);
        }
        .tab-item.main-tab .tab-close {
            display: none;
        }
        
        /* Hover Tooltip with Progress */
        .tab-tooltip {
            position: absolute;
            bottom: calc(100% + 8px);
            left: 50%;
            transform: translateX(-50%) scale(0.95);
            background: var(--bg-tertiary);
            border: 1px solid var(--border-light);
            border-radius: 10px;
            padding: 12px 16px;
            min-width: 180px;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 1000;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
            pointer-events: none;
        }
        .tab-item:hover .tab-tooltip {
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%) scale(1);
            pointer-events: none !important; /* FIX: Ensure tooltip doesn't block button clicks */
            transition-delay: 0.5s; /* Delay tooltip appearance to reduce sensitivity */
        }
        .tab-item:not(:hover) .tab-tooltip {
            transition-delay: 0s; /* No delay when hiding */
        }
        .tab-tooltip::after {
            content: '';
            position: absolute;
            bottom: -6px;
            left: 50%;
            transform: translateX(-50%) rotate(45deg);
            width: 10px;
            height: 10px;
            background: var(--bg-tertiary);
            border-right: 1px solid var(--border-light);
            border-bottom: 1px solid var(--border-light);
        }
        .tab-tooltip-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border);
        }
        .tab-tooltip-title {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-primary);
        }
        .tab-tooltip-version {
            font-size: 10px;
            padding: 2px 8px;
            background: var(--accent);
            color: #fff;
            border-radius: 10px;
        }
        .tab-tooltip-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 11px;
        }
        .tab-tooltip-row:last-child {
            margin-bottom: 0;
        }
        .tab-tooltip-label {
            color: var(--text-muted);
        }
        .tab-tooltip-value {
            color: var(--text-primary);
            font-weight: 500;
        }
        .tab-tooltip-progress {
            margin-top: 10px;
        }
        .tab-tooltip-progress-label {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            color: var(--text-muted);
            margin-bottom: 4px;
        }
        .tab-tooltip-progress-bar {
            height: 4px;
            background: var(--bg-primary);
            border-radius: 2px;
            overflow: hidden;
        }
        .tab-tooltip-progress-fill {
            height: 100%;
            border-radius: 2px;
            transition: width 0.3s;
        }
        .tab-tooltip-progress-fill.phase {
            background: linear-gradient(90deg, var(--accent) 0%, #6366f1 100%);
        }
        .tab-tooltip-progress-fill.budget {
            background: var(--success);
        }
        .tab-tooltip-progress-fill.budget.warning {
            background: var(--warning);
        }
        .tab-tooltip-progress-fill.budget.danger {
            background: var(--danger);
        }
        
        /* Add Branch Button */
        .tab-add-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            background: transparent;
            border: 2px dashed var(--border);
            border-radius: 10px;
            color: var(--text-muted);
            cursor: pointer;
            font-size: 18px;
            font-weight: 300;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            margin-left: 8px;
            margin-bottom: 4px;
        }
        .tab-add-btn:hover {
            border-color: var(--accent);
            border-style: solid;
            color: var(--accent);
            background: rgba(79,140,255,0.1);
            transform: scale(1.05);
            box-shadow: 0 0 16px rgba(79,140,255,0.2);
        }
        .tab-add-btn:active {
            transform: scale(0.98);
        }
        
        /* Tab Content Container */
        .tab-content-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-height: 0;
        }
        .tab-content {
            display: none;
            flex: 1;
            flex-direction: column;
            overflow: hidden;
            min-height: 0;
        }
        .tab-content.active {
            display: flex;
        }
        
        /* Main Tab Styles */
        .main-tab-content {
            flex: 1;
            overflow-y: auto;
            padding: 24px;
            background: var(--bg-primary);
        }
        .main-tab-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
        }
        .main-tab-header h2 {
            font-size: 20px;
            font-weight: 500;
            color: var(--text-primary);
        }
        .main-tab-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }
        .main-tab-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 20px;
        }
        .main-tab-card h3 {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .main-tab-card h3 .icon {
            font-size: 16px;
        }
        
        /* Branch List in Main Tab */
        .branch-list-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.15s;
            border: 1px solid transparent;
        }
        .branch-list-item:hover {
            border-color: var(--accent);
        }
        .branch-list-item.active {
            border-color: var(--accent);
            background: rgba(79,140,255,0.1);
        }
        .branch-list-item .branch-icon {
            font-size: 18px;
        }
        .branch-list-item .branch-info {
            flex: 1;
        }
        .branch-list-item .branch-name {
            font-size: 13px;
            font-weight: 500;
            color: var(--text-primary);
        }
        .branch-list-item .branch-meta {
            font-size: 11px;
            color: var(--text-muted);
            margin-top: 2px;
        }
        .branch-list-item .branch-cost {
            font-size: 12px;
            font-weight: 500;
            color: var(--success);
        }
        .branch-list-item .branch-actions {
            display: flex;
            gap: 4px;
            opacity: 0;
            transition: opacity 0.15s;
        }
        .branch-list-item:hover .branch-actions {
            opacity: 1;
        }
        .branch-action-btn {
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 12px;
        }
        .branch-action-btn:hover {
            background: var(--accent);
            border-color: var(--accent);
            color: #fff;
        }
        
        /* Budget Overview Card */
        .budget-overview {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }
        .budget-total {
            text-align: center;
            padding: 20px;
            background: var(--bg-tertiary);
            border-radius: 8px;
        }
        .budget-total .amount {
            font-size: 32px;
            font-weight: 600;
            color: var(--text-primary);
        }
        .budget-total .label {
            font-size: 11px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 4px;
        }
        .budget-breakdown {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .budget-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: var(--bg-tertiary);
            border-radius: 6px;
            font-size: 12px;
        }
        .budget-row .name {
            color: var(--text-secondary);
        }
        .budget-row .value {
            color: var(--text-primary);
            font-weight: 500;
        }
        
        /* Global Settings Card */
        .settings-form {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }
        .settings-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .settings-group label {
            font-size: 11px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .settings-input {
            padding: 10px 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 13px;
        }
        .settings-input:focus {
            outline: none;
            border-color: var(--accent);
        }
        
        /* Compare View */
        .compare-container {
            display: flex;
            gap: 16px;
            height: 100%;
        }
        .compare-pane {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--bg-tertiary);
            border-radius: 8px;
            overflow: hidden;
        }
        .compare-pane-header {
            padding: 12px;
            background: var(--bg-primary);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .compare-pane-content {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
            font-family: 'SF Mono', monospace;
            font-size: 12px;
        }
        .diff-line {
            padding: 2px 8px;
            white-space: pre-wrap;
            word-break: break-all;
        }
        .diff-line.added {
            background: rgba(76, 217, 100, 0.15);
            color: var(--success);
        }
        .diff-line.removed {
            background: rgba(255, 59, 48, 0.15);
            color: var(--danger);
        }
        
        /* Main Layout */
        .main-container {
            flex: 1;
            display: flex;
            overflow: hidden;
            min-height: 0; /* Allow flex children to shrink and scroll */
        }
        
        /* Sidebar */
        .sidebar-container {
            display: flex;
            flex-shrink: 0;
        }
        
        .sidebar {
            width: 260px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            overflow-x: hidden;
            transition: width 0.2s ease;
            position: relative;
            padding-bottom: 20px; /* Ensure last section isn't cut off */
        }
        
        .sidebar.collapsed {
            width: 0;
            border-right: none;
        }
        
        .sidebar-toggle {
            position: absolute;
            right: -24px;
            top: 50%;
            transform: translateY(-50%);
            width: 24px;
            height: 60px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-left: none;
            border-radius: 0 8px 8px 0;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            z-index: 100;
        }
        .sidebar-toggle:hover { 
            background: var(--accent); 
            color: #fff; 
        }
        
        .sidebar-section {
            padding: 12px;
            border-bottom: 1px solid var(--border);
        }
        
        .sidebar-section h3 {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-secondary);
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .badge {
            background: var(--accent);
            color: #fff;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
        }
        
        /* Episodic Memory Tabs */
        .episodic-tab {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            color: var(--text-secondary);
            transition: all 0.2s;
        }
        .episodic-tab:hover {
            background: var(--bg-primary);
        }
        .episodic-tab.active {
            background: var(--accent);
            border-color: var(--accent);
            color: #fff;
        }
        
        /* Space Selector */
        .space-selector {
            width: 100%;
            padding: 8px 10px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 12px;
            cursor: pointer;
        }
        .space-selector:focus { outline: none; border-color: var(--accent); }
        
        /* File List */
        .file-list {
            flex: 1;
            overflow-y: auto;
            padding: 8px 0;
            transition: all 0.2s ease;
            border: 2px dashed transparent;
            border-radius: 6px;
        }
        
        .file-list.drag-over {
            border-color: var(--accent);
            background: rgba(59, 130, 246, 0.1);
        }
        
        .file-item {
            padding: 6px 12px;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background 0.15s;
            color: var(--text-secondary);
        }
        .file-item:hover { background: rgba(255,255,255,0.05); }
        .file-item.in-context { 
            background: rgba(79,140,255,0.15); 
            color: var(--accent);
        }
        .file-item .icon { opacity: 0.6; }
        .file-item .preview-icon { 
            margin-left: auto; 
            opacity: 0.4; 
            font-size: 10px;
        }
        .file-item:hover .preview-icon { opacity: 0.8; }
        
        /* Center Area */
        .center-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
            min-height: 0; /* Allow flex children to shrink and scroll */
            overflow: hidden; /* Contain overflow, children handle scrolling */
        }
        
        /* Setup Panel */
        .setup-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding: 20px;
            padding-top: 10px;
            text-align: center;
            overflow-y: auto;
        }
        
        .setup-panel.hidden { display: none; }
        
        .setup-hero {
            max-width: 500px;
        }
        
        .setup-hero img {
            width: 100%;
            max-width: 200px;
            margin-bottom: 12px;
            border-radius: 12px;
            opacity: 0.9;
        }
        
        .setup-hero h2 {
            font-size: 20px;
            font-weight: 500;
            margin-bottom: 8px;
            color: var(--text-primary);
        }
        
        .setup-hero p {
            color: var(--text-secondary);
            font-size: 13px;
            margin-bottom: 16px;
            line-height: 1.5;
        }
        
        .setup-form {
            display: flex;
            flex-direction: column;
            gap: 12px;
            width: 100%;
            max-width: 400px;
        }
        
        .form-group {
            text-align: left;
        }
        
        .form-group label {
            display: block;
            font-size: 11px;
            color: var(--text-secondary);
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .form-select, .form-input {
            width: 100%;
            padding: 10px 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 13px;
        }
        .form-select:focus, .form-input:focus { 
            outline: none; 
            border-color: var(--accent); 
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .btn-primary {
            background: var(--accent);
            color: #fff;
        }
        .btn-primary:hover { background: var(--accent-hover); }
        .btn-primary:disabled { opacity: 0.5; cursor: not-allowed; }
        
        .btn-test {
            background: linear-gradient(135deg, #8b5cf6 0%, #6366f1 100%);
            color: #fff;
            font-size: 16px;
            padding: 8px 12px;
            border-radius: 8px;
            transition: all 0.2s;
        }
        .btn-test:hover { 
            background: linear-gradient(135deg, #7c3aed 0%, #4f46e5 100%);
            transform: scale(1.05);
        }
        .btn-test:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-test.running {
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        
        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border);
        }
        .btn-secondary:hover { background: rgba(255,255,255,0.1); }
        
        .btn-sm {
            padding: 6px 12px;
            font-size: 11px;
        }
        
        /* Chat Area */
        .chat-area {
            flex: 1;
            display: none;
            flex-direction: column;
            overflow: hidden;
        }
        .chat-area.active { display: flex; }
        
        /* Chat Toolbar */
        .chat-toolbar {
            display: flex;
            gap: 8px;
            padding: 8px 12px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            flex-wrap: wrap;
        }
        .chat-toolbar .spacer {
            flex: 1;
        }
        
        /* Feed-style messages */
        .messages {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            font-family: 'SF Mono', 'Fira Code', monospace;
            font-size: 12px;
            line-height: 1.6;
            background: var(--bg-primary);
        }
        
        .message {
            padding: 8px 0;
            border-bottom: 1px solid var(--border);
            display: flex;
            gap: 12px;
        }
        
        .message-time {
            color: var(--text-muted);
            font-size: 10px;
            min-width: 60px;
            flex-shrink: 0;
        }
        
        .message-type {
            min-width: 40px;
            font-weight: 600;
            flex-shrink: 0;
        }
        .message-type.user { color: var(--accent); }
        .message-type.ai { color: var(--success); }
        .message-type.system { color: var(--warning); }
        .message-type.error { color: var(--danger); }
        
        .message-content {
            flex: 1;
            white-space: pre-wrap;
            word-break: break-word;
        }
        
        .message-files {
            margin-top: 8px;
            padding: 8px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            font-size: 11px;
        }
        
        /* Streaming message styles */
        .message-content.streaming {
            background: var(--bg-tertiary);
            padding: 12px;
            border-radius: 6px;
            border-left: 3px solid var(--accent);
        }
        .streaming-status {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: var(--bg-primary);
            border-radius: 6px;
            margin-bottom: 12px;
            font-size: 13px;
        }
        .streaming-status .status-icon {
            font-size: 16px;
        }
        .streaming-status .status-text {
            color: var(--accent);
            font-weight: 500;
            flex: 1;
        }
        .streaming-status .status-timer {
            color: var(--text-muted);
            font-size: 11px;
            font-family: monospace;
        }
        .thinking-indicator {
            color: var(--accent);
            font-style: italic;
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .stream-output {
            margin: 0;
            padding: 0;
            white-space: pre-wrap;
            word-break: break-word;
            font-family: inherit;
            font-size: inherit;
            background: transparent;
            max-height: 400px;
            overflow-y: auto;
        }
        
        /* Collapsible code blocks */
        .code-collapse {
            margin: 8px 0;
            border: 1px solid var(--border);
            border-radius: 6px;
            background: var(--bg-primary);
            overflow: hidden;
        }
        .code-collapse summary {
            padding: 8px 12px;
            cursor: pointer;
            font-size: 12px;
            color: var(--text-muted);
            background: var(--bg-secondary);
            user-select: none;
        }
        .code-collapse summary:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        .code-collapse[open] summary {
            border-bottom: 1px solid var(--border);
        }
        .collapsed-code {
            margin: 0;
            padding: 12px;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
            font-size: 11px;
            line-height: 1.5;
            max-height: 300px;
            overflow-y: auto;
            background: #1a1a1a;
            color: #d4d4d4;
        }
        
        /* Meta Learning Cycle Panel - Minimal */
        .cycle-panel {
            display: none;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            padding: 8px 16px;
            flex-shrink: 0;
        }
        .cycle-panel.visible { display: flex; align-items: center; gap: 16px; }
        .cycle-label {
            font-size: 10px;
            font-weight: 600;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .cycle-version {
            font-size: 10px;
            color: var(--text-muted);
            font-weight: 500;
            min-width: 24px;
        }
        
        /* Inline Phase Pipeline */
        .cycle-pipeline {
            display: flex;
            align-items: center;
            gap: 4px;
            flex: 1;
        }
        .phase-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--border);
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }
        
        /* Execute phase - Hexagon shape, larger */
        .phase-dot#phase-execute {
            width: 12px;
            height: 12px;
            border-radius: 0;
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            margin: 0 -2px; /* Compensate for larger size in flow */
        }
        
        .phase-dot:hover {
            transform: scale(1.3);
        }
        .phase-dot:hover::after {
            content: attr(data-label);
            position: absolute;
            bottom: 14px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 9px;
            color: var(--text-secondary);
            white-space: nowrap;
            background: var(--bg-tertiary);
            padding: 2px 6px;
            border-radius: 3px;
            z-index: 10;
        }
        
        /* Execute hexagon needs adjusted tooltip position */
        .phase-dot#phase-execute:hover::after {
            bottom: 18px;
        }
        
        .phase-dot.active {
            background: var(--accent);
            box-shadow: 0 0 8px var(--accent);
        }
        .phase-dot.completed { background: var(--success); }
        .phase-dot.failed { background: var(--danger); }
        
        /* ========== PHASE-SPECIFIC ACTIVE ANIMATIONS ========== */
        
        /* Evaluate - Radar sweep scanning effect */
        .phase-dot.active#phase-evaluate {
            background: #6366f1;
            box-shadow: 0 0 8px #6366f1;
            animation: radar-sweep 2s infinite linear;
        }
        
        /* Research - Expanding ripple effect */
        .phase-dot.active#phase-research {
            background: #8b5cf6;
            box-shadow: 0 0 8px #8b5cf6;
            animation: ripple-out 1.5s infinite ease-out;
        }
        
        /* Plan - Orbiting pulse effect */
        .phase-dot.active#phase-plan {
            background: #a855f7;
            box-shadow: 0 0 8px #a855f7;
            animation: orbit-pulse 2s infinite ease-in-out;
        }
        
        /* Execute - Heartbeat bounce (hexagon) */
        .phase-dot.active#phase-execute {
            background: #ec4899;
            box-shadow: 0 0 12px #ec4899, 0 0 24px rgba(236, 72, 153, 0.4);
            animation: heartbeat-hex 0.8s infinite ease-in-out;
        }
        
        /* Test - Blinking validation check */
        .phase-dot.active#phase-test {
            background: #f43f5e;
            box-shadow: 0 0 8px #f43f5e;
            animation: blink-check 1s infinite;
        }
        
        /* Improve - Spinning rotation */
        .phase-dot.active#phase-improve {
            background: #f97316;
            box-shadow: 0 0 8px #f97316;
            animation: spin-refine 1.5s infinite linear;
        }
        
        /* Finalize - Glowing shimmer celebration */
        .phase-dot.active#phase-finalize {
            background: #22c55e;
            box-shadow: 0 0 8px #22c55e;
            animation: glow-celebrate 1.2s infinite ease-in-out;
        }
        
        /* ========== KEYFRAME ANIMATIONS ========== */
        
        /* Evaluate: Radar sweep - rotating glow around the dot */
        @keyframes radar-sweep {
            0% {
                box-shadow: 0 0 8px #6366f1, 
                            8px 0 12px rgba(99, 102, 241, 0.6),
                            0 0 2px #6366f1 inset;
            }
            25% {
                box-shadow: 0 0 8px #6366f1, 
                            0 8px 12px rgba(99, 102, 241, 0.6),
                            0 0 2px #6366f1 inset;
            }
            50% {
                box-shadow: 0 0 8px #6366f1, 
                            -8px 0 12px rgba(99, 102, 241, 0.6),
                            0 0 2px #6366f1 inset;
            }
            75% {
                box-shadow: 0 0 8px #6366f1, 
                            0 -8px 12px rgba(99, 102, 241, 0.6),
                            0 0 2px #6366f1 inset;
            }
            100% {
                box-shadow: 0 0 8px #6366f1, 
                            8px 0 12px rgba(99, 102, 241, 0.6),
                            0 0 2px #6366f1 inset;
            }
        }
        
        /* Research: Ripple - expanding rings outward */
        @keyframes ripple-out {
            0% {
                box-shadow: 0 0 0 0 rgba(139, 92, 246, 0.7),
                            0 0 0 0 rgba(139, 92, 246, 0.5),
                            0 0 0 0 rgba(139, 92, 246, 0.3);
            }
            100% {
                box-shadow: 0 0 0 4px rgba(139, 92, 246, 0),
                            0 0 0 8px rgba(139, 92, 246, 0),
                            0 0 0 12px rgba(139, 92, 246, 0);
            }
        }
        
        /* Plan: Orbit - pulsing with slight rotation feel */
        @keyframes orbit-pulse {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 0 8px #a855f7, 
                            4px 0 6px rgba(168, 85, 247, 0.5),
                            -4px 0 6px rgba(168, 85, 247, 0.5);
            }
            50% {
                transform: scale(1.1);
                box-shadow: 0 0 12px #a855f7, 
                            0 4px 6px rgba(168, 85, 247, 0.5),
                            0 -4px 6px rgba(168, 85, 247, 0.5);
            }
        }
        
        /* Execute: Heartbeat - strong energetic bounce */
        @keyframes heartbeat-hex {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 0 12px #ec4899, 0 0 24px rgba(236, 72, 153, 0.4);
            }
            14% {
                transform: scale(1.3);
                box-shadow: 0 0 20px #ec4899, 0 0 40px rgba(236, 72, 153, 0.6);
            }
            28% {
                transform: scale(1);
                box-shadow: 0 0 12px #ec4899, 0 0 24px rgba(236, 72, 153, 0.4);
            }
            42% {
                transform: scale(1.2);
                box-shadow: 0 0 16px #ec4899, 0 0 32px rgba(236, 72, 153, 0.5);
            }
            56% {
                transform: scale(1);
                box-shadow: 0 0 12px #ec4899, 0 0 24px rgba(236, 72, 153, 0.4);
            }
        }
        
        /* Test: Blink check - quick validation flash */
        @keyframes blink-check {
            0%, 100% {
                opacity: 1;
                box-shadow: 0 0 8px #f43f5e;
            }
            25% {
                opacity: 0.4;
                box-shadow: 0 0 4px #f43f5e;
            }
            50% {
                opacity: 1;
                box-shadow: 0 0 16px #f43f5e, 0 0 4px #fff inset;
            }
            75% {
                opacity: 0.6;
                box-shadow: 0 0 6px #f43f5e;
            }
        }
        
        /* Improve: Spin refine - rotating improvement */
        @keyframes spin-refine {
            0% {
                box-shadow: 0 0 8px #f97316,
                            6px 0 0 rgba(249, 115, 22, 0.8);
            }
            25% {
                box-shadow: 0 0 8px #f97316,
                            0 6px 0 rgba(249, 115, 22, 0.8);
            }
            50% {
                box-shadow: 0 0 8px #f97316,
                            -6px 0 0 rgba(249, 115, 22, 0.8);
            }
            75% {
                box-shadow: 0 0 8px #f97316,
                            0 -6px 0 rgba(249, 115, 22, 0.8);
            }
            100% {
                box-shadow: 0 0 8px #f97316,
                            6px 0 0 rgba(249, 115, 22, 0.8);
            }
        }
        
        /* Finalize: Glow celebrate - victorious shimmer */
        @keyframes glow-celebrate {
            0%, 100% {
                box-shadow: 0 0 8px #22c55e,
                            0 0 16px rgba(34, 197, 94, 0.3);
                filter: brightness(1);
            }
            50% {
                box-shadow: 0 0 16px #22c55e,
                            0 0 32px rgba(34, 197, 94, 0.5),
                            0 0 48px rgba(34, 197, 94, 0.2);
                filter: brightness(1.2);
            }
        }
        
        /* Fallback pulse for any phase without specific animation */
        @keyframes pulse-dot {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .phase-line {
            width: 20px;
            height: 1px;
            background: var(--border);
        }
        .phase-line.active { background: var(--accent); }
        .phase-line.completed { background: var(--success); }
        
        /* Compact Version Pills */
        .version-timeline {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .version-pill {
            padding: 2px 8px;
            background: transparent;
            border: 1px solid var(--border);
            border-radius: 10px;
            font-size: 9px;
            color: var(--text-muted);
            cursor: pointer;
            transition: all 0.2s;
        }
        .version-pill:hover {
            border-color: var(--accent);
            color: var(--text-primary);
        }
        .version-pill.current {
            background: var(--accent);
            border-color: var(--accent);
            color: #fff;
        }
        .version-pill.add {
            border-style: dashed;
            padding: 2px 6px;
        }
        .version-pill.active {
            background: var(--accent);
            border-color: var(--accent);
            color: #fff;
        }
        .version-pill.has-backup {
            border-color: var(--success, #4caf50);
        }
        .version-pill.has-backup:hover {
            background: rgba(76, 175, 80, 0.15);
        }
        
        /* Branch Tabs */
        .branch-tabs {
            display: flex;
            gap: 4px;
            padding: 4px 8px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
        }
        .branch-tab {
            padding: 4px 10px;
            font-size: 11px;
            border-radius: 6px;
            cursor: pointer;
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.15s;
        }
        .branch-tab:hover {
            background: rgba(255,255,255,0.05);
            border-color: var(--accent);
        }
        .branch-tab.active {
            background: var(--accent);
            border-color: var(--accent);
            color: #fff;
        }
        .branch-tab .status {
            font-size: 9px;
            opacity: 0.7;
        }
        
        /* Multi-Progress Bar */
        .multi-progress {
            display: flex;
            flex-direction: column;
            gap: 4px;
            padding: 8px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
        }
        .branch-progress {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 11px;
        }
        .branch-progress .branch-id {
            min-width: 40px;
            font-weight: 600;
        }
        .branch-progress .progress-bar {
            flex: 1;
            height: 6px;
            background: var(--bg-primary);
            border-radius: 3px;
            overflow: hidden;
        }
        .branch-progress .progress-fill {
            height: 100%;
            background: var(--accent);
            transition: width 0.3s;
        }
        .branch-progress .branch-status {
            min-width: 80px;
            font-size: 10px;
            color: var(--text-muted);
        }
        .branch-progress .branch-model {
            font-size: 10px;
            color: var(--text-muted);
            opacity: 0.7;
        }
        
        /* ===== Branch Control Panel (DEPRECATED - Now using Tabbed UI) ===== */
        .branch-control-panel {
            display: none !important; /* Deprecated: Each branch now has its own tab */
        }
        .branch-control-panel.visible {
            display: none !important; /* Deprecated: Each branch now has its own tab */
        }
        
        .branch-control-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border);
        }
        .branch-control-header h4 {
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-secondary);
            margin: 0;
        }
        
        .branch-budget-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 11px;
        }
        .branch-budget-indicator .budget-spent {
            color: var(--accent);
            font-weight: 600;
        }
        .branch-budget-indicator .budget-separator {
            color: var(--text-muted);
        }
        .branch-budget-indicator .budget-total {
            color: var(--text-secondary);
        }
        .branch-budget-bar {
            width: 60px;
            height: 4px;
            background: var(--bg-primary);
            border-radius: 2px;
            overflow: hidden;
        }
        .branch-budget-bar .budget-fill {
            height: 100%;
            background: var(--success);
            transition: width 0.3s, background 0.3s;
        }
        .branch-budget-bar .budget-fill.warning { background: var(--warning); }
        .branch-budget-bar .budget-fill.danger { background: var(--danger); }
        
        .branch-timeline {
            padding: 8px 12px;
        }
        
        .branch-row {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 6px 8px;
            margin-bottom: 4px;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.15s;
            border: 1px solid transparent;
        }
        .branch-row:hover {
            background: rgba(255,255,255,0.03);
        }
        .branch-row.focused {
            background: rgba(79,140,255,0.1);
            border-color: var(--accent);
        }
        .branch-row.main-branch {
            opacity: 0.7;
        }
        .branch-row.main-branch.focused {
            opacity: 1;
        }
        
        .branch-selector {
            width: 14px;
            height: 14px;
            border: 2px solid var(--border-light);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        .branch-row.focused .branch-selector {
            border-color: var(--accent);
        }
        .branch-row.focused .branch-selector::after {
            content: '';
            width: 6px;
            height: 6px;
            background: var(--accent);
            border-radius: 50%;
        }
        
        .branch-name {
            min-width: 100px;
            max-width: 120px;
            font-size: 11px;
            font-weight: 500;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .branch-row.main-branch .branch-name {
            font-weight: 600;
        }
        
        .branch-gantt-bar {
            flex: 1;
            height: 16px;
            background: var(--bg-primary);
            border-radius: 3px;
            display: flex;
            overflow: hidden;
            position: relative;
        }
        
        .phase-segment {
            height: 100%;
            transition: flex 0.3s, opacity 0.3s;
            position: relative;
        }
        .phase-segment.evaluate { background: #6366f1; }
        .phase-segment.research { background: #8b5cf6; }
        .phase-segment.plan { background: #a855f7; }
        .phase-segment.execute { background: #ec4899; }
        .phase-segment.test { background: #f43f5e; }
        .phase-segment.improve { background: #f97316; }
        .phase-segment.finalize { background: #22c55e; }
        
        .phase-segment.completed {
            opacity: 1;
        }
        .phase-segment.current {
            opacity: 1;
            animation: pulse-phase 1.5s infinite;
        }
        .phase-segment.pending {
            opacity: 0.2;
        }
        
        @keyframes pulse-phase {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        
        .branch-cost {
            min-width: 50px;
            font-size: 11px;
            font-weight: 600;
            color: var(--accent);
            text-align: right;
        }
        .branch-cost.high {
            color: var(--warning);
        }
        .branch-cost.very-high {
            color: var(--danger);
        }
        
        .branch-phase-label {
            min-width: 60px;
            font-size: 10px;
            color: var(--text-muted);
            text-align: center;
        }
        .branch-phase-label.running {
            color: var(--accent);
        }
        .branch-phase-label.completed {
            color: var(--success);
        }
        .branch-phase-label.failed {
            color: var(--danger);
        }
        
        .branch-actions {
            display: flex;
            gap: 4px;
            opacity: 0;
            transition: opacity 0.15s;
        }
        .branch-row:hover .branch-actions {
            opacity: 1;
        }
        .branch-actions button {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: 2px 4px;
            font-size: 12px;
            border-radius: 4px;
            transition: all 0.15s;
        }
        .branch-actions button:hover {
            background: rgba(255,255,255,0.1);
            color: var(--text-primary);
        }
        .branch-actions button.promote {
            color: var(--success);
        }
        .branch-actions button.delete {
            color: var(--danger);
        }
        
        .phase-legend {
            display: flex;
            gap: 12px;
            padding: 6px 12px;
            border-top: 1px solid var(--border);
            background: var(--bg-tertiary);
            flex-wrap: wrap;
        }
        .phase-legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 9px;
            color: var(--text-muted);
            cursor: default;
        }
        .phase-legend-item .phase-dot {
            width: 8px;
            height: 8px;
            border-radius: 2px;
        }
        .phase-legend-item .phase-dot.evaluate { background: #6366f1; }
        .phase-legend-item .phase-dot.research { background: #8b5cf6; }
        .phase-legend-item .phase-dot.plan { background: #a855f7; }
        .phase-legend-item .phase-dot.execute { background: #ec4899; }
        .phase-legend-item .phase-dot.test { background: #f43f5e; }
        .phase-legend-item .phase-dot.improve { background: #f97316; }
        .phase-legend-item .phase-dot.finalize { background: #22c55e; }
        
        .phase-legend-item:hover {
            color: var(--text-primary);
        }
        .phase-legend-item:hover .phase-dot {
            transform: scale(1.3);
            transition: transform 0.15s;
        }
        
        /* Phase tooltip on hover */
        .phase-legend-item {
            position: relative;
        }
        .phase-legend-item::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-primary);
            border: 1px solid var(--border);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 10px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            z-index: 10;
        }
        .phase-legend-item:hover::after {
            opacity: 1;
        }
        
        /* Cost Breakdown Panel */
        .cost-breakdown-panel {
            background: var(--bg-tertiary);
            border-top: 1px solid var(--border);
            padding: 8px 12px;
            display: none;
        }
        .cost-breakdown-panel.visible {
            display: block;
        }
        .cost-breakdown-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }
        .cost-breakdown-header h5 {
            font-size: 10px;
            font-weight: 600;
            color: var(--text-secondary);
            margin: 0;
        }
        .cost-breakdown-header .branch-model {
            font-size: 10px;
            color: var(--text-muted);
            background: var(--bg-primary);
            padding: 2px 6px;
            border-radius: 4px;
        }
        .branch-rationale {
            font-size: 11px;
            color: var(--text-secondary);
            padding: 8px;
            background: var(--bg-primary);
            border-radius: 6px;
            margin-bottom: 8px;
            line-height: 1.4;
        }
        .branch-rationale .focus-tag {
            display: inline-block;
            padding: 2px 6px;
            background: var(--accent);
            color: white;
            border-radius: 4px;
            font-size: 9px;
            font-weight: 600;
            margin-right: 6px;
        }
        .cost-breakdown-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 4px;
        }
        .cost-breakdown-item {
            text-align: center;
            padding: 4px 2px;
            background: var(--bg-primary);
            border-radius: 4px;
        }
        .cost-breakdown-item .phase-name {
            font-size: 8px;
            color: var(--text-muted);
            text-transform: uppercase;
            margin-bottom: 2px;
        }
        .cost-breakdown-item .phase-cost {
            font-size: 10px;
            font-weight: 600;
            color: var(--text-primary);
        }
        .cost-breakdown-item.current {
            border: 1px solid var(--accent);
        }
        
        /* Branch row tooltip */
        .branch-row {
            position: relative;
        }
        .branch-tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-primary);
            border: 1px solid var(--border);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 11px;
            max-width: 300px;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            margin-bottom: 6px;
        }
        .branch-row:hover .branch-tooltip {
            opacity: 1;
        }
        .branch-tooltip .tooltip-title {
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 4px;
        }
        .branch-tooltip .tooltip-desc {
            color: var(--text-secondary);
            line-height: 1.4;
        }
        .branch-tooltip .tooltip-focus {
            margin-top: 6px;
            font-size: 10px;
        }
        .branch-tooltip .tooltip-focus span {
            display: inline-block;
            padding: 2px 6px;
            background: var(--accent);
            color: white;
            border-radius: 4px;
            margin-right: 4px;
        }
        
        /* ===== Branch Chat Tabs ===== */
        .branch-chat-tabs {
            display: flex;
            gap: 2px;
            padding: 8px 12px 0;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            overflow-x: auto;
        }
        .branch-tab {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 14px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-bottom: none;
            border-radius: 8px 8px 0 0;
            cursor: pointer;
            font-size: 12px;
            color: var(--text-secondary);
            transition: all 0.15s;
            white-space: nowrap;
            position: relative;
            top: 1px;
        }
        .branch-tab:hover {
            background: var(--bg-primary);
            color: var(--text-primary);
        }
        .branch-tab.active {
            background: var(--bg-primary);
            color: var(--text-primary);
            border-bottom: 1px solid var(--bg-primary);
            font-weight: 500;
        }
        .branch-tab-icon {
            font-size: 14px;
        }
        .branch-tab-name {
            max-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .branch-tab-status {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--text-muted);
        }
        .branch-tab-status.running {
            background: var(--warning);
            animation: pulse 1.5s infinite;
        }
        .branch-tab-status.complete {
            background: var(--success);
        }
        .branch-tab-status.error {
            background: var(--danger);
        }
        .branch-tab .close-btn {
            margin-left: 6px;
            opacity: 0;
            font-size: 14px;
            color: var(--text-muted);
            transition: opacity 0.15s;
        }
        .branch-tab:hover .close-btn {
            opacity: 0.7;
        }
        .branch-tab .close-btn:hover {
            opacity: 1;
            color: var(--danger);
        }
        
        /* Messages wrapper for branch switching */
        .messages-wrapper {
            flex: 1;
            display: flex;
            overflow: hidden;
        }
        .messages.branch-messages {
            display: none;
            flex: 1;
            overflow-y: auto;
        }
        .messages.branch-messages.active {
            display: block;
        }
        
        /* Compact Progress */
        .cycle-progress {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 10px;
            color: var(--text-muted);
        }
        .progress-bar-mini {
            width: 40px;
            height: 3px;
            background: var(--bg-primary);
            border-radius: 2px;
            overflow: hidden;
        }
        .progress-fill-mini {
            height: 100%;
            background: var(--accent);
            transition: width 0.3s;
        }
        .progress-fill-mini.good { background: var(--success); }
        .progress-fill-mini.warning { background: var(--warning); }
        
        /* Cycle Control Button - Consciousness Spark */
        .cycle-ctrl {
            width: 32px;
            height: 32px;
            border: none;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,255,255,0.15) 0%, transparent 70%);
            color: rgba(255,255,255,0.4);
            font-size: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.5s ease;
            box-shadow: 0 0 3px rgba(255,255,255,0.1);
            position: relative;
        }
        
        /* Dormant state - tiny ember pulse */
        .cycle-ctrl::before {
            content: '';
            position: absolute;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: rgba(255,255,255,0.6);
            animation: ember-pulse 3s ease-in-out infinite;
        }
        
        @keyframes ember-pulse {
            0%, 100% { opacity: 0.4; transform: scale(0.8); }
            50% { opacity: 0.7; transform: scale(1); }
        }
        
        .cycle-ctrl:hover {
            background: radial-gradient(circle, rgba(255,255,255,0.3) 0%, transparent 70%);
            box-shadow: 0 0 15px rgba(255,255,255,0.3);
        }
        
        .cycle-ctrl:hover::before {
            opacity: 1;
            transform: scale(1.2);
        }
        
        /* Igniting state - the awakening flash */
        .cycle-ctrl.igniting {
            animation: ignite 0.6s ease-out forwards;
        }
        
        .cycle-ctrl.igniting::before {
            animation: ignite-core 0.6s ease-out forwards;
        }
        
        @keyframes ignite {
            0% { 
                transform: scale(1); 
                box-shadow: 0 0 3px rgba(255,255,255,0.1);
            }
            30% { 
                transform: scale(1.2); 
                box-shadow: 
                    0 0 20px rgba(255,255,255,0.9),
                    0 0 40px rgba(255,255,255,0.6),
                    0 0 60px rgba(255,255,255,0.3);
            }
            100% { 
                transform: scale(1); 
                box-shadow: 
                    0 0 10px rgba(255,255,255,0.7),
                    0 0 25px rgba(255,255,255,0.4),
                    0 0 40px rgba(255,255,255,0.2);
            }
        }
        
        @keyframes ignite-core {
            0% { transform: scale(1); opacity: 0.6; }
            30% { transform: scale(3); opacity: 1; }
            100% { transform: scale(1.5); opacity: 0.9; }
        }
        
        /* Alive state - consciousness running, breathing glow */
        .cycle-ctrl.alive {
            background: radial-gradient(circle, rgba(255,255,255,0.5) 0%, transparent 70%);
            box-shadow: 
                0 0 10px rgba(255,255,255,0.7),
                0 0 25px rgba(255,255,255,0.4),
                0 0 40px rgba(255,255,255,0.2);
            animation: breathe 3s ease-in-out infinite;
        }
        
        .cycle-ctrl.alive::before {
            width: 10px;
            height: 10px;
            background: rgba(255,255,255,0.9);
            animation: breathe-core 3s ease-in-out infinite;
        }
        
        @keyframes breathe {
            0%, 100% { 
                transform: scale(1); 
                box-shadow: 
                    0 0 10px rgba(255,255,255,0.6),
                    0 0 25px rgba(255,255,255,0.3),
                    0 0 40px rgba(255,255,255,0.15);
            }
            50% { 
                transform: scale(1.03); 
                box-shadow: 
                    0 0 15px rgba(255,255,255,0.8),
                    0 0 30px rgba(255,255,255,0.5),
                    0 0 50px rgba(255,255,255,0.25);
            }
        }
        
        @keyframes breathe-core {
            0%, 100% { transform: scale(1); opacity: 0.85; }
            50% { transform: scale(1.1); opacity: 1; }
        }
        
        /* Thinking state - intensified rhythmic glow */
        .cycle-ctrl.thinking {
            animation: think 1.5s ease-in-out infinite;
        }
        
        .cycle-ctrl.thinking::before {
            animation: think-core 1.5s ease-in-out infinite;
        }
        
        @keyframes think {
            0%, 100% { 
                box-shadow: 
                    0 0 10px rgba(255,255,255,0.7),
                    0 0 25px rgba(255,255,255,0.4);
            }
            50% { 
                box-shadow: 
                    0 0 20px rgba(255,255,255,0.9),
                    0 0 40px rgba(255,255,255,0.6),
                    0 0 60px rgba(255,255,255,0.3);
            }
        }
        
        @keyframes think-core {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.3); }
        }
        
        /* Paused state - gentle rest, not death */
        .cycle-ctrl.paused {
            background: radial-gradient(circle, rgba(255,255,255,0.25) 0%, transparent 70%);
            box-shadow: 0 0 8px rgba(255,255,255,0.3);
            animation: rest 4s ease-in-out infinite;
        }
        
        .cycle-ctrl.paused::before {
            width: 8px;
            height: 8px;
            animation: rest-core 4s ease-in-out infinite;
        }
        
        @keyframes rest {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 0.9; }
        }
        
        @keyframes rest-core {
            0%, 100% { opacity: 0.5; transform: scale(0.9); }
            50% { opacity: 0.7; transform: scale(1); }
        }
        
        /* Legacy running state - map to alive */
        .cycle-ctrl.running {
            background: radial-gradient(circle, rgba(255,255,255,0.5) 0%, transparent 70%);
            box-shadow: 
                0 0 10px rgba(255,255,255,0.7),
                0 0 25px rgba(255,255,255,0.4),
                0 0 40px rgba(255,255,255,0.2);
            animation: breathe 3s ease-in-out infinite;
        }
        
        .cycle-ctrl.running::before {
            width: 10px;
            height: 10px;
            background: rgba(255,255,255,0.9);
            animation: breathe-core 3s ease-in-out infinite;
        }
        .cycle-auto-toggle {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: transparent;
            color: var(--text-muted);
            border: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            margin-left: 6px;
            opacity: 0.5;
            flex-shrink: 0;
        }
        .cycle-auto-toggle:hover {
            opacity: 1;
            border-color: var(--text-secondary);
            color: var(--text-secondary);
        }
        .cycle-auto-toggle.active {
            background: var(--accent);
            color: #fff;
            border-color: var(--accent);
            opacity: 1;
        }
        .cycle-auto-toggle svg {
            width: 10px;
            height: 10px;
        }
        .cycle-help {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            font-size: 10px;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            margin-left: auto;
        }
        .cycle-help:hover {
            background: var(--accent);
            color: #fff;
        }
        .progress-label {
            color: var(--text-secondary);
        }
        .progress-bar {
            width: 120px;
            height: 6px;
            background: var(--bg-primary);
            border-radius: 3px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: var(--accent);
            border-radius: 3px;
            transition: width 0.3s;
        }
        .progress-fill.good { background: var(--success); }
        .progress-fill.warning { background: var(--warning); }
        .progress-fill.danger { background: var(--danger); }
        .progress-score {
            font-weight: 600;
            color: var(--text-primary);
        }
        .progress-target {
            color: var(--text-muted);
        }
        
        /* Test Agent Styles */
        .test-tab {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            color: var(--text-secondary);
        }
        .test-tab.active {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }
        .test-panel {
            display: none;
        }
        .test-panel.active {
            display: block;
        }
        .test-result-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 12px;
            background: var(--bg-tertiary);
            border-radius: 6px;
            margin-bottom: 8px;
        }
        .test-result-item.passed {
            border-left: 3px solid var(--success);
        }
        .test-result-item.failed {
            border-left: 3px solid var(--error);
        }
        .test-status-icon {
            font-size: 16px;
        }
        .test-name {
            flex: 1;
            font-size: 12px;
            color: var(--text-primary);
        }
        .test-duration {
            font-size: 11px;
            color: var(--text-muted);
        }
        .accessibility-issue {
            padding: 10px 12px;
            background: var(--bg-tertiary);
            border-radius: 6px;
            margin-bottom: 8px;
            font-size: 12px;
        }
        .accessibility-issue.error {
            border-left: 3px solid var(--error);
        }
        .accessibility-issue.warning {
            border-left: 3px solid #f59e0b;
        }
        .performance-metric {
            display: flex;
            justify-content: space-between;
            padding: 8px 12px;
            background: var(--bg-tertiary);
            border-radius: 6px;
            margin-bottom: 6px;
        }
        .performance-score {
            font-size: 48px;
            font-weight: 700;
            text-align: center;
            padding: 20px;
        }
        .performance-score.good { color: var(--success); }
        .performance-score.ok { color: #f59e0b; }
        .performance-score.bad { color: var(--error); }
        
        /* Code Tools */
        .code-tool-tab {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
        }
        .code-tool-tab.active {
            background: var(--accent);
            border-color: var(--accent);
            color: #fff;
        }
        .code-tool-panel {
            display: none;
        }
        .code-tool-panel.active {
            display: block;
        }
        .code-result-item {
            padding: 10px;
            border-bottom: 1px solid var(--border);
            cursor: pointer;
            transition: background 0.2s;
        }
        .code-result-item:hover {
            background: var(--bg-tertiary);
        }
        .code-result-file {
            color: var(--accent);
            font-weight: 600;
            margin-bottom: 4px;
        }
        .code-result-line {
            color: var(--text-muted);
            font-size: 10px;
        }
        .code-result-content {
            color: var(--text-primary);
            background: var(--bg-primary);
            padding: 6px 8px;
            border-radius: 4px;
            margin-top: 6px;
            overflow-x: auto;
        }
        
        .file-change {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 0;
        }
        .file-change.created { color: var(--success); }
        .file-change.modified { color: var(--warning); }
        
        /* Input Area */
        .input-area {
            padding: 12px 16px;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border);
            display: flex;
            gap: 12px;
            align-items: flex-end;
        }
        
        .input-wrapper {
            flex: 1;
            display: flex;
            align-items: center;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 0 12px;
        }
        
        .input-prefix {
            color: var(--accent);
            font-weight: bold;
            margin-right: 8px;
        }
        
        .input-wrapper textarea {
            flex: 1;
            background: transparent;
            border: none;
            color: var(--text-primary);
            font-family: inherit;
            font-size: 13px;
            padding: 10px 0;
            resize: none;
            min-height: 40px;
            max-height: 150px;
        }
        .input-wrapper textarea:focus { outline: none; }
        .input-wrapper textarea::placeholder { color: var(--text-muted); }
        
        /* Preview Panel - Always visible split view */
        .preview-panel {
            width: 50%;
            min-width: 300px;
            max-width: 70%;
            background: var(--bg-secondary);
            border-left: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            position: relative;
        }
        .preview-panel.active { display: flex; }
        
        /* Center area takes remaining space in split view */
        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        .main-container .center-area {
            flex: 1;
            min-width: 300px;
        }
        .preview-panel.collapsed { 
            width: 40px !important; 
            min-width: 40px !important; 
        }
        .preview-panel.collapsed .preview-content,
        .preview-panel.collapsed .preview-header > *:not(.preview-toggle) {
            display: none;
        }
        
        /* Resize handle for preview panel - left edge */
        .preview-resize-handle {
            position: absolute;
            left: -3px;
            top: 0;
            bottom: 0;
            width: 8px;
            cursor: ew-resize;
            background: transparent;
            z-index: 20;
        }
        .preview-resize-handle::after {
            content: '';
            position: absolute;
            left: 3px;
            top: 0;
            bottom: 0;
            width: 2px;
            background: transparent;
            transition: background 0.2s;
        }
        .preview-resize-handle:hover::after,
        .preview-resize-handle.dragging::after {
            background: var(--accent);
        }
        
        /* Preview toggle button */
        .preview-toggle {
            position: absolute;
            left: -20px;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
            height: 48px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-right: none;
            border-radius: 6px 0 0 6px;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            transition: background 0.2s;
            z-index: 15;
        }
        .preview-toggle:hover { 
            background: var(--accent); 
            color: #fff; 
        }
        
        .preview-header {
            padding: 10px 12px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }
        
        .preview-tabs {
            display: flex;
            gap: 4px;
        }
        
        .preview-tab {
            padding: 4px 10px;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 11px;
            cursor: pointer;
            border-radius: 4px;
        }
        .preview-tab.active {
            background: var(--accent);
            color: #fff;
        }
        
        .preview-actions {
            display: flex;
            gap: 4px;
        }
        
        .preview-actions button {
            padding: 4px 8px;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            color: var(--text-secondary);
            font-size: 10px;
            border-radius: 4px;
            cursor: pointer;
        }
        .preview-actions button:hover { 
            background: var(--accent); 
            color: #fff; 
            border-color: var(--accent);
        }
        
        .preview-content {
            flex: 1;
            overflow: hidden;
            background: var(--bg-primary);
            position: relative;
        }
        
        .preview-content iframe {
            width: 100%;
            height: 100%;
            border: none;
        }
        
        .preview-empty {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-muted);
            font-size: 12px;
        }
        
        /* Docked Activity Bar in Preview Panel */
        .preview-activity-bar {
            padding: 10px 14px;
            background: linear-gradient(135deg, rgba(79, 140, 255, 0.1) 0%, rgba(99, 102, 241, 0.1) 100%);
            border-bottom: 1px solid var(--border);
            display: none;
            flex-direction: column;
            gap: 8px;
        }
        .preview-activity-bar.active {
            display: flex;
        }
        .activity-bar-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .activity-bar-phase {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .activity-phase-badge {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            background: var(--accent);
            color: #fff;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 500;
        }
        .activity-phase-badge.evaluate { background: #6366f1; }
        .activity-phase-badge.research { background: #8b5cf6; }
        .activity-phase-badge.plan { background: #0ea5e9; }
        .activity-phase-badge.execute { background: #22c55e; }
        .activity-phase-badge.test { background: #f59e0b; }
        .activity-phase-badge.improve { background: #ec4899; }
        .activity-phase-badge.finalize { background: #10b981; }
        .activity-phase-badge.idle { background: var(--text-muted); }
        
        .activity-bar-progress {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .activity-progress-bar {
            flex: 1;
            height: 4px;
            background: var(--bg-primary);
            border-radius: 2px;
            overflow: hidden;
        }
        .activity-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent) 0%, #6366f1 100%);
            border-radius: 2px;
            transition: width 0.3s ease;
        }
        .activity-progress-text {
            font-size: 10px;
            color: var(--text-secondary);
            min-width: 40px;
            text-align: right;
        }
        
        .activity-bar-details {
            display: flex;
            gap: 16px;
            font-size: 11px;
        }
        .activity-detail {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .activity-detail-label {
            color: var(--text-muted);
        }
        .activity-detail-value {
            color: var(--text-primary);
            font-weight: 500;
            max-width: 200px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        /* Welcome State for Preview */
        .preview-welcome {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px;
            text-align: center;
            background: linear-gradient(180deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
        }
        .preview-welcome-icon {
            font-size: 64px;
            margin-bottom: 20px;
            opacity: 0.6;
        }
        .preview-welcome-title {
            font-size: 18px;
            font-weight: 500;
            color: var(--text-primary);
            margin-bottom: 8px;
        }
        .preview-welcome-subtitle {
            font-size: 13px;
            color: var(--text-secondary);
            max-width: 280px;
            line-height: 1.5;
        }
        .preview-welcome-status {
            margin-top: 24px;
            padding: 12px 20px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 8px;
            font-size: 12px;
            color: var(--text-secondary);
        }
        .preview-welcome-status.building {
            background: rgba(79, 140, 255, 0.1);
            border-color: var(--accent);
            color: var(--accent);
        }
        .preview-welcome-status.building::before {
            content: ' ';
        }
        
        /* Pulsing animation for building state */
        @keyframes pulse-border {
            0%, 100% { border-color: var(--accent); box-shadow: 0 0 0 0 rgba(79, 140, 255, 0.4); }
            50% { border-color: #6366f1; box-shadow: 0 0 20px 0 rgba(79, 140, 255, 0.2); }
        }
        .preview-panel.building {
            animation: pulse-border 2s ease-in-out infinite;
        }
        
        /* Config Panel (collapsible) */
        .config-panel {
            padding: 12px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border);
            display: none;
        }
        .config-panel.active { display: block; }
        
        .config-row {
            display: flex;
            gap: 12px;
            margin-bottom: 10px;
        }
        
        .config-row:last-child { margin-bottom: 0; }
        
        .config-group {
            flex: 1;
        }
        
        .config-group label {
            display: block;
            font-size: 10px;
            color: var(--text-secondary);
            margin-bottom: 4px;
            text-transform: uppercase;
        }
        
        .config-group select,
        .config-group input {
            width: 100%;
            padding: 6px 8px;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 11px;
        }
        
        /* Global Instructions */
        .global-instructions {
            padding: 12px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border);
            display: none;
        }
        .global-instructions.active { display: block; }
        
        .global-instructions textarea {
            width: 100%;
            height: 80px;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 11px;
            padding: 8px;
            resize: vertical;
            font-family: inherit;
        }
        
        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        .modal.active { display: flex; }
        
        .modal-content {
            background: var(--bg-secondary);
            border-radius: 12px;
            width: 90%;
            max-width: 800px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            border: 1px solid var(--border);
        }
        
        .modal-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .modal-header h3 { font-size: 14px; font-weight: 500; }
        
        .modal-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 20px;
            cursor: pointer;
        }
        
        .modal-body {
            flex: 1;
            overflow-y: auto;
            padding: 16px 20px;
        }
        
        /* Error Analyzer Modal */
        .error-modal .modal-content {
            max-width: 700px;
            border-color: var(--danger);
        }
        .error-modal .modal-header {
            background: rgba(255, 59, 48, 0.1);
            border-bottom-color: var(--danger);
        }
        .error-modal .modal-header h3 {
            color: var(--danger);
        }
        .error-section {
            margin-bottom: 16px;
        }
        .error-section-title {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            margin-bottom: 8px;
        }
        .error-message {
            background: rgba(255, 59, 48, 0.1);
            border: 1px solid rgba(255, 59, 48, 0.3);
            border-radius: 6px;
            padding: 12px;
            font-family: 'SF Mono', monospace;
            font-size: 12px;
            color: #ff6b6b;
            white-space: pre-wrap;
            word-break: break-word;
        }
        .error-stack {
            background: var(--bg-tertiary);
            border-radius: 6px;
            padding: 12px;
            font-family: 'SF Mono', monospace;
            font-size: 10px;
            color: var(--text-secondary);
            max-height: 120px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        .error-ai-analysis {
            background: var(--bg-tertiary);
            border-radius: 6px;
            padding: 12px;
            font-size: 12px;
            line-height: 1.5;
        }
        .error-ai-analysis.loading {
            color: var(--text-muted);
            font-style: italic;
        }
        .error-location {
            display: flex;
            gap: 12px;
            font-size: 11px;
        }
        .error-location-item {
            background: var(--bg-tertiary);
            padding: 6px 10px;
            border-radius: 4px;
        }
        .error-location-label {
            color: var(--text-muted);
            margin-right: 4px;
        }
        .error-actions {
            display: flex;
            gap: 8px;
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid var(--border);
        }
        .error-actions button {
            padding: 8px 16px;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
        }
        .error-btn-fix {
            background: var(--accent);
            color: white;
        }
        .error-btn-log {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border) !important;
        }
        .error-btn-dismiss {
            background: transparent;
            color: var(--text-secondary);
            margin-left: auto;
        }
        
        /* Quick Log Modal */
        .quick-log-modal {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 400px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            z-index: 1001;
            display: none;
            animation: slideUp 0.2s ease;
        }
        .quick-log-modal.active { display: block; }
        @keyframes slideUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .quick-log-header {
            padding: 12px 16px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .quick-log-header h4 {
            font-size: 13px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .quick-log-type {
            font-size: 10px;
            padding: 2px 8px;
            border-radius: 10px;
            background: var(--bg-tertiary);
        }
        .quick-log-type.error { background: rgba(255,59,48,0.2); color: var(--danger); }
        .quick-log-type.warning { background: rgba(255,204,0,0.2); color: var(--warning); }
        .quick-log-type.info { background: rgba(79,140,255,0.2); color: var(--accent); }
        .quick-log-body {
            padding: 12px 16px;
        }
        .quick-log-field {
            margin-bottom: 12px;
        }
        .quick-log-field label {
            display: block;
            font-size: 10px;
            color: var(--text-muted);
            text-transform: uppercase;
            margin-bottom: 4px;
        }
        .quick-log-field textarea,
        .quick-log-field input {
            width: 100%;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 8px 10px;
            font-size: 12px;
            color: var(--text-primary);
            font-family: inherit;
            resize: vertical;
        }
        .quick-log-field textarea { min-height: 60px; }
        .quick-log-field textarea:focus,
        .quick-log-field input:focus {
            outline: none;
            border-color: var(--accent);
        }
        .quick-log-ai {
            background: var(--bg-tertiary);
            border-radius: 6px;
            padding: 10px;
            font-size: 11px;
            line-height: 1.5;
            max-height: 100px;
            overflow-y: auto;
        }
        .quick-log-ai.loading {
            color: var(--text-muted);
            font-style: italic;
        }
        .quick-log-actions {
            padding: 12px 16px;
            border-top: 1px solid var(--border);
            display: flex;
            gap: 8px;
            justify-content: flex-end;
        }
        .quick-log-actions button {
            padding: 6px 14px;
            border-radius: 6px;
            border: none;
            font-size: 12px;
            cursor: pointer;
        }
        .quick-log-save {
            background: var(--accent);
            color: white;
        }
        .quick-log-dismiss {
            background: transparent;
            color: var(--text-secondary);
        }
        
        /* Log Table */
        .log-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px;
        }
        
        .log-table th, .log-table td {
            padding: 8px 10px;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }
        
        .log-table th {
            background: var(--bg-tertiary);
            font-weight: 600;
            position: sticky;
            top: 0;
        }
        
        .log-table tr:hover { background: rgba(255,255,255,0.03); }
        
        /* Scrollbar */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: var(--bg-primary); }
        ::-webkit-scrollbar-thumb { background: var(--border-light); border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--text-muted); }
        
        /* No API Key Warning */
        .no-api-warning {
            background: rgba(255,59,48,0.1);
            border: 1px solid var(--danger);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: center;
        }
        .no-api-warning h3 { color: var(--danger); margin-bottom: 8px; }
        .no-api-warning p { color: var(--text-secondary); font-size: 13px; }
        
        /* ==================== Voice Mode - Compact Floating Panel ==================== */
        
        /* Voice trigger button in input area */
        .btn-voice {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .btn-voice:hover {
            background: var(--accent);
            border-color: var(--accent);
        }
        .btn-voice.active {
            background: var(--accent);
            border-color: var(--accent);
            animation: voicePulse 1.5s ease-in-out infinite;
        }
        
        @keyframes voicePulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(79, 140, 255, 0.4); }
            50% { box-shadow: 0 0 0 8px rgba(79, 140, 255, 0); }
        }
        
        /* Floating voice panel - bottom right, doesn't block app view */
        .voice-panel {
            position: fixed;
            bottom: 100px;
            right: 24px;
            width: 320px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            z-index: 1000;
            opacity: 0;
            transform: translateY(20px) scale(0.95);
            pointer-events: none;
            transition: all 0.3s ease;
            overflow: hidden;
        }
        .voice-panel.active {
            opacity: 1;
            transform: translateY(0) scale(1);
            pointer-events: auto;
        }
        
        .voice-panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border);
        }
        .voice-panel-title {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .voice-panel-close {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }
        .voice-panel-close:hover {
            background: var(--danger);
            color: white;
        }
        
        .voice-panel-body {
            padding: 16px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
        }
        
        /* Compact orb */
        .voice-orb-small {
            width: 80px;
            height: 80px;
        }
        
        /* Voice status */
        .voice-status {
            font-size: 13px;
            color: var(--text-secondary);
            text-align: center;
        }
        .voice-status.listening { color: var(--accent); }
        .voice-status.thinking { color: var(--warning); }
        .voice-status.speaking { color: var(--success); }
        
        /* Live transcript */
        .voice-transcript {
            font-size: 14px;
            color: var(--text-primary);
            text-align: center;
            min-height: 40px;
            max-height: 80px;
            overflow-y: auto;
            width: 100%;
            line-height: 1.4;
        }
        .voice-transcript .partial {
            color: var(--text-secondary);
            font-style: italic;
        }
        
        /* Prompt preview in panel */
        .voice-prompt-preview {
            width: 100%;
            padding: 10px;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 8px;
            font-size: 12px;
            color: var(--text-primary);
            max-height: 60px;
            overflow-y: auto;
            display: none;
        }
        .voice-prompt-preview.visible {
            display: block;
        }
        
        /* Voice hints */
        .voice-hints {
            font-size: 11px;
            color: var(--text-muted);
            text-align: center;
        }
        .voice-hints kbd {
            background: var(--bg-tertiary);
            padding: 2px 6px;
            border-radius: 3px;
            border: 1px solid var(--border);
            margin: 0 2px;
        }
        
        /* ==================== SMART TESTING MODE STYLES ==================== */
        
        /* Testing Mode Banner */
        .testing-banner {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            background: linear-gradient(135deg, #059669, #10b981);
            color: white;
            font-size: 12px;
            font-weight: 500;
            border-bottom: 1px solid rgba(255,255,255,0.2);
            animation: slideDown 0.3s ease-out;
        }
        .testing-banner.hidden {
            display: none;
        }
        .testing-banner-icon {
            margin-right: 6px;
        }
        .testing-banner-text {
            flex: 1;
        }
        .testing-banner-btn {
            padding: 4px 12px;
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 4px;
            color: white;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        .testing-banner-btn:hover {
            background: rgba(255,255,255,0.3);
        }
        @keyframes slideDown {
            from { transform: translateY(-100%); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        /* Debug Mode Toggle */
        .debug-toggle {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px;
            color: var(--text-secondary);
            transition: all 0.2s;
        }
        .debug-toggle:hover {
            border-color: var(--accent);
        }
        .debug-toggle input[type="checkbox"] {
            width: 14px;
            height: 14px;
            cursor: pointer;
        }
        .debug-toggle input[type="checkbox"]:checked + .debug-toggle-label {
            color: var(--success);
        }
        .debug-toggle-label {
            white-space: nowrap;
        }
        
        /* ========== UNIFIED TASK QUEUE STYLES ========== */
        .task-queue-section {
            background: var(--bg-secondary);
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 16px; /* Prevent cutoff at bottom of sidebar */
        }
        
        .task-queue-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 12px;
            background: linear-gradient(135deg, var(--bg-tertiary) 0%, var(--bg-secondary) 100%);
            border-bottom: 1px solid var(--border);
        }
        
        .task-queue-title {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
            font-size: 13px;
        }
        
        .task-queue-icon {
            font-size: 14px;
        }
        
        .task-queue-count {
            background: var(--accent);
            color: white;
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 10px;
            min-width: 18px;
            text-align: center;
        }
        
        .task-quick-add-btn {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: none;
            background: var(--accent);
            color: white;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        
        .task-quick-add-btn:hover {
            transform: scale(1.1);
            background: var(--accent-hover);
        }
        
        /* Progress Bar */
        .task-queue-progress {
            height: 4px;
            background: var(--bg-tertiary);
            position: relative;
            overflow: hidden;
        }
        
        .task-queue-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--success) 0%, #22d3ee 100%);
            transition: width 0.5s ease-out;
            border-radius: 0 2px 2px 0;
        }
        
        .task-queue-progress-text {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 9px;
            color: var(--text-muted);
            display: none;
        }
        
        /* Quick Add Input */
        .task-quick-add-container {
            display: flex;
            padding: 8px;
            gap: 6px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border);
        }
        
        .task-quick-add-container.hidden {
            display: none;
        }
        
        .task-quick-add-input {
            flex: 1;
            padding: 8px 10px;
            border: 1px solid var(--border);
            border-radius: 6px;
            background: var(--bg-primary);
            color: var(--text-primary);
            font-size: 12px;
        }
        
        .task-quick-add-input:focus {
            outline: none;
            border-color: var(--accent);
        }
        
        .task-quick-add-submit {
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            background: var(--accent);
            color: white;
            cursor: pointer;
            font-size: 14px;
        }
        
        /* Task List */
        .task-queue-list {
            max-height: 280px;
            overflow-y: auto;
            padding: 4px 0;
        }
        
        .task-queue-empty {
            padding: 20px;
            text-align: center;
            color: var(--text-muted);
            font-size: 11px;
        }
        
        /* Task Item */
        .task-item {
            display: flex;
            align-items: flex-start;
            gap: 8px;
            padding: 8px 12px;
            transition: all 0.3s ease;
            border-left: 3px solid transparent;
        }
        
        .task-item:hover {
            background: var(--bg-tertiary);
        }
        
        .task-item.current {
            background: rgba(59, 130, 246, 0.1);
            border-left-color: var(--accent);
        }
        
        .task-item.completed {
            opacity: 0.5;
        }
        
        .task-item.completing {
            animation: taskComplete 0.5s ease-out forwards;
        }
        
        @keyframes taskComplete {
            0% { transform: scale(1); background: transparent; }
            50% { transform: scale(1.02); background: rgba(34, 197, 94, 0.2); }
            100% { transform: scale(1); opacity: 0.5; }
        }
        
        .task-item.new-task {
            animation: taskSlideIn 0.4s ease-out;
        }
        
        @keyframes taskSlideIn {
            0% { transform: translateX(20px); opacity: 0; background: rgba(251, 191, 36, 0.2); }
            100% { transform: translateX(0); opacity: 1; background: transparent; }
        }
        
        /* Task Dot (status indicator) */
        .task-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-top: 3px;
            flex-shrink: 0;
        }
        
        .task-dot.pending {
            border: 2px solid var(--text-muted);
            background: transparent;
        }
        
        .task-dot.running {
            background: var(--accent);
            animation: taskPulse 1.5s infinite;
        }
        
        @keyframes taskPulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.3); opacity: 0.7; }
        }
        
        .task-dot.completed {
            background: var(--success);
            position: relative;
        }
        
        .task-dot.completed::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 7px;
            color: white;
        }
        
        .task-dot.user {
            background: #22c55e;
        }
        
        .task-dot.error {
            background: #ef4444;
        }
        
        /* Task Content */
        .task-content {
            flex: 1;
            min-width: 0;
        }
        
        .task-text {
            font-size: 11px;
            line-height: 1.4;
            color: var(--text-primary);
            word-break: break-word;
        }
        
        .task-item.completed .task-text {
            text-decoration: line-through;
            color: var(--text-muted);
        }
        
        .task-meta {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-top: 2px;
        }
        
        .task-type-badge {
            font-size: 9px;
            padding: 1px 5px;
            border-radius: 8px;
            background: var(--bg-tertiary);
            color: var(--text-muted);
        }
        
        .task-type-badge.user {
            background: rgba(34, 197, 94, 0.2);
            color: #22c55e;
        }
        
        .task-type-badge.error {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
        }
        
        .task-duration {
            font-size: 9px;
            color: var(--text-muted);
        }
        
        /* Stats Footer */
        .task-queue-stats {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 8px 12px;
            background: var(--bg-tertiary);
            border-top: 1px solid var(--border);
            font-size: 10px;
        }
        
        .task-stat {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .task-stat-label {
            color: var(--text-muted);
        }
        
        .task-stat-value {
            color: var(--text-primary);
            font-weight: 600;
        }
        
        .task-stat-divider {
            color: var(--border);
        }
        
        /* Enhanced Empty State */
        .task-queue-empty {
            padding: 24px 16px;
            text-align: center;
            color: var(--text-muted);
        }
        .task-queue-empty .empty-icon {
            font-size: 28px;
            margin-bottom: 8px;
            opacity: 0.5;
        }
        .task-queue-empty .empty-hint {
            font-size: 10px;
            margin-top: 4px;
            opacity: 0.7;
        }
        
        /* Task Action Buttons */
        .task-actions {
            display: flex;
            gap: 2px;
            opacity: 0;
            transition: opacity 0.2s;
            margin-left: auto;
            flex-shrink: 0;
        }
        .task-item:hover .task-actions {
            opacity: 1;
        }
        .task-action-btn {
            width: 20px;
            height: 20px;
            border: none;
            border-radius: 4px;
            background: var(--bg-tertiary);
            color: var(--text-muted);
            font-size: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
        }
        .task-action-btn:hover {
            background: var(--bg-primary);
            color: var(--text-primary);
        }
        .task-action-btn.cancel:hover {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
        }
        .task-action-btn.pause:hover {
            background: rgba(251, 191, 36, 0.2);
            color: #fbbf24;
        }
        .task-action-btn.move:hover {
            background: rgba(59, 130, 246, 0.2);
            color: #3b82f6;
        }
        
        /* Task Estimate & Running Text */
        .task-estimate {
            font-size: 9px;
            color: var(--text-muted);
            opacity: 0.7;
        }
        .task-running-text {
            font-size: 9px;
            color: var(--accent);
            animation: taskRunningPulse 1s infinite;
        }
        @keyframes taskRunningPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        /* AI Optimizing State */
        .task-item.optimizing {
            background: rgba(139, 92, 246, 0.08);
            border-left-color: #8b5cf6;
        }
        .task-dot.optimizing {
            background: #8b5cf6;
            animation: optimizePulse 0.8s infinite;
        }
        @keyframes optimizePulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.4); opacity: 0.6; }
        }
        .task-optimizing {
            font-size: 9px;
            color: #8b5cf6;
            animation: taskRunningPulse 1s infinite;
        }
        
        /* Feedback Item in Chat */
        .feedback-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 12px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            margin: 4px 0;
            border-left: 3px solid var(--warning);
        }
        .feedback-item.cancelled {
            opacity: 0.5;
            text-decoration: line-through;
            border-left-color: var(--error);
        }
        .feedback-item.completed {
            border-left-color: var(--success);
            background: linear-gradient(90deg, rgba(34, 197, 94, 0.15) 0%, var(--bg-tertiary) 100%);
            animation: feedbackComplete 0.5s ease-out;
        }
        @keyframes feedbackComplete {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); background: rgba(34, 197, 94, 0.3); }
            100% { transform: scale(1); }
        }
        .feedback-checkbox {
            font-size: 16px;
            min-width: 20px;
            text-align: center;
        }
        .feedback-checkbox.completed {
            color: #22c55e;
        }
        .feedback-checkbox.cancelled {
            color: #ef4444;
        }
        .feedback-text {
            flex: 1;
            font-size: 12px;
        }
        .feedback-status {
            font-size: 10px;
            padding: 2px 8px;
            border-radius: 10px;
            font-weight: 500;
        }
        .feedback-status.pending {
            background: #fef3c7;
            color: #92400e;
        }
        .feedback-status.queued {
            background: #dbeafe;
            color: #1e40af;
        }
        .feedback-status.in-progress {
            background: #e0e7ff;
            color: #3730a3;
        }
        .feedback-status.completed {
            background: #dcfce7;
            color: #166534;
        }
        .feedback-status.cancelled {
            background: #fee2e2;
            color: #991b1b;
        }
        .feedback-actions {
            display: flex;
            gap: 4px;
        }
        .feedback-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px 6px;
            border-radius: 4px;
            font-size: 12px;
            transition: background 0.2s;
        }
        .feedback-btn:hover {
            background: var(--bg-hover);
        }
        .feedback-btn.cancel:hover {
            background: #fee2e2;
        }
        
        /* Feedback Panel in Sidebar */
        .panel-feedback-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 8px;
            background: var(--bg-secondary);
            border-radius: 4px;
            margin-bottom: 4px;
            font-size: 11px;
        }
        .panel-feedback-item.cancelled {
            opacity: 0.5;
            text-decoration: line-through;
        }
        .panel-checkbox {
            font-size: 12px;
            min-width: 16px;
        }
        .panel-text {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .panel-actions {
            display: flex;
            gap: 2px;
        }
        .panel-actions button {
            padding: 2px 6px;
            font-size: 9px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 3px;
            cursor: pointer;
            color: var(--text-secondary);
        }
        .panel-actions button:hover {
            background: var(--bg-hover);
        }
        .panel-status {
            font-size: 9px;
            color: var(--text-muted);
        }
        .no-feedback {
            color: var(--text-muted);
            font-size: 11px;
            padding: 8px;
            text-align: center;
        }
        
        /* Auto-detected Errors in Modal */
        .auto-error-item {
            display: flex;
            align-items: flex-start;
            gap: 8px;
            padding: 8px 10px;
            background: #fef2f2;
            border: 1px solid #fecaca;
            border-radius: 6px;
            margin-bottom: 8px;
            font-size: 11px;
            color: #991b1b;
        }
        .auto-error-item .error-icon {
            font-size: 14px;
        }
        .auto-error-item .error-text {
            flex: 1;
            word-break: break-word;
        }
        .auto-error-item .queue-fix-btn {
            padding: 2px 8px;
            background: #dc2626;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 10px;
            cursor: pointer;
        }
        .auto-error-item .queue-fix-btn:hover {
            background: #b91c1c;
        }
        
        /* ========== AGENT ACTIVITY HUD ========== */
        .agent-hud {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 320px;
            /* Glassmorphism effect */
            background: linear-gradient(
                135deg,
                rgba(255, 255, 255, 0.1) 0%,
                rgba(255, 255, 255, 0.05) 50%,
                rgba(255, 255, 255, 0.02) 100%
            );
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.18);
            border-radius: 16px;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1),
                inset 0 -1px 0 rgba(0, 0, 0, 0.1);
            z-index: 9999;
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', sans-serif;
            transition: width 0.3s cubic-bezier(0.4, 0, 0.2, 1), 
                        opacity 0.3s ease, 
                        transform 0.3s ease;
            overflow: hidden;
        }
        .agent-hud.dragging {
            transition: none;
            box-shadow: 
                0 16px 48px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.15);
        }
        .agent-hud.minimized {
            width: 180px;
        }
        .agent-hud.hidden {
            opacity: 0;
            pointer-events: none;
            transform: translateY(20px);
        }
        /* Glass reflection highlight */
        .agent-hud::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 50%;
            background: linear-gradient(
                180deg,
                rgba(255, 255, 255, 0.1) 0%,
                rgba(255, 255, 255, 0.02) 50%,
                transparent 100%
            );
            border-radius: 16px 16px 0 0;
            pointer-events: none;
        }
        .agent-hud-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 14px;
            background: linear-gradient(
                180deg,
                rgba(255, 255, 255, 0.08) 0%,
                rgba(255, 255, 255, 0.02) 100%
            );
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
            cursor: grab;
            user-select: none;
        }
        .agent-hud-header:active {
            cursor: grabbing;
        }
        .agent-hud-title {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            font-weight: 600;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .agent-hud-title .hud-icon {
            font-size: 14px;
            animation: hud-pulse 2s ease-in-out infinite;
        }
        @keyframes hud-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        .agent-hud-controls {
            display: flex;
            gap: 4px;
        }
        .agent-hud-controls button {
            width: 22px;
            height: 22px;
            border: none;
            background: rgba(255, 255, 255, 0.1);
            color: #888;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        .agent-hud-controls button:hover {
            background: rgba(255, 255, 255, 0.25);
            color: #fff;
            transform: scale(1.05);
        }
        .agent-hud-body {
            padding: 14px;
            background: linear-gradient(
                180deg,
                rgba(0, 0, 0, 0.1) 0%,
                rgba(0, 0, 0, 0.2) 100%
            );
        }
        .agent-hud.minimized .agent-hud-body {
            display: none;
        }
        
        /* Phase indicator */
        .hud-phase {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }
        .hud-phase-badge {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            background: linear-gradient(135deg, #0066cc, #0052a3);
            border-radius: 6px;
            font-size: 11px;
            font-weight: 600;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .hud-phase-badge.evaluate { background: linear-gradient(135deg, #7c3aed, #5b21b6); }
        .hud-phase-badge.research { background: linear-gradient(135deg, #0891b2, #0e7490); }
        .hud-phase-badge.plan { background: linear-gradient(135deg, #ca8a04, #a16207); }
        .hud-phase-badge.execute { background: linear-gradient(135deg, #059669, #047857); }
        .hud-phase-badge.test { background: linear-gradient(135deg, #dc2626, #b91c1c); }
        .hud-phase-badge.improve { background: linear-gradient(135deg, #ea580c, #c2410c); }
        .hud-phase-badge.finalize { background: linear-gradient(135deg, #16a34a, #15803d); }
        .hud-phase-count {
            font-size: 11px;
            color: #888;
        }
        
        /* Progress bar */
        .hud-progress {
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            margin-bottom: 14px;
            overflow: hidden;
        }
        .hud-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #0066cc, #00cc88);
            border-radius: 2px;
            transition: width 0.3s ease;
        }
        
        /* Current task */
        .hud-section {
            margin-bottom: 10px;
        }
        .hud-section:last-child {
            margin-bottom: 0;
        }
        .hud-label {
            font-size: 10px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }
        .hud-value {
            font-size: 12px;
            color: #ddd;
            line-height: 1.4;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
        .hud-value.file {
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 11px;
            color: #0ea5e9;
        }
        .hud-value.action {
            color: #a78bfa;
            font-style: italic;
        }
        
        /* Recent actions */
        .hud-recent {
            border-top: 1px solid rgba(255, 255, 255, 0.08);
            padding-top: 10px;
            margin-top: 10px;
        }
        .hud-recent-item {
            font-size: 10px;
            color: #666;
            padding: 2px 0;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .hud-recent-item::before {
            content: '';
            color: #444;
        }
        
        /* Minimized state inline display */
        .hud-minimized-info {
            display: none;
            align-items: center;
            gap: 8px;
            padding: 0 12px 10px;
        }
        .agent-hud.minimized .hud-minimized-info {
            display: flex;
        }
        .hud-mini-progress {
            flex: 1;
            height: 3px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
        }
        .hud-mini-progress-fill {
            height: 100%;
            background: #0066cc;
            transition: width 0.3s;
        }
        .hud-mini-percent {
            font-size: 11px;
            color: #888;
            font-weight: 500;
        }
    </style>
</head>
<body>
    <!-- ========== AGENT ACTIVITY HUD ========== -->
    <div class="agent-hud hidden" id="agentHUD">
        <div class="agent-hud-header" id="hudHeader">
            <div class="agent-hud-title">
                <span class="hud-icon"></span>
                <span>Agent Activity</span>
            </div>
            <div class="agent-hud-controls">
                <button onclick="GSXCreate.toggleHUDMinimize()" title="Minimize" id="hudMinBtn"></button>
                <button onclick="GSXCreate.hideHUD()" title="Close"></button>
            </div>
        </div>
        <div class="agent-hud-body" id="hudBody">
            <div class="hud-phase">
                <div class="hud-phase-badge" id="hudPhaseBadge">
                    <span id="hudPhaseIcon"></span>
                    <span id="hudPhaseText">Ready</span>
                </div>
                <span class="hud-phase-count" id="hudPhaseCount">0/0</span>
            </div>
            <div class="hud-progress">
                <div class="hud-progress-fill" id="hudProgressFill" style="width: 0%"></div>
            </div>
            <div class="hud-section">
                <div class="hud-label"> Current Task</div>
                <div class="hud-value" id="hudTask">Waiting for task...</div>
            </div>
            <div class="hud-section">
                <div class="hud-label"> File</div>
                <div class="hud-value file" id="hudFile"></div>
            </div>
            <div class="hud-section">
                <div class="hud-label"> Action</div>
                <div class="hud-value action" id="hudAction">Idle</div>
            </div>
            <div class="hud-recent" id="hudRecentSection">
                <div class="hud-label">Recent</div>
                <div id="hudRecentList"></div>
            </div>
        </div>
        <div class="hud-minimized-info">
            <div class="hud-mini-progress">
                <div class="hud-mini-progress-fill" id="hudMiniProgressFill" style="width: 0%"></div>
            </div>
            <span class="hud-mini-percent" id="hudMiniPercent">0%</span>
        </div>
    </div>

    <!-- Header -->
    <div class="header">
        <h1>GSX Create <span id="appVersion" style="font-size: 12px; font-weight: 400; color: var(--text-muted, #666); margin-left: 6px;">v1.5.0</span></h1>
        <div class="header-right">
            <div class="cost-display" id="costDisplay" onclick="GSXCreate.showBudgetModal()">
                <span class="cost-badge" id="costBadge">$0.00</span>
                <span class="cost-separator">/</span>
                <span class="budget-badge" id="budgetBadge"></span>
                <div class="budget-progress" id="budgetProgress">
                    <div class="budget-fill" id="budgetFill" style="width: 0%"></div>
                </div>
            </div>
            <!-- Debug Mode Toggle -->
            <label class="debug-toggle" title="Generate verbose debug logging in AI code">
                <input type="checkbox" id="debugModeToggle" checked onchange="GSXCreate.toggleDebugMode()">
                <span class="debug-toggle-label"> Debug</span>
            </label>
        <div class="status">
            <span class="status-dot" id="statusDot"></span>
            <span id="statusText">Not Connected</span>
            </div>
        </div>
    </div>
    
    <!-- Tab Navigation Bar - Hidden until space is selected -->
    <div class="tab-bar" id="tabBar" style="display: none;">
        <button class="tab-item main-tab" data-tab="main" onclick="TabManager.switchTab('main')">
            <span class="tab-icon"></span>
            <span class="tab-label">Overview</span>
            <!-- Tooltip for main tab -->
            <div class="tab-tooltip">
                <div class="tab-tooltip-header">
                    <span class="tab-tooltip-title">Project Overview</span>
                </div>
                <div class="tab-tooltip-row">
                    <span class="tab-tooltip-label">Active Branches</span>
                    <span class="tab-tooltip-value" id="tooltip-branch-count">1</span>
                </div>
                <div class="tab-tooltip-row">
                    <span class="tab-tooltip-label">Total Spent</span>
                    <span class="tab-tooltip-value" id="tooltip-total-cost">$0.00</span>
                </div>
            </div>
        </button>
        <button class="tab-item active" data-tab="main-branch" onclick="TabManager.switchTab('main-branch')">
            <span class="tab-status-indicator idle" id="tab-status-main-branch"></span>
            <span class="tab-icon"></span>
            <span class="tab-label">main</span>
            <span class="tab-version" id="tab-version-main-branch">v1.0</span>
            <span class="tab-close" onclick="event.stopPropagation(); TabManager.closeTab('main-branch')"></span>
            <!-- Hover Tooltip -->
            <div class="tab-tooltip">
                <div class="tab-tooltip-header">
                    <span class="tab-tooltip-title">main</span>
                    <span class="tab-tooltip-version" id="tooltip-version-main-branch">v1.0</span>
                </div>
                <div class="tab-tooltip-row">
                    <span class="tab-tooltip-label">Status</span>
                    <span class="tab-tooltip-value" id="tooltip-status-main-branch">Idle</span>
                </div>
                <div class="tab-tooltip-row">
                    <span class="tab-tooltip-label">Cost</span>
                    <span class="tab-tooltip-value" id="tooltip-cost-main-branch">$0.00</span>
                </div>
                <div class="tab-tooltip-progress">
                    <div class="tab-tooltip-progress-label">
                        <span>Phase Progress</span>
                        <span id="tooltip-phase-pct-main-branch">0%</span>
                    </div>
                    <div class="tab-tooltip-progress-bar">
                        <div class="tab-tooltip-progress-fill phase" id="tooltip-phase-fill-main-branch" style="width: 0%;"></div>
                    </div>
                </div>
                <div class="tab-tooltip-progress" style="margin-top: 8px;">
                    <div class="tab-tooltip-progress-label">
                        <span>Budget Used</span>
                        <span id="tooltip-budget-pct-main-branch">0%</span>
                    </div>
                    <div class="tab-tooltip-progress-bar">
                        <div class="tab-tooltip-progress-fill budget" id="tooltip-budget-fill-main-branch" style="width: 0%;"></div>
                    </div>
                </div>
            </div>
        </button>
        <button class="tab-add-btn" onclick="TabManager.showNewBranchModal()" title="Create new branch">+</button>
    </div>
    
    <!-- Error Analyzer Modal -->
    <div class="modal error-modal" id="errorAnalyzerModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3> Error Detected</h3>
                <button class="modal-close" onclick="GSXCreate.closeErrorModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="error-section">
                    <div class="error-section-title">Error Message</div>
                    <div class="error-message" id="errorMessage">Loading...</div>
                </div>
                
                <div class="error-section">
                    <div class="error-section-title">Location</div>
                    <div class="error-location" id="errorLocation">
                        <div class="error-location-item">
                            <span class="error-location-label">File:</span>
                            <span id="errorFile">-</span>
                        </div>
                        <div class="error-location-item">
                            <span class="error-location-label">Line:</span>
                            <span id="errorLine">-</span>
                        </div>
                    </div>
                </div>
                
                <div class="error-section">
                    <div class="error-section-title">Stack Trace</div>
                    <div class="error-stack" id="errorStack">No stack trace available</div>
                </div>
                
                <div class="error-section">
                    <div class="error-section-title">AI Analysis</div>
                    <div class="error-ai-analysis loading" id="errorAIAnalysis"> Analyzing error...</div>
                </div>
                
                <div class="error-actions">
                    <button class="error-btn-fix" onclick="GSXCreate.fixError()" id="errorFixBtn" disabled> Fix This Error</button>
                    <button class="error-btn-log" onclick="GSXCreate.saveErrorToLog()"> Save to Log</button>
                    <button class="error-btn-dismiss" onclick="GSXCreate.closeErrorModal()">Dismiss</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Quick Log Modal (for global logging) -->
    <div class="quick-log-modal" id="quickLogModal">
        <div class="quick-log-header">
            <h4>
                 Log Event
                <span class="quick-log-type" id="quickLogType">error</span>
            </h4>
            <button class="modal-close" onclick="GSXCreate.closeQuickLog()" style="background:none;border:none;color:var(--text-secondary);font-size:18px;cursor:pointer;">&times;</button>
        </div>
        <div class="quick-log-body">
            <div class="quick-log-field">
                <label>Summary</label>
                <input type="text" id="quickLogSummary" placeholder="Brief description of what happened">
            </div>
            <div class="quick-log-field">
                <label>AI Explanation</label>
                <div class="quick-log-ai loading" id="quickLogAI"> Generating explanation...</div>
            </div>
            <div class="quick-log-field">
                <label>Additional Notes (optional)</label>
                <textarea id="quickLogNotes" placeholder="Add any extra context or notes..."></textarea>
            </div>
        </div>
        <div class="quick-log-actions">
            <button class="quick-log-dismiss" onclick="GSXCreate.closeQuickLog()">Dismiss</button>
            <button class="quick-log-save" onclick="GSXCreate.saveQuickLog()"> Save to Log</button>
        </div>
    </div>
    
    <!-- Meta Learning Cycle Panel - Minimal -->
    <div class="cycle-panel" id="cyclePanel">
        <span class="cycle-label">Meta Learning Cycle</span>
        <button class="cycle-ctrl" id="cycleCtrlBtn" onclick="GSXCreate.toggleCycle()" title="Awaken consciousness"></button>
        <span class="cycle-version" id="cycleVersion" onclick="GSXCreate.showVersionTimeline()" title="Open version timeline" style="cursor: pointer;">v1</span>
        
        <div class="cycle-pipeline">
            <div class="phase-dot" id="phase-evaluate" data-label="Evaluate" onclick="GSXCreate.goToPhase('evaluate')"></div>
            <div class="phase-line" id="line-0"></div>
            <div class="phase-dot" id="phase-research" data-label="Research" onclick="GSXCreate.goToPhase('research')"></div>
            <div class="phase-line" id="line-1"></div>
            <div class="phase-dot" id="phase-plan" data-label="Plan" onclick="GSXCreate.goToPhase('plan')"></div>
            <div class="phase-line" id="line-2"></div>
            <div class="phase-dot" id="phase-execute" data-label="Execute" onclick="GSXCreate.goToPhase('execute')"></div>
            <div class="phase-line" id="line-3"></div>
            <div class="phase-dot" id="phase-test" data-label="Test" onclick="GSXCreate.goToPhase('test')"></div>
            <div class="phase-line" id="line-4"></div>
            <div class="phase-dot" id="phase-improve" data-label="Improve" onclick="GSXCreate.goToPhase('improve')"></div>
            <div class="phase-line" id="line-5"></div>
            <div class="phase-dot" id="phase-finalize" data-label="Finalize" onclick="GSXCreate.goToPhase('finalize')"></div>
            <button class="cycle-auto-toggle" id="autoCycleBtn" onclick="GSXCreate.toggleAutoCycle()" title="Auto-cycle: Off (click to toggle)">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/>
                    <path d="M3 3v5h5"/>
                </svg>
            </button>
        </div>
        
        <div class="version-timeline" id="versionTimeline"></div>
        
        <!-- Parallel branches control - DEPRECATED: Now using tabbed UI -->
        <div class="parallel-control" style="display: none;">
            <span style="font-size: 10px; color: var(--text-muted);" title="Number of parallel approach branches"></span>
            <select id="parallelCountControl" onchange="GSXCreate.setParallelCount(parseInt(this.value))" 
                    style="padding: 2px 4px; font-size: 10px; background: var(--bg-secondary); border: 1px solid var(--border); border-radius: 4px; color: var(--text-primary);">
                <option value="1">1</option>
                <option value="2" selected>2</option>
                <option value="3">3</option>
                <option value="4">4</option>
            </select>
        </div>
        
        <div class="cycle-progress">
            <div class="progress-bar-mini">
                <div class="progress-fill-mini" id="cycleProgressFill" style="width: 0%"></div>
            </div>
            <span id="cycleScore">0%</span>
        </div>
        
        <div class="cycle-help" onclick="GSXCreate.showCycleHelp()">?</div>
    </div>

    <!-- Version Timeline Modal (Cycle versions) -->
    <div class="modal" id="versionTimelineModal">
        <div class="modal-content" style="max-width: 900px;">
            <div class="modal-header">
                <h3>Version Timeline</h3>
                <button class="modal-close" onclick="GSXCreate.closeModal('versionTimelineModal')">&times;</button>
            </div>
            <div class="modal-body" id="versionTimelineModalBody"></div>
        </div>
    </div>
    
    <!-- Tab Content Container -->
    <div class="tab-content-container" id="tabContentContainer">
        <!-- Main Tab Content (Overview) - Hidden until session starts -->
        <div class="tab-content" id="tab-content-main" data-tab="main">
            <div class="main-tab-content">
                <div class="main-tab-header">
                    <h2>Project Overview</h2>
                    <div style="display: flex; gap: 8px;">
                        <button class="btn btn-secondary btn-sm" onclick="TabManager.refreshOverview()"> Refresh</button>
                    </div>
                </div>
                
                <div class="main-tab-grid">
                    <!-- All Branches Card -->
                    <div class="main-tab-card">
                        <h3><span class="icon"></span> Active Branches</h3>
                        
                        <!-- Prominent Create New Version Button -->
                        <div style="margin-bottom: 16px; padding: 16px; background: linear-gradient(135deg, rgba(79,140,255,0.15) 0%, rgba(99,102,241,0.15) 100%); border-radius: 10px; border: 1px dashed rgba(79,140,255,0.3);">
                            <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
                                <div style="width: 40px; height: 40px; background: linear-gradient(135deg, var(--accent) 0%, #6366f1 100%); border-radius: 10px; display: flex; align-items: center; justify-content: center; font-size: 20px;">+</div>
                                <div>
                                    <div style="font-size: 14px; font-weight: 600; color: var(--text-primary);">Create New Version</div>
                                    <div style="font-size: 11px; color: var(--text-muted);">Start a new branch with its own independent workspace</div>
                                </div>
                            </div>
                            <button class="btn btn-primary" style="width: 100%; padding: 12px; font-size: 13px; background: linear-gradient(135deg, var(--accent) 0%, #6366f1 100%);" onclick="TabManager.showNewBranchModal()">
                                 New Branch
                            </button>
                        </div>
                        
                        <div style="font-size: 11px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 8px;">Current Branches</div>
                        <div id="branchListContainer">
                            <div class="branch-list-item active" onclick="TabManager.switchTab('main-branch')">
                                <span class="branch-icon"></span>
                                <div class="branch-info">
                                    <div class="branch-name">main</div>
                                    <div class="branch-meta">Default branch</div>
                                </div>
                                <span class="branch-cost" id="main-branch-cost">$0.00</span>
                                <div class="branch-actions">
                                    <button class="branch-action-btn" title="Open in tab" onclick="event.stopPropagation(); TabManager.switchTab('main-branch')"></button>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Budget Overview Card -->
                    <div class="main-tab-card">
                        <h3><span class="icon"></span> Budget Overview</h3>
                        <div class="budget-overview">
                            <div class="budget-total">
                                <div class="amount" id="totalBudgetSpent">$0.00</div>
                                <div class="label">Total Spent</div>
                            </div>
                            <div class="budget-breakdown" id="budgetBreakdown">
                                <div class="budget-row">
                                    <span class="name">main</span>
                                    <span class="value" id="main-budget-value">$0.00</span>
                                </div>
                            </div>
                            <div style="margin-top: 12px;">
                                <button class="btn btn-secondary btn-sm" style="width: 100%;" onclick="GSXCreate.showBudgetModal()">
                                     Configure Budget
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Global Settings Card -->
                    <div class="main-tab-card">
                        <h3><span class="icon"></span> Global Settings</h3>
                        <div class="settings-form">
                            <div class="settings-group">
                                <label>Default AI Model</label>
                                <select class="settings-input" id="globalModelSelect" onchange="TabManager.setGlobalModel(this.value)">
                                    <option value="claude-sonnet-4-20250514">Claude Sonnet 4</option>
                                    <option value="claude-opus-4-20250514">Claude Opus 4</option>
                                </select>
                            </div>
                            <div class="settings-group">
                                <label>API Provider</label>
                                <select class="settings-input" id="globalProviderSelect" disabled>
                                    <option value="anthropic">Anthropic</option>
                                </select>
                            </div>
                            <div class="settings-group">
                                <label>Current Space</label>
                                <div style="padding: 10px 12px; background: var(--bg-tertiary); border-radius: 6px; font-size: 13px; color: var(--text-secondary);" id="globalCurrentSpace">
                                    No space selected
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Compare Branches Card -->
                    <div class="main-tab-card" style="grid-column: span 2;">
                        <h3><span class="icon"></span> Compare Branches</h3>
                        <div style="display: flex; gap: 12px; margin-bottom: 16px; flex-wrap: wrap;">
                            <div class="settings-group" style="flex: 1; min-width: 150px;">
                                <label>Branch A</label>
                                <select class="settings-input" id="compareBranchA">
                                    <option value="main">main</option>
                                </select>
                            </div>
                            <div class="settings-group" style="flex: 1; min-width: 150px;">
                                <label>Branch B</label>
                                <select class="settings-input" id="compareBranchB">
                                    <option value="">Select branch...</option>
                                </select>
                            </div>
                            <button class="btn btn-primary" style="align-self: flex-end;" onclick="TabManager.compareBranches()">
                                Compare
                            </button>
                        </div>
                        <div id="compareResultsContainer" style="display: none;">
                            <!-- Diff Summary -->
                            <div id="diffSummary" style="display: flex; gap: 16px; margin-bottom: 16px; padding: 12px; background: var(--bg-tertiary); border-radius: 8px; font-size: 12px;">
                                <span><strong id="diffFilesChanged">0</strong> files changed</span>
                                <span style="color: var(--success);"><strong id="diffInsertions">0</strong> insertions(+)</span>
                                <span style="color: var(--danger);"><strong id="diffDeletions">0</strong> deletions(-)</span>
                            </div>
                            <!-- Files List -->
                            <div id="diffFilesList" style="margin-bottom: 16px; max-height: 150px; overflow-y: auto;">
                            </div>
                            <!-- Diff View -->
                            <div class="compare-container" style="height: 300px;">
                                <div class="compare-pane">
                                    <div class="compare-pane-header">
                                        <span id="comparePaneAName">main</span>
                                    </div>
                                    <div class="compare-pane-content" id="comparePaneAContent">
                                        Select files to compare
                                    </div>
                                </div>
                                <div class="compare-pane">
                                    <div class="compare-pane-header">
                                        <span id="comparePaneBName">-</span>
                                    </div>
                                    <div class="compare-pane-content" id="comparePaneBContent">
                                        Select files to compare
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Branch Tab Content (main branch - default, active initially to show setup panel) -->
        <div class="tab-content active" id="tab-content-main-branch" data-tab="main-branch">
            <!-- Main Container (existing UI wrapped here) -->
            <div class="main-container">
        <!-- Sidebar (hidden until session starts) -->
        <div class="sidebar-container" id="sidebarContainer" style="display: none;">
            <div class="sidebar" id="sidebar">
                <!-- Toggle button - positioned on right edge -->
                <button class="sidebar-toggle" id="sidebarToggle" onclick="GSXCreate.toggleSidebar()" title="Toggle sidebar">
                    <span id="sidebarToggleIcon"></span>
                </button>
                <!-- Space Selection -->
                <div class="sidebar-section">
                    <h3>Space</h3>
                    <select class="space-selector" id="spaceSelect" onchange="GSXCreate.selectSpace(this.value)">
                        <option value="">Select a space...</option>
                    </select>
                </div>
                
                <!-- Constitutional Memory (shown after space selected) -->
                <div class="sidebar-section" id="configSection" style="display: none;">
                    <h3 style="display: flex; align-items: center; justify-content: space-between; cursor: pointer;" onclick="GSXCreate.toggleConfigSection()">
                        <span>Constitutional Memory</span>
                        <span id="configToggleIcon" style="font-size: 10px; transition: transform 0.2s;"></span>
                    </h3>
                    <div id="configSectionContent" style="display: none;">
                        <!-- Constitutional Files Status -->
                        <div id="constitutionalStatus" style="margin-bottom: 10px; font-size: 10px;">
                            <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 4px;">
                                <span id="styleGuideStatus" style="color: var(--text-muted);"></span>
                                <span>Style Guide</span>
                            </div>
                            <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 4px;">
                                <span id="journeyMapStatus" style="color: var(--text-muted);"></span>
                                <span>Journey Map</span>
                            </div>
                            <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 4px;">
                                <span id="criteriaStatus" style="color: var(--text-muted);"></span>
                                <span>Evaluation Criteria</span>
                            </div>
                        </div>
                        
                        <!-- Summary Status -->
                        <div id="summaryStatus" style="font-size: 10px; color: var(--text-muted); margin-bottom: 8px; padding: 6px; background: var(--bg-tertiary); border-radius: 4px;">
                            No summary loaded
                        </div>
                        
                        <div class="form-group" style="margin-bottom: 8px;">
                            <label>Style Guide</label>
                            <select class="form-select" id="styleGuideSelect" style="padding: 6px 8px; font-size: 11px;">
                                <option value="">None</option>
                            </select>
                        </div>
                        <div class="form-group" style="margin-bottom: 8px;">
                            <label>Journey Map</label>
                            <select class="form-select" id="journeyMapSelect" style="padding: 6px 8px; font-size: 11px;">
                                <option value="">None</option>
                            </select>
                        </div>
                        
                        <div style="display: flex; gap: 6px; margin-top: 8px;">
                            <button class="btn btn-primary btn-sm" style="flex: 1;" onclick="GSXCreate.startSession()" id="startBtn">
                                Start Session
                            </button>
                            <button class="btn btn-secondary btn-sm" onclick="GSXCreate.refreshConstitutionalMemory()" title="Refresh constitutional memory" style="padding: 6px 10px;">
                                
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- Reference Memory (collapsed by default) -->
                <div class="sidebar-section">
                    <h3 style="display: flex; align-items: center; justify-content: space-between; cursor: pointer;" onclick="GSXCreate.toggleSection('refMemory')">
                        <span style="display: flex; align-items: center; gap: 6px;">
                            <span id="refMemoryToggleIcon" style="font-size: 10px; transition: transform 0.2s;"></span>
                            Reference Memory
                            <span class="badge" id="fileCount">0</span>
                        </span>
                        <button class="btn btn-sm" onclick="event.stopPropagation(); GSXCreate.triggerFileUpload()" title="Upload file" style="padding: 2px 6px; font-size: 14px;">
                            +
                        </button>
                    </h3>
                    <div id="refMemoryContent" style="display: none;">
                        <input type="file" id="fileUploadInput" multiple style="display: none;" onchange="GSXCreate.handleFileUpload(event)">
                        <div class="file-list" id="fileList" style="max-height: 180px; overflow-y: auto;"
                             ondragover="GSXCreate.handleDragOver(event)" 
                             ondragleave="GSXCreate.handleDragLeave(event)" 
                             ondrop="GSXCreate.handleFileDrop(event)">
                            <div style="color: var(--text-muted); font-size: 11px; padding: 8px;">
                                Select a space to see files
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Context Files (collapsed by default) -->
                <div class="sidebar-section">
                    <h3 style="display: flex; align-items: center; gap: 6px; cursor: pointer;" onclick="GSXCreate.toggleSection('context')">
                        <span id="contextToggleIcon" style="font-size: 10px; transition: transform 0.2s;"></span>
                        In Context
                        <span class="badge" id="contextCount">0</span>
                    </h3>
                    <div id="contextContent" style="display: none;">
                        <div id="contextList" style="max-height: 120px; overflow-y: auto;">
                            <div style="color: var(--text-muted); font-size: 11px;">
                                Click files to add to context
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- ========== UNIFIED TASK QUEUE PANEL ========== -->
                <div class="sidebar-section task-queue-section" id="taskQueueSection">
                    <div class="task-queue-header">
                        <div class="task-queue-title">
                            <span class="task-queue-icon"></span>
                            <span>Task Queue</span>
                            <span class="task-queue-count" id="taskQueueCount">0</span>
                        </div>
                        <button class="task-quick-add-btn" onclick="GSXCreate.showQuickAddInput()" title="Add task">+</button>
                    </div>
                    
                    <!-- Progress Bar -->
                    <div class="task-queue-progress">
                        <div class="task-queue-progress-bar" id="taskQueueProgressBar" style="width: 0%"></div>
                        <span class="task-queue-progress-text" id="taskQueueProgressText">0%</span>
                    </div>
                    
                    <!-- Quick Add Input (hidden by default) -->
                    <div class="task-quick-add-container hidden" id="taskQuickAddContainer">
                        <input type="text" 
                               class="task-quick-add-input" 
                               id="taskQuickAddInput" 
                               placeholder="What should I do next?"
                               onkeydown="if(event.key==='Enter') GSXCreate.submitQuickAdd(); if(event.key==='Escape') GSXCreate.hideQuickAddInput();">
                        <button class="task-quick-add-submit" onclick="GSXCreate.submitQuickAdd()"></button>
                    </div>
                    
                    <!-- Task List -->
                    <div class="task-queue-list" id="taskQueueList">
                        <div class="task-queue-empty">
                            No tasks yet. Start a cycle or click [+] to add a task.
                        </div>
                    </div>
                    
                    <!-- Stats Footer -->
                    <div class="task-queue-stats" id="taskQueueStats">
                        <span class="task-stat">
                            <span class="task-stat-label">Done:</span>
                            <span class="task-stat-value" id="taskStatCompleted">0</span>
                        </span>
                        <span class="task-stat-divider"></span>
                        <span class="task-stat">
                            <span class="task-stat-label">Left:</span>
                            <span class="task-stat-value" id="taskStatRemaining">0</span>
                        </span>
                        <span class="task-stat-divider"></span>
                        <span class="task-stat">
                            <span class="task-stat-label">~</span>
                            <span class="task-stat-value" id="taskStatTime">0 min</span>
                        </span>
                    </div>
                </div>
                
                <!-- Episodic Memory (collapsed by default) -->
                <div class="sidebar-section">
                    <h3 style="display: flex; align-items: center; justify-content: space-between; cursor: pointer;" onclick="GSXCreate.toggleSection('episodic')">
                        <span style="display: flex; align-items: center; gap: 6px;">
                            <span id="episodicToggleIcon" style="font-size: 10px; transition: transform 0.2s;"></span>
                            Episodic Memory
                        </span>
                        <button class="btn btn-sm" onclick="event.stopPropagation(); GSXCreate.showTransactionLogs()" title="View all history" style="padding: 2px 6px; font-size: 10px;">
                            
                        </button>
                    </h3>
                    <div id="episodicContent" style="display: none;">
                        <!-- Episodic Memory Tabs -->
                        <div style="display: flex; gap: 4px; margin-bottom: 8px;">
                            <button class="btn btn-sm episodic-tab active" id="historyTab" onclick="GSXCreate.switchEpisodicTab('history')" style="flex: 1; padding: 4px 8px; font-size: 10px;">
                                 History <span class="badge" id="historyCount" style="font-size: 9px;">0</span>
                            </button>
                            <button class="btn btn-sm episodic-tab" id="planTab" onclick="GSXCreate.switchEpisodicTab('plan')" style="flex: 1; padding: 4px 8px; font-size: 10px;">
                                 Plan <span class="badge" id="planCount" style="font-size: 9px;">0</span>
                            </button>
                        </div>
                        
                        <!-- History Panel (what we did) -->
                        <div id="historyPanel" style="max-height: 140px; overflow-y: auto;">
                            <div id="episodicMemoryList">
                                <div style="color: var(--text-muted); font-size: 11px;">
                                    No history yet
                                </div>
                            </div>
                        </div>
                        
                        <!-- Plan Panel (what we plan to do) -->
                        <div id="planPanel" style="display: none; max-height: 140px; overflow-y: auto;">
                            <div style="display: flex; gap: 4px; margin-bottom: 6px;">
                                <input type="text" id="newTodoInput" placeholder="Add task..." 
                                       style="flex: 1; padding: 4px 8px; font-size: 11px; background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 4px; color: var(--text-primary);"
                                       onkeypress="if(event.key==='Enter')GSXCreate.addTodo()">
                                <button class="btn btn-sm btn-primary" onclick="GSXCreate.addTodo()" style="padding: 4px 8px; font-size: 11px;">+</button>
                            </div>
                            <div id="todoList">
                                <div style="color: var(--text-muted); font-size: 11px;">
                                    No tasks planned
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Center Area -->
        <div class="center-area" style="overflow: auto !important; min-height: 0 !important;">
        <!-- Setup Panel (shown initially) -->
        <div class="setup-panel" id="setupPanel" style="overflow-y: auto !important; max-height: 100% !important;">
                <div class="setup-hero">
                    <h2 style="margin-top: 20px;">GSX Create</h2>
                    <p>AI-powered code generation integrated with your Spaces</p>
                    
                    <div id="noApiWarning" class="no-api-warning" style="display: none;">
                        <h3>API Key Required</h3>
                        <p>Please add an OpenAI or Anthropic API key in Settings to use GSX Create.</p>
                    </div>
                    
                    <!-- Space Selection - Primary Action -->
                    <div class="setup-form" id="mainSetupForm" style="margin-top: 16px;">
                        <div class="form-group">
                            <label style="font-size: 14px; font-weight: 500; margin-bottom: 12px; display: block; color: var(--text-primary);">
                                Select a Space
                            </label>
                            <select class="form-select" id="mainSpaceSelect" onchange="GSXCreate.selectSpaceFromMain(this.value)" 
                                    style="font-size: 14px; padding: 10px 12px; background: var(--bg-tertiary); border: 2px solid var(--border-light); border-radius: 8px;">
                                <option value="">Choose a space...</option>
                            </select>
                            <div style="text-align: center; margin: 8px 0; color: var(--text-muted); font-size: 11px;"> or </div>
                            <button class="btn btn-secondary" onclick="GSXCreate.createNewSpace()" 
                                    style="width: 100%; padding: 10px; border: 2px dashed var(--border-light); background: transparent; font-size: 13px;">
                                + Create New Space
            </button>
                        </div>
                        
                        <!-- Start Button - always visible, disabled until space selected -->
                        <div style="display: flex; gap: 8px; margin-top: 16px;">
                            <button class="btn btn-primary" disabled style="flex: 1; padding: 12px; opacity: 0.5; cursor: not-allowed;" onclick="GSXCreate.startSession()" id="mainStartBtn">
                                Start Session
                            </button>
                            <button class="btn btn-secondary" onclick="GSXCreate.showSettings()" title="Settings" style="padding: 12px 14px;">
                                
                            </button>
                        </div>
                        <div style="text-align: center; margin-top: 8px; font-size: 11px; color: var(--text-muted);">
                            Model: <span id="currentModelDisplay">Claude Sonnet 4.5</span>
                        </div>
                        
                        <!-- Optional config - shown after space selected -->
                        <div id="spaceSelectedConfig" style="display: none; margin-top: 24px; padding-top: 24px; border-top: 1px solid var(--border);">
                            <label style="font-size: 12px; font-weight: 500; margin-bottom: 12px; display: block; color: var(--text-secondary);">
                                Constitutional Memory
                            </label>
                            
                            <!-- Main File Selection -->
                            <div class="form-group" style="margin-bottom: 12px;">
                                <label style="font-size: 11px;">Main File <span style="color: var(--text-muted);">(for preview & testing)</span></label>
                                <select class="form-select" id="mainFileSelect" style="padding: 10px;" onchange="GSXCreate.setMainFile(this.value)">
                                    <option value="">Auto-detect</option>
                </select>
            </div>
                            
                            <div style="display: flex; flex-direction: column; gap: 12px;">
                                <div class="form-group">
                                    <label style="font-size: 11px;">Journey Map <span style="color: var(--text-muted);">(select first)</span></label>
                                    <select class="form-select" id="mainJourneyMapSelect" onchange="GSXCreate.onJourneyMapSelected(this.value)">
                                        <option value="">Select a journey map...</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label style="font-size: 11px;">Style Guide</label>
                                    <select class="form-select" id="mainStyleGuideSelect" disabled style="opacity: 0.5;">
                                        <option value="">Select journey map first...</option>
                                    </select>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Chat Area (shown after session starts) -->
            <div class="chat-area" id="chatArea">
                <!-- Chat Toolbar -->
                <div class="chat-toolbar">
                    <button class="btn btn-secondary btn-sm" onclick="GSXCreate.toggleGlobalInstructions()" title="Global instructions">
                        Instructions
            </button>
                    <button class="btn btn-secondary btn-sm" onclick="GSXCreate.toggleConfig()" title="Lint & test config">
                        Config
                    </button>
                    <button class="btn btn-secondary btn-sm" onclick="GSXCreate.showCodeTools()" title="Code intelligence tools">
                         Code
                    </button>
                    <button class="btn btn-secondary btn-sm" onclick="GSXCreate.showTestAgent()" title="Automated testing with Puppeteer" style="background: var(--success);">
                         Test Agent
                    </button>
                    <button class="btn btn-secondary btn-sm" onclick="GSXCreate.showSettings()" title="Settings">
                        
                    </button>
                    <div class="spacer"></div>
                    <button class="btn btn-secondary btn-sm" onclick="GSXCreate.runCodeTest()" title="Analyze code">
                        Test
                    </button>
                    <button class="btn btn-secondary btn-sm" onclick="GSXCreate.showVersionHistory()" title="Version history">
                        History
                    </button>
                    <button class="btn btn-secondary btn-sm" onclick="GSXCreate.showTransactionLogs()" title="Episodic Memory">
                        Episodic Memory
                    </button>
                </div>
                
                <!-- Global Instructions Panel -->
                <div class="global-instructions" id="globalInstructionsPanel">
                    <label style="font-size: 10px; color: var(--text-secondary); display: block; margin-bottom: 6px;">
                        GLOBAL INSTRUCTIONS (included with every prompt)
                    </label>
                    <textarea id="globalInstructions" placeholder="Enter instructions that should be included with every prompt..."></textarea>
                    <div style="margin-top: 8px; display: flex; gap: 8px;">
                        <button class="btn btn-sm btn-secondary" onclick="GSXCreate.saveGlobalInstructions()">Save</button>
                        <button class="btn btn-sm btn-secondary" onclick="GSXCreate.applyTemplate('typescript')">TypeScript</button>
                        <button class="btn btn-sm btn-secondary" onclick="GSXCreate.applyTemplate('react')">React</button>
                        <button class="btn btn-sm btn-secondary" onclick="GSXCreate.applyTemplate('python')">Python</button>
                    </div>
        </div>
        
                <!-- Config Panel -->
                <div class="config-panel" id="configPanel">
                    <div class="config-row">
                        <div class="config-group">
                            <label>Lint Command</label>
                            <input type="text" id="lintCmd" placeholder="e.g., npm run lint">
            </div>
                        <div class="config-group">
                            <label>Test Command</label>
                            <input type="text" id="testCmd" placeholder="e.g., npm test">
                        </div>
                        <button class="btn btn-sm btn-secondary" onclick="GSXCreate.detectTools()" style="align-self: flex-end;">
                            Auto-Detect
            </button>
                    </div>
        </div>
        
                <!-- Branch Chat Tabs -->
                <div class="branch-chat-tabs" id="branchChatTabs" style="display: none;">
                    <div class="branch-tab active" data-branch="main" onclick="GSXCreate.switchChatTab('main')">
                        <span class="branch-tab-icon"></span>
                        <span class="branch-tab-name">Main</span>
                        <span class="branch-tab-status"></span>
                    </div>
                </div>
                
                <!-- Messages Container (holds all branch message areas) -->
                <div class="messages-wrapper" id="messagesWrapper">
                    <!-- Main branch messages -->
                    <div class="messages branch-messages active" id="messages" data-branch="main">
                        <div class="message">
                            <span class="message-time">--:--</span>
                            <span class="message-type system">SYS</span>
                            <span class="message-content">Session started. Describe what you want to build or modify.</span>
                        </div>
                    </div>
                </div>
            
                <!-- Input Area -->
            <div class="input-area">
                <div class="input-wrapper">
                        <span class="input-prefix">&gt;</span>
                        <textarea id="promptInput" placeholder="Describe what you want to build..." rows="1"></textarea>
                </div>
                    <button class="btn btn-voice" onclick="GSXCreate.toggleVoiceMode()" id="voiceBtn" title="Voice input (Ctrl+M)"></button>
                    <button class="btn btn-test" onclick="GSXCreate.runQuickTest()" id="testBtn" title="Run AI Test & Fix"></button>
                    <button class="btn btn-primary" onclick="GSXCreate.sendPrompt()" id="sendBtn">Send</button>
                </div>
            </div>
        </div>
        
        <!-- Preview Panel - Always visible split view -->
        <div class="preview-panel" id="previewPanel">
            <div class="preview-resize-handle" id="previewResizeHandle"></div>
            <button class="preview-toggle" id="previewToggle" onclick="GSXCreate.collapsePreview()" title="Collapse/Expand">
                <span id="previewToggleIcon"></span>
                </button>
            <div class="preview-header">
                <span class="preview-title" id="previewTitle">Preview</span>
                <div class="preview-actions">
                    <button onclick="GSXCreate.captureAndAnalyze()" title="Capture screenshot and send to AI for review" style="background: var(--accent);"> AI Review</button>
                    <button onclick="GSXCreate.refreshPreview()" title="Refresh"></button>
                    <button onclick="GSXCreate.openInBrowser()" title="Open in browser"></button>
                    <button onclick="GSXCreate.collapsePreview()" title="Collapse preview"></button>
                </div>
            </div>
            
            <!-- Docked Activity Bar - Shows what AI is currently working on -->
            <div class="preview-activity-bar" id="previewActivityBar">
                <div class="activity-bar-header">
                    <div class="activity-bar-phase">
                        <div class="activity-phase-badge idle" id="activityPhaseBadge">
                            <span id="activityPhaseIcon"></span>
                            <span id="activityPhaseText">Ready</span>
                        </div>
                    </div>
                    <div class="activity-bar-progress">
                        <div class="activity-progress-bar">
                            <div class="activity-progress-fill" id="activityProgressFill" style="width: 0%"></div>
                        </div>
                        <span class="activity-progress-text" id="activityProgressText">0%</span>
                    </div>
                </div>
                <div class="activity-bar-details">
                    <div class="activity-detail">
                        <span class="activity-detail-label"></span>
                        <span class="activity-detail-value" id="activityTask">Waiting...</span>
                    </div>
                    <div class="activity-detail">
                        <span class="activity-detail-label"></span>
                        <span class="activity-detail-value" id="activityFile"></span>
                    </div>
                </div>
            </div>
            
            <!-- Testing Mode Banner -->
            <div id="testingBanner" class="testing-banner hidden">
                <span class="testing-banner-icon"></span>
                <span class="testing-banner-text">Testing Mode - <span id="pendingUpdateCount">0</span> update(s) pending</span>
                <button class="testing-banner-btn" onclick="GSXCreate.showLatestAndAskFeedback()">Show Latest</button>
            </div>
            
            <!-- Branch Control Panel - DEPRECATED: Now using tabbed UI where each branch has its own tab -->
            <!-- This panel is hidden. Create new branches from the Overview tab instead. -->
            <div class="branch-control-panel" id="branchControlPanel" style="display: none !important;">
                <div class="branch-control-header">
                    <h4>Parallel Branches</h4>
                    <div style="display: flex; align-items: center; gap: 12px;">
                        <div style="display: flex; align-items: center; gap: 4px;">
                            <span style="font-size: 10px; color: var(--text-muted);">Branches:</span>
                            <select id="branchParallelCount" onchange="GSXCreate.setParallelCount(parseInt(this.value))"
                                    style="padding: 2px 6px; font-size: 10px; background: var(--bg-primary); border: 1px solid var(--border); border-radius: 4px; color: var(--text-primary);">
                                <option value="1">1</option>
                                <option value="2" selected>2</option>
                                <option value="3">3</option>
                                <option value="4">4</option>
                            </select>
                        </div>
                        <button onclick="GSXCreate.startParallelPlanning()" 
                                style="padding: 4px 10px; font-size: 10px; background: var(--accent); color: white; border: none; border-radius: 4px; cursor: pointer;"
                                title="Start parallel exploration with AI-generated approaches">
                            + New Exploration
                        </button>
                        <div class="branch-budget-indicator">
                            <span class="budget-spent" id="branchBudgetSpent">$0.00</span>
                            <span class="budget-separator">/</span>
                            <span class="budget-total" id="branchBudgetTotal">$5.00</span>
                            <div class="branch-budget-bar">
                                <div class="budget-fill" id="branchBudgetFill" style="width: 0%;"></div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="branch-timeline" id="branchTimeline">
                    <!-- Branch rows rendered dynamically -->
                </div>
                <div class="phase-legend" id="phaseLegend">
                    <div class="phase-legend-item" data-tooltip="Analyze current state and evaluate quality"><span class="phase-dot evaluate"></span>Eval</div>
                    <div class="phase-legend-item" data-tooltip="Research best practices and solutions"><span class="phase-dot research"></span>Research</div>
                    <div class="phase-legend-item" data-tooltip="Plan implementation approach"><span class="phase-dot plan"></span>Plan</div>
                    <div class="phase-legend-item" data-tooltip="Execute code changes"><span class="phase-dot execute"></span>Execute</div>
                    <div class="phase-legend-item" data-tooltip="Run tests and verify functionality"><span class="phase-dot test"></span>Test</div>
                    <div class="phase-legend-item" data-tooltip="Apply improvements and fixes"><span class="phase-dot improve"></span>Improve</div>
                    <div class="phase-legend-item" data-tooltip="Finalize and document version"><span class="phase-dot finalize"></span>Finalize</div>
                </div>
                <div class="cost-breakdown-panel" id="costBreakdownPanel">
                    <div class="cost-breakdown-header">
                        <h5>Cost Breakdown: <span id="focusedBranchName">-</span></h5>
                        <span class="branch-model" id="focusedBranchModel">-</span>
                    </div>
                    <div id="costBreakdownGrid">
                        <!-- Rationale and cost per phase rendered dynamically -->
                    </div>
                </div>
            </div>
            
            <div class="preview-content" id="previewContent">
                <!-- Welcome State - shown when no file is being previewed -->
                <div class="preview-welcome" id="previewWelcome">
                    <div class="preview-welcome-icon"></div>
                    <div class="preview-welcome-title" id="previewWelcomeTitle">Your App Preview</div>
                    <div class="preview-welcome-subtitle" id="previewWelcomeSubtitle">
                        Select a space and start building. Your app will appear here in real-time.
                    </div>
                    <div class="preview-welcome-status" id="previewWelcomeStatus">
                        Select a space to begin
                    </div>
                </div>
            </div>
        </div>
    </div>
            </div><!-- End main-container -->
        </div><!-- End tab-content main-branch -->
    </div><!-- End tab-content-container -->
    
    <!-- New Branch Modal -->
    <div class="modal" id="newBranchModal">
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-header">
                <h3> Create New Branch</h3>
                <button class="modal-close" onclick="TabManager.closeNewBranchModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group" style="margin-bottom: 16px;">
                    <label style="font-size: 12px; font-weight: 500; margin-bottom: 8px; display: block;">Branch Name</label>
                    <input type="text" id="newBranchName" class="form-input" placeholder="e.g., feature-auth, refactor-ui" style="width: 100%;">
                </div>
                <div class="form-group" style="margin-bottom: 16px;">
                    <label style="font-size: 12px; font-weight: 500; margin-bottom: 8px; display: block;">Base Branch</label>
                    <select id="newBranchBase" class="form-select" style="width: 100%;">
                        <option value="main">main</option>
                    </select>
                </div>
                <div class="form-group" style="margin-bottom: 16px;">
                    <label style="font-size: 12px; font-weight: 500; margin-bottom: 8px; display: block;">AI Model</label>
                    <select id="newBranchModel" class="form-select" style="width: 100%;">
                        <option value="claude-sonnet-4-20250514">Claude Sonnet 4</option>
                        <option value="claude-opus-4-20250514">Claude Opus 4</option>
                    </select>
                </div>
                <button class="btn btn-primary" style="width: 100%;" onclick="TabManager.createBranch()">
                    Create Branch & Open Tab
                </button>
            </div>
        </div>
    </div>
    
    <!-- Transaction Log Modal -->
    <div class="modal" id="logModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Episodic Memory</h3>
                <button class="modal-close" onclick="GSXCreate.closeModal('logModal')">&times;</button>
            </div>
            <div class="modal-body">
                <table class="log-table">
                    <thead>
                        <tr>
                            <th>Time</th>
                            <th>Type</th>
                            <th>Model</th>
                            <th>Tokens</th>
                            <th>Cost</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody id="logTableBody">
                    </tbody>
                </table>
            </div>
        </div>
    </div>
    
    <!-- Version History Modal -->
    <div class="modal" id="historyModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Version History</h3>
                <button class="modal-close" onclick="GSXCreate.closeModal('historyModal')">&times;</button>
            </div>
            <div class="modal-body" id="historyModalBody">
            </div>
        </div>
    </div>
    
    <!-- Code Tools Modal -->
    <div class="modal" id="codeToolsModal">
        <div class="modal-content" style="max-width: 800px;">
            <div class="modal-header">
                <h3> Code Intelligence</h3>
                <button class="modal-close" onclick="GSXCreate.closeModal('codeToolsModal')">&times;</button>
            </div>
            <div class="modal-body">
                <!-- Tool Tabs -->
                <div style="display: flex; gap: 8px; margin-bottom: 16px; border-bottom: 1px solid var(--border); padding-bottom: 12px;">
                    <button class="btn btn-sm code-tool-tab active" data-tool="search" onclick="GSXCreate.selectCodeTool('search')">Search Code</button>
                    <button class="btn btn-sm code-tool-tab" data-tool="definition" onclick="GSXCreate.selectCodeTool('definition')">Find Definition</button>
                    <button class="btn btn-sm code-tool-tab" data-tool="usages" onclick="GSXCreate.selectCodeTool('usages')">Find Usages</button>
                    <button class="btn btn-sm code-tool-tab" data-tool="repomap" onclick="GSXCreate.selectCodeTool('repomap')">Repo Map</button>
                </div>
                
                <!-- Search Code Panel -->
                <div id="codeToolSearch" class="code-tool-panel active">
                    <p style="font-size: 12px; color: var(--text-secondary); margin-bottom: 12px;">
                        Search for patterns in your codebase using regex
                    </p>
                    <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                        <input type="text" id="searchPattern" placeholder="Search pattern (regex)" style="flex: 2; padding: 10px; background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 6px; color: var(--text-primary);">
                        <input type="text" id="searchGlob" placeholder="File glob (e.g., *.js)" style="flex: 1; padding: 10px; background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 6px; color: var(--text-primary);">
                        <button class="btn btn-primary" onclick="GSXCreate.searchCode()">Search</button>
                    </div>
                    <div id="searchResults" style="max-height: 400px; overflow-y: auto; font-family: monospace; font-size: 12px;"></div>
                </div>
                
                <!-- Find Definition Panel -->
                <div id="codeToolDefinition" class="code-tool-panel">
                    <p style="font-size: 12px; color: var(--text-secondary); margin-bottom: 12px;">
                        Find where a function, class, or variable is defined
                    </p>
                    <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                        <input type="text" id="definitionSymbol" placeholder="Symbol name (e.g., handleSubmit, UserClass)" style="flex: 1; padding: 10px; background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 6px; color: var(--text-primary);">
                        <button class="btn btn-primary" onclick="GSXCreate.findDefinition()">Find</button>
                    </div>
                    <div id="definitionResults" style="max-height: 400px; overflow-y: auto; font-family: monospace; font-size: 12px;"></div>
                </div>
                
                <!-- Find Usages Panel -->
                <div id="codeToolUsages" class="code-tool-panel">
                    <p style="font-size: 12px; color: var(--text-secondary); margin-bottom: 12px;">
                        Find all places where a symbol is used
                    </p>
                    <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                        <input type="text" id="usagesSymbol" placeholder="Symbol name" style="flex: 1; padding: 10px; background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 6px; color: var(--text-primary);">
                        <button class="btn btn-primary" onclick="GSXCreate.findUsages()">Find Usages</button>
                    </div>
                    <div id="usagesResults" style="max-height: 400px; overflow-y: auto; font-family: monospace; font-size: 12px;"></div>
                </div>
                
                <!-- Repo Map Panel -->
                <div id="codeToolRepomap" class="code-tool-panel">
                    <p style="font-size: 12px; color: var(--text-secondary); margin-bottom: 12px;">
                        View the structure of your codebase - files, classes, and functions
                    </p>
                    <button class="btn btn-primary" onclick="GSXCreate.getRepoMap()" style="margin-bottom: 12px;">Generate Repo Map</button>
                    <div id="repomapResults" style="max-height: 400px; overflow-y: auto; font-family: monospace; font-size: 12px; white-space: pre-wrap;"></div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Settings Modal -->
    <div class="modal" id="settingsModal">
        <div class="modal-content" style="max-width: 450px;">
            <div class="modal-header">
                <h3> Settings</h3>
                <button class="modal-close" onclick="GSXCreate.closeModal('settingsModal')">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group" style="margin-bottom: 16px;">
                    <label style="font-size: 12px; font-weight: 500; margin-bottom: 8px; display: block; color: var(--text-primary);">
                        AI Model
                    </label>
                    <select class="form-select" id="settingsModelSelect" style="padding: 12px; font-size: 14px;">
                    </select>
                    <p style="font-size: 11px; color: var(--text-muted); margin-top: 6px;">
                        Claude Sonnet 4.5 is faster and more cost-effective. Claude Opus 4.5 is more capable for complex tasks.
                    </p>
                </div>
                
                <div style="border-top: 1px solid var(--border); padding-top: 16px; margin-top: 16px;">
                    <button class="btn btn-primary" onclick="GSXCreate.saveSettings()" style="width: 100%; padding: 12px;">
                        Save Settings
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Budget Modal -->
    <div class="modal" id="budgetModal">
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-header">
                <h3> Budget & Costs</h3>
                <button class="modal-close" onclick="GSXCreate.closeModal('budgetModal')">&times;</button>
            </div>
            <div class="modal-body">
                <!-- Current Session Stats -->
                <div style="background: var(--bg-tertiary); padding: 16px; border-radius: 8px; margin-bottom: 16px;">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 12px;">
                        <span style="color: var(--text-secondary);">Current Cost</span>
                        <span id="budgetCurrentCost" style="font-weight: 600; color: var(--success);">$0.00</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-bottom: 12px;">
                        <span style="color: var(--text-secondary);">Budget</span>
                        <span id="budgetLimit" style="font-weight: 500;"> (No limit)</span>
                    </div>
                    <div style="display: flex; justify-content: space-between;">
                        <span style="color: var(--text-secondary);">Usage</span>
                        <span id="budgetPercentage" style="font-weight: 500;">0%</span>
                    </div>
                    <div style="margin-top: 12px; height: 6px; background: var(--bg-primary); border-radius: 3px; overflow: hidden;">
                        <div id="budgetModalFill" style="height: 100%; width: 0%; background: var(--success); transition: all 0.3s;"></div>
                    </div>
                </div>
                
                <!-- Cycle Statistics -->
                <div style="background: var(--bg-tertiary); padding: 16px; border-radius: 8px; margin-bottom: 16px;">
                    <h4 style="margin: 0 0 12px 0; font-size: 12px; color: var(--text-primary);"> Cycle Statistics</h4>
                    <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                        <span style="color: var(--text-secondary); font-size: 11px;">Cycles Completed</span>
                        <span id="cyclesCompleted" style="font-size: 11px;">0</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                        <span style="color: var(--text-secondary); font-size: 11px;">Avg Cost / Cycle</span>
                        <span id="avgCostPerCycle" style="font-size: 11px; color: var(--accent);">$0.00</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                        <span style="color: var(--text-secondary); font-size: 11px;"> Reserved Buffer</span>
                        <span id="budgetBufferDisplay" style="font-size: 11px; color: var(--success);">$0.00</span>
                    </div>
                    <div style="display: flex; justify-content: space-between;">
                        <span style="color: var(--text-secondary); font-size: 11px;">Est. Cycles Remaining</span>
                        <span id="estCyclesRemaining" style="font-size: 11px;"></span>
                    </div>
                </div>
                
                <!-- Set Budget -->
                <div class="form-group" style="margin-bottom: 16px;">
                    <label style="font-size: 12px; font-weight: 500; margin-bottom: 8px; display: block; color: var(--text-primary);">
                        Set Budget Limit
                    </label>
                    <div style="display: flex; gap: 8px;">
                        <input type="number" id="budgetInput" placeholder="e.g. 5.00" step="0.50" min="0" 
                               style="flex: 1; padding: 10px; background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 6px; color: var(--text-primary); font-size: 14px;">
                        <button class="btn btn-primary" onclick="GSXCreate.setBudget()" style="padding: 10px 16px;">
                            Set
                        </button>
                    </div>
                    <p style="font-size: 10px; color: var(--text-muted); margin-top: 6px;">
                        Auto-cycle will pause when budget is reached. Leave empty for no limit.
                    </p>
                </div>
                
                <!-- Quick Budget Buttons -->
                <div style="display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 16px;">
                    <button class="btn btn-secondary btn-sm" onclick="GSXCreate.setQuickBudget(1)">$1</button>
                    <button class="btn btn-secondary btn-sm" onclick="GSXCreate.setQuickBudget(5)">$5</button>
                    <button class="btn btn-secondary btn-sm" onclick="GSXCreate.setQuickBudget(10)">$10</button>
                    <button class="btn btn-secondary btn-sm" onclick="GSXCreate.setQuickBudget(25)">$25</button>
                    <button class="btn btn-secondary btn-sm" onclick="GSXCreate.setQuickBudget(null)" style="color: var(--text-muted);">No Limit</button>
                </div>
                
                <!-- Set Reserve Buffer -->
                <div class="form-group" style="margin-bottom: 16px;">
                    <label style="font-size: 12px; font-weight: 500; margin-bottom: 8px; display: block; color: var(--text-primary);">
                         Reserve Buffer (for fixes)
                    </label>
                    <div style="display: flex; gap: 8px;">
                        <input type="number" id="budgetBufferInput" placeholder="e.g. 1.00" step="0.25" min="0" 
                               style="flex: 1; padding: 10px; background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 6px; color: var(--text-primary); font-size: 14px;">
                        <button class="btn btn-primary" onclick="GSXCreate.setBudgetBuffer()" style="padding: 10px 16px;">
                            Set
                        </button>
                    </div>
                    <p style="font-size: 10px; color: var(--text-muted); margin-top: 6px;">
                        Reserved for manual fixes after auto-cycles complete.
                    </p>
                </div>
                
                <!-- Quick Buffer Buttons -->
                <div style="display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 16px;">
                    <button class="btn btn-secondary btn-sm" onclick="GSXCreate.setQuickBudgetBuffer(0.50)">$0.50</button>
                    <button class="btn btn-secondary btn-sm" onclick="GSXCreate.setQuickBudgetBuffer(1)">$1</button>
                    <button class="btn btn-secondary btn-sm" onclick="GSXCreate.setQuickBudgetBuffer(2)">$2</button>
                    <button class="btn btn-secondary btn-sm" onclick="GSXCreate.setQuickBudgetBuffer(null)" style="color: var(--text-muted);">None</button>
                </div>
                
                <div style="border-top: 1px solid var(--border); padding-top: 16px;">
                    <button class="btn btn-secondary" onclick="GSXCreate.showTransactionLogs()" style="width: 100%; padding: 10px;">
                         View Transaction History
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Test Agent Modal -->
    <div class="modal" id="testAgentModal">
        <div class="modal-content" style="max-width: 900px; max-height: 85vh;">
            <div class="modal-header">
                <h3> Test Agent</h3>
                <button class="modal-close" onclick="GSXCreate.closeModal('testAgentModal')">&times;</button>
            </div>
            <div class="modal-body" style="overflow-y: auto;">
                <!-- Test Type Tabs -->
                <div style="display: flex; gap: 8px; margin-bottom: 16px; border-bottom: 1px solid var(--border); padding-bottom: 12px; flex-wrap: wrap;">
                    <button class="btn btn-sm test-tab active" data-test="functional" onclick="GSXCreate.selectTestTab('functional')"> Functional</button>
                    <button class="btn btn-sm test-tab" data-test="visual" onclick="GSXCreate.selectTestTab('visual')"> Visual</button>
                    <button class="btn btn-sm test-tab" data-test="accessibility" onclick="GSXCreate.selectTestTab('accessibility')"> Accessibility</button>
                    <button class="btn btn-sm test-tab" data-test="performance" onclick="GSXCreate.selectTestTab('performance')"> Performance</button>
                    <button class="btn btn-sm test-tab" data-test="interactive" onclick="GSXCreate.selectTestTab('interactive')"> AI Interactive</button>
                    <button class="btn btn-sm test-tab" data-test="ai-evals" onclick="GSXCreate.selectTestTab('ai-evals')" style="background: linear-gradient(135deg, #8b5cf6, #6366f1);"> AI Evals</button>
                </div>
                
                <!-- Functional Tests Panel -->
                <div id="testPanelFunctional" class="test-panel active">
                    <p style="font-size: 12px; color: var(--text-secondary); margin-bottom: 12px;">
                        Automatically test buttons, forms, links, and interactions using Playwright
                    </p>
                    <div style="display: flex; gap: 8px; margin-bottom: 16px; align-items: center; flex-wrap: wrap;">
                        <select id="browserSelect" style="padding: 8px; background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 6px; color: var(--text-primary);">
                            <option value="chromium"> Chrome</option>
                            <option value="firefox"> Firefox</option>
                            <option value="webkit"> Safari</option>
                        </select>
                        <button class="btn btn-primary" onclick="GSXCreate.generateTestPlan()"> Generate Test Plan</button>
                        <button class="btn btn-success" onclick="GSXCreate.runFunctionalTests()" id="runTestsBtn" disabled> Run Tests</button>
                        <label style="display: flex; align-items: center; gap: 6px; font-size: 12px; color: var(--text-secondary);">
                            <input type="checkbox" id="useAIForTests" checked> Use AI
                        </label>
                    </div>
                    
                    <!-- Test Plan Display -->
                    <div id="testPlanDisplay" style="margin-bottom: 16px; display: none;">
                        <h4 style="font-size: 13px; margin-bottom: 8px; color: var(--text-primary);"> Test Plan</h4>
                        <div id="testPlanList" style="background: var(--bg-tertiary); border-radius: 6px; padding: 12px; max-height: 200px; overflow-y: auto;"></div>
                    </div>
                    
                    <!-- Test Results -->
                    <div id="testResultsDisplay" style="display: none;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <h4 style="font-size: 13px; color: var(--text-primary);"> Results</h4>
                            <button class="btn btn-success btn-sm" onclick="GSXCreate.fixFailedTests()" id="fixFailedTestsBtn" disabled> Fix Failed Tests</button>
                        </div>
                        <div id="testSummary" style="display: flex; gap: 16px; margin-bottom: 12px; padding: 12px; background: var(--bg-tertiary); border-radius: 6px;"></div>
                        <div id="testResultsList" style="max-height: 300px; overflow-y: auto;"></div>
                    </div>
                </div>
                
                <!-- Visual Tests Panel -->
                <div id="testPanelVisual" class="test-panel">
                    <p style="font-size: 12px; color: var(--text-secondary); margin-bottom: 12px;">
                        Capture screenshots and compare visual changes over time. Test across multiple browsers.
                    </p>
                    <div style="display: flex; gap: 8px; margin-bottom: 16px; flex-wrap: wrap;">
                        <button class="btn btn-primary" onclick="GSXCreate.captureBaseline()"> Capture Baseline</button>
                        <button class="btn btn-secondary" onclick="GSXCreate.compareVisual()"> Compare to Baseline</button>
                        <button class="btn btn-secondary" onclick="GSXCreate.runCrossBrowserTest()" style="background: linear-gradient(135deg, #4285f4, #ea4335, #fbbc05);"> Cross-Browser Test</button>
                    </div>
                    <div id="visualTestResults" style="display: flex; gap: 16px; flex-wrap: wrap;"></div>
                </div>
                
                <!-- Accessibility Tests Panel -->
                <div id="testPanelAccessibility" class="test-panel">
                    <p style="font-size: 12px; color: var(--text-secondary); margin-bottom: 12px;">
                        Check for accessibility issues: missing alt text, labels, keyboard navigation, etc.
                    </p>
                    <div style="display: flex; gap: 8px; margin-bottom: 16px;">
                        <button class="btn btn-primary" onclick="GSXCreate.runAccessibilityTest()"> Run Accessibility Audit</button>
                        <button class="btn btn-success" onclick="GSXCreate.fixAccessibilityIssues()" id="fixAccessibilityBtn" disabled> Fix Issues</button>
                    </div>
                    <div id="accessibilityResults"></div>
                </div>
                
                <!-- Performance Tests Panel -->
                <div id="testPanelPerformance" class="test-panel">
                    <p style="font-size: 12px; color: var(--text-secondary); margin-bottom: 12px;">
                        Measure load time, DOM size, and resource usage
                    </p>
                    <div style="display: flex; gap: 8px; margin-bottom: 16px;">
                        <button class="btn btn-primary" onclick="GSXCreate.runPerformanceTest()"> Run Performance Test</button>
                        <button class="btn btn-success" onclick="GSXCreate.fixPerformanceIssues()" id="fixPerformanceBtn" disabled> Optimize</button>
                    </div>
                    <div id="performanceResults"></div>
                </div>
                
                <!-- AI Interactive Tests Panel -->
                <div id="testPanelInteractive" class="test-panel">
                    <p style="font-size: 12px; color: var(--text-secondary); margin-bottom: 12px;">
                        Let AI analyze your UI, find bugs, and suggest fixes - then implement them automatically
                    </p>
                    <div style="display: flex; gap: 8px; margin-bottom: 16px;">
                        <button class="btn btn-primary" onclick="GSXCreate.runInteractiveTest()"> AI Analyze & Test</button>
                        <button class="btn btn-success" onclick="GSXCreate.implementTestFixes()" id="implementFixesBtn" disabled> Implement Fixes</button>
                    </div>
                    <div id="interactiveResults"></div>
                </div>
                
                <!-- AI Evals Panel -->
                <div id="testPanelAi-evals" class="test-panel">
                    <p style="font-size: 12px; color: var(--text-secondary); margin-bottom: 12px;">
                        Run LLM-based evaluations using vitest-evals and promptfoo. Validate tool calls, code quality, and plan accuracy.
                    </p>
                    <div style="display: flex; gap: 8px; margin-bottom: 16px; flex-wrap: wrap;">
                        <select id="evalProfileSelect" style="padding: 8px; background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 6px; color: var(--text-primary);">
                            <option value="quick"> Quick (2-3 agents, ~5s)</option>
                            <option value="standard" selected> Standard (4-5 agents, ~15s)</option>
                            <option value="deep"> Deep (All agents, ~45s)</option>
                        </select>
                        <button class="btn btn-primary" onclick="GSXCreate.runAIEvals()"> Run AI Evals</button>
                        <button class="btn btn-secondary" onclick="GSXCreate.runMultiAgentEval()"> Multi-Agent Eval</button>
                        <button class="btn btn-success" onclick="GSXCreate.toggleEvalHUD()"> Show Eval HUD</button>
                    </div>
                    
                    <!-- Eval Results -->
                    <div id="aiEvalsResults" style="display: none;">
                        <h4 style="font-size: 13px; margin-bottom: 8px; color: var(--text-primary);"> Evaluation Results</h4>
                        <div id="aiEvalsResultsList" style="background: var(--bg-tertiary); border-radius: 6px; padding: 12px; max-height: 300px; overflow-y: auto;"></div>
                    </div>
                    
                    <!-- Run History -->
                    <div id="aiEvalsHistory" style="margin-top: 16px;">
                        <h4 style="font-size: 13px; margin-bottom: 8px; color: var(--text-primary);"> Recent Evals</h4>
                        <div id="aiEvalsHistoryList" style="font-size: 12px; color: var(--text-secondary);">
                            No evaluations run yet
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Feedback Prompt Modal (after testing) -->
    <div class="modal" id="feedbackPromptModal">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
                <h3> Testing Feedback</h3>
                <button class="modal-close" onclick="GSXCreate.closeModal('feedbackPromptModal')">&times;</button>
            </div>
            <div class="modal-body">
                <p style="margin-bottom: 12px; color: var(--text-secondary);">Did you find any issues while testing?</p>
                <div id="autoDetectedErrors" style="margin-bottom: 12px;"></div>
                <textarea id="testingFeedbackInput" placeholder="Describe any issues you found..." rows="4" style="width: 100%; padding: 12px; background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 8px; color: var(--text-primary); font-size: 13px; resize: vertical;"></textarea>
            </div>
            <div class="modal-footer" style="display: flex; gap: 8px; justify-content: flex-end;">
                <button class="btn btn-secondary" onclick="GSXCreate.skipTestingFeedback()">No Issues</button>
                <button class="btn btn-primary" onclick="GSXCreate.submitTestingFeedback()">Submit Feedback</button>
            </div>
        </div>
    </div>
    
    <script>
        // ==================== TAB MANAGER ====================
        const TabManager = {
            // State
            tabs: new Map(), // tabId -> { branchId, name, status, cost, aiderSession, ... }
            activeTab: 'main',
            branchSessions: new Map(), // branchId -> Aider session state
            tabStates: new Map(), // tabId -> { messages: [], contextFiles: [], costSummary: {...} }
            
            // Initialize TabManager
            init() {
                console.log('[TabManager] Initializing...');
                // Register the main branch tab
                this.tabs.set('main-branch', {
                    branchId: 'main',
                    name: 'main',
                    status: 'idle',
                    cost: 0,
                    budget: 5.00,
                    version: 'v1.0',
                    phase: null,
                    phaseProgress: 0,
                    isDefault: true
                });
                
                // Initialize state for main branch
                this.tabStates.set('main-branch', {
                    messages: [],
                    contextFiles: [],
                    projectFiles: [],
                    costSummary: { totalCost: 0, totalCalls: 0 },
                    initialized: false
                });
                
                // Don't switch tabs on init - let the setup panel show
                // The tab bar is hidden until session starts
                this.activeTab = 'main-branch';
            },
            
            // Get the state for a specific tab
            getTabState(tabId) {
                if (!this.tabStates.has(tabId)) {
                    this.tabStates.set(tabId, {
                        messages: [],
                        contextFiles: [],
                        projectFiles: [],
                        costSummary: { totalCost: 0, totalCalls: 0 },
                        initialized: false
                    });
                }
                return this.tabStates.get(tabId);
            },
            
            // Save current GSXCreate state to the active tab
            saveCurrentTabState() {
                if (this.activeTab === 'main') return; // Overview tab has no state to save
                
                const state = this.getTabState(this.activeTab);
                
                // Save current messages from DOM
                const messagesEl = document.querySelector(`#tab-content-${this.activeTab} .messages`);
                if (messagesEl) {
                    state.messagesHTML = messagesEl.innerHTML;
                }
                
                // Save context files
                state.contextFiles = [...(GSXCreate.contextFiles || [])];
                state.projectFiles = [...(GSXCreate.projectFiles || [])];
                state.costSummary = { ...GSXCreate.costSummary };
                
                console.log('[TabManager] Saved state for tab:', this.activeTab);
            },
            
            // Restore state when switching to a tab
            restoreTabState(tabId) {
                if (tabId === 'main') return; // Overview tab has no state to restore
                
                const state = this.getTabState(tabId);
                
                // Restore messages to DOM
                if (state.messagesHTML) {
                    const messagesEl = document.querySelector(`#tab-content-${tabId} .messages`);
                    if (messagesEl) {
                        messagesEl.innerHTML = state.messagesHTML;
                    }
                }
                
                // Restore context to GSXCreate (for the active session)
                GSXCreate.contextFiles = [...state.contextFiles];
                GSXCreate.projectFiles = [...state.projectFiles];
                
                // Update cost display for this tab
                const tab = this.tabs.get(tabId);
                if (tab) {
                    this.updateTabCost(tabId, state.costSummary.totalCost || 0, tab.budget);
                }
                
                console.log('[TabManager] Restored state for tab:', tabId);
            },
            
            // Switch to a tab
            switchTab(tabId) {
                console.log('[TabManager] Switching to tab:', tabId);
                
                // Save current tab state before switching
                if (this.activeTab && this.activeTab !== 'main') {
                    this.saveCurrentTabState();
                }
                
                // Update active state on tab bar
                document.querySelectorAll('.tab-item').forEach(tab => {
                    tab.classList.toggle('active', tab.dataset.tab === tabId);
                });
                
                // Show/hide tab content
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.toggle('active', content.dataset.tab === tabId);
                });
                
                const previousTab = this.activeTab;
                this.activeTab = tabId;
                
                // If switching to a branch tab, ensure Aider session is ready and restore state
                if (tabId !== 'main' && this.tabs.has(tabId)) {
                    const tab = this.tabs.get(tabId);
                    this.activateBranchSession(tab.branchId);
                    this.restoreTabState(tabId);
                }
                
                // Update overview if switching to main tab
                if (tabId === 'main') {
                    this.refreshOverview();
                }
                
                console.log('[TabManager] Switched from', previousTab, 'to', tabId);
            },
            
            // Refresh the overview tab
            refreshOverview() {
                console.log('[TabManager] Refreshing overview...');
                
                // Update current space display
                const spaceDisplay = document.getElementById('globalCurrentSpace');
                if (spaceDisplay && GSXCreate.currentSpaceName) {
                    spaceDisplay.textContent = GSXCreate.currentSpaceName;
                }
                
                // Calculate totals
                let total = 0;
                let branchCount = 0;
                this.tabs.forEach((tab, tabId) => {
                    if (tabId !== 'main') {
                        total += tab.cost || 0;
                        branchCount++;
                    }
                });
                
                // Update total budget spent
                const totalSpent = document.getElementById('totalBudgetSpent');
                if (totalSpent) {
                    totalSpent.textContent = '$' + total.toFixed(2);
                }
                
                // Update overview tooltip values
                const tooltipBranchCount = document.getElementById('tooltip-branch-count');
                if (tooltipBranchCount) tooltipBranchCount.textContent = branchCount;
                
                const tooltipTotalCost = document.getElementById('tooltip-total-cost');
                if (tooltipTotalCost) tooltipTotalCost.textContent = '$' + total.toFixed(2);
                
                // Update branch list
                this.renderBranchList();
                
                // Update budget breakdown
                this.renderBudgetBreakdown();
                
                // Update compare dropdowns
                this.updateCompareDropdowns();
            },
            
            // Render the branch list in the overview
            renderBranchList() {
                const container = document.getElementById('branchListContainer');
                if (!container) return;
                
                let html = '';
                this.tabs.forEach((tab, tabId) => {
                    if (tabId === 'main') return; // Skip the overview "tab"
                    
                    const statusClass = tab.status === 'running' ? 'running' : 
                                       tab.status === 'error' ? 'error' : '';
                    const statusDot = tab.status === 'running' ? '' : 
                                     tab.status === 'success' ? '' :
                                     tab.status === 'error' ? '' : '';
                    
                    html += `
                        <div class="branch-list-item ${this.activeTab === tabId ? 'active' : ''}" onclick="TabManager.switchTab('${tabId}')">
                            <span class="branch-icon"></span>
                            <div class="branch-info">
                                <div class="branch-name">${this.escapeHtml(tab.name)} <span style="font-size: 10px; color: var(--accent); margin-left: 4px;">${tab.version || 'v1.0'}</span></div>
                                <div class="branch-meta">${statusDot} ${tab.isDefault ? 'Default branch' : tab.status || 'Idle'}</div>
                            </div>
                            <span class="branch-cost">$${(tab.cost || 0).toFixed(2)}</span>
                            <div class="branch-actions">
                                <button class="branch-action-btn" title="Open in tab" onclick="event.stopPropagation(); TabManager.switchTab('${tabId}')"></button>
                                ${!tab.isDefault ? `<button class="branch-action-btn" title="Delete branch" onclick="event.stopPropagation(); TabManager.deleteBranch('${tabId}')" style="color: var(--danger);"></button>` : ''}
                            </div>
                        </div>
                    `;
                });
                
                container.innerHTML = html || '<div style="color: var(--text-muted); text-align: center; padding: 20px;">No branches yet</div>';
            },
            
            // Render budget breakdown
            renderBudgetBreakdown() {
                const container = document.getElementById('budgetBreakdown');
                if (!container) return;
                
                let html = '';
                this.tabs.forEach((tab, tabId) => {
                    if (tabId === 'main') return;
                    html += `
                        <div class="budget-row">
                            <span class="name">${tab.name}</span>
                            <span class="value">$${(tab.cost || 0).toFixed(2)}</span>
                        </div>
                    `;
                });
                
                container.innerHTML = html || '<div class="budget-row"><span class="name">No branches</span><span class="value">$0.00</span></div>';
            },
            
            // Update compare dropdowns
            updateCompareDropdowns() {
                const selectA = document.getElementById('compareBranchA');
                const selectB = document.getElementById('compareBranchB');
                if (!selectA || !selectB) return;
                
                let optionsHtml = '';
                this.tabs.forEach((tab, tabId) => {
                    if (tabId === 'main') return;
                    optionsHtml += `<option value="${tab.branchId}">${tab.name}</option>`;
                });
                
                selectA.innerHTML = optionsHtml;
                selectB.innerHTML = '<option value="">Select branch...</option>' + optionsHtml;
            },
            
            // Show new branch modal
            showNewBranchModal() {
                const modal = document.getElementById('newBranchModal');
                if (modal) {
                    modal.classList.add('active');
                    // Update base branch dropdown
                    const baseSelect = document.getElementById('newBranchBase');
                    if (baseSelect) {
                        let html = '';
                        this.tabs.forEach((tab, tabId) => {
                            if (tabId === 'main') return;
                            html += `<option value="${tab.branchId}">${tab.name}</option>`;
                        });
                        baseSelect.innerHTML = html;
                    }
                }
            },
            
            // Close new branch modal
            closeNewBranchModal() {
                const modal = document.getElementById('newBranchModal');
                if (modal) modal.classList.remove('active');
            },
            
            // Create a new branch
            async createBranch() {
                const nameInput = document.getElementById('newBranchName');
                const baseSelect = document.getElementById('newBranchBase');
                const modelSelect = document.getElementById('newBranchModel');
                
                const branchName = nameInput?.value?.trim() || `branch-${Date.now()}`;
                const baseBranch = baseSelect?.value || 'main';
                const model = modelSelect?.value || 'claude-sonnet-4-20250514';
                
                // Sanitize branch name for use as ID
                const branchId = branchName.toLowerCase().replace(/[^a-z0-9-]/g, '-');
                const tabId = `branch-${branchId}`;
                
                console.log('[TabManager] Creating branch:', branchName, 'from', baseBranch);
                
                // Create git branch if repo is available
                if (GSXCreate.repoPath && window.aider?.gitCreateBranch) {
                    try {
                        const result = await window.aider.gitCreateBranch(GSXCreate.repoPath, branchName, baseBranch);
                        if (!result.success) {
                            console.error('[TabManager] Failed to create git branch:', result.error);
                            GSXCreate.showToast?.('error', 'Failed to create branch: ' + result.error);
                            return;
                        }
                    } catch (error) {
                        console.error('[TabManager] Error creating branch:', error);
                    }
                }
                
                // Register the new tab
                this.tabs.set(tabId, {
                    branchId: branchName,
                    name: branchName,
                    status: 'idle',
                    cost: 0,
                    budget: 5.00,
                    version: 'v1.0',
                    phase: null,
                    phaseProgress: 0,
                    model: model,
                    baseBranch: baseBranch,
                    isDefault: false
                });
                
                // Initialize isolated state for this tab
                this.tabStates.set(tabId, {
                    messages: [],
                    contextFiles: [],
                    projectFiles: [...(GSXCreate.projectFiles || [])], // Copy current project files
                    costSummary: { totalCost: 0, totalCalls: 0 },
                    initialized: false,
                    messagesHTML: `
                        <div class="message">
                            <span class="message-time">${new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</span>
                            <span class="message-type system">SYS</span>
                            <span class="message-content">Branch "${branchName}" created. Describe what you want to build or modify.</span>
                        </div>
                    `
                });
                
                // Create tab element
                this.createTabElement(tabId, branchName);
                
                // Create tab content (clone from main-branch template)
                this.createTabContent(tabId, branchName);
                
                // Close modal and switch to new tab
                this.closeNewBranchModal();
                this.switchTab(tabId);
                
                // Refresh overview
                this.refreshOverview();
                
                GSXCreate.showToast?.('success', `Branch "${branchName}" created`);
            },
            
            // Create a tab element in the tab bar
            createTabElement(tabId, name) {
                const tabBar = document.getElementById('tabBar');
                const addBtn = tabBar?.querySelector('.tab-add-btn');
                
                if (!tabBar || !addBtn) return;
                
                const tab = this.tabs.get(tabId);
                const version = tab?.version || 'v1.0';
                
                const tabEl = document.createElement('button');
                tabEl.className = 'tab-item';
                tabEl.dataset.tab = tabId;
                tabEl.onclick = () => this.switchTab(tabId);
                tabEl.innerHTML = `
                    <span class="tab-status-indicator idle" id="tab-status-${tabId}"></span>
                    <span class="tab-icon"></span>
                    <span class="tab-label">${this.escapeHtml(name)}</span>
                    <span class="tab-version" id="tab-version-${tabId}">${version}</span>
                    <span class="tab-close" onclick="event.stopPropagation(); TabManager.closeTab('${tabId}')"></span>
                    <!-- Hover Tooltip -->
                    <div class="tab-tooltip">
                        <div class="tab-tooltip-header">
                            <span class="tab-tooltip-title">${this.escapeHtml(name)}</span>
                            <span class="tab-tooltip-version" id="tooltip-version-${tabId}">${version}</span>
                        </div>
                        <div class="tab-tooltip-row">
                            <span class="tab-tooltip-label">Status</span>
                            <span class="tab-tooltip-value" id="tooltip-status-${tabId}">Idle</span>
                        </div>
                        <div class="tab-tooltip-row">
                            <span class="tab-tooltip-label">Cost</span>
                            <span class="tab-tooltip-value" id="tooltip-cost-${tabId}">$0.00</span>
                        </div>
                        <div class="tab-tooltip-progress">
                            <div class="tab-tooltip-progress-label">
                                <span>Phase Progress</span>
                                <span id="tooltip-phase-pct-${tabId}">0%</span>
                            </div>
                            <div class="tab-tooltip-progress-bar">
                                <div class="tab-tooltip-progress-fill phase" id="tooltip-phase-fill-${tabId}" style="width: 0%;"></div>
                            </div>
                        </div>
                        <div class="tab-tooltip-progress" style="margin-top: 8px;">
                            <div class="tab-tooltip-progress-label">
                                <span>Budget Used</span>
                                <span id="tooltip-budget-pct-${tabId}">0%</span>
                            </div>
                            <div class="tab-tooltip-progress-bar">
                                <div class="tab-tooltip-progress-fill budget" id="tooltip-budget-fill-${tabId}" style="width: 0%;"></div>
                            </div>
                        </div>
                    </div>
                `;
                
                tabBar.insertBefore(tabEl, addBtn);
            },
            
            // Create tab content container
            createTabContent(tabId, branchName) {
                const container = document.querySelector('.tab-content-container');
                if (!container) return;
                
                // Clone the main-branch tab content as a template
                const template = document.getElementById('tab-content-main-branch');
                if (!template) return;
                
                const newContent = template.cloneNode(true);
                newContent.id = `tab-content-${tabId}`;
                newContent.dataset.tab = tabId;
                newContent.classList.remove('active');
                
                // Update IDs to be unique for this branch
                newContent.querySelectorAll('[id]').forEach(el => {
                    el.id = el.id + '-' + tabId;
                });
                
                container.appendChild(newContent);
            },
            
            // Close a tab
            async closeTab(tabId) {
                if (!this.tabs.has(tabId)) return;
                
                const tab = this.tabs.get(tabId);
                if (tab.isDefault) {
                    console.log('[TabManager] Cannot close default branch tab');
                    return;
                }
                
                // Remove tab element
                const tabEl = document.querySelector(`.tab-item[data-tab="${tabId}"]`);
                if (tabEl) tabEl.remove();
                
                // Remove tab content
                const content = document.getElementById(`tab-content-${tabId}`);
                if (content) content.remove();
                
                // Clean up Aider session for this branch
                await this.cleanupBranchSession(tab.branchId);
                
                // Remove from tabs map
                this.tabs.delete(tabId);
                
                // Switch to main if this was the active tab
                if (this.activeTab === tabId) {
                    this.switchTab('main');
                }
                
                this.refreshOverview();
            },
            
            // Delete a branch entirely
            async deleteBranch(tabId) {
                if (!this.tabs.has(tabId)) return;
                
                const tab = this.tabs.get(tabId);
                if (tab.isDefault) return;
                
                if (!confirm(`Delete branch "${tab.name}"? This cannot be undone.`)) return;
                
                // Delete git branch if repo is available
                if (GSXCreate.repoPath && window.aider?.gitDeleteBranch) {
                    try {
                        await window.aider.gitDeleteBranch(GSXCreate.repoPath, tab.branchId);
                    } catch (error) {
                        console.error('[TabManager] Error deleting branch:', error);
                    }
                }
                
                this.closeTab(tabId);
                GSXCreate.showToast?.('success', `Branch "${tab.name}" deleted`);
            },
            
            // Activate a branch session
            async activateBranchSession(branchId) {
                console.log('[TabManager] Activating session for branch:', branchId);
                
                // If main branch, use the default GSXCreate session
                if (branchId === 'main') {
                    return;
                }
                
                // Check if session already exists
                if (this.branchSessions.has(branchId)) {
                    console.log('[TabManager] Session already exists for branch:', branchId);
                    return;
                }
                
                // For other branches, switch git branch and start a sandboxed Aider session
                if (GSXCreate.repoPath) {
                    try {
                        // Switch git branch
                        if (window.aider?.gitSwitchBranch) {
                            const switchResult = await window.aider.gitSwitchBranch(GSXCreate.repoPath, branchId);
                            if (!switchResult.success) {
                                console.error('[TabManager] Failed to switch branch:', switchResult.error);
                            }
                        }
                        
                        // Initialize sandboxed Aider for this branch
                        if (window.aider?.initBranchAider) {
                            const tab = Array.from(this.tabs.values()).find(t => t.branchId === branchId);
                            const model = tab?.model || 'claude-sonnet-4-20250514';
                            
                            const initResult = await window.aider.initBranchAider(
                                GSXCreate.repoPath,
                                branchId,
                                model,
                                [] // readOnlyFiles
                            );
                            
                            if (initResult.success) {
                                this.branchSessions.set(branchId, {
                                    initialized: true,
                                    model: model,
                                    startTime: new Date()
                                });
                                console.log('[TabManager] Initialized Aider session for branch:', branchId);
                            } else {
                                console.error('[TabManager] Failed to initialize branch Aider:', initResult.error);
                            }
                        }
                    } catch (error) {
                        console.error('[TabManager] Error activating branch session:', error);
                    }
                }
            },
            
            // Send a prompt to a specific branch's Aider session
            async sendBranchPrompt(branchId, prompt, callback) {
                console.log('[TabManager] Sending prompt to branch:', branchId);
                
                // If main branch, use the default GSXCreate session
                if (branchId === 'main') {
                    return GSXCreate.sendPrompt();
                }
                
                // For other branches, use the sandboxed session
                if (!this.branchSessions.has(branchId)) {
                    await this.activateBranchSession(branchId);
                }
                
                if (window.aider?.runBranchPromptStreaming && callback) {
                    return window.aider.runBranchPromptStreaming(branchId, prompt, callback);
                } else if (window.aider?.runBranchPrompt) {
                    return window.aider.runBranchPrompt(branchId, prompt);
                }
            },
            
            // Cleanup a branch's Aider session
            async cleanupBranchSession(branchId) {
                if (!this.branchSessions.has(branchId)) return;
                
                if (window.aider?.cleanupBranchAider) {
                    try {
                        await window.aider.cleanupBranchAider(branchId);
                        this.branchSessions.delete(branchId);
                        console.log('[TabManager] Cleaned up session for branch:', branchId);
                    } catch (error) {
                        console.error('[TabManager] Error cleaning up branch session:', error);
                    }
                }
            },
            
            // Update tab status
            updateTabStatus(tabId, status, phase = null, phaseProgress = 0) {
                const tab = this.tabs.get(tabId);
                if (tab) {
                    tab.status = status;
                    tab.phase = phase;
                    tab.phaseProgress = phaseProgress;
                    
                    // Update status indicator
                    const statusEl = document.getElementById(`tab-status-${tabId}`);
                    if (statusEl) {
                        statusEl.className = 'tab-status-indicator ' + status;
                    }
                    
                    // Update tooltip status text
                    const tooltipStatus = document.getElementById(`tooltip-status-${tabId}`);
                    if (tooltipStatus) {
                        const statusLabels = {
                            idle: 'Idle',
                            running: 'Running...',
                            success: 'Complete',
                            error: 'Error'
                        };
                        tooltipStatus.textContent = phase ? `${statusLabels[status] || status} (${phase})` : (statusLabels[status] || status);
                    }
                    
                    // Update phase progress in tooltip
                    const phasePct = document.getElementById(`tooltip-phase-pct-${tabId}`);
                    const phaseFill = document.getElementById(`tooltip-phase-fill-${tabId}`);
                    if (phasePct) phasePct.textContent = `${Math.round(phaseProgress)}%`;
                    if (phaseFill) phaseFill.style.width = `${phaseProgress}%`;
                }
            },
            
            // Update tab cost
            updateTabCost(tabId, cost, budget = null) {
                const tab = this.tabs.get(tabId);
                if (tab) {
                    tab.cost = cost;
                    if (budget !== null) tab.budget = budget;
                    
                    // Update tooltip cost
                    const tooltipCost = document.getElementById(`tooltip-cost-${tabId}`);
                    if (tooltipCost) {
                        tooltipCost.textContent = '$' + cost.toFixed(2);
                    }
                    
                    // Update budget progress in tooltip
                    const budgetPct = document.getElementById(`tooltip-budget-pct-${tabId}`);
                    const budgetFill = document.getElementById(`tooltip-budget-fill-${tabId}`);
                    if (budget && budget > 0) {
                        const pct = Math.min((cost / budget) * 100, 100);
                        if (budgetPct) budgetPct.textContent = `${Math.round(pct)}%`;
                        if (budgetFill) {
                            budgetFill.style.width = `${pct}%`;
                            budgetFill.className = 'tab-tooltip-progress-fill budget' + 
                                (pct > 90 ? ' danger' : pct > 70 ? ' warning' : '');
                        }
                    }
                    
                    // Update overview tooltip total
                    const totalCost = document.getElementById('tooltip-total-cost');
                    if (totalCost) {
                        totalCost.textContent = '$' + this.getTotalCost().toFixed(2);
                    }
                }
            },
            
            // Update tab version
            updateTabVersion(tabId, version) {
                const tab = this.tabs.get(tabId);
                if (tab) {
                    tab.version = version;
                    
                    const versionEl = document.getElementById(`tab-version-${tabId}`);
                    if (versionEl) versionEl.textContent = version;
                    
                    const tooltipVersion = document.getElementById(`tooltip-version-${tabId}`);
                    if (tooltipVersion) tooltipVersion.textContent = version;
                }
            },
            
            // Set global model
            setGlobalModel(model) {
                console.log('[TabManager] Setting global model:', model);
                GSXCreate.selectedModel = model;
            },
            
            // Compare branches
            async compareBranches() {
                const branchA = document.getElementById('compareBranchA')?.value;
                const branchB = document.getElementById('compareBranchB')?.value;
                
                if (!branchA || !branchB) {
                    GSXCreate.showToast?.('error', 'Please select two branches to compare');
                    return;
                }
                
                if (branchA === branchB) {
                    GSXCreate.showToast?.('error', 'Please select different branches to compare');
                    return;
                }
                
                console.log('[TabManager] Comparing branches:', branchA, 'vs', branchB);
                
                // Show results container
                const resultsContainer = document.getElementById('compareResultsContainer');
                if (resultsContainer) {
                    resultsContainer.style.display = 'block';
                }
                
                // Update pane headers
                document.getElementById('comparePaneAName').textContent = branchA;
                document.getElementById('comparePaneBName').textContent = branchB;
                
                // Reset state
                document.getElementById('comparePaneAContent').innerHTML = '<div style="color: var(--text-muted);">Loading diff...</div>';
                document.getElementById('comparePaneBContent').innerHTML = '<div style="color: var(--text-muted);">Loading diff...</div>';
                
                // Get diff if available
                if (GSXCreate.repoPath && window.aider?.gitDiffBranches) {
                    try {
                        const result = await window.aider.gitDiffBranches(GSXCreate.repoPath, branchA, branchB);
                        if (result.success && result.diff) {
                            this.parsedDiff = this.parseDiff(result.diff);
                            this.renderDiffSummary(this.parsedDiff);
                            this.renderDiffFilesList(this.parsedDiff);
                            
                            // Show first file by default
                            if (this.parsedDiff.files.length > 0) {
                                this.renderFileDiff(this.parsedDiff.files[0]);
                            } else {
                                document.getElementById('comparePaneAContent').innerHTML = '<div style="color: var(--text-muted);">No differences found</div>';
                                document.getElementById('comparePaneBContent').innerHTML = '<div style="color: var(--text-muted);">No differences found</div>';
                            }
                        } else {
                            document.getElementById('diffFilesChanged').textContent = '0';
                            document.getElementById('diffInsertions').textContent = '0';
                            document.getElementById('diffDeletions').textContent = '0';
                            document.getElementById('diffFilesList').innerHTML = '';
                            document.getElementById('comparePaneAContent').innerHTML = '<div style="color: var(--text-muted);">No differences found</div>';
                            document.getElementById('comparePaneBContent').innerHTML = '<div style="color: var(--text-muted);">No differences found</div>';
                        }
                    } catch (error) {
                        console.error('[TabManager] Error comparing branches:', error);
                        document.getElementById('comparePaneAContent').innerHTML = '<div style="color: var(--danger);">Error: ' + error.message + '</div>';
                        document.getElementById('comparePaneBContent').innerHTML = '';
                    }
                } else {
                    document.getElementById('comparePaneAContent').innerHTML = '<div style="color: var(--text-muted);">Branch comparison requires an active repository</div>';
                    document.getElementById('comparePaneBContent').innerHTML = '';
                }
            },
            
            // Parse git diff output into structured format
            parseDiff(diffText) {
                const result = {
                    files: [],
                    totalInsertions: 0,
                    totalDeletions: 0
                };
                
                const lines = diffText.split('\n');
                let currentFile = null;
                
                for (const line of lines) {
                    // New file
                    if (line.startsWith('diff --git')) {
                        if (currentFile) {
                            result.files.push(currentFile);
                        }
                        const match = line.match(/diff --git a\/(.*) b\/(.*)/);
                        currentFile = {
                            pathA: match?.[1] || '',
                            pathB: match?.[2] || '',
                            name: match?.[2] || match?.[1] || 'unknown',
                            hunks: [],
                            insertions: 0,
                            deletions: 0
                        };
                    } else if (currentFile) {
                        if (line.startsWith('@@')) {
                            currentFile.hunks.push({ header: line, lines: [] });
                        } else if (currentFile.hunks.length > 0) {
                            const hunk = currentFile.hunks[currentFile.hunks.length - 1];
                            hunk.lines.push(line);
                            
                            if (line.startsWith('+') && !line.startsWith('+++')) {
                                currentFile.insertions++;
                                result.totalInsertions++;
                            } else if (line.startsWith('-') && !line.startsWith('---')) {
                                currentFile.deletions++;
                                result.totalDeletions++;
                            }
                        }
                    }
                }
                
                if (currentFile) {
                    result.files.push(currentFile);
                }
                
                return result;
            },
            
            // Render diff summary
            renderDiffSummary(parsed) {
                document.getElementById('diffFilesChanged').textContent = parsed.files.length;
                document.getElementById('diffInsertions').textContent = parsed.totalInsertions;
                document.getElementById('diffDeletions').textContent = parsed.totalDeletions;
            },
            
            // Render list of changed files
            renderDiffFilesList(parsed) {
                const container = document.getElementById('diffFilesList');
                if (!container) return;
                
                let html = '';
                parsed.files.forEach((file, index) => {
                    const isActive = index === 0 ? 'active' : '';
                    html += `
                        <div class="branch-list-item ${isActive}" onclick="TabManager.selectDiffFile(${index})" data-file-index="${index}">
                            <span style="font-size: 14px;"></span>
                            <div class="branch-info">
                                <div class="branch-name" style="font-size: 12px;">${this.escapeHtml(file.name)}</div>
                            </div>
                            <span style="color: var(--success); font-size: 11px;">+${file.insertions}</span>
                            <span style="color: var(--danger); font-size: 11px;">-${file.deletions}</span>
                        </div>
                    `;
                });
                
                container.innerHTML = html || '<div style="color: var(--text-muted); text-align: center; padding: 12px;">No files changed</div>';
            },
            
            // Select a file to view its diff
            selectDiffFile(index) {
                if (!this.parsedDiff || !this.parsedDiff.files[index]) return;
                
                // Update active state
                document.querySelectorAll('#diffFilesList .branch-list-item').forEach((el, i) => {
                    el.classList.toggle('active', i === index);
                });
                
                this.renderFileDiff(this.parsedDiff.files[index]);
            },
            
            // Render diff for a specific file
            renderFileDiff(file) {
                const paneA = document.getElementById('comparePaneAContent');
                const paneB = document.getElementById('comparePaneBContent');
                if (!paneA || !paneB) return;
                
                let htmlA = '';
                let htmlB = '';
                
                file.hunks.forEach(hunk => {
                    // Add hunk header
                    const headerHtml = `<div class="diff-line" style="color: var(--accent); background: var(--bg-tertiary);">${this.escapeHtml(hunk.header)}</div>`;
                    htmlA += headerHtml;
                    htmlB += headerHtml;
                    
                    hunk.lines.forEach(line => {
                        if (line.startsWith('-') && !line.startsWith('---')) {
                            htmlA += `<div class="diff-line removed">${this.escapeHtml(line)}</div>`;
                        } else if (line.startsWith('+') && !line.startsWith('+++')) {
                            htmlB += `<div class="diff-line added">${this.escapeHtml(line)}</div>`;
                        } else if (!line.startsWith('\\')) {
                            const escaped = this.escapeHtml(line);
                            htmlA += `<div class="diff-line">${escaped}</div>`;
                            htmlB += `<div class="diff-line">${escaped}</div>`;
                        }
                    });
                });
                
                paneA.innerHTML = htmlA || '<div style="color: var(--text-muted);">No changes</div>';
                paneB.innerHTML = htmlB || '<div style="color: var(--text-muted);">No changes</div>';
            },
            
            // Escape HTML
            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            },
            
            // Load existing git branches for a repository
            async loadGitBranches(repoPath) {
                console.log('[TabManager] Loading git branches for:', repoPath);
                
                if (!repoPath || !window.aider?.gitListBranches) {
                    console.log('[TabManager] No repo path or API not available');
                    return;
                }
                
                try {
                    let result = await window.aider.gitListBranches(repoPath);
                    
                    // If not a git repo, initialize one
                    if (!result.success && result.notGitRepo) {
                        console.log('[TabManager] Not a git repo, initializing...');
                        
                        const initResult = await window.aider.gitInit(repoPath);
                        if (initResult.success) {
                            console.log('[TabManager] Git repo initialized successfully');
                            // Retry listing branches
                            result = await window.aider.gitListBranches(repoPath);
                        } else {
                            console.error('[TabManager] Failed to initialize git repo:', initResult.error);
                            return;
                        }
                    }
                    
                    if (!result.success) {
                        console.error('[TabManager] Failed to list branches:', result.error);
                        return;
                    }
                    
                    console.log('[TabManager] Found branches:', result.branches);
                    
                    // Clear existing branch tabs (except main overview)
                    const existingTabs = Array.from(this.tabs.keys());
                    for (const tabId of existingTabs) {
                        if (tabId !== 'main-branch') {
                            this.closeTab(tabId);
                        }
                    }
                    
                    // Update main branch with current branch info
                    const mainTab = this.tabs.get('main-branch');
                    if (mainTab) {
                        mainTab.branchId = result.currentBranch || 'main';
                        mainTab.name = result.currentBranch || 'main';
                        
                        // Update tab name in UI
                        const mainTabEl = document.querySelector('.tab-item[data-tab="main-branch"] span:nth-child(2)');
                        if (mainTabEl) {
                            mainTabEl.textContent = mainTab.name;
                        }
                    }
                    
                    // Create tabs for other branches
                    for (const branchName of result.branches) {
                        if (branchName === result.currentBranch || branchName === 'main') continue;
                        
                        const branchId = branchName.toLowerCase().replace(/[^a-z0-9-]/g, '-');
                        const tabId = `branch-${branchId}`;
                        
                        if (!this.tabs.has(tabId)) {
                            this.tabs.set(tabId, {
                                branchId: branchName,
                                name: branchName,
                                status: 'idle',
                                cost: 0,
                                budget: 5.00,
                                version: 'v1.0',
                                phase: null,
                                phaseProgress: 0,
                                isDefault: false
                            });
                            
                            this.createTabElement(tabId, branchName);
                            this.createTabContent(tabId, branchName);
                        }
                    }
                    
                    this.refreshOverview();
                    
                } catch (error) {
                    console.error('[TabManager] Error loading git branches:', error);
                }
            },
            
            // Track cost for a branch
            addBranchCost(branchId, cost) {
                // Find the tab for this branch
                for (const [tabId, tab] of this.tabs) {
                    if (tab.branchId === branchId || tabId === branchId) {
                        tab.cost = (tab.cost || 0) + cost;
                        this.updateTabCost(tabId, tab.cost, tab.budget);
                        
                        // Also update the tab's isolated state
                        const state = this.getTabState(tabId);
                        state.costSummary.totalCost = tab.cost;
                        state.costSummary.totalCalls++;
                        break;
                    }
                }
                
                // Update total in overview if visible
                if (this.activeTab === 'main') {
                    this.refreshOverview();
                }
            },
            
            // Add a message to a specific tab
            addTabMessage(tabId, type, content) {
                const state = this.getTabState(tabId);
                const time = new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                const typeLabel = type === 'user' ? 'YOU' : type === 'ai' ? 'AI' : type === 'error' ? 'ERR' : 'SYS';
                const typeClass = type;
                
                const messageHTML = `
                    <div class="message">
                        <span class="message-time">${time}</span>
                        <span class="message-type ${typeClass}">${typeLabel}</span>
                        <span class="message-content">${this.escapeHtml(content)}</span>
                    </div>
                `;
                
                // Add to state
                state.messages.push({ type, content, time });
                state.messagesHTML = (state.messagesHTML || '') + messageHTML;
                
                // If this is the active tab, also update the DOM
                if (this.activeTab === tabId) {
                    const messagesEl = document.querySelector(`#tab-content-${tabId} .messages, .messages`);
                    if (messagesEl) {
                        messagesEl.innerHTML += messageHTML;
                        messagesEl.scrollTop = messagesEl.scrollHeight;
                    }
                }
            },
            
            // Get total cost across all branches
            getTotalCost() {
                let total = 0;
                this.tabs.forEach(tab => {
                    total += tab.cost || 0;
                });
                return total;
            }
        };
        
        // Initialize TabManager on load
        document.addEventListener('DOMContentLoaded', () => {
            TabManager.init();
        });
        
        // Hook into GSXCreate to track costs
        const originalUpdateCostSummary = null; // Will be set after GSXCreate is defined
        
        // ==================== VOICE MODE CLASSES ====================
        
        // VoiceOrb - Compact animated canvas visualization
        class VoiceOrb {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.state = 'idle';
                this.audioLevel = 0;
                this.targetAudioLevel = 0;
                this.animationId = null;
                this.phase = 0;
                this.colors = {
                    idle: { primary: '#4f8cff', glow: 'rgba(79, 140, 255, 0.3)' },
                    listening: { primary: '#4f8cff', glow: 'rgba(79, 140, 255, 0.5)' },
                    thinking: { primary: '#fbbf24', glow: 'rgba(251, 191, 36, 0.5)' },
                    speaking: { primary: '#4cd964', glow: 'rgba(76, 217, 100, 0.5)' }
                };
            }
            
            setState(state) { this.state = state; }
            setAudioLevel(level) { this.targetAudioLevel = Math.min(1, Math.max(0, level)); }
            
            startAnimation() {
                if (this.animationId) return;
                this.animate();
            }
            
            stopAnimation() {
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }
            }
            
            animate() {
                this.draw();
                this.animationId = requestAnimationFrame(() => this.animate());
            }
            
            draw() {
                const { canvas, ctx } = this;
                const cx = canvas.width / 2;
                const cy = canvas.height / 2;
                const baseRadius = Math.min(cx, cy) * 0.7;
                
                this.audioLevel += (this.targetAudioLevel - this.audioLevel) * 0.15;
                this.phase += 0.03;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const colors = this.colors[this.state] || this.colors.idle;
                
                // Glow
                const glowRadius = baseRadius * (1.3 + this.audioLevel * 0.3);
                const glow = ctx.createRadialGradient(cx, cy, 0, cx, cy, glowRadius);
                glow.addColorStop(0, colors.glow);
                glow.addColorStop(1, 'transparent');
                ctx.fillStyle = glow;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Orb with pulsing
                const pulseAmount = this.state === 'idle' ? 0.05 : 0.1;
                const radius = baseRadius * (1 + this.audioLevel * 0.15 + Math.sin(this.phase) * pulseAmount);
                
                ctx.beginPath();
                ctx.arc(cx, cy, radius, 0, Math.PI * 2);
                ctx.fillStyle = colors.primary;
                ctx.fill();
                
                // Inner highlight
                ctx.beginPath();
                ctx.arc(cx - radius * 0.2, cy - radius * 0.2, radius * 0.25, 0, Math.PI * 2);
                const highlight = ctx.createRadialGradient(cx - radius * 0.2, cy - radius * 0.2, 0, cx - radius * 0.2, cy - radius * 0.2, radius * 0.3);
                highlight.addColorStop(0, 'rgba(255,255,255,0.4)');
                highlight.addColorStop(1, 'transparent');
                ctx.fillStyle = highlight;
                ctx.fill();
            }
        }
        
        // SoundFeedback - Gentle audio tones using Web Audio API
        class SoundFeedback {
            constructor() { this.enabled = true; this.ctx = null; }
            
            getContext() {
                if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                return this.ctx;
            }
            
            play(name) {
                if (!this.enabled) return;
                try {
                    const ctx = this.getContext();
                    const tones = {
                        start: [[440, 554, 659], 0.1, 0.15],
                        end: [[659, 554, 440], 0.1, 0.15],
                        tick: [[880], 0.03, 0.08],
                        process: [[330, 392], 0.15, 0.1],
                        ready: [[523, 659], 0.1, 0.15],
                        sent: [[784, 988], 0.08, 0.12]
                    };
                    const tone = tones[name];
                    if (tone) this.playTones(ctx, tone[0], tone[1], tone[2]);
                } catch (e) { console.warn('[Sound]', e); }
            }
            
            playTones(ctx, freqs, dur, vol) {
                let t = ctx.currentTime;
                freqs.forEach((f, i) => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = 'sine';
                    osc.frequency.value = f;
                    gain.gain.setValueAtTime(vol, t + i * dur);
                    gain.gain.exponentialRampToValueAtTime(0.01, t + (i + 1) * dur);
                    osc.connect(gain).connect(ctx.destination);
                    osc.start(t + i * dur);
                    osc.stop(t + (i + 1) * dur + 0.05);
                });
            }
        }
        
        // ==================== GSX CREATE ====================
        const GSX_CREATE_VERSION = '1.5.0';
        
        const GSXCreate = {
            // Version
            version: GSX_CREATE_VERSION,
            
            // State
            currentSpace: null,
            currentSpaceId: null,
            currentSpaceName: null,
            repoPath: null,
            files: [],
            projectFiles: [],
            contextFiles: [],
            apiConfig: null,
            costSummary: { totalCost: 0, totalCalls: 0 },
            currentPreviewFile: null,
            globalInstructionsText: '',
            styleGuides: [],
            journeyMaps: [],
            spaceItems: [],
            fileWatcher: null,
            
            // ========== AGENT ACTIVITY HUD ==========
            activityTracker: {
                visible: false,
                minimized: false,
                currentPhase: null,
                currentTask: null,
                currentFile: null,
                currentAction: null,
                progress: { current: 0, total: 0 },
                recentActions: [],
                startTime: null
            },
            
            // Evaluated assets from dropdowns
            evaluatedJourneyMap: null,  // { id, name, content, evaluation }
            evaluatedStyleGuide: null,  // { id, name, content, evaluation }
            isEvaluatingAsset: false,
            
            // Auto-refresh for preview
            autoRefreshInterval: null,
            
            // ========== SMART TESTING MODE ==========
            // Detects user interaction in preview, pauses refresh, prompts for feedback
            userTestingState: {
                isActive: false,
                lastActivity: null,
                pendingUpdates: 0
            },
            
            // Debug Mode - generates verbose logging code (ON by default)
            debugMode: {
                enabled: true,
                options: {
                    consoleLogs: true,
                    errorBoundaries: true,
                    eventTracking: true
                }
            },
            
            // Error Fix Queue - auto-detected errors from preview
            errorFixQueue: [],
            
            // Feedback Queue - user feedback with live status (DEPRECATED - use taskQueue)
            feedbackQueue: [],
            
            // ========== UNIFIED TASK QUEUE (Heart of the System) ==========
            // All tasks flow through this queue - phases add tasks, executor processes them
            taskQueue: [],
            currentTaskId: null,
            queueStats: {
                completed: 0,
                total: 0,
                startTime: null,
                estimatedRemaining: 0
            },
            
            // Task type constants for color-coding
            TASK_TYPES: {
                EVALUATE: 'evaluate',
                RESEARCH: 'research', 
                PLAN: 'plan',
                DESIGN: 'design',
                BUILD: 'build',
                TEST: 'test',
                IMPROVE: 'improve',
                USER: 'user',
                ERROR: 'error'
            },
            
            // Cycle State
            cycleState: {
                active: false,
                paused: false,
                currentVersion: 1,
                currentPhase: null,
                phases: ['evaluate', 'research', 'plan', 'execute', 'test', 'improve', 'finalize'],
                versions: [],
                targetScore: 90,
                currentScore: 0,
                autoMode: false,
                autoCycle: false,          // Auto-restart cycle after completion
                cycleBudget: null,         // Max cost before stopping auto-cycle
                budgetBuffer: 0,           // Reserved buffer for manual fixes
                costAtCycleStart: 0,       // Track cost when cycle starts
                objective: null,           // Current iteration objective
                lastPrompt: null,          // Last user prompt for context
                todos: [],                 // Current todo list
                currentTodoIndex: 0,       // Which todo we're working on
                evaluationCriteria: [],    // Criteria from file
                evaluationScores: {},      // Scores for each criterion
                evaluation: null,          // Full evaluation data
                parallelCount: 2,          // Number of parallel branches to create (default 2)
                waitingForCriteria: false, // Waiting for criteria file creation
                pendingEvaluation: null,   // Evaluation data when paused
                // Version backups and branches
                backups: [],               // Available version backups
                branches: [],              // Active parallel branches
                activeBranch: null,        // Currently viewing branch (legacy)
                focusedBranch: 'main',     // Currently focused branch in timeline
                parallelCount: 2,          // Number of parallel branches (1-4)
                // Cost tracking for main branch
                mainCost: 0,               // Total cost for main branch
                mainCostByPhase: {},       // Cost breakdown by phase for main
                // Supporting files (versioned per cycle)
                files: {
                    styleGuide: 'style-guide.md',
                    userFeedback: 'user-feedback.md',
                    journeyMap: 'journey-map.md',
                    researchNotes: 'research-notes-v{version}.md',
                    todoList: 'TODO-v{version}.md',
                    testResults: 'test-results-v{version}.md',
                    evaluationCriteria: 'evaluation-criteria.md'
                }
            },
            
            // Constitutional Memory State
            constitutionalMemory: {
                styleGuide: null,
                journeyMap: null,
                evaluationCriteria: null,
                currentSummary: null,
                lastTask: null,
                lastSummarizedAt: null
            },
            
            // Error Analyzer State
            errorAnalyzer: {
                enabled: true,
                currentError: null,
                errorLog: [],
                maxLogSize: 100,
                suppressedErrors: new Set()
            },
            
            // Voice Mode State
            voiceMode: {
                active: false,
                state: 'idle',
                orb: null,
                sounds: null,
                stopStreaming: null,
                currentTranscript: '',
                currentPrompt: '',
                originalTranscript: '',
                ttsAudio: null,
                autoSendTimer: null
            },
            
            // ========== SAFE STRING CONVERSION ==========
            // Converts any value to a safe displayable string
            safeStringify(value) {
                // Handle null/undefined
                if (value === null || value === undefined) {
                    return '';
                }
                // Already a string
                if (typeof value === 'string') {
                    return value;
                }
                // Error objects - get message
                if (value instanceof Error) {
                    return value.message || String(value);
                }
                // Arrays - join with newlines
                if (Array.isArray(value)) {
                    return value.map(v => this.safeStringify(v)).join('\n');
                }
                // Objects - try JSON, fallback to inspect-like output
                if (typeof value === 'object') {
                    try {
                        const json = JSON.stringify(value, null, 2);
                        // If it's a simple object, show inline
                        if (json.length < 100 && !json.includes('\n')) {
                            return json;
                        }
                        // For complex objects, wrap in code block
                        return '```json\n' + json + '\n```';
                    } catch (e) {
                        // Circular reference or other issue
                        return '[Complex Object]';
                    }
                }
                // Numbers, booleans, etc
                return String(value);
            },
            
            // Format code blocks in text (``` blocks)
            formatCodeBlocks(text, escapeHtmlFn) {
                if (!text || typeof text !== 'string') return text;
                
                // Match code blocks: ```language\ncode\n```
                const codeBlockRegex = /```(\w*)\n?([\s\S]*?)```/g;
                
                return text.replace(codeBlockRegex, (match, lang, code) => {
                    // Escape HTML inside code blocks
                    const escapedCode = escapeHtmlFn ? escapeHtmlFn(code.trim()) : code.trim();
                    const langClass = lang ? ` class="language-${lang}"` : '';
                    return `<pre style="background: var(--bg-tertiary); padding: 12px; border-radius: 6px; overflow-x: auto; margin: 8px 0; border: 1px solid var(--border);"><code${langClass} style="font-family: 'SF Mono', Monaco, 'Courier New', monospace; font-size: 12px; color: var(--text-primary);">${escapedCode}</code></pre>`;
                });
            },
            
            // Format inline code (`code`)
            formatInlineCode(text, escapeHtmlFn) {
                if (!text || typeof text !== 'string') return text;
                
                // Match inline code: `code`
                const inlineCodeRegex = /`([^`]+)`/g;
                
                return text.replace(inlineCodeRegex, (match, code) => {
                    const escapedCode = escapeHtmlFn ? escapeHtmlFn(code) : code;
                    return `<code style="background: var(--bg-tertiary); padding: 2px 6px; border-radius: 4px; font-family: 'SF Mono', Monaco, 'Courier New', monospace; font-size: 11px;">${escapedCode}</code>`;
                });
            },
            
            // ========== EVENT LOGGING HELPER FOR MULTIPATH BUILDS ==========
            // Logs granular events to the event log system for debugging
            logBranchEvent(eventType, data = {}) {
                const eventData = {
                    ...data,
                    repoPath: this.repoPath,
                    spaceId: this.currentSpaceId,
                    currentVersion: this.cycleState?.currentVersion,
                    focusedBranch: this.cycleState?.focusedBranch,
                    branchCount: this.cycleState?.branches?.length || 0,
                    timestamp: new Date().toISOString()
                };
                
                // Log via electronAPI if available
                if (window.electronAPI?.logEvent) {
                    window.electronAPI.logEvent(`branch:${eventType}`, eventData);
                }
                
                // Also log via window.log.event for redundancy
                if (window.log?.event) {
                    window.log.event(`branch:${eventType}`, eventData);
                }
                
                // Console log for immediate debugging
                console.log(`[Branch Event] ${eventType}:`, eventData);
            },
            
            // Initialize
            async init() {
                console.log(`[GSX Create] v${this.version} Initializing...`);
                
                // Update version display in UI
                const versionEl = document.getElementById('appVersion');
                if (versionEl) {
                    versionEl.textContent = `v${this.version}`;
                }
                
                try {
                    await this.checkApiConfig();
                    await this.loadSpaces();
                    this.setupEventListeners();
                    this.restoreSidebarState();
                    this.setupErrorAnalyzer();
                    this.setupBehaviorTracking();
                    this.trackBehavior('session_start', { timestamp: new Date().toISOString() });
                    this.initVoiceMode();
                    
                    // Set up HUD activity listener for Aider Bridge and Agent updates
                    this.setupHUDActivityListener();
                    
                    // Set up graceful shutdown listener
                    this.setupShutdownListener();
                } catch (error) {
                    console.error('[GSX Create] Init error:', error);
                }
            },
            
            // Set up listener for external HUD activity (Aider Bridge, Agent)
            setupHUDActivityListener() {
                if (window.electronAPI?.onHUDActivity) {
                    this.hudActivityCleanup = window.electronAPI.onHUDActivity((data) => {
                        this.handleExternalHUDUpdate(data);
                    });
                    console.log('[GSX Create] HUD activity listener registered');
                }
            },
            
            // Handle incoming HUD activity from Aider Bridge or Agent
            handleExternalHUDUpdate(data) {
                if (!data) return;
                
                // Handle different message types
                switch (data.type) {
                    case 'chat':
                        // Add AI summary to chat as system message
                        if (data.message) {
                            this.addMessage('system', data.message);
                        }
                        return;
                        
                    case 'cost':
                        // Track cost in budget system
                        this.trackExternalCost(data);
                        return;
                        
                    case 'summary':
                        // AI-generated summary - highlight it
                        this.updateHUD({
                            currentAction: data.action,
                            currentPhase: data.phase || this.activityTracker.currentPhase
                        });
                        // Add visual indicator that this is AI-generated
                        const hudAction = document.getElementById('hudAction');
                        if (hudAction && data.aiGenerated) {
                            hudAction.innerHTML = `<span style="color: #a78bfa;"></span> ${data.action}`;
                        }
                        return;
                        
                    default:
                        // Standard activity update
                        break;
                }
                
                const updates = {};
                
                // Set phase if provided
                if (data.phase) {
                    updates.currentPhase = data.phase;
                }
                
                // Set action if provided
                if (data.action) {
                    updates.currentAction = data.action;
                }
                
                // Set task if provided
                if (data.task) {
                    updates.currentTask = data.task;
                }
                
                // Set file if provided
                if (data.file) {
                    updates.currentFile = data.file;
                }
                
                // Apply updates to HUD
                if (Object.keys(updates).length > 0) {
                    this.updateHUD(updates);
                }
                
                // Add to recent actions if provided
                if (data.recent) {
                    this.addRecentAction(data.recent);
                }
                
                // Log for debugging
                console.log('[HUD] External update:', data.type, data.action || data.phase);
            },
            
            // Track cost from external sources (Agent, etc.)
            async trackExternalCost(data) {
                if (!data.cost) return;
                
                try {
                    // Record to EventDB (episodic memory) - it will delegate to BudgetManager
                    await window.aider.txdbRecordTransaction({
                        spaceId: this.currentSpaceId || 'system',
                        spaceName: this.currentSpaceName || 'System',
                        type: data.feature || 'agent',
                        model: data.model || 'claude-sonnet-4-5-20250929',
                        inputTokens: data.inputTokens || 0,
                        outputTokens: data.outputTokens || 0,
                        cost: data.cost,
                        feature: data.feature || 'agent-summary',
                        status: 'success',
                        promptPreview: 'Agent activity summary'
                    });
                    
                    // Update local display
                    this.costSummary.totalCost = (this.costSummary.totalCost || 0) + data.cost;
                    this.costSummary.totalCalls = (this.costSummary.totalCalls || 0) + 1;
                    this.updateCostDisplay();
                    
                    console.log('[HUD] External cost tracked:', data.feature, '$' + data.cost.toFixed(4));
                } catch (error) {
                    console.error('[HUD] External cost tracking error:', error);
                }
            },
            
            // ==================== AGENT ACTIVITY HUD ====================
            
            // HUD drag state
            hudDragState: {
                isDragging: false,
                startX: 0,
                startY: 0,
                startLeft: 0,
                startTop: 0
            },
            
            // Initialize HUD drag functionality
            initHUDDrag() {
                const hud = document.getElementById('agentHUD');
                const header = document.getElementById('hudHeader');
                if (!hud || !header) return;
                
                // Load saved position
                const savedPos = localStorage.getItem('hudPosition');
                if (savedPos) {
                    try {
                        const pos = JSON.parse(savedPos);
                        hud.style.left = pos.left + 'px';
                        hud.style.top = pos.top + 'px';
                        hud.style.right = 'auto';
                        hud.style.bottom = 'auto';
                    } catch (e) {}
                }
                
                header.addEventListener('mousedown', (e) => this.startHUDDrag(e));
                document.addEventListener('mousemove', (e) => this.doHUDDrag(e));
                document.addEventListener('mouseup', () => this.stopHUDDrag());
            },
            
            startHUDDrag(e) {
                const hud = document.getElementById('agentHUD');
                if (!hud) return;
                
                this.hudDragState.isDragging = true;
                this.hudDragState.startX = e.clientX;
                this.hudDragState.startY = e.clientY;
                
                const rect = hud.getBoundingClientRect();
                this.hudDragState.startLeft = rect.left;
                this.hudDragState.startTop = rect.top;
                
                hud.classList.add('dragging');
                e.preventDefault();
            },
            
            doHUDDrag(e) {
                if (!this.hudDragState.isDragging) return;
                
                const hud = document.getElementById('agentHUD');
                if (!hud) return;
                
                const dx = e.clientX - this.hudDragState.startX;
                const dy = e.clientY - this.hudDragState.startY;
                
                let newLeft = this.hudDragState.startLeft + dx;
                let newTop = this.hudDragState.startTop + dy;
                
                // Keep within viewport
                const rect = hud.getBoundingClientRect();
                newLeft = Math.max(0, Math.min(newLeft, window.innerWidth - rect.width));
                newTop = Math.max(0, Math.min(newTop, window.innerHeight - rect.height));
                
                hud.style.left = newLeft + 'px';
                hud.style.top = newTop + 'px';
                hud.style.right = 'auto';
                hud.style.bottom = 'auto';
            },
            
            stopHUDDrag() {
                if (!this.hudDragState.isDragging) return;
                
                const hud = document.getElementById('agentHUD');
                if (hud) {
                    hud.classList.remove('dragging');
                    
                    // Save position
                    const rect = hud.getBoundingClientRect();
                    localStorage.setItem('hudPosition', JSON.stringify({
                        left: rect.left,
                        top: rect.top
                    }));
                }
                
                this.hudDragState.isDragging = false;
            },
            
            // Show the HUD
            showHUD() {
                const hud = document.getElementById('agentHUD');
                if (hud) {
                    hud.classList.remove('hidden');
                    this.activityTracker.visible = true;
                    this.activityTracker.startTime = Date.now();
                    
                    // Initialize drag if not already done
                    if (!this.hudDragInitialized) {
                        this.initHUDDrag();
                        this.hudDragInitialized = true;
                    }
                }
            },
            
            // Hide the HUD
            hideHUD() {
                const hud = document.getElementById('agentHUD');
                if (hud) {
                    hud.classList.add('hidden');
                    this.activityTracker.visible = false;
                }
            },
            
            // Toggle minimize state
            toggleHUDMinimize() {
                const hud = document.getElementById('agentHUD');
                const minBtn = document.getElementById('hudMinBtn');
                if (hud) {
                    this.activityTracker.minimized = !this.activityTracker.minimized;
                    hud.classList.toggle('minimized', this.activityTracker.minimized);
                    if (minBtn) {
                        minBtn.textContent = this.activityTracker.minimized ? '' : '';
                        minBtn.title = this.activityTracker.minimized ? 'Expand' : 'Minimize';
                    }
                }
            },
            
            // Update activity tracker state and render
            updateHUD(updates = {}) {
                // Merge updates into tracker state
                Object.assign(this.activityTracker, updates);
                
                // Show HUD if not visible and we have activity
                if (!this.activityTracker.visible && (updates.currentPhase || updates.currentTask)) {
                    this.showHUD();
                }
                
                this.renderHUD();
            },
            
            // Render the HUD with current state
            renderHUD() {
                const tracker = this.activityTracker;
                
                // Phase badge
                const phaseBadge = document.getElementById('hudPhaseBadge');
                const phaseIcon = document.getElementById('hudPhaseIcon');
                const phaseText = document.getElementById('hudPhaseText');
                const phaseCount = document.getElementById('hudPhaseCount');
                
                const phaseIcons = {
                    evaluate: '', research: '', plan: '', 
                    execute: '', test: '', improve: '', finalize: ''
                };
                
                if (phaseBadge && tracker.currentPhase) {
                    phaseBadge.className = 'hud-phase-badge ' + tracker.currentPhase.toLowerCase();
                    if (phaseIcon) phaseIcon.textContent = phaseIcons[tracker.currentPhase.toLowerCase()] || '';
                    if (phaseText) phaseText.textContent = tracker.currentPhase;
                }
                
                // Progress
                const progress = tracker.progress;
                const percent = progress.total > 0 ? Math.round((progress.current / progress.total) * 100) : 0;
                
                if (phaseCount) phaseCount.textContent = `${progress.current}/${progress.total}`;
                
                const progressFill = document.getElementById('hudProgressFill');
                const miniProgressFill = document.getElementById('hudMiniProgressFill');
                const miniPercent = document.getElementById('hudMiniPercent');
                
                if (progressFill) progressFill.style.width = percent + '%';
                if (miniProgressFill) miniProgressFill.style.width = percent + '%';
                if (miniPercent) miniPercent.textContent = percent + '%';
                
                // Task
                const hudTask = document.getElementById('hudTask');
                if (hudTask) {
                    hudTask.textContent = tracker.currentTask || 'Waiting for task...';
                }
                
                // File
                const hudFile = document.getElementById('hudFile');
                if (hudFile) {
                    hudFile.textContent = tracker.currentFile || '';
                }
                
                // Action
                const hudAction = document.getElementById('hudAction');
                if (hudAction) {
                    hudAction.textContent = tracker.currentAction || 'Idle';
                }
                
                // Recent actions
                const recentList = document.getElementById('hudRecentList');
                if (recentList && tracker.recentActions.length > 0) {
                    recentList.innerHTML = tracker.recentActions
                        .slice(-3)
                        .map(a => `<div class="hud-recent-item">${a}</div>`)
                        .join('');
                }
                
                // ===== UPDATE DOCKED ACTIVITY BAR IN PREVIEW PANEL =====
                this.updateDockedActivityBar(tracker, phaseIcons, percent);
            },
            
            // Update the docked activity bar in the preview panel
            updateDockedActivityBar(tracker, phaseIcons, percent) {
                const activityBar = document.getElementById('previewActivityBar');
                const activityPhaseBadge = document.getElementById('activityPhaseBadge');
                const activityPhaseIcon = document.getElementById('activityPhaseIcon');
                const activityPhaseText = document.getElementById('activityPhaseText');
                const activityProgressFill = document.getElementById('activityProgressFill');
                const activityProgressText = document.getElementById('activityProgressText');
                const activityTask = document.getElementById('activityTask');
                const activityFile = document.getElementById('activityFile');
                const previewPanel = document.getElementById('previewPanel');
                
                // Show/hide activity bar based on whether there's activity
                const hasActivity = tracker.currentPhase || tracker.currentTask;
                if (activityBar) {
                    activityBar.classList.toggle('active', hasActivity);
                }
                
                // Add building class to preview panel when active
                if (previewPanel) {
                    previewPanel.classList.toggle('building', hasActivity && tracker.currentPhase !== 'Complete');
                }
                
                // Update phase badge
                if (activityPhaseBadge && tracker.currentPhase) {
                    activityPhaseBadge.className = 'activity-phase-badge ' + tracker.currentPhase.toLowerCase();
                    if (activityPhaseIcon) activityPhaseIcon.textContent = phaseIcons[tracker.currentPhase.toLowerCase()] || '';
                    if (activityPhaseText) activityPhaseText.textContent = tracker.currentPhase;
                } else if (activityPhaseBadge) {
                    activityPhaseBadge.className = 'activity-phase-badge idle';
                    if (activityPhaseIcon) activityPhaseIcon.textContent = '';
                    if (activityPhaseText) activityPhaseText.textContent = 'Ready';
                }
                
                // Update progress
                if (activityProgressFill) activityProgressFill.style.width = percent + '%';
                if (activityProgressText) activityProgressText.textContent = percent + '%';
                
                // Update task and file
                if (activityTask) {
                    activityTask.textContent = tracker.currentTask || 'Waiting...';
                }
                if (activityFile) {
                    activityFile.textContent = tracker.currentFile || '';
                }
                
                // Update welcome state if visible
                this.updatePreviewWelcomeState(hasActivity);
            },
            
            // Update the welcome state in preview panel
            updatePreviewWelcomeState(isBuilding) {
                const welcomeStatus = document.getElementById('previewWelcomeStatus');
                const previewWelcome = document.getElementById('previewWelcome');
                
                if (welcomeStatus && previewWelcome) {
                    if (isBuilding) {
                        welcomeStatus.classList.add('building');
                        welcomeStatus.textContent = 'Building your app...';
                    } else if (this.currentSpaceId) {
                        welcomeStatus.classList.remove('building');
                        welcomeStatus.textContent = 'Ready to build';
                    } else {
                        welcomeStatus.classList.remove('building');
                        welcomeStatus.textContent = 'Select a space to begin';
                    }
                }
            },
            
            // Add to recent actions
            addRecentAction(action) {
                if (!action) return;
                const truncated = action.length > 50 ? action.substring(0, 47) + '...' : action;
                this.activityTracker.recentActions.push(truncated);
                // Keep only last 5
                if (this.activityTracker.recentActions.length > 5) {
                    this.activityTracker.recentActions.shift();
                }
                this.renderHUD();
            },
            
            // Set phase (called from runPhase)
            setHUDPhase(phase, taskCount = null) {
                this.updateHUD({ 
                    currentPhase: phase,
                    currentAction: `Starting ${phase} phase...`,
                    progress: taskCount ? { current: 0, total: taskCount } : this.activityTracker.progress
                });
            },
            
            // Set current task (called from executeQueueTask)
            setHUDTask(task, current, total) {
                this.updateHUD({
                    currentTask: task,
                    progress: { current, total },
                    currentAction: 'Processing...'
                });
            },
            
            // Set current action (called from streaming detection)
            setHUDAction(action, file = null) {
                const updates = { currentAction: action };
                if (file) updates.currentFile = file;
                this.updateHUD(updates);
            },
            
            // Mark task complete
            completeHUDTask(task) {
                this.addRecentAction(task);
                this.activityTracker.progress.current++;
                this.renderHUD();
            },
            
            // Reset HUD when done
            resetHUD() {
                this.activityTracker = {
                    visible: this.activityTracker.visible,
                    minimized: this.activityTracker.minimized,
                    currentPhase: null,
                    currentTask: null,
                    currentFile: null,
                    currentAction: 'Complete!',
                    progress: { current: 0, total: 0 },
                    recentActions: this.activityTracker.recentActions,
                    startTime: null
                };
                this.renderHUD();
                // Auto-hide after a few seconds
                setTimeout(() => {
                    if (!this.cycleState?.active) {
                        this.hideHUD();
                    }
                }, 5000);
            },
            
            // ==================== VOICE MODE ====================
            
            initVoiceMode() {
                console.log('[Voice] Initializing...');
                const canvas = document.getElementById('voiceOrb');
                if (canvas) this.voiceMode.orb = new VoiceOrb(canvas);
                this.voiceMode.sounds = new SoundFeedback();
                
                // Keyboard shortcut (Ctrl/Cmd + M)
                document.addEventListener('keydown', (e) => {
                    if ((e.ctrlKey || e.metaKey) && e.key === 'm') {
                        e.preventDefault();
                        this.toggleVoiceMode();
                    }
                    if (e.key === 'Escape' && this.voiceMode.active) {
                        e.preventDefault();
                        this.exitVoiceMode();
                    }
                });
            },
            
            toggleVoiceMode() {
                if (this.voiceMode.active) {
                    this.exitVoiceMode();
                } else {
                    this.enterVoiceMode();
                }
            },
            
            async enterVoiceMode() {
                console.log('[Voice] Entering voice mode...');
                const panel = document.getElementById('voicePanel');
                const btn = document.getElementById('voiceBtn');
                
                if (panel) panel.classList.add('active');
                if (btn) btn.classList.add('active');
                
                this.voiceMode.active = true;
                this.voiceMode.state = 'listening';
                this.updateVoiceStatus('Listening...');
                
                this.voiceMode.sounds?.play('start');
                if (this.voiceMode.orb) {
                    this.voiceMode.orb.setState('listening');
                    this.voiceMode.orb.startAnimation();
                }
                
                try {
                    if (window.realtimeSpeech) {
                        const result = await window.realtimeSpeech.startStreaming(
                            this.onVoiceTranscript.bind(this),
                            { language: 'en' }
                        );
                        this.voiceMode.stopStreaming = result?.stop;
                    } else {
                        this.updateVoiceStatus('Voice not available - check API key');
                    }
                } catch (err) {
                    console.error('[Voice] Error:', err);
                    this.updateVoiceStatus('Error: ' + err.message);
                }
            },
            
            async exitVoiceMode() {
                console.log('[Voice] Exiting...');
                const panel = document.getElementById('voicePanel');
                const btn = document.getElementById('voiceBtn');
                
                if (this.voiceMode.stopStreaming) {
                    await this.voiceMode.stopStreaming();
                    this.voiceMode.stopStreaming = null;
                }
                
                this.stopTTS();
                if (this.voiceMode.autoSendTimer) {
                    clearTimeout(this.voiceMode.autoSendTimer);
                    this.voiceMode.autoSendTimer = null;
                }
                
                this.voiceMode.sounds?.play('end');
                if (this.voiceMode.orb) this.voiceMode.orb.stopAnimation();
                
                if (panel) panel.classList.remove('active');
                if (btn) btn.classList.remove('active');
                
                this.voiceMode.active = false;
                this.voiceMode.state = 'idle';
                this.voiceMode.currentTranscript = '';
                this.voiceMode.currentPrompt = '';
                this.updateVoiceTranscript('');
                this.updateVoicePromptPreview('');
            },
            
            onVoiceTranscript(text, isFinal) {
                if (!this.voiceMode.active) return;
                
                if (!isFinal) {
                    this.voiceMode.currentTranscript = text;
                    this.updateVoiceTranscript(`<span class="partial">${text}</span>`);
                    if (this.voiceMode.orb) this.voiceMode.orb.setAudioLevel(0.4 + Math.random() * 0.4);
                    
                    if (this.voiceMode.state !== 'transcribing') {
                        this.voiceMode.state = 'transcribing';
                        this.voiceMode.sounds?.play('tick');
                        this.updateVoiceStatus('Listening...');
                    }
                } else {
                    this.voiceMode.sounds?.play('tick');
                    if (this.voiceMode.state === 'ready') {
                        this.handlePostPromptSpeech(text);
                    } else {
                        this.processVoiceTranscript(text);
                    }
                }
            },
            
            async processVoiceTranscript(transcript) {
                console.log('[Voice] Processing:', transcript);
                this.voiceMode.originalTranscript = transcript;
                this.voiceMode.state = 'thinking';
                this.voiceMode.sounds?.play('process');
                this.updateVoiceTranscript(transcript);
                this.updateVoiceStatus('Refining prompt...');
                if (this.voiceMode.orb) this.voiceMode.orb.setState('thinking');
                
                try {
                    let refined = await this.refineVoiceToPrompt(transcript);
                    if (!refined || typeof refined !== 'string') refined = transcript;
                    
                    this.voiceMode.currentPrompt = refined;
                    this.updateVoicePromptPreview(refined);
                    
                    const promptInput = document.getElementById('promptInput');
                    if (promptInput) promptInput.value = refined;
                    
                    this.voiceMode.state = 'speaking';
                    if (this.voiceMode.orb) this.voiceMode.orb.setState('speaking');
                    
                    const preview = String(refined).substring(0, 80);
                    await this.speakResponse(`I'll ${preview}. Say go to confirm.`);
                    
                    this.voiceMode.state = 'ready';
                    this.voiceMode.sounds?.play('ready');
                    this.updateVoiceStatus('Say "go" to execute');
                    if (this.voiceMode.orb) this.voiceMode.orb.setState('listening');
                    
                    this.startAutoSendTimer();
                } catch (err) {
                    console.error('[Voice] Error:', err);
                    this.updateVoiceStatus('Error: ' + err.message);
                    this.voiceMode.state = 'listening';
                }
            },
            
            async handlePostPromptSpeech(speech) {
                if (this.voiceMode.autoSendTimer) {
                    clearTimeout(this.voiceMode.autoSendTimer);
                    this.voiceMode.autoSendTimer = null;
                }
                this.stopTTS();
                
                const cmd = String(speech).trim().toLowerCase();
                
                if (isGoCmd) {
                    await this.speakResponse('Building...');
                    this.voiceMode.sounds?.play('sent');
                    this.sendPrompt();
                    this.resetVoiceState();
                    return;
                }
                
                if (isCancelCmd) {
                    await this.speakResponse('Cancelled.');
                    const promptInput = document.getElementById('promptInput');
                    if (promptInput) promptInput.value = '';
                    this.resetVoiceState();
                    return;
                }
                
                // Treat as correction
                await this.refineWithCorrection(speech);
            },
            
            async refineWithCorrection(correction) {
                this.voiceMode.state = 'thinking';
                this.voiceMode.sounds?.play('process');
                this.updateVoiceStatus('Updating...');
                if (this.voiceMode.orb) this.voiceMode.orb.setState('thinking');
                
                try {
                    const orig = String(this.voiceMode.originalTranscript || '');
                    const curr = String(this.voiceMode.currentPrompt || '');
                    const corr = String(correction || '');
                    
                    const promptText = `Original: "${orig}"\nRefined to: "${curr}"\nUser said: "${corr}"\n\nUpdate the prompt. Return ONLY the updated prompt.`;
                    const result = await window.aider.runPrompt(promptText);
                    
                    let updated = curr;
                    if (result?.response && typeof result.response === 'string') {
                        updated = result.response.trim() || curr;
                    }
                    
                    await this.trackTaskCost(promptText, result?.response || '', 'voice-correction');
                    
                    this.voiceMode.currentPrompt = updated;
                    this.updateVoicePromptPreview(updated);
                    
                    const promptInput = document.getElementById('promptInput');
                    if (promptInput) promptInput.value = updated;
                    
                    this.voiceMode.state = 'speaking';
                    if (this.voiceMode.orb) this.voiceMode.orb.setState('speaking');
                    await this.speakResponse('Updated. Say go to confirm.');
                    
                    this.voiceMode.state = 'ready';
                    this.voiceMode.sounds?.play('ready');
                    this.updateVoiceStatus('Say "go" to execute');
                    if (this.voiceMode.orb) this.voiceMode.orb.setState('listening');
                    this.startAutoSendTimer();
                } catch (err) {
                    console.error('[Voice] Correction error:', err);
                    this.updateVoiceStatus('Error updating');
                    this.voiceMode.state = 'listening';
                }
            },
            
            async refineVoiceToPrompt(transcript) {
                const safe = String(transcript || '').trim();
                if (!safe) return 'Describe what you want to build';
                
                const promptText = `Convert this spoken request into a clear prompt for a coding assistant:\n\n"${safe}"\n\nRemove filler words, fix grammar, preserve intent, start with action verb.\nReturn ONLY the refined prompt.`;
                
                try {
                    const result = await window.aider.runPrompt(promptText);
                    await this.trackTaskCost(promptText, result?.response || '', 'voice-refine');
                    
                    if (result?.response && typeof result.response === 'string') {
                        return result.response.trim() || safe;
                    }
                    return safe;
                } catch (err) {
                    console.error('[Voice] Refine error:', err);
                    return safe;
                }
            },
            
            async speakResponse(text) {
                console.log('[Voice] Speaking:', text);
                try {
                    if (window.voiceTTS) {
                        const audioPath = await window.voiceTTS.speak(text, 'Rachel');
                        if (audioPath) {
                            this.voiceMode.ttsAudio = new Audio(audioPath);
                            if (this.voiceMode.orb) {
                                this.voiceMode.ttsAudio.onplay = () => this.animateTTSOutput();
                            }
                            await new Promise((resolve, reject) => {
                                this.voiceMode.ttsAudio.onended = resolve;
                                this.voiceMode.ttsAudio.onerror = reject;
                                this.voiceMode.ttsAudio.play();
                            });
                        }
                    }
                } catch (err) {
                    console.log('[Voice] TTS not available:', err.message);
                }
            },
            
            animateTTSOutput() {
                if (!this.voiceMode.ttsAudio || !this.voiceMode.orb) return;
                const animate = () => {
                    if (this.voiceMode.ttsAudio && !this.voiceMode.ttsAudio.paused) {
                        this.voiceMode.orb.setAudioLevel(0.3 + Math.random() * 0.4);
                        requestAnimationFrame(animate);
                    }
                };
                animate();
            },
            
            stopTTS() {
                if (this.voiceMode.ttsAudio) {
                    this.voiceMode.ttsAudio.pause();
                    this.voiceMode.ttsAudio.currentTime = 0;
                    this.voiceMode.ttsAudio = null;
                }
            },
            
            startAutoSendTimer() {
                if (this.voiceMode.autoSendTimer) clearTimeout(this.voiceMode.autoSendTimer);
                this.voiceMode.autoSendTimer = setTimeout(async () => {
                    if (this.voiceMode.state === 'ready' && this.voiceMode.currentPrompt) {
                        await this.speakResponse('Sending...');
                        this.voiceMode.sounds?.play('sent');
                        this.sendPrompt();
                        this.resetVoiceState();
                    }
                }, 10000);
            },
            
            resetVoiceState() {
                this.voiceMode.currentPrompt = '';
                this.voiceMode.originalTranscript = '';
                this.updateVoicePromptPreview('');
                this.updateVoiceTranscript('');
                this.updateVoiceStatus('Listening...');
                this.voiceMode.state = 'listening';
            },
            
            updateVoiceStatus(text) {
                const el = document.getElementById('voiceStatus');
                if (el) {
                    el.textContent = text;
                    el.className = 'voice-status ' + this.voiceMode.state;
                }
            },
            
            updateVoiceTranscript(html) {
                const el = document.getElementById('voiceTranscript');
                if (el) el.innerHTML = html;
            },
            
            updateVoicePromptPreview(text) {
                const el = document.getElementById('voicePromptPreview');
                if (el) {
                    if (text) {
                        el.textContent = text;
                        el.classList.add('visible');
                    } else {
                        el.textContent = '';
                        el.classList.remove('visible');
                    }
                }
            },
            
            // Selected model (stored in settings) - Claude 4.5 only
            // Auto-migrate old model names to correct ones
            selectedModel: (() => {
                let model = localStorage.getItem('gsxCreateModel') || 'claude-opus-4-5-20251101';
                // Fix incorrect Opus date (was 20250929, should be 20251101)
                if (model === 'claude-opus-4-5-20250929') {
                    model = 'claude-opus-4-5-20251101';
                    localStorage.setItem('gsxCreateModel', model);
                    console.log('[GSX Create] Migrated model name: claude-opus-4-5-20250929  claude-opus-4-5-20251101');
                }
                return model;
            })(),
            
            // Check API Configuration
            async checkApiConfig() {
                try {
                    this.apiConfig = await window.aider.getApiConfig();
                    console.log('[GSX Create] API Config:', this.apiConfig);
                    
                    const settingsModelSelect = document.getElementById('settingsModelSelect');
                    const noApiWarning = document.getElementById('noApiWarning');
                    const mainSetupForm = document.getElementById('mainSetupForm');
                    
                    if (!this.apiConfig.hasApiKey) {
                        noApiWarning.style.display = 'block';
                        if (mainSetupForm) mainSetupForm.style.display = 'none';
                        return;
                    }
                    
                    noApiWarning.style.display = 'none';
                    if (mainSetupForm) mainSetupForm.style.display = 'block';
                    
                    // Model options HTML - Only Claude 4.5 Opus and Sonnet allowed for GSX Create
                    const modelOptionsHtml = `
                        <option value="claude-opus-4-5-20251101">Claude Opus 4.5</option>
                        <option value="claude-sonnet-4-5-20250929">Claude Sonnet 4.5</option>
                    `;
                    
                    // Populate settings modal model select
                    if (settingsModelSelect) {
                        settingsModelSelect.innerHTML = modelOptionsHtml;
                        settingsModelSelect.value = this.selectedModel;
                    }
                    
                    // Update model display
                    this.updateModelDisplay();
                } catch (error) {
                    console.error('[GSX Create] API config error:', error);
                }
            },
            
            // Update model display text
            updateModelDisplay() {
                const display = document.getElementById('currentModelDisplay');
                if (display) {
                    display.textContent = this.getModelDisplayName(this.selectedModel);
                }
            },
            
            // Show Settings Modal
            showSettings() {
                const settingsModelSelect = document.getElementById('settingsModelSelect');
                if (settingsModelSelect) {
                    settingsModelSelect.value = this.selectedModel;
                }
                document.getElementById('settingsModal').classList.add('active');
            },
            
            // Save Settings
            saveSettings() {
                const settingsModelSelect = document.getElementById('settingsModelSelect');
                if (settingsModelSelect) {
                    this.selectedModel = settingsModelSelect.value;
                    localStorage.setItem('gsxCreateModel', this.selectedModel);
                }
                this.updateModelDisplay();
                this.closeModal('settingsModal');
                // Only show message if chat area is active
                if (document.getElementById('chatArea').classList.contains('active')) {
                    this.addMessage('system', `Settings saved. Model: ${this.getModelDisplayName(this.selectedModel)}`);
                }
            },
            
            // Get human-readable model name
            getModelDisplayName(modelId) {
                const names = {
                    'claude-opus-4-5-20251101': 'Claude Opus 4.5',
                    'claude-sonnet-4-5-20250929': 'Claude Sonnet 4.5'
                };
                return names[modelId] || modelId;
            },
            
            // Load Spaces
            async loadSpaces() {
                try {
                    const spaces = await window.aider.getSpaces();
                    console.log('[GSX Create] Loaded spaces:', spaces);
                    this.spaces = spaces;
                    
                    // Populate sidebar select
                    const select = document.getElementById('spaceSelect');
                    if (select) {
                        select.innerHTML = '<option value="">Select a space...</option>';
                    }
                    
                    // Populate main setup select
                    const mainSelect = document.getElementById('mainSpaceSelect');
                    if (mainSelect) {
                        mainSelect.innerHTML = '<option value="">Choose a space...</option>';
                    }
                    
                    if (spaces && spaces.length > 0) {
                        spaces.forEach(space => {
                            if (space.path) {
                                // Sidebar select
                                if (select) {
                                    const option = document.createElement('option');
                                    option.value = space.id;
                                    option.textContent = `${space.name} (${space.itemCount || 0} items)`;
                                    option.dataset.path = space.path;
                                    option.dataset.name = space.name;
                                    select.appendChild(option);
                                }
                                
                                // Main setup select
                                if (mainSelect) {
                                    const option2 = document.createElement('option');
                                    option2.value = space.id;
                                    option2.textContent = `${space.name} (${space.itemCount || 0} items)`;
                                    option2.dataset.path = space.path;
                                    option2.dataset.name = space.name;
                                    mainSelect.appendChild(option2);
                                }
                            }
                        });
                    }
                } catch (error) {
                    console.error('[GSX Create] Load spaces error:', error);
                }
            },
            
            // Show a custom prompt modal (since prompt() is not supported in Electron)
            showPromptModal(title, placeholder = '') {
                return new Promise((resolve) => {
                    // Create modal overlay
                    const overlay = document.createElement('div');
                    overlay.style.cssText = `
                        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                        background: rgba(0,0,0,0.7); z-index: 10000;
                        display: flex; align-items: center; justify-content: center;
                    `;
                    
                    const modal = document.createElement('div');
                    modal.style.cssText = `
                        background: var(--bg-secondary, #1e1e1e); border-radius: 12px;
                        padding: 24px; min-width: 320px; max-width: 400px;
                        box-shadow: 0 8px 32px rgba(0,0,0,0.4);
                        border: 1px solid var(--border-color, #333);
                    `;
                    
                    modal.innerHTML = `
                        <h3 style="margin: 0 0 16px 0; color: var(--text-primary, #fff); font-size: 16px;">${title}</h3>
                        <input type="text" id="promptInput" placeholder="${placeholder}" style="
                            width: 100%; padding: 10px 12px; border-radius: 6px;
                            border: 1px solid var(--border-color, #444); background: var(--bg-primary, #121212);
                            color: var(--text-primary, #fff); font-size: 14px; box-sizing: border-box;
                        " autofocus>
                        <div style="display: flex; gap: 8px; margin-top: 16px; justify-content: flex-end;">
                            <button id="promptCancel" style="
                                padding: 8px 16px; border-radius: 6px; border: 1px solid var(--border-color, #444);
                                background: transparent; color: var(--text-secondary, #888); cursor: pointer;
                            ">Cancel</button>
                            <button id="promptOk" style="
                                padding: 8px 16px; border-radius: 6px; border: none;
                                background: var(--accent-color, #0066cc); color: #fff; cursor: pointer;
                            ">Create</button>
                        </div>
                    `;
                    
                    overlay.appendChild(modal);
                    document.body.appendChild(overlay);
                    
                    const input = modal.querySelector('#promptInput');
                    const okBtn = modal.querySelector('#promptOk');
                    const cancelBtn = modal.querySelector('#promptCancel');
                    
                    const cleanup = (value) => {
                        overlay.remove();
                        resolve(value);
                    };
                    
                    input.focus();
                    input.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') cleanup(input.value.trim() || null);
                        if (e.key === 'Escape') cleanup(null);
                    });
                    okBtn.addEventListener('click', () => cleanup(input.value.trim() || null));
                    cancelBtn.addEventListener('click', () => cleanup(null));
                    overlay.addEventListener('click', (e) => { if (e.target === overlay) cleanup(null); });
                });
            },
            
            // Create New Space
            async createNewSpace() {
                const spaceName = await this.showPromptModal('Create New Space', 'Enter space name...');
                if (!spaceName) {
                    return;
                }
                
                try {
                    console.log('[GSX Create] Creating new space:', spaceName);
                    this.trackBehavior('create_space_started', { name: spaceName });
                    
                    // Create the space via clipboard API
                    const result = await window.clipboard.createSpace({
                        name: spaceName,
                        icon: '',
                        notebook: {
                            description: `Project space for ${spaceName}`,
                            objective: '',
                            instructions: '',
                            tags: ['gsx-create'],
                            links: []
                        }
                    });
                    
                    if (result && result.success) {
                        console.log('[GSX Create] Space created:', result.space);
                        this.trackBehavior('create_space_success', { spaceId: result.space.id, name: spaceName });
                        
                        // Reload spaces to update the dropdown
                        await this.loadSpaces();
                        
                        // Auto-select the new space
                        const mainSelect = document.getElementById('mainSpaceSelect');
                        if (mainSelect && result.space.id) {
                            mainSelect.value = result.space.id;
                            await this.selectSpaceFromMain(result.space.id);
                        }
                        
                        this.addMessage('system', ` Space "${spaceName}" created successfully!`);
                    } else {
                        throw new Error(result?.error || 'Failed to create space');
                    }
                } catch (error) {
                    console.error('[GSX Create] Create space error:', error);
                    this.trackBehavior('create_space_error', { name: spaceName, error: error.message });
                    this.addMessage('error', 'Failed to create space: ' + error.message);
                }
            },
            
            // Select Space from Main Setup
            async selectSpaceFromMain(spaceId) {
                const startBtn = document.getElementById('mainStartBtn');
                const previewWelcomeTitle = document.getElementById('previewWelcomeTitle');
                const previewWelcomeSubtitle = document.getElementById('previewWelcomeSubtitle');
                const previewWelcomeStatus = document.getElementById('previewWelcomeStatus');
                
                if (!spaceId) {
                    document.getElementById('spaceSelectedConfig').style.display = 'none';
                    // Disable start button
                        startBtn.disabled = true;
                        startBtn.style.opacity = '0.5';
                        startBtn.style.cursor = 'not-allowed';
                    // Reset welcome state
                    if (previewWelcomeTitle) previewWelcomeTitle.textContent = 'Your App Preview';
                    if (previewWelcomeSubtitle) previewWelcomeSubtitle.textContent = 'Select a space and start building. Your app will appear here in real-time.';
                    if (previewWelcomeStatus) {
                        previewWelcomeStatus.classList.remove('building');
                        previewWelcomeStatus.textContent = 'Select a space to begin';
                    }
                    return;
                }
                
                const select = document.getElementById('mainSpaceSelect');
                const option = select.options[select.selectedIndex];
                
                    this.currentSpaceId = spaceId;
                    this.currentSpaceName = option.dataset.name;
                    this.repoPath = option.dataset.path;
                    this.currentSpace = {
                        id: spaceId,
                        name: option.dataset.name,
                        path: option.dataset.path
                    };
                
                console.log('[GSX Create] Selected space from main:', this.currentSpace);
                this.trackBehavior('space_selected', { spaceId, name: this.currentSpaceName });
                
                // Update welcome state in preview panel
                if (previewWelcomeTitle) previewWelcomeTitle.textContent = this.currentSpaceName;
                if (previewWelcomeSubtitle) previewWelcomeSubtitle.textContent = 'Start a session to begin building. Your app will appear here as you work.';
                if (previewWelcomeStatus) {
                    previewWelcomeStatus.classList.remove('building');
                    previewWelcomeStatus.textContent = 'Ready to build - click Start Session';
                }
                
                // Enable start button
                    startBtn.disabled = false;
                    startBtn.style.opacity = '1';
                    startBtn.style.cursor = 'pointer';
                
                // Show config options
                document.getElementById('spaceSelectedConfig').style.display = 'block';
                
                // Sync sidebar select
                const sidebarSelect = document.getElementById('spaceSelect');
                if (sidebarSelect) sidebarSelect.value = spaceId;
                
                // Load space data - load space items first, then populate dropdowns
                await this.loadSpaceItems();
                await Promise.all([
                    this.loadProjectFiles(),
                    this.loadStyleGuidesForMain(),
                    this.loadJourneyMapsForMain(),
                    this.loadCostSummary(),
                    this.loadGlobalInstructions(),
                    this.loadCycleState()
                ]);
                
                // Load task queue for this space
                this.loadTaskQueue();
                
                // Load version backups and branches
                await this.loadVersionBackups();
                await this.loadBranches();
                
                // Load git branches into TabManager
                if (this.repoPath) {
                    await TabManager.loadGitBranches(this.repoPath);
                }
                
                // Update TabManager overview with current space
                TabManager.refreshOverview();
                
                // Show sidebar config section too
                const configSection = document.getElementById('configSection');
                if (configSection) configSection.style.display = 'block';
            },
            
            // ========== DROPDOWN POPULATION (HARDENED) ==========
            // These functions populate the style guide and journey map dropdowns.
            // IMPORTANT: this.spaceItems MUST be loaded before calling these functions.
            
            async loadStyleGuidesForMain() {
                if (!this.currentSpaceId) {
                    console.warn('[GSX Create] loadStyleGuidesForMain: No space selected');
                    return;
                }
                
                // Style guide dropdown starts disabled - will be enabled when journey map is selected
                const mainSelect = document.getElementById('mainStyleGuideSelect');
                if (mainSelect) {
                    mainSelect.disabled = true;
                    mainSelect.style.opacity = '0.5';
                    mainSelect.innerHTML = '<option value="">Select journey map first...</option>';
                }
                
                // Also populate sidebar select
                this.renderStyleGuideSelect();
            },
            
            async loadJourneyMapsForMain() {
                if (!this.currentSpaceId) {
                    console.warn('[GSX Create] loadJourneyMapsForMain: No space selected');
                    return;
                }
                
                // Ensure spaceItems is an array (defensive)
                const items = Array.isArray(this.spaceItems) ? this.spaceItems : [];
                console.log('[GSX Create] loadJourneyMapsForMain: spaceItems count =', items.length);
                
                // Populate journey map dropdown from space items (assets in the space)
                const mainSelect = document.getElementById('mainJourneyMapSelect');
                if (mainSelect) {
                    mainSelect.innerHTML = '<option value="">Select a journey map...</option>';
                    if (items.length > 0) {
                        items.forEach(item => {
                            const option = document.createElement('option');
                            option.value = item.id || '';
                            const displayText = item.name || item.title || 'Untitled';
                            option.textContent = displayText;
                            option.dataset.content = item.content || '';
                            mainSelect.appendChild(option);
                        });
                        console.log('[GSX Create] Journey map dropdown populated with', items.length, 'items');
                    } else {
                        console.warn('[GSX Create] No space items available for journey map dropdown');
                    }
                }
                
                // Reset style guide dropdown to disabled state
                const styleSelect = document.getElementById('mainStyleGuideSelect');
                if (styleSelect) {
                    styleSelect.disabled = true;
                    styleSelect.style.opacity = '0.5';
                    styleSelect.innerHTML = '<option value="">Select journey map first...</option>';
                }
                
                // Also populate sidebar select
                this.renderJourneyMapSelect();
            },
            
            // Called when journey map is selected - enables style guide dropdown
            onJourneyMapSelected(journeyMapId) {
                console.log('[GSX Create] onJourneyMapSelected:', journeyMapId);
                
                const styleSelect = document.getElementById('mainStyleGuideSelect');
                if (!styleSelect) {
                    console.error('[GSX Create] mainStyleGuideSelect element not found');
                    return;
                }
                
                if (journeyMapId) {
                    // Store selected ID for later evaluation (after session starts)
                    this.selectedJourneyMapId = journeyMapId;
                    
                    // Evaluate journey map
                    this.evaluateJourneyMap(journeyMapId);
                    
                    // Enable style guide dropdown
                    styleSelect.disabled = false;
                    styleSelect.style.opacity = '1';
                    styleSelect.innerHTML = '<option value="">Select a style guide...</option>';
                    
                    // Populate with space items (defensive)
                    const items = Array.isArray(this.spaceItems) ? this.spaceItems : [];
                    if (items.length > 0) {
                        items.forEach(item => {
                            const option = document.createElement('option');
                            option.value = item.id || '';
                            option.textContent = item.name || item.title || 'Untitled';
                            option.dataset.content = item.content || '';
                            styleSelect.appendChild(option);
                        });
                        console.log('[GSX Create] Style guide dropdown populated with', items.length, 'items');
                    } else {
                        console.warn('[GSX Create] No space items available for style guide dropdown');
                    }
                    
                    // Add onchange handler for style guide
                    styleSelect.onchange = (e) => this.onStyleGuideSelect(e.target.value);
                    
                    console.log('[GSX Create] Style guide enabled after journey map selection');
                } else {
                    // No journey map - disable style guide and clear evaluated data
                    this.evaluatedJourneyMap = null;
                    this.evaluatedStyleGuide = null;
                    this.selectedJourneyMapId = null;
                    this.selectedStyleGuideId = null;
                    styleSelect.disabled = true;
                    styleSelect.style.opacity = '0.5';
                    styleSelect.innerHTML = '<option value="">Select journey map first...</option>';
                }
            },
            
            // Call evaluation API with retry logic for Claude 4.5 models
            async callEvaluationAPI(systemPrompt, userPrompt) {
                const model = this.selectedModel || 'claude-opus-4-5-20251101';
                const maxRetries = 10;
                const maxWaitSeconds = 30;
                let waitSeconds = 1;
                
                for (let attempt = 1; attempt <= maxRetries; attempt++) {
                    try {
                        // Use IPC to call evaluation API from main process (has access to API keys)
                        if (window.aider && typeof window.aider.evaluate === 'function') {
                            console.log(`[GSX Create] Calling evaluation API with model: ${model} (attempt ${attempt}/${maxRetries})`);
                            const result = await window.aider.evaluate(systemPrompt, userPrompt, model);
                            
                            if (!result.success) {
                                // Check if it's a model not found error - retry with backoff
                                if (result.error && (result.error.includes('404') || result.error.includes('not_found'))) {
                                    console.warn(`[GSX Create] Model ${model} not available, waiting ${waitSeconds}s before retry...`);
                                    this.addMessage('system', ` Model ${model} not available yet, retrying in ${waitSeconds}s... (${attempt}/${maxRetries})`);
                                    
                                    await this.delay(waitSeconds * 1000);
                                    waitSeconds = Math.min(waitSeconds * 2, maxWaitSeconds); // Exponential backoff, max 30s
                                    continue;
                                }
                                throw new Error(result.error || 'Evaluation failed');
                            }
                            return result.content;
                        }
                        
                        // Fallback: Return a helpful message if IPC not available
                        console.warn('[GSX Create] Evaluation API not available via IPC');
                        throw new Error('Evaluation API not configured. Please check your API key in settings.');
                        
                    } catch (error) {
                        // Check if it's a retryable error (model not found)
                        if (error.message && (error.message.includes('404') || error.message.includes('not_found'))) {
                            if (attempt < maxRetries) {
                                console.warn(`[GSX Create] Model ${model} not available, waiting ${waitSeconds}s before retry...`);
                                this.addMessage('system', ` Model ${model} not available yet, retrying in ${waitSeconds}s... (${attempt}/${maxRetries})`);
                                
                                await this.delay(waitSeconds * 1000);
                                waitSeconds = Math.min(waitSeconds * 2, maxWaitSeconds); // Exponential backoff, max 30s
                                continue;
                            }
                        }
                        console.error('[GSX Create] Evaluation API error:', error);
                        throw error;
                    }
                }
                
                throw new Error(`Model ${model} not available after ${maxRetries} retries. Please try again later.`);
            },
            
            // Helper delay function
            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            },
            
            // Load full content for a space item
            async loadItemContent(itemId) {
                const item = this.spaceItems.find(i => i.id === itemId);
                if (!item) return null;
                
                // If content is already loaded, return it
                if (item.content && !item._needsContent) {
                    return item.content;
                }
                
                // Load content from storage
                try {
                    if (window.aider && window.aider.getItemContent) {
                        const content = await window.aider.getItemContent(itemId);
                        item.content = content;
                        item._needsContent = false;
                        return content;
                    }
                } catch (error) {
                    console.error('[GSX Create] Failed to load item content:', error);
                }
                
                return item.content || '';
            },
            
            // Evaluate Journey Map
            async evaluateJourneyMap(itemId) {
                if (this.isEvaluatingAsset) return;
                this.isEvaluatingAsset = true;
                
                try {
                    const item = this.spaceItems.find(i => i.id === itemId);
                    if (!item) {
                        this.addMessage('system', ' Journey Map not found');
                        return;
                    }
                    
                    this.addMessage('system', ` Evaluating Journey Map: ${item.name || item.title}...`);
                    
                    const content = await this.loadItemContent(itemId);
                    if (!content) {
                        this.addMessage('system', ' Journey Map has no content');
                        return;
                    }
                    
                    const systemPrompt = `You are a UX expert analyzing a user journey map. Provide a comprehensive evaluation in markdown format.`;
                    
                    const userPrompt = `Analyze this Journey Map and provide:

1. **Summary**: Brief overview of the journey (2-3 sentences)
2. **Phases**: List the main journey phases
3. **Touchpoints**: Key user touchpoints identified
4. **Goals**: User goals at each phase
5. **Pain Points**: Identified pain points or friction
6. **Opportunities**: Improvement opportunities
7. **Quality Score**: Rate 1-10 with explanation

Journey Map Content:
${content}`;
                    
                    const evaluation = await this.callEvaluationAPI(systemPrompt, userPrompt);
                    
                    this.evaluatedJourneyMap = {
                        id: itemId,
                        name: item.name || item.title,
                        content: content,
                        evaluation: evaluation
                    };
                    
                    this.addMessage('system', ` Journey Map Evaluation:\n\n${evaluation}`);
                    
                    // Enable style guide selection
                    const styleSelect = document.getElementById('mainStyleGuideSelect');
                    if (styleSelect) {
                        styleSelect.disabled = false;
                        styleSelect.style.opacity = '1';
                    }
                    
                } catch (error) {
                    this.addMessage('system', ` Journey Map evaluation failed: ${error.message}`);
                } finally {
                    this.isEvaluatingAsset = false;
                }
            },
            
            // Evaluate Style Guide (requires Journey Map first)
            async evaluateStyleGuide(itemId) {
                if (this.isEvaluatingAsset) return;
                
                if (!this.evaluatedJourneyMap) {
                    this.addMessage('system', ' Please evaluate a Journey Map first');
                    return;
                }
                
                this.isEvaluatingAsset = true;
                
                try {
                    const item = this.spaceItems.find(i => i.id === itemId);
                    if (!item) {
                        this.addMessage('system', ' Style Guide not found');
                        return;
                    }
                    
                    this.addMessage('system', ` Evaluating Style Guide: ${item.name || item.title}...`);
                    
                    const content = await this.loadItemContent(itemId);
                    if (!content) {
                        this.addMessage('system', ' Style Guide has no content');
                        return;
                    }
                    
                    const systemPrompt = `You are a UI/UX design expert analyzing a style guide in context of a user journey. Evaluate how well the style guide supports the journey.`;
                    
                    const userPrompt = `Analyze this Style Guide in context of the Journey Map and provide:

1. **Summary**: Brief overview of the style guide (2-3 sentences)
2. **Visual Elements**: Key visual design elements defined
3. **Components**: UI components and their styles
4. **Journey Alignment**: How well it supports the journey phases
5. **Consistency**: Design consistency assessment
6. **Gaps**: Missing elements for the journey
7. **Recommendations**: Specific improvements
8. **Quality Score**: Rate 1-10 with explanation

Journey Map Context:
${this.evaluatedJourneyMap.content}

Style Guide Content:
${content}`;
                    
                    const evaluation = await this.callEvaluationAPI(systemPrompt, userPrompt);
                    
                    this.evaluatedStyleGuide = {
                        id: itemId,
                        name: item.name || item.title,
                        content: content,
                        evaluation: evaluation
                    };
                    
                    this.addMessage('system', ` Style Guide Evaluation:\n\n${evaluation}`);
                    
                } catch (error) {
                    this.addMessage('system', ` Style Guide evaluation failed: ${error.message}`);
                } finally {
                    this.isEvaluatingAsset = false;
                }
            },
            
            // Handle style guide selection
            onStyleGuideSelect(itemId) {
                if (!itemId) return;
                this.evaluateStyleGuide(itemId);
            },
            
            // Select Space
            async selectSpace(spaceId) {
                const sidebarContainer = document.getElementById('sidebarContainer');
                
                if (!spaceId) {
                    this.currentSpace = null;
                    this.currentSpaceId = null;
                    document.getElementById('configSection').style.display = 'none';
                    sidebarContainer.style.display = 'none';
                    return;
                }
                
                const select = document.getElementById('spaceSelect');
                const option = select.options[select.selectedIndex];
                
                this.currentSpaceId = spaceId;
                this.currentSpaceName = option.dataset.name;
                this.repoPath = option.dataset.path;
                this.currentSpace = {
                    id: spaceId,
                    name: option.dataset.name,
                    path: option.dataset.path
                };
                
                console.log('[GSX Create] Selected space:', this.currentSpace);
                
                // Show sidebar container and config section
                sidebarContainer.style.display = 'flex';
                document.getElementById('configSection').style.display = 'block';
                
                // IMPORTANT: Load space items FIRST - other functions depend on this.spaceItems
                await this.loadSpaceItems();
                
                // Now load everything else (these depend on spaceItems being populated)
                await Promise.all([
                    this.loadProjectFiles(),
                    this.loadStyleGuides(),
                    this.loadJourneyMaps(),
                    this.loadCostSummary(),
                    this.loadGlobalInstructions(),
                    this.loadCycleState()
                ]);
                
                // Load task queue for this space
                this.loadTaskQueue();
                
                // Load version backups and branches
                await this.loadVersionBackups();
                await this.loadBranches();
                
                // Load git branches into TabManager
                if (this.repoPath) {
                    await TabManager.loadGitBranches(this.repoPath);
                }
                
                // Update TabManager overview with current space
                TabManager.refreshOverview();
            },
            
            // Load Reference Memory Files
            // ========== FILE UPLOAD ==========
            
            // Trigger file input click
            triggerFileUpload() {
                if (!this.repoPath) {
                    this.addMessage('error', 'Please select a space first');
                    return;
                }
                document.getElementById('fileUploadInput').click();
            },
            
            // Handle file input change
            async handleFileUpload(event) {
                const files = event.target.files;
                if (!files || files.length === 0) return;
                
                await this.uploadFiles(Array.from(files));
                event.target.value = ''; // Reset input
            },
            
            // Handle drag over
            handleDragOver(event) {
                event.preventDefault();
                event.stopPropagation();
                event.currentTarget.classList.add('drag-over');
            },
            
            // Handle drag leave
            handleDragLeave(event) {
                event.preventDefault();
                event.stopPropagation();
                event.currentTarget.classList.remove('drag-over');
            },
            
            // Handle file drop
            async handleFileDrop(event) {
                event.preventDefault();
                event.stopPropagation();
                event.currentTarget.classList.remove('drag-over');
                
                if (!this.repoPath) {
                    this.addMessage('error', 'Please select a space first');
                    return;
                }
                
                const files = event.dataTransfer.files;
                if (!files || files.length === 0) return;
                
                await this.uploadFiles(Array.from(files));
            },
            
            // Upload files to the space
            async uploadFiles(files) {
                if (!this.repoPath) return;
                
                this.addMessage('system', `Uploading ${files.length} file(s)...`);
                
                let uploaded = 0;
                let failed = 0;
                const uploadedFiles = [];
                
                for (const file of files) {
                    try {
                        const content = await this.readFileContent(file);
                        const filePath = this.repoPath + '/' + file.name;
                        
                        // Check if it's a binary file
                        if (this.isBinaryFile(file.name)) {
                            // For binary files, we need to save as base64 or use a different method
                            const result = await window.aider.writeFile(filePath, content);
                            if (result && result.success !== false) {
                                uploaded++;
                                uploadedFiles.push({ name: file.name, path: filePath, size: file.size, type: file.type });
                            } else {
                                failed++;
                                console.error('[Upload] Failed to write:', file.name);
                            }
                        } else {
                            // Text file
                            const result = await window.aider.writeFile(filePath, content);
                            if (result && result.success !== false) {
                                uploaded++;
                                uploadedFiles.push({ name: file.name, path: filePath, size: file.size, type: file.type });
                            } else {
                                failed++;
                            }
                        }
                    } catch (e) {
                        console.error('[Upload] Error uploading file:', file.name, e);
                        failed++;
                    }
                }
                
                // Save file metadata to unified space metadata
                if (this.currentSpaceId && uploadedFiles.length > 0) {
                    for (const uploadedFile of uploadedFiles) {
                        try {
                            await window.aider.setFileMetadata(this.currentSpaceId, uploadedFile.path, {
                                source: 'upload',
                                originalName: uploadedFile.name,
                                size: uploadedFile.size,
                                mimeType: uploadedFile.type,
                                uploadedAt: new Date().toISOString()
                            });
                        } catch (e) {
                            console.log('[Upload] Could not save file metadata:', e);
                        }
                    }
                }
                
                
                // Refresh file list
                await this.loadProjectFiles();
                
                if (failed === 0) {
                    this.addMessage('system', ` Uploaded ${uploaded} file(s) successfully`);
                } else {
                    this.addMessage('system', ` Uploaded ${uploaded} file(s), ${failed} failed`);
                }
                
                // Add to context if session is active
                if (this.contextFiles && uploaded > 0) {
                    const newFiles = files.map(f => this.repoPath + '/' + f.name);
                    try {
                        await window.aider.addFiles(newFiles);
                        this.contextFiles = [...new Set([...this.contextFiles, ...newFiles])];
                        this.renderContextFiles();
                    } catch (e) {
                        console.log('[Upload] Could not add to context:', e);
                    }
                }
            },
            
            // Read file content
            readFileContent(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    
                    if (this.isBinaryFile(file.name)) {
                        // Read as data URL for binary files (images, etc.)
                        reader.onload = () => resolve(reader.result);
                        reader.onerror = reject;
                        reader.readAsDataURL(file);
                    } else {
                        // Read as text for text files
                        reader.onload = () => resolve(reader.result);
                        reader.onerror = reject;
                        reader.readAsText(file);
                    }
                });
            },
            
            // Check if file is binary
            isBinaryFile(fileName) {
                const binaryExtensions = [
                    'png', 'jpg', 'jpeg', 'gif', 'webp', 'ico', 'svg',
                    'pdf', 'doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx',
                    'zip', 'tar', 'gz', 'rar', '7z',
                    'mp3', 'mp4', 'wav', 'avi', 'mov', 'webm',
                    'ttf', 'otf', 'woff', 'woff2', 'eot'
                ];
                const ext = fileName.split('.').pop().toLowerCase();
                return binaryExtensions.includes(ext);
            },
            
            // ========== END FILE UPLOAD ==========
            
            async loadProjectFiles() {
                if (!this.repoPath) return;
                
                try {
                    // Track previous HTML file count for auto-preview detection
                    const prevHtmlFiles = this.projectFiles.filter(f => 
                        !f.isDirectory && (f.name.toLowerCase().endsWith('.html') || f.name.toLowerCase().endsWith('.htm'))
                    );
                    const hadNoHtmlFiles = prevHtmlFiles.length === 0;
                    
                    const result = await window.aider.listProjectFiles(this.repoPath);
                    console.log('[GSX Create] Project files:', result);
                    
                    if (result.success) {
                        this.projectFiles = result.files || [];
                        this.renderProjectFiles();
                        this.populateMainFileSelect();
                        
                        // Auto-preview: If we had no HTML files before and now we do, auto-preview the first one
                        const newHtmlFiles = this.projectFiles.filter(f => 
                            !f.isDirectory && (f.name.toLowerCase().endsWith('.html') || f.name.toLowerCase().endsWith('.htm'))
                        );
                        
                        if (hadNoHtmlFiles && newHtmlFiles.length > 0 && !this.currentPreviewFile) {
                            console.log('[GSX Create] Auto-preview: First HTML file detected');
                            await this.autoDetectAndPreview();
                        }
                    }
                } catch (error) {
                    console.error('[GSX Create] Load files error:', error);
                }
            },
            
            // Auto-detect main HTML file and preview it
            async autoDetectAndPreview() {
                const mainFile = await this.findMainHtmlFile();
                if (mainFile) {
                    this.mainFile = mainFile;
                    const select = document.getElementById('mainFileSelect');
                    if (select) {
                        select.value = mainFile;
                    }
                    console.log('[GSX Create] Auto-preview: Showing', mainFile);
                    await this.previewFile(mainFile);
                    
                    // Hide welcome state and show actual preview
                    const welcomeEl = document.getElementById('previewWelcome');
                    if (welcomeEl) {
                        welcomeEl.style.display = 'none';
                    }
                }
            },
            
            // Populate main file dropdown with HTML files
            populateMainFileSelect() {
                const select = document.getElementById('mainFileSelect');
                if (!select) return;
                
                const files = this.projectFiles.filter(f => !f.isDirectory);
                const htmlFiles = files.filter(f => 
                    f.name.toLowerCase().endsWith('.html') || 
                    f.name.toLowerCase().endsWith('.htm')
                );
                
                // Keep auto-detect option
                select.innerHTML = '<option value="">Auto-detect</option>';
                
                // Add HTML files
                htmlFiles.forEach(file => {
                    const option = document.createElement('option');
                    option.value = file.path;
                    option.textContent = file.name;
                    select.appendChild(option);
                });
                
                // If we have a saved main file, select it
                if (this.mainFile) {
                    select.value = this.mainFile;
                    } else {
                    // Auto-detect and set
                    this.autoDetectMainFile();
                }
            },
            
            // Auto-detect the main HTML file
            async autoDetectMainFile() {
                const mainFile = await this.findMainHtmlFile();
                if (mainFile) {
                    this.mainFile = mainFile;
                    const select = document.getElementById('mainFileSelect');
                    if (select) {
                        select.value = mainFile;
                    }
                    console.log('[GSX Create] Auto-detected main file:', mainFile);
                }
            },
            
            // Set the main file (called from dropdown)
            setMainFile(filePath) {
                this.mainFile = filePath || null;
                console.log('[GSX Create] Main file set to:', this.mainFile || 'Auto-detect');
                
                // If a file is selected, preview it
                if (filePath) {
                    this.previewFile(filePath);
                }
            },
            
            // Render Reference Memory Files
            renderProjectFiles() {
                const fileList = document.getElementById('fileList');
                const fileCount = document.getElementById('fileCount');
                
                const files = this.projectFiles.filter(f => !f.isDirectory);
                fileCount.textContent = files.length;
                
                if (files.length === 0) {
                    fileList.innerHTML = '<div style="color: var(--text-muted); font-size: 11px; padding: 8px;">No files yet</div>';
                    return;
                }
                
                fileList.innerHTML = files.map(file => {
                    const inContext = this.contextFiles.includes(file.path);
                    const icon = this.getFileIcon(file.name);
                    const ext = file.name.split('.').pop().toLowerCase();
                    const isPreviewable = ['html', 'htm', 'css', 'js', 'json', 'ts', 'txt', 'md'].includes(ext);
                    return `
                        <div class="file-item ${inContext ? 'in-context' : ''}" 
                             onclick="GSXCreate.selectFile('${file.path}')">
                            <span class="icon">${icon}</span>
                            <span>${file.name}</span>
                            ${isPreviewable ? '<span class="preview-icon" title="Click to preview">&#128065;</span>' : ''}
                        </div>
                    `;
                }).join('');
            },
            
            // Load Space Items
            async loadSpaceItems() {
                
                if (!this.currentSpaceId) return;
                
                try {
                    const result = await window.aider.getSpaceItems(this.currentSpaceId);
                    if (result.success) {
                        this.spaceItems = result.items || [];
                    console.log('[GSX Create] Space items:', this.spaceItems);
                    }
                } catch (error) {
                    console.error('[GSX Create] Load space items error:', error);
                }
            },
            
            // Load Style Guides
            async loadStyleGuides() {
                if (!this.currentSpaceId) return;
                
                try {
                    const result = await window.aider.getStyleGuides(this.currentSpaceId);
                    if (result.success) {
                        this.styleGuides = result.styleGuides || [];
                this.renderStyleGuideSelect();
                    }
                } catch (error) {
                    console.error('[GSX Create] Load style guides error:', error);
                }
            },
            
            renderStyleGuideSelect() {
                const select = document.getElementById('styleGuideSelect');
                if (!select) return;
                
                select.innerHTML = '<option value="">None</option>';
                
                // Use space items (defensive - ensure array)
                const items = Array.isArray(this.spaceItems) ? this.spaceItems : [];
                console.log('[GSX Create] renderStyleGuideSelect: items count =', items.length);
                
                items.forEach(item => {
                    const option = document.createElement('option');
                    option.value = item.id || '';
                    option.textContent = item.name || item.title || 'Untitled';
                    select.appendChild(option);
                });
            },
            
            // Load Journey Maps
            async loadJourneyMaps() {
                if (!this.currentSpaceId) return;
                
                try {
                    const result = await window.aider.getJourneyMaps(this.currentSpaceId);
                    if (result.success) {
                        this.journeyMaps = result.journeyMaps || [];
                this.renderJourneyMapSelect();
                    }
                } catch (error) {
                    console.error('[GSX Create] Load journey maps error:', error);
                }
            },
            
            renderJourneyMapSelect() {
                const select = document.getElementById('journeyMapSelect');
                if (!select) return;
                
                select.innerHTML = '<option value="">None</option>';
                
                // Use space items (defensive - ensure array)
                const items = Array.isArray(this.spaceItems) ? this.spaceItems : [];
                console.log('[GSX Create] renderJourneyMapSelect: items count =', items.length);
                
                items.forEach(item => {
                    const option = document.createElement('option');
                    option.value = item.id || '';
                    option.textContent = item.name || item.title || 'Untitled';
                    select.appendChild(option);
                });
            },
            
            // Toggle File Context
            // Select file - adds to context AND previews
            async selectFile(filePath) {
                // Add to context if not already there
                if (!this.contextFiles.includes(filePath)) {
                    this.contextFiles.push(filePath);
                    await window.aider.addFiles([filePath]);
                    this.renderProjectFiles();
                    this.renderContextFiles();
                }
                
                // Preview the file
                this.previewFile(filePath);
            },
            
            async toggleFileContext(filePath) {
                const index = this.contextFiles.indexOf(filePath);
                const action = index > -1 ? 'removed' : 'added';
                
                this.trackBehavior('context_file_toggle', { 
                    file: filePath.split('/').pop(), 
                    action 
                });
                
                if (index > -1) {
                    this.contextFiles.splice(index, 1);
                    await window.aider.removeFiles([filePath]);
                } else {
                    this.contextFiles.push(filePath);
                    await window.aider.addFiles([filePath]);
                }
                
                this.renderProjectFiles();
                this.renderContextFiles();
            },
            
            renderContextFiles() {
                const contextList = document.getElementById('contextList');
                const contextCount = document.getElementById('contextCount');
                
                contextCount.textContent = this.contextFiles.length;
                
                if (this.contextFiles.length === 0) {
                    contextList.innerHTML = '<div style="color: var(--text-muted); font-size: 11px;">Click files to add</div>';
                    return;
                }
                
                contextList.innerHTML = this.contextFiles.map(path => {
                    const name = path.split('/').pop();
                    return `
                        <div class="file-item in-context" onclick="GSXCreate.toggleFileContext('${path}')">
                            <span>${name}</span>
                            <span style="margin-left: auto; opacity: 0.5;"></span>
                        </div>
                    `;
                }).join('');
            },
            
            // Start Session
            async startSession() {
                // Get buttons (main or sidebar)
                const startBtn = document.getElementById('mainStartBtn') || document.getElementById('startBtn');
                const modelName = this.selectedModel;
                
                this.trackBehavior('session_starting', { 
                    space: this.currentSpaceName, 
                    model: modelName 
                });
                
                // Get style guide and journey map from main selects if available
                const styleGuideSelect = document.getElementById('mainStyleGuideSelect') || document.getElementById('styleGuideSelect');
                const journeyMapSelect = document.getElementById('mainJourneyMapSelect') || document.getElementById('journeyMapSelect');
                
                if (styleGuideSelect && styleGuideSelect.value) {
                    // Sync to sidebar
                    const sidebarSG = document.getElementById('styleGuideSelect');
                    if (sidebarSG) sidebarSG.value = styleGuideSelect.value;
                }
                if (journeyMapSelect && journeyMapSelect.value) {
                    const sidebarJM = document.getElementById('journeyMapSelect');
                    if (sidebarJM) sidebarJM.value = journeyMapSelect.value;
                }
                
                startBtn.disabled = true;
                startBtn.textContent = 'Starting...';
                
                try {
                    this.updateStatus('Starting...', false);
                    
                    const startResult = await window.aider.start();
                    if (!startResult.success) {
                        throw new Error(startResult.error || 'Failed to start');
                    }
                    
                    this.updateStatus('Initializing...', false);
                    
                    const result = await window.aider.initialize(this.repoPath, modelName);
                    
                    if (result.success) {
                        this.updateStatus('Connected', true);
                        
                        // Add all files to context automatically
                        const filePaths = this.projectFiles.filter(f => !f.isDirectory).map(f => f.path);
                        if (filePaths.length > 0) {
                            await window.aider.addFiles(filePaths);
                            this.contextFiles = filePaths;
                            this.renderContextFiles();
                        }
                        
                        // Show chat area and sidebar, hide setup
                        document.getElementById('setupPanel').classList.add('hidden');
                        document.getElementById('chatArea').classList.add('active');
                        document.getElementById('sidebarContainer').style.display = 'flex';
                        document.getElementById('costDisplay').classList.add('visible');
                        
                        // Show tab bar now that session is active
                        document.getElementById('tabBar').style.display = 'flex';
                        
                        // Switch to main branch tab (not overview) when starting
                        TabManager.switchTab('main-branch');
                        
                        // Initialize meta learning cycle panel
                        this.initCyclePanel();
                        
                        // Show branch timeline (even with just main branch)
                        this.renderBranchTimeline();
                        
                        // Load episodic memory in sidebar
                        this.loadEpisodicMemory();
                        
                        // Load constitutional memory (persistent guidelines)
                        this.loadConstitutionalMemory();
                        
                        // Check if this is a new project that needs setup
                        const needsSetup = await this.checkIfNeedsSetup();
                        
                        if (needsSetup) {
                            // Start the setup wizard agent
                            await this.startSetupWizard();
                        } else {
                            this.addMessage('system', `Connected to ${this.currentSpaceName}. ${filePaths.length} files in context.`);
                        }
                    } else {
                        throw new Error(result.error || 'Initialization failed');
                    }
                } catch (error) {
                    console.error('[GSX Create] Start error:', error);
                    this.addMessage('error', error.message);
                    this.updateStatus('Error', false);
                } finally {
                    startBtn.disabled = false;
                    startBtn.textContent = 'Start Session';
                }
            },
            
            // ========== SETUP WIZARD AGENT ==========
            
            setupWizardActive: false,
            setupWizardPhase: null,
            setupWizardData: {},
            setupWizardAssets: [],
            setupWizardCurrentAsset: 0,
            setupWizardAwaitingApproval: false,
            
            // Asset types with metadata
            assetTypes: {
                'journey-map': {
                    name: 'Journey Map',
                    description: 'User flow and interaction paths',
                    fileName: 'journey-map.md',
                    icon: ''
                },
                'style-guide': {
                    name: 'Style Guide',
                    description: 'Colors, typography, and design tokens',
                    fileName: 'style-guide.md',
                    icon: ''
                },
                'user-personas': {
                    name: 'User Personas',
                    description: 'Target user profiles and needs',
                    fileName: 'user-personas.md',
                    icon: ''
                },
                'requirements': {
                    name: 'Requirements',
                    description: 'Functional and non-functional requirements',
                    fileName: 'requirements.md',
                    icon: ''
                },
                'todo': {
                    name: 'Todo List',
                    description: 'Tasks for v1 implementation',
                    fileName: 'todo.md',
                    icon: ''
                },
                'evaluation-criteria': {
                    name: 'Evaluation Criteria',
                    description: 'How to measure success',
                    fileName: 'evaluation-criteria.md',
                    icon: ''
                }
            },
            
            // Check if the space needs initial setup
            async checkIfNeedsSetup() {
                // First check unified space metadata
                if (this.currentSpaceId) {
                    try {
                        const result = await window.aider.getSpaceMetadata(this.currentSpaceId);
                        if (result.success && result.metadata) {
                            const config = result.metadata.projectConfig;
                            if (config && config.setupComplete) {
                                console.log('[SetupWizard] Setup already complete (from space metadata)');
                                return false;
                            }
                        }
                    } catch (e) {
                        console.log('[SetupWizard] Could not read space metadata:', e);
                    }
                }
                
                // Fallback: Check for project-config.json
                const configFile = this.projectFiles.find(f => 
                    f.name === 'project-config.json'
                );
                
                if (configFile) {
                    try {
                        const content = await window.aider.readFile(configFile.path);
                        const config = JSON.parse(content);
                        if (config.setupComplete) {
                            return false;
                        }
                    } catch (e) {
                        console.log('[SetupWizard] Could not read config file:', e);
                    }
                }
                
                // Check for HTML files
                const htmlFiles = this.projectFiles.filter(f => 
                    !f.isDirectory && 
                    (f.name.toLowerCase().endsWith('.html') || f.name.toLowerCase().endsWith('.htm'))
                );
                
                if (htmlFiles.length === 0) {
                    return true;
                }
                
                // Check for essential assets
                const hasJourneyMap = this.projectFiles.find(f => f.name === 'journey-map.md');
                const hasStyleGuide = this.projectFiles.find(f => f.name === 'style-guide.md');
                
                if (!hasJourneyMap || !hasStyleGuide) {
                    return true;
                }
                
                return false;
            },
            
            // Start the setup wizard
            async startSetupWizard() {
                this.setupWizardActive = true;
                this.setupWizardPhase = 'welcome';
                this.setupWizardData = {
                    projectName: this.currentSpaceName,
                    description: null,
                    targetUsers: null,
                    keyFeatures: [],
                    stylePreference: null,
                    approvedAssets: {}
                };
                this.setupWizardAssets = [];
                this.setupWizardCurrentAsset = 0;
                this.setupWizardAwaitingApproval = false;
                
                this.addMessage('assistant', ` **Welcome to ${this.currentSpaceName}!**

I'll help you set up this project step by step. We'll create:

1. **Project Vision** - What you're building and for whom
2. **Journey Map** - How users will interact with your app
3. **Style Guide** - Colors, fonts, and design system
4. **MVP (v1)** - A working minimal version
5. **Todo List** - Tasks for future iterations

Let's start! **What would you like to build?**

Describe your idea in a sentence or two.`);
                
                this.setupWizardPhase = 'description';
            },
            
            // Process setup wizard responses
            async processSetupWizardInput(message) {
                if (!this.setupWizardActive) return false;
                
                // Handle approval responses
                if (this.setupWizardAwaitingApproval) {
                    return await this.handleAssetApproval(message);
                }
                
                switch (this.setupWizardPhase) {
                    case 'description':
                        this.setupWizardData.description = message;
                        await this.askTargetUsers();
                        return true;
                        
                    case 'target-users':
                        this.setupWizardData.targetUsers = message;
                        await this.askKeyFeatures();
                        return true;
                        
                    case 'features':
                        await this.processFeatures(message);
                        return true;
                        
                    case 'style':
                        this.setupWizardData.stylePreference = message;
                        await this.startAssetGeneration();
                        return true;
                        
                    case 'mvp-approval':
                        return await this.handleMVPApproval(message);
                        
                    default:
                        return false;
                }
            },
            
            // Ask about target users
            async askTargetUsers() {
                this.setupWizardPhase = 'target-users';
                this.addMessage('assistant', `Great! **Who is this for?**

Describe your target users:
 Who will use this?
 What problem does it solve for them?
 Any specific needs or constraints?`);
            },
            
            // Ask about key features
            async askKeyFeatures() {
                this.setupWizardPhase = 'features';
                
                this.addMessage('assistant', `Thinking about key features...`);
                
                const prompt = `Based on this project, suggest 5-7 key features as a numbered list.

Project: ${this.setupWizardData.description}
Target Users: ${this.setupWizardData.targetUsers}

Return ONLY a numbered list of features with brief descriptions. Be specific and actionable.`;

                try {
                    const response = await this.callAIForSetup(prompt);
                    this.setupWizardData.suggestedFeatures = response;
                    
                    this.addMessage('assistant', `Here are the key features I'd suggest:

${response}

**Do these look right?**

Reply "yes" to continue, or list the features you'd prefer.`);
                } catch (e) {
                    this.addMessage('assistant', `What are the key features you want? List them out.`);
                }
            },
            
            // Process features response
            async processFeatures(message) {
                const lower = message.toLowerCase();
                if (lower === 'yes' || lower === 'looks good' || lower === 'perfect' || lower === 'ok') {
                    this.setupWizardData.keyFeatures = this.setupWizardData.suggestedFeatures;
                } else {
                    this.setupWizardData.keyFeatures = message;
                }
                
                await this.askStylePreference();
            },
            
            // Ask about style
            async askStylePreference() {
                this.setupWizardPhase = 'style';
                
                this.addMessage('assistant', `**What visual style fits your project?**

 **Minimal** - Clean, lots of whitespace, subtle colors
 **Bold** - Strong colors, high contrast, impactful
 **Dark** - Dark backgrounds, easy on eyes
 **Soft** - Rounded corners, pastels, friendly
 **Professional** - Corporate, trustworthy, structured

Or describe your own style!`);
            },
            
            // Start generating assets
            async startAssetGeneration() {
                this.addMessage('assistant', `Perfect! Now I'll create your project assets one by one.

Each asset will appear in the preview panel. **Review it and type "approve" to continue**, or describe changes you'd like.

---

**Creating Journey Map...**`);
                
                // Define assets to create in order
                this.setupWizardAssets = [
                    'journey-map',
                    'style-guide',
                    'user-personas',
                    'requirements',
                    'evaluation-criteria'
                ];
                
                this.setupWizardCurrentAsset = 0;
                await this.generateNextAsset();
            },
            
            // Generate the next asset
            async generateNextAsset() {
                if (this.setupWizardCurrentAsset >= this.setupWizardAssets.length) {
                    // All assets done, create MVP
                    await this.createMVP();
                    return;
                }
                
                const assetKey = this.setupWizardAssets[this.setupWizardCurrentAsset];
                const asset = this.assetTypes[assetKey];
                
                this.addMessage('system', `${asset.icon} Creating ${asset.name}...`);
                
                const prompt = this.getAssetPrompt(assetKey);
                
                try {
                    const result = await window.aider.runPrompt(prompt);
                    await this.trackTaskCost(prompt, result?.response || '', 'asset_generation');
                    
                    // Refresh files and preview the new asset
                    await this.loadProjectFiles();
                    const assetPath = this.repoPath + '/' + asset.fileName;
                    await this.previewFile(assetPath);
                    
                    // Save asset metadata
                    await this.saveAssetMetadata(assetKey, asset.fileName);
                    
                    this.addMessage('assistant', `${asset.icon} **${asset.name}** is ready!

I've opened it in the preview panel. Please review it.

**Type "approve" to continue**, or describe any changes you'd like.`);
                    
                    this.setupWizardAwaitingApproval = true;
                    
                } catch (e) {
                    console.error('[SetupWizard] Asset generation error:', e);
                    this.addMessage('error', `Failed to create ${asset.name}: ${e.message}`);
                    // Skip to next asset
                    this.setupWizardCurrentAsset++;
                    await this.generateNextAsset();
                }
            },
            
            // Get prompt for each asset type
            getAssetPrompt(assetKey) {
                const context = `
Project: ${this.setupWizardData.description}
Target Users: ${this.setupWizardData.targetUsers}
Key Features: ${this.setupWizardData.keyFeatures}
Style: ${this.setupWizardData.stylePreference}`;

                const prompts = {
                    'journey-map': `Create a journey-map.md file for this project:
${context}

Include:
1. User entry points (how users discover/access the app)
2. Key user flows (step-by-step paths through main features)
3. Decision points and branches
4. Success states and error states
5. Emotional journey notes

Format as clear Markdown with sections and diagrams using ASCII/text.`,

                    'style-guide': `Create a style-guide.md file for this project:
${context}

Include:
1. Color palette (primary, secondary, accent, semantic colors) with hex codes
2. Typography (font families, sizes, weights)
3. Spacing system (consistent spacing values)
4. Border radius and shadows
5. Component patterns (buttons, inputs, cards)
6. Dark/light mode considerations if applicable

Format as Markdown with CSS variable examples.`,

                    'user-personas': `Create a user-personas.md file for this project:
${context}

Include 2-3 personas with:
1. Name and brief bio
2. Goals and motivations
3. Pain points and frustrations
4. Technical comfort level
5. How they would use this app
6. Key quotes that represent their mindset

Format as clear Markdown with sections for each persona.`,

                    'requirements': `Create a requirements.md file for this project:
${context}

Include:
1. Functional requirements (what the app must do)
2. Non-functional requirements (performance, accessibility, etc.)
3. MVP scope (what's in v1 vs future versions)
4. Constraints and assumptions
5. Success metrics

Format as Markdown with clear sections and bullet points.`,

                    'evaluation-criteria': `Create an evaluation-criteria.md file for this project:
${context}

Include criteria for rating the app on:
1. Functionality (features work correctly)
2. User Experience (intuitive, easy to use)
3. Performance (fast, responsive)
4. Design (visually appealing, consistent)
5. Code Quality (clean, maintainable)
6. Accessibility (keyboard, screen reader support)

Each criterion should have:
- Description
- Rating scale (1-10)
- What constitutes each rating level

Format as Markdown with checkboxes for evaluation.`
                };
                
                return prompts[assetKey] || `Create a ${assetKey}.md file with relevant content for this project:\n${context}`;
            },
            
            // Handle asset approval
            async handleAssetApproval(message) {
                const lower = message.toLowerCase().trim();
                const assetKey = this.setupWizardAssets[this.setupWizardCurrentAsset];
                const asset = this.assetTypes[assetKey];
                
                if (lower === 'approve' || lower === 'approved' || lower === 'yes' || lower === 'ok' || lower === 'looks good') {
                    // Mark as approved
                    this.setupWizardData.approvedAssets[assetKey] = {
                        approved: true,
                        approvedAt: new Date().toISOString()
                    };
                    
                    await this.updateAssetMetadata(assetKey, { approved: true });
                    
                    this.addMessage('system', ` ${asset.name} approved!`);
                    
                    // Move to next asset
                    this.setupWizardCurrentAsset++;
                    this.setupWizardAwaitingApproval = false;
                    await this.generateNextAsset();
                    
                } else {
                    // User wants changes
                    this.addMessage('assistant', `Making changes to ${asset.name}...`);
                    
                    const changePrompt = `Update the ${asset.fileName} file based on this feedback:

${message}

Keep the same format but incorporate the requested changes.`;

                    try {
                        const changeResult = await window.aider.runPrompt(changePrompt);
                        await this.trackTaskCost(changePrompt, changeResult?.response || '', 'asset_update');
                        await this.loadProjectFiles();
                        
                        const assetPath = this.repoPath + '/' + asset.fileName;
                        await this.previewFile(assetPath);
                        
                        this.addMessage('assistant', `I've updated the ${asset.name}. Please review again.

**Type "approve" to continue**, or describe more changes.`);
                        
                    } catch (e) {
                        this.addMessage('error', `Failed to update: ${e.message}`);
                    }
                }
                
                return true;
            },
            
            // Save asset metadata (uses unified space metadata)
            async saveAssetMetadata(assetKey, fileName) {
                if (!this.currentSpaceId) return;
                
                try {
                    await window.aider.setAssetMetadata(this.currentSpaceId, assetKey, {
                        fileName: fileName,
                        approved: false,
                        version: 1
                    });
                    console.log('[SetupWizard] Asset metadata saved:', assetKey);
                } catch (e) {
                    console.error('[SetupWizard] Failed to save asset metadata:', e);
                }
            },
            
            // Update asset metadata (uses unified space metadata)
            async updateAssetMetadata(assetKey, updates) {
                if (!this.currentSpaceId) return;
                
                try {
                    // Get current metadata
                    const result = await window.aider.getSpaceMetadata(this.currentSpaceId);
                    if (result.success && result.metadata && result.metadata.assets[assetKey]) {
                        const currentAsset = result.metadata.assets[assetKey];
                        await window.aider.setAssetMetadata(this.currentSpaceId, assetKey, {
                            ...currentAsset,
                            ...updates
                        });
                    }
                    console.log('[SetupWizard] Asset metadata updated:', assetKey);
                } catch (e) {
                    console.error('[SetupWizard] Failed to update asset metadata:', e);
                }
            },
            
            // Create the MVP
            async createMVP() {
                this.setupWizardPhase = 'mvp-approval';
                
                this.addMessage('assistant', ` **All assets approved!**

Now I'll create the **MVP (v1)** - a minimal working version of your app.

This will be a fully functional HTML file with:
 Core features implemented
 Your chosen style applied
 Sample data included

Creating MVP...`);
                
                const prompt = `Create a complete, working HTML file for this project.

Project: ${this.setupWizardData.description}
Target Users: ${this.setupWizardData.targetUsers}
Features: ${this.setupWizardData.keyFeatures}
Style: ${this.setupWizardData.stylePreference}

Requirements:
1. Single HTML file with embedded CSS and JavaScript
2. Implement the core MVP features
3. Apply the style guide colors and typography
4. Include realistic sample data
5. Make it fully interactive and functional
6. Responsive design
7. Clean, commented code

Name the file appropriately (e.g., app.html, calendar.html, dashboard.html).

Create the file now.`;

                try {
                    const result = await window.aider.runPrompt(prompt);
                    await this.trackTaskCost(prompt, result?.response || '', 'mvp_creation');
                    
                    await this.loadProjectFiles();
                    await this.autoDetectMainFile();
                    
                    if (this.mainFile) {
                        await this.previewFile(this.mainFile);
                    }
                    
                    this.addMessage('assistant', ` **MVP Created!**

Your minimal viable product is ready in the preview panel.

**Please review it and type "approve"** to finalize setup, or describe any changes needed.`);
                    
                    this.setupWizardAwaitingApproval = true;
                    
                } catch (e) {
                    console.error('[SetupWizard] MVP creation error:', e);
                    this.addMessage('error', `Failed to create MVP: ${e.message}`);
                }
            },
            
            // Handle MVP approval
            async handleMVPApproval(message) {
                const lower = message.toLowerCase().trim();
                
                if (lower === 'approve' || lower === 'approved' || lower === 'yes' || lower === 'ok' || lower === 'looks good') {
                    await this.finishSetup();
                } else {
                    // User wants changes
                    this.addMessage('assistant', `Making changes to the MVP...`);
                    
                    try {
                        const mvpUpdatePrompt = `Update the main HTML file based on this feedback:\n\n${message}`;
                        const mvpResult = await window.aider.runPrompt(mvpUpdatePrompt);
                        await this.trackTaskCost(mvpUpdatePrompt, mvpResult?.response || '', 'mvp_update');
                        await this.loadProjectFiles();
                        
                        if (this.mainFile) {
                            await this.previewFile(this.mainFile);
                        }
                        
                        this.addMessage('assistant', `I've updated the MVP. Please review again.

**Type "approve" to finalize**, or describe more changes.`);
                        
                    } catch (e) {
                        this.addMessage('error', `Failed to update: ${e.message}`);
                    }
                }
                
                return true;
            },
            
            // Finish setup and create todo list
            async finishSetup() {
                this.addMessage('system', ` MVP approved!`);
                this.addMessage('assistant', `Creating todo list for future iterations...`);
                
                // Create todo list
                const todoPrompt = `Create a todo.md file for this project's future development.

Project: ${this.setupWizardData.description}
Current MVP Features: ${this.setupWizardData.keyFeatures}

Include:
1. v2 Features (next iteration)
2. v3 Features (future)
3. Technical debt and improvements
4. Nice-to-have features

Format as Markdown with checkboxes [ ] for each item.`;

                try {
                    const todoResult = await window.aider.runPrompt(todoPrompt);
                    await this.trackTaskCost(todoPrompt, todoResult?.response || '', 'todo_creation');
                    await this.loadProjectFiles();
                } catch (e) {
                    console.log('[SetupWizard] Todo creation error:', e);
                }
                
                // Update unified space metadata with project config
                if (this.currentSpaceId) {
                    try {
                        await window.aider.updateProjectConfig(this.currentSpaceId, {
                            setupComplete: true,
                            setupCompletedAt: new Date().toISOString(),
                            currentVersion: 1,
                            mainFile: this.mainFile,
                            description: this.setupWizardData.description,
                            targetUsers: this.setupWizardData.targetUsers,
                            stylePreference: this.setupWizardData.stylePreference
                        });
                        
                        // Add version to history
                        await window.aider.addVersion(this.currentSpaceId, {
                            description: 'v1 - Initial MVP from setup wizard',
                            mainFile: this.mainFile,
                            assets: Object.keys(this.setupWizardData.approvedAssets)
                        });
                        
                        console.log('[SetupWizard] Space metadata updated');
                    } catch (e) {
                        console.error('[SetupWizard] Failed to update space metadata:', e);
                    }
                }
                
                // Also save local project-config.json for backwards compatibility
                const config = {
                    projectName: this.setupWizardData.projectName,
                    description: this.setupWizardData.description,
                    targetUsers: this.setupWizardData.targetUsers,
                    stylePreference: this.setupWizardData.stylePreference,
                    setupComplete: true,
                    setupCompletedAt: new Date().toISOString(),
                    currentVersion: 1,
                    approvedAssets: this.setupWizardData.approvedAssets
                };
                
                await window.aider.writeFile(
                    this.repoPath + '/project-config.json',
                    JSON.stringify(config, null, 2)
                );
                
                // Save version
                await this.saveVersion('v1 - Initial MVP from setup wizard');
                
                // Complete wizard
                this.setupWizardActive = false;
                this.setupWizardPhase = null;
                this.setupWizardAwaitingApproval = false;
                
                await this.loadProjectFiles();
                
                this.addMessage('assistant', ` **Setup Complete!**

Your project is ready with:
  Journey Map
  Style Guide  
  User Personas
  Requirements
  Evaluation Criteria
  MVP (v1)
  Todo List

**What's next?**
 Start the **Meta Learning Cycle** to iterate and improve
 Or just tell me what changes you'd like to make

You're all set! `);
            },
            
            // Simple AI call for setup suggestions
            async callAIForSetup(prompt) {
                const result = await window.aider.runPrompt(prompt);
                await this.trackTaskCost(prompt, result?.response || '', 'setup_suggestion');
                return result.response || '';
            },
            
            // ========== END SETUP WIZARD ==========
            
            // Store last visual analysis for context
            lastVisualAnalysis: null,
            lastVisualAnalysisTime: null,
            
            // Send Prompt with Streaming
            async sendPrompt() {
                const input = document.getElementById('promptInput');
                const sendBtn = document.getElementById('sendBtn');
                const message = input.value.trim();
                
                if (!message) return;
                
                // Track prompt
                this.trackBehavior('prompt_sent', { 
                    length: message.length, 
                    preview: message.substring(0, 50) 
                });
                
                // Store as last prompt for cycle context
                this.cycleState.lastPrompt = message;
                
                // Check if setup wizard is active
                if (this.setupWizardActive) {
                this.addMessage('user', message);
                input.value = '';
                    const handled = await this.processSetupWizardInput(message);
                    if (handled) return;
                }
                
                // Check if cycle is waiting for objective
                if (this.cycleState.waitingForObjective) {
                    this.cycleState.objective = message;
                    this.cycleState.waitingForObjective = false;
                    this.cycleState.paused = false;
                    this.addMessage('user', message);
                    input.value = '';
                    this.updateCycleUI();
                    
                    // If parallel count > 1, show planning modal for approach selection
                    if (this.cycleState.parallelCount > 1) {
                        await this.showPlanningModal(message);
                    } else {
                        // Resume the research phase with the objective
                        await this.runPhase('research');
                    }
                    return;
                }
                
                this.addMessage('user', message);
                input.value = '';
                
                sendBtn.disabled = true;
                sendBtn.textContent = 'Thinking...';
                
                // Create a streaming message element
                const streamingMsgId = 'streaming-' + Date.now();
                this.addStreamingMessage(streamingMsgId);
                
                // Show HUD for direct prompt
                this.updateHUD({
                    currentPhase: 'Execute',
                    currentTask: message.substring(0, 60) + (message.length > 60 ? '...' : ''),
                    currentAction: 'Processing prompt...',
                    currentFile: null,
                    progress: { current: 1, total: 1 }
                });
                
                try {
                    // Build full message with context
                    let fullMessage = '';
                    
                    // Check if user is asking to implement something and we have recent visual analysis
                    const implementKeywords = ['implement', 'impliment', 'apply', 'make these changes', 'fix these', 'do these', 'add these', 'update based on'];
                    const isImplementRequest = implementKeywords.some(kw => message.toLowerCase().includes(kw));
                    
                    // Include visual analysis if recent (within 5 minutes) and user is asking to implement
                    if (this.lastVisualAnalysis && isImplementRequest) {
                        const analysisAge = Date.now() - this.lastVisualAnalysisTime;
                        if (analysisAge < 5 * 60 * 1000) { // 5 minutes
                            fullMessage += `[Visual Analysis of Current UI - Please implement these improvements]\n${this.lastVisualAnalysis}\n\n`;
                            fullMessage += `[User Request]\n${message}\n\nPlease implement the improvements from the visual analysis above. Focus on the high priority items first.\n\n`;
                        } else {
                            fullMessage += message;
                        }
                    } else {
                        fullMessage += message;
                    }
                    
                    // Add global instructions
                    if (this.globalInstructionsText) {
                        fullMessage = `[Global Instructions]\n${this.globalInstructionsText}\n\n` + fullMessage;
                    }
                    
                    // Add style guide if selected
                    const styleGuideId = document.getElementById('styleGuideSelect').value;
                        if (styleGuideId) {
                        const sg = this.styleGuides.find(s => s.id === styleGuideId);
                        if (sg && sg.content) {
                            fullMessage += `[Style Guide: ${sg.name}]\n${sg.content}\n\n`;
                        }
                    }
                    
                    // Add journey map if selected or evaluated
                    if (this.evaluatedJourneyMap && this.evaluatedJourneyMap.content) {
                        fullMessage += `[Journey Map: ${this.evaluatedJourneyMap.name}]\n${this.evaluatedJourneyMap.content}\n\n`;
                    } else {
                        const journeyMapId = document.getElementById('journeyMapSelect')?.value;
                        if (journeyMapId) {
                            // Try spaceItems first, then legacy journeyMaps
                            const jm = this.spaceItems?.find(j => j.id === journeyMapId) || 
                                       this.journeyMaps?.find(j => j.id === journeyMapId);
                            if (jm && jm.content) {
                                fullMessage += `[Journey Map: ${jm.name || jm.title}]\n${jm.content}\n\n`;
                            }
                        }
                    }
                    
                    fullMessage += message;
                    
                    // Use streaming to show thinking process
                    let lastRefresh = Date.now();
                    let streamedContent = ''; // Accumulate streamed content for token counting
                    
                    const result = await window.aider.runPromptStreaming(
                        fullMessage,
                        (token) => {
                            streamedContent += token; // Accumulate for cost calculation
                            this.appendToStreamingMessage(streamingMsgId, token);
                            
                            // Check for file modification indicators and refresh preview
                            // Refresh every 2 seconds if we're in the middle of edits
                            const now = Date.now();
                            if (now - lastRefresh > 2000) {
                                lastRefresh = now;
                                if (this.currentPreviewFile) {
                                    this.refreshPreview();
                                }
                            }
                        },
                        { include_thinking: true }
                    );
                    
                    // Final refresh after completion
                    if (this.currentPreviewFile) {
                        this.refreshPreview();
                    }
                    
                    // Finalize the streaming message
                    this.finalizeStreamingMessage(streamingMsgId, result);
                    
                    if (result.success) {
                        const fileDetails = result.file_details || [];
                        // Record for version timeline (best-effort)
                        try { this.recordFilesChangedForCurrentVersion(fileDetails); } catch (e) {}
                        
                        // Parse actual token counts and cost from Aider's output
                        const model = document.getElementById('modelSelect').value;
                        let inputTokens = 0;
                        let outputTokens = 0;
                        let actualCost = 0;
                        
                        // Try to parse "Tokens: 15k sent, 2.1k received. Cost: $0.08 message"
                        const tokenMatch = streamedContent.match(/Tokens:\s*([\d.]+)k?\s*sent,\s*([\d.]+)k?\s*received/i);
                        const costMatch = streamedContent.match(/Cost:\s*\$([\d.]+)\s*message/i);
                        
                        if (tokenMatch) {
                            inputTokens = parseFloat(tokenMatch[1]) * (tokenMatch[1].includes('k') || streamedContent.includes('k sent') ? 1000 : 1);
                            outputTokens = parseFloat(tokenMatch[2]) * (tokenMatch[2].includes('k') || streamedContent.includes('k received') ? 1000 : 1);
                            // Handle "15k" format
                            if (streamedContent.match(/[\d.]+k\s*sent/i)) inputTokens = parseFloat(tokenMatch[1]) * 1000;
                            if (streamedContent.match(/[\d.]+k\s*received/i)) outputTokens = parseFloat(tokenMatch[2]) * 1000;
                        }
                        
                        if (costMatch) {
                            actualCost = parseFloat(costMatch[1]);
                        }
                        
                        // Fallback to estimates if parsing failed
                        if (inputTokens === 0) inputTokens = Math.ceil(fullMessage.length / 4);
                        if (outputTokens === 0) outputTokens = Math.ceil(streamedContent.length / 4);
                        
                        console.log('[GSX Create] Parsed tokens - input:', inputTokens, 'output:', outputTokens, 'actual cost:', actualCost);
                        
                        // Use actual cost if available, otherwise calculate
                        await this.recordApiCost(model, inputTokens, outputTokens, 'prompt', message, actualCost);
                        
                        // Register created/modified files
                        for (const file of fileDetails) {
                            try {
                                if (file.action === 'created') {
                                    await window.aider.registerCreatedFile({
                                        spaceId: this.currentSpaceId,
                                        filePath: file.path,
                                        description: file.description || result.summary,
                                        aiModel: model
                                    });
                                } else if (file.action === 'modified') {
                                    await window.aider.updateFileMetadata({
                                        spaceId: this.currentSpaceId,
                                        filePath: file.path,
                                        description: file.description || result.summary
                                    });
                                }
                            } catch (e) {
                                console.error('[GSX Create] File registration error:', e);
                            }
                        }
                        
                        // Refresh files and preview
                        await this.loadProjectFiles();
                        
                        // Auto-preview first HTML file
                        const htmlFile = fileDetails.find(f => f.path && f.path.endsWith('.html'));
                        if (htmlFile) {
                            setTimeout(() => this.previewFile(htmlFile.path), 500);
                        }
                    }
                } catch (error) {
                    console.error('[GSX Create] Prompt error:', error);
                    this.removeStreamingMessage(streamingMsgId);
                    this.addMessage('error', error.message);
                } finally {
                    sendBtn.disabled = false;
                    sendBtn.textContent = 'Send';
                    
                    // Reset HUD after prompt completes
                    if (!this.cycleState?.active) {
                        this.resetHUD();
                    }
                    
                    // Notify any pending fix callbacks
                    if (this.onPromptComplete) {
                        this.onPromptComplete();
                    }
                }
            },
            
            // Callback for fix-one-by-one flow
            pendingFixCallback: null,
            
            // Streaming message helpers
            streamingPhase: '',
            streamingStartTime: null,
            
            addStreamingMessage(id) {
                const messages = document.getElementById('messages');
                const now = new Date();
                const time = now.toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit' });
                
                this.streamingStartTime = Date.now();
                this.streamingPhase = 'thinking';
                
                const msgDiv = document.createElement('div');
                msgDiv.className = 'message';
                msgDiv.id = id;
                msgDiv.innerHTML = `
                    <span class="message-time">${time}</span>
                    <span class="message-type ai">AI</span>
                    <div class="message-content streaming">
                        <div class="streaming-status" id="${id}-status">
                            <span class="status-icon"></span>
                            <span class="status-text">Thinking...</span>
                            <span class="status-timer">0s</span>
                        </div>
                        <pre class="stream-output"></pre>
                    </div>
                `;
                messages.appendChild(msgDiv);
                messages.scrollTop = messages.scrollHeight;
                
                // Start timer update
                this.updateStreamingTimer(id);
            },
            
            updateStreamingTimer(id) {
                const timerEl = document.querySelector(`#${id}-status .status-timer`);
                if (!timerEl || !this.streamingStartTime) return;
                
                const elapsed = Math.floor((Date.now() - this.streamingStartTime) / 1000);
                timerEl.textContent = elapsed + 's';
                
                if (document.getElementById(id)) {
                    setTimeout(() => this.updateStreamingTimer(id), 1000);
                }
            },
            
            updateStreamingStatus(id, phase, icon) {
                const statusEl = document.getElementById(`${id}-status`);
                if (!statusEl) return;
                
                this.streamingPhase = phase;
                statusEl.querySelector('.status-icon').textContent = icon;
                statusEl.querySelector('.status-text').textContent = phase;
            },
            
            // Track if we're inside a code block
            inCodeBlock: false,
            codeBlockContent: '',
            codeBlockCount: 0,
            
            appendToStreamingMessage(id, token) {
                const msgDiv = document.getElementById(id);
                if (!msgDiv) return;
                
                const output = msgDiv.querySelector('.stream-output');
                
                // ROBUST STRING CONVERSION: Handle all edge cases
                let tokenStr = '';
                if (token === null || token === undefined) {
                    return; // Skip null/undefined tokens
                } else if (typeof token === 'string') {
                    tokenStr = token;
                } else if (token instanceof Error) {
                    tokenStr = token.message || String(token);
                } else if (Array.isArray(token)) {
                    // Arrays might come from chunked responses
                    tokenStr = token.map(t => typeof t === 'string' ? t : (t?.content || t?.text || '')).join('');
                } else if (typeof token === 'object') {
                    // Handle streaming API response objects
                    tokenStr = token.content || token.text || token.delta?.content || token.delta?.text || '';
                    // If still empty and it's not a known structure, try JSON (but don't show [object Object])
                    if (!tokenStr && Object.keys(token).length > 0) {
                        try {
                            const json = JSON.stringify(token);
                            // Only use JSON if it's meaningful (not just {})
                            if (json !== '{}' && json !== '[]') {
                                tokenStr = ''; // Skip complex objects in streaming - they're likely metadata
                            }
                        } catch (e) {
                            tokenStr = ''; // Skip circular/complex objects
                        }
                    }
                } else {
                    tokenStr = String(token);
                }
                
                // Skip empty tokens
                if (!tokenStr) return;
                
                // Detect phase changes from the output and update HUD
                if (tokenStr.includes('SEARCH/REPLACE') || tokenStr.includes('<<<<<<')) {
                    this.updateStreamingStatus(id, 'Editing files...', '');
                    this.inCodeBlock = true;
                    this.codeBlockCount++;
                    
                    // Try to extract filename from SEARCH/REPLACE block
                    const fileMatch = tokenStr.match(/(?:<<<<<<< SEARCH|SEARCH\/REPLACE)\s*(?:in\s+)?([^\n]+\.[a-zA-Z]+)/i);
                    if (fileMatch) {
                        this.setHUDAction('Writing code...', fileMatch[1].trim());
                    } else {
                        this.setHUDAction('Writing code...');
                    }
                } else if (tokenStr.includes('Applied edit') || tokenStr.includes('Wrote')) {
                    this.updateStreamingStatus(id, 'Files updated!', '');
                    this.inCodeBlock = false;
                    
                    // Extract filename from "Wrote path/file.ext" or "Applied edit to path/file.ext"
                    const wroteMatch = tokenStr.match(/(?:Wrote|Applied edit to)\s+([^\s\n]+)/);
                    if (wroteMatch) {
                        this.setHUDAction('File saved', wroteMatch[1]);
                        this.addRecentAction(`Updated ${wroteMatch[1].split('/').pop()}`);
                    } else {
                        this.setHUDAction('Files saved');
                    }
                } else if (tokenStr.includes('>>>>>>> REPLACE')) {
                    this.inCodeBlock = false;
                } else if (tokenStr.includes('Tokens:') && tokenStr.includes('Cost:')) {
                    this.updateStreamingStatus(id, 'Complete!', '');
                    this.setHUDAction('Complete!');
                } else if (this.streamingPhase === 'thinking' && output && output.textContent.length > 50) {
                    this.updateStreamingStatus(id, 'Analyzing...', '');
                    this.setHUDAction('Analyzing code...');
                }
                
                // Enhanced pattern detection for HUD
                if (!this.inCodeBlock) {
                    // Detect reading/examining patterns
                    if (tokenStr.match(/(?:Reading|Examining|Looking at|Checking)\s+([^\n]+)/i)) {
                        const match = tokenStr.match(/(?:Reading|Examining|Looking at|Checking)\s+([^\n]+)/i);
                        this.setHUDAction('Reading...', match[1].substring(0, 40));
                    }
                    // Detect creating patterns
                    else if (tokenStr.match(/(?:Creating|Adding|Building|Implementing)\s+([^\n]+)/i)) {
                        const match = tokenStr.match(/(?:Creating|Adding|Building|Implementing)\s+([^\n]+)/i);
                        this.setHUDAction(match[0].substring(0, 50) + '...');
                    }
                    // Detect file paths in output
                    else if (tokenStr.match(/([a-zA-Z0-9_-]+\/)*[a-zA-Z0-9_-]+\.(js|jsx|ts|tsx|html|css|json|md)/)) {
                        const fileMatch = tokenStr.match(/([a-zA-Z0-9_-]+\/)*[a-zA-Z0-9_-]+\.(js|jsx|ts|tsx|html|css|json|md)/);
                        if (fileMatch && !this.activityTracker.currentFile) {
                            this.updateHUD({ currentFile: fileMatch[0] });
                        }
                    }
                }
                
                if (output) {
                    // If we're in a code block, add to collapsed section
                    if (this.inCodeBlock || tokenStr.includes('<<<<<<') || tokenStr.includes('>>>>>>>')) {
                        // Check if we need to create a new collapsible
                        let codeSection = output.querySelector('.code-section-' + this.codeBlockCount);
                        if (!codeSection) {
                            const details = document.createElement('details');
                            details.className = 'code-collapse code-section-' + this.codeBlockCount;
                            details.innerHTML = `<summary> Code change #${this.codeBlockCount} (click to expand)</summary><pre class="collapsed-code"></pre>`;
                            output.appendChild(details);
                            codeSection = details;
                        }
                        const codeContent = codeSection.querySelector('.collapsed-code');
                        if (codeContent) {
                            codeContent.textContent += tokenStr;
                        }
                    } else {
                        // Regular text - append directly
                        output.appendChild(document.createTextNode(tokenStr));
                    }
                    
                    const messages = document.getElementById('messages');
                    messages.scrollTop = messages.scrollHeight;
                }
            },
            
            finalizeStreamingMessage(id, result) {
                const msgDiv = document.getElementById(id);
                if (!msgDiv) return;
                
                // Handle undefined/null result
                const safeResult = result || {};
                
                const content = msgDiv.querySelector('.message-content');
                const statusEl = document.getElementById(`${id}-status`);
                
                // Calculate elapsed time
                const elapsed = this.streamingStartTime ? Math.floor((Date.now() - this.streamingStartTime) / 1000) : 0;
                
                // Update final status
                if (statusEl) {
                    const modifiedCount = safeResult.modified_files ? safeResult.modified_files.length : 0;
                    const fileDetails = safeResult.file_details || [];
                    
                    let summaryText = ' Complete';
                    if (modifiedCount > 0 || fileDetails.length > 0) {
                        const count = modifiedCount || fileDetails.length;
                        summaryText = ` Done! ${count} file(s) modified`;
                    }
                    summaryText += ` (${elapsed}s)`;
                    
                    statusEl.innerHTML = `<span style="color: var(--success); font-weight: 600;">${summaryText}</span>`;
                }
                
                // Add file details if any
                const files = safeResult.modified_files || safeResult.file_details || [];
                if (files.length > 0) {
                    // Record for version timeline (best-effort)
                    try { this.recordFilesChangedForCurrentVersion(files); } catch (e) {}
                    const filesDiv = document.createElement('div');
                    filesDiv.className = 'message-files';
                    filesDiv.style.marginTop = '12px';
                    filesDiv.innerHTML = `
                        <div style="color: var(--success); font-weight: 600; margin-bottom: 8px;"> Modified Files:</div>
                        ${files.map(f => {
                            const path = typeof f === 'string' ? f : (f.path || f.name);
                            const name = path.split('/').pop();
                            const action = f.action || 'modified';
                            return `<div style="padding: 4px 8px; background: var(--bg-primary); border-radius: 4px; margin: 4px 0; display: flex; justify-content: space-between;">
                                <span>${name}</span>
                                <span style="color: var(--text-muted); font-size: 10px;">${action}</span>
                            </div>`;
                        }).join('')}
                    `;
                    content.appendChild(filesDiv);
                }
                
                this.streamingStartTime = null;
            },

            toRepoRelativePath(filePath) {
                if (!filePath || typeof filePath !== 'string') return String(filePath || '');
                if (this.repoPath && filePath.startsWith(this.repoPath)) {
                    const rel = filePath.slice(this.repoPath.length);
                    return rel.startsWith('/') ? rel.slice(1) : rel;
                }
                return filePath;
            },

            normalizeFilesChanged(files) {
                const out = [];
                (files || []).forEach(f => {
                    if (!f) return;
                    if (typeof f === 'string') {
                        out.push(`~ ${this.toRepoRelativePath(f)}`);
                        return;
                    }
                    const action = f.action || 'modified';
                    const path = f.path || f.name || '';
                    if (!path) return;
                    const rel = this.toRepoRelativePath(path);
                    const prefix = action === 'created' ? '+' : (action === 'deleted' ? '-' : '~');
                    out.push(`${prefix} ${rel}`);
                });
                // Dedupe, keep stable
                return Array.from(new Set(out));
            },

            recordFilesChangedForCurrentVersion(files) {
                const version = Number(this.cycleState.currentVersion || 1);
                const entry = this.ensureVersionEntry(version);
                const normalized = this.normalizeFilesChanged(files);
                if (!Array.isArray(entry.filesChanged)) entry.filesChanged = [];
                const merged = new Set([...(entry.filesChanged || []), ...normalized]);
                entry.filesChanged = Array.from(merged);
                // Mark that an update exists for the user to try
                this.previewRefresh.pendingUpdate = true;
                this.showPreviewUpdateBanner('Update available (click Refresh when ready)');
                this.saveCycleState();
            },

            buildTestsSummaryFromEvaluation(evaluation) {
                const summary = evaluation && evaluation.testResults && evaluation.testResults.summary;
                if (!summary) return '';
                const passed = summary.passed ?? 0;
                const failed = summary.failed ?? 0;
                const passRate = summary.passRate ?? null;
                const lines = [
                    `Passed: ${passed}`,
                    `Failed: ${failed}`
                ];
                if (passRate !== null && passRate !== undefined) lines.push(`Pass rate: ${passRate}%`);
                return lines.join('\n');
            },

            async generateReleaseNotesForVersion(entry) {
                // Strict, fact-only release notes
                const facts = {
                    version: entry.version,
                    objective: entry.objective || '',
                    scoreDelta: entry.scoreDelta,
                    costDelta: entry.costDelta,
                    testsSummary: entry.testsSummary || '',
                    filesChanged: Array.isArray(entry.filesChanged) ? entry.filesChanged.slice(0, 50) : []
                };

                // Fallback local summary (guaranteed precise)
                const fallback = [
                    facts.objective ? `- Objective: ${facts.objective}` : null,
                    facts.scoreDelta !== null && facts.scoreDelta !== undefined ? `- Score change: ${facts.scoreDelta}` : null,
                    facts.costDelta !== null && facts.costDelta !== undefined ? `- Cost this version: $${Number(facts.costDelta).toFixed(4)}` : null,
                    facts.testsSummary ? `- Tests: ${facts.testsSummary.replace(/\n/g, '; ')}` : null,
                    facts.filesChanged.length ? `- Files changed (${facts.filesChanged.length}): ${facts.filesChanged.slice(0, 8).join(', ')}${facts.filesChanged.length > 8 ? '' : ''}` : null
                ].filter(Boolean).join('\n');

                try {
                    if (!window.aider || typeof window.aider.runPrompt !== 'function') return fallback;
                    const prompt = `Write release notes as a concise bullet list.\n\nRules:\n- Use ONLY the facts provided below. Do NOT infer or guess.\n- Keep it cumulative and precise.\n- Max 5 bullets.\n\nFACTS (JSON):\n${JSON.stringify(facts, null, 2)}\n\nReturn only bullets.`;
                    const res = await window.aider.runPrompt(prompt);
                    const text = res && res.response && typeof res.response === 'string' ? res.response.trim() : '';
                    return text || fallback;
                } catch (e) {
                    return fallback;
                }
            },
            
            removeStreamingMessage(id) {
                const msgDiv = document.getElementById(id);
                if (msgDiv) msgDiv.remove();
                this.streamingStartTime = null;
            },
            
            // Add Message - routes to the focused branch's chat
            addMessage(type, text, fileDetails = null, allowHtml = false, branchId = null) {
                // Determine which branch to add message to
                const targetBranch = branchId || this.cycleState?.focusedBranch || 'main';
                
                // Find the correct messages container
                let messages = document.getElementById('messages'); // default to main
                if (targetBranch !== 'main') {
                    const branchMessages = document.getElementById(`messages-${targetBranch}`);
                    if (branchMessages) {
                        messages = branchMessages;
                    }
                }
                
                if (!messages) {
                    console.warn('[Chat] No messages container found for branch:', targetBranch);
                    return;
                }
                
                const time = new Date().toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit' });
                
                const typeLabels = {
                    user: 'YOU',
                    ai: 'AI',
                    system: 'SYS',
                    error: 'ERR'
                };
                
                // SAFE STRING CONVERSION: Convert any non-string to displayable string
                let safeText = this.safeStringify(text);
                
                // Format text - handle code blocks BEFORE escaping
                let formattedText;
                if (allowHtml) {
                    formattedText = safeText;
                } else {
                    // Check if text contains code blocks - process them specially
                    if (safeText.includes('```')) {
                        // Split by code blocks, escape non-code parts, format code blocks
                        formattedText = this.formatCodeBlocks(safeText, (t) => this.escapeHtml(t));
                    } else {
                        formattedText = this.escapeHtml(safeText);
                    }
                    // Format inline code
                    formattedText = this.formatInlineCode(formattedText, (t) => this.escapeHtml(t));
                }
                
                // Apply markdown formatting (bold, newlines)
                formattedText = formattedText
                        .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
                        .replace(/\n/g, '<br>');
                
                let html = `
                    <div class="message">
                        <span class="message-time">${time}</span>
                        <span class="message-type ${type}">${typeLabels[type] || type.toUpperCase()}</span>
                        <span class="message-content">${formattedText}`;
                
                if (fileDetails && fileDetails.length > 0) {
                    html += '<div class="message-files">';
                    fileDetails.forEach(f => {
                        html += `<div class="file-change ${f.action}">${f.action === 'created' ? '+' : '~'} ${f.name}</div>`;
                    });
                    html += '</div>';
                }
                
                html += '</span></div>';
                
                messages.insertAdjacentHTML('beforeend', html);
                messages.scrollTop = messages.scrollHeight;
            },
            
            // Add message to a specific branch's chat
            addBranchMessage(branchId, type, text, fileDetails = null, allowHtml = false) {
                this.addMessage(type, text, fileDetails, allowHtml, branchId);
            },
            
            // Preview File
            async previewFile(filePath) {
                if (!filePath) return;
                
                this.trackBehavior('file_preview', { file: filePath.split('/').pop() });
                console.log('[GSX Create] Preview file:', filePath);
                const previewContent = document.getElementById('previewContent');
                const previewTitle = document.getElementById('previewTitle');
                const previewPanel = document.getElementById('previewPanel');
                const previewWelcome = document.getElementById('previewWelcome');
                
                try {
                    const content = await window.aider.readFile(filePath);
                    console.log('[GSX Create] File content length:', content ? content.length : 0);
                    
                    this.currentPreviewFile = filePath;
                    const ext = filePath.split('.').pop().toLowerCase();
                    const fileName = filePath.split('/').pop();
                    
                    // Update title
                    if (previewTitle) previewTitle.textContent = fileName;
                    
                    // Show preview panel
                    if (previewPanel) previewPanel.classList.add('active');
                    
                    // Hide welcome state when showing actual file
                    if (previewWelcome) previewWelcome.style.display = 'none';
                    
                    if (!content) {
                        previewContent.innerHTML = '<div class="preview-empty">File is empty or could not be read</div>';
                        return;
                    }
                    
                    if (ext === 'html' || ext === 'htm') {
                        // Use file:// URL for HTML preview (most reliable in Electron)
                        const iframe = document.createElement('iframe');
                        iframe.id = 'previewIframe';
                        iframe.style.cssText = 'width: 100%; height: 100%; border: none; background: white;';
                        iframe.src = 'file://' + filePath;
                        previewContent.innerHTML = '';
                        previewContent.appendChild(iframe);
                        
                        // Set up activity detection for Smart Testing Mode
                        this.setupPreviewActivityDetection(iframe);
                        
                        console.log('[GSX Create] HTML preview rendered via file:// URL');
                    } else {
                        // Code preview
                        previewContent.innerHTML = '<pre style="padding: 16px; margin: 0; font-size: 12px; background: #1e1e1e; color: #d4d4d4; height: 100%; overflow: auto; white-space: pre-wrap; word-wrap: break-word;">' + this.escapeHtml(content) + '</pre>';
                    }
                    
                    // Start file watcher
                    this.startFileWatcher(filePath);
                } catch (error) {
                    console.error('[GSX Create] Preview error:', error);
                    previewContent.innerHTML = '<div class="preview-empty">Error loading file: ' + error.message + '</div>';
                }
            },
            
            // File Watcher
            async startFileWatcher(filePath) {
                if (this.fileWatcher) {
                    await window.aider.unwatchFile(this.fileWatcher);
                }
                this.fileWatcher = filePath;
                await window.aider.watchFile(filePath);
            },
            
            refreshPreview() {
                // If user is testing, don't auto-refresh - just increment pending updates
                if (this.userTestingState?.isActive) {
                    this.userTestingState.pendingUpdates = (this.userTestingState.pendingUpdates || 0) + 1;
                    this.updateTestingBanner();
                    return;
                }
                if (this.currentPreviewFile) {
                    this.previewFile(this.currentPreviewFile);
                }
            },
            
            // ==================== SMART TESTING MODE ====================
            
            // Called when user interacts with preview iframe
            onPreviewActivity() {
                // Ensure state object exists
                if (!this.userTestingState) {
                    this.userTestingState = { isActive: false, lastActivity: null, pendingUpdates: 0 };
                }
                this.userTestingState.lastActivity = Date.now();
                // Enter testing mode immediately on first interaction
                if (!this.userTestingState.isActive) {
                    this.enterTestingMode();
                }
            },
            
            // Enter testing mode - pause auto-refresh
            enterTestingMode() {
                try {
                    // Ensure state object exists
                    if (!this.userTestingState) {
                        this.userTestingState = { isActive: false, lastActivity: null, pendingUpdates: 0 };
                    }
                    if (this.userTestingState.isActive) return;
                    
                    this.userTestingState.isActive = true;
                    this.userTestingState.pendingUpdates = 0;
                    this.stopAutoRefresh();
                    this.showTestingBanner();
                    
                    console.log('[TestingMode] Entered testing mode');
                    this.addMessage('system', ' Testing mode activated - auto-refresh paused');
                } catch (e) {
                    console.error('[TestingMode] Error entering testing mode:', e);
                }
            },
            
            // Exit testing mode - shows feedback prompt modal
            exitTestingMode() {
                try {
                    // Ensure state object exists
                    if (!this.userTestingState) {
                        this.userTestingState = { isActive: false, lastActivity: null, pendingUpdates: 0 };
                    }
                    
                    // Hide the banner first
                    this.hideTestingBanner();
                    
                    // Show feedback prompt modal (user can submit or skip)
                    this.showFeedbackPromptModal();
                    
                    // Note: Testing state is reset when user submits or skips feedback
                    console.log('[TestingMode] Showing feedback prompt');
                } catch (e) {
                    console.error('[TestingMode] Error exiting testing mode:', e);
                }
            },
            
            // Show testing banner
            showTestingBanner() {
                const banner = document.getElementById('testingBanner');
                if (banner) {
                    banner.classList.remove('hidden');
                    this.updateTestingBanner();
                }
            },
            
            // Hide testing banner
            hideTestingBanner() {
                const banner = document.getElementById('testingBanner');
                if (banner) {
                    banner.classList.add('hidden');
                }
            },
            
            // Update testing banner with pending count
            updateTestingBanner() {
                const countEl = document.getElementById('pendingUpdateCount');
                if (countEl) {
                    countEl.textContent = this.userTestingState.pendingUpdates;
                }
            },
            
            // Show preview update banner (fix for broken call at line 7903)
            showPreviewUpdateBanner(message) {
                // If testing mode is active, just update pending count
                if (this.userTestingState.isActive) {
                    this.userTestingState.pendingUpdates++;
                    this.updateTestingBanner();
                } else {
                    // Show a temporary notification
                    this.addMessage('system', ` ${message}`);
                }
            },
            
            // Called when "Show Latest" button is clicked
            showLatestAndAskFeedback() {
                // Refresh the preview
                if (this.currentPreviewFile) {
                    this.previewFile(this.currentPreviewFile);
                }
                
                // Show feedback prompt modal
                this.showFeedbackPromptModal();
            },
            
            // Show feedback prompt modal after testing
            showFeedbackPromptModal() {
                try {
                    // Ensure queue exists
                    if (!Array.isArray(this.errorFixQueue)) {
                        this.errorFixQueue = [];
                    }
                    
                    // Populate auto-detected errors
                    const errorsContainer = document.getElementById('autoDetectedErrors');
                    if (errorsContainer) {
                        if (this.errorFixQueue.length > 0) {
                            errorsContainer.innerHTML = `
                                <div style="margin-bottom: 8px; font-weight: 500; color: var(--error);">
                                    Auto-detected errors (${this.errorFixQueue.length}):
                                </div>
                                ${this.errorFixQueue.map(err => {
                                    const errText = err?.description || err?.error?.message || 'Unknown error';
                                    const escapedText = this.escapeHtml ? this.escapeHtml(errText) : errText;
                                    const errId = err?.id || 'unknown';
                                    return `
                                        <div class="auto-error-item">
                                            <span class="error-icon"></span>
                                            <span class="error-text">${escapedText}</span>
                                            <button class="queue-fix-btn" onclick="GSXCreate.queueErrorAsTask('${errId}')">Queue Fix</button>
                                        </div>
                                    `;
                                }).join('')}
                            `;
                        } else {
                            errorsContainer.innerHTML = '<div style="color: var(--success);">No errors detected </div>';
                        }
                    }
                    
                    // Clear the input
                    const input = document.getElementById('testingFeedbackInput');
                    if (input) input.value = '';
                    
                    // Show modal
                    const modal = document.getElementById('feedbackPromptModal');
                    if (modal) {
                        modal.classList.add('active');
                    } else {
                        console.warn('[FeedbackPrompt] Modal element not found');
                    }
                } catch (e) {
                    console.error('[FeedbackPrompt] Error showing modal:', e);
                }
            },
            
            // Submit testing feedback
            submitTestingFeedback() {
                try {
                    const input = document.getElementById('testingFeedbackInput');
                    const feedback = input?.value?.trim();
                    
                    if (feedback) {
                        // Add feedback to the unified task queue
                        const task = this.addUserFeedbackTask(feedback);
                        if (task) {
                            const truncated = feedback.length > 50 ? feedback.substring(0, 50) + '...' : feedback;
                            this.addMessage('system', ` Feedback added to task queue: "${truncated}"`);
                        }
                    }
                    
                    // Queue all auto-detected errors as fixes
                    if (Array.isArray(this.errorFixQueue)) {
                        this.errorFixQueue.forEach(err => {
                            if (err && err.status !== 'queued' && err.id) {
                                this.addErrorFixTask(err);
                            }
                        });
                        // Clear the error queue after processing
                        this.errorFixQueue = [];
                    }
                    
                    // Close modal and exit testing mode
                    this.closeModal('feedbackPromptModal');
                    
                    // Reset testing state
                    if (this.userTestingState) {
                        this.userTestingState.isActive = false;
                        this.userTestingState.pendingUpdates = 0;
                    }
                    this.hideTestingBanner();
                    this.startAutoRefresh();
                    
                    console.log('[TestingMode] Exited after feedback submission');
                } catch (e) {
                    console.error('[FeedbackSubmit] Error:', e);
                    this.closeModal('feedbackPromptModal');
                }
            },
            
            // Skip feedback and just resume
            skipTestingFeedback() {
                try {
                    this.closeModal('feedbackPromptModal');
                    
                    // Reset testing state
                    if (this.userTestingState) {
                        this.userTestingState.isActive = false;
                        this.userTestingState.pendingUpdates = 0;
                    }
                    this.hideTestingBanner();
                    this.startAutoRefresh();
                    
                    console.log('[TestingMode] Exited - no feedback');
                } catch (e) {
                    console.error('[FeedbackSkip] Error:', e);
                }
            },
            
            // Stop auto-refresh
            stopAutoRefresh() {
                if (this.autoRefreshInterval) {
                    clearInterval(this.autoRefreshInterval);
                    this.autoRefreshInterval = null;
                }
            },
            
            // Start auto-refresh for preview panel
            startPreviewAutoRefresh() {
                this.stopPreviewAutoRefresh();
                // Auto-refresh every 2 seconds when not in testing mode
                this.previewAutoRefreshInterval = setInterval(() => {
                    if (!this.userTestingState?.isActive && this.currentPreviewFile) {
                        this.previewFile(this.currentPreviewFile);
                    }
                }, 2000);
            },
            
            // Stop preview auto-refresh
            stopPreviewAutoRefresh() {
                if (this.previewAutoRefreshInterval) {
                    clearInterval(this.previewAutoRefreshInterval);
                    this.previewAutoRefreshInterval = null;
                }
            },
            
            // ==================== PREVIEW ACTIVITY DETECTION ====================
            
            // Set up activity detection on preview iframe
            setupPreviewActivityDetection(iframe) {
                if (!iframe) {
                    console.warn('[ActivityDetect] No iframe provided');
                    return;
                }
                
                try {
                    // Listen for messages from iframe (works for same-origin)
                    // Use named function to avoid duplicate listeners
                    const messageHandler = (event) => {
                        if (event.data && event.data.type === 'user_activity') {
                            this.onPreviewActivity();
                        }
                    };
                    
                    // Remove existing listener if any
                    window.removeEventListener('message', this._activityMessageHandler);
                    this._activityMessageHandler = messageHandler;
                    window.addEventListener('message', messageHandler);
                    
                    // Fallback: detect mouse/click on iframe element (works for cross-origin)
                    iframe.addEventListener('mouseenter', () => {
                        // Start tracking - user is hovering over preview
                        console.log('[ActivityDetect] Mouse entered preview');
                    });
                    
                    iframe.addEventListener('click', () => {
                        // User clicked in the preview area
                        this.onPreviewActivity();
                        console.log('[ActivityDetect] Click detected on preview');
                    });
                    
                    // When iframe loads, try to inject activity detection script
                    iframe.addEventListener('load', () => {
                        this.injectActivityDetectionScript(iframe);
                    });
                } catch (e) {
                    console.error('[ActivityDetect] Setup error:', e);
                }
            },
            
            // Inject activity detection script into iframe (same-origin only)
            injectActivityDetectionScript(iframe) {
                try {
                    const iframeDoc = iframe.contentDocument || iframe.contentWindow?.document;
                    if (!iframeDoc) {
                        console.log('[ActivityDetect] Cannot access iframe document (cross-origin)');
                        return;
                    }
                    
                    // Check if script already injected
                    if (iframeDoc.querySelector('#gsx-activity-detector')) {
                        return;
                    }
                    
                    const script = iframeDoc.createElement('script');
                    script.id = 'gsx-activity-detector';
                    script.textContent = `
                        (function() {
                            const activityEvents = ['click', 'keydown', 'scroll', 'input', 'touchstart'];
                            activityEvents.forEach(function(evt) {
                                document.addEventListener(evt, function() {
                                    try {
                                        parent.postMessage({ type: 'user_activity' }, '*');
                                    } catch(e) {}
                                }, { passive: true });
                            });
                            console.log('[GSX] Activity detection injected');
                        })();
                    `;
                    iframeDoc.body.appendChild(script);
                    console.log('[ActivityDetect] Script injected into iframe');
                } catch (e) {
                    // Cross-origin - fallback detection already set up
                    console.log('[ActivityDetect] Cannot inject (cross-origin), using fallback');
                }
            },
            
            togglePreview() {
                document.getElementById('previewPanel').classList.remove('active');
                this.trackBehavior('preview_closed', {});
            },
            
            collapsePreview() {
                const panel = document.getElementById('previewPanel');
                const icon = document.getElementById('previewToggleIcon');
                panel.classList.toggle('collapsed');
                const isCollapsed = panel.classList.contains('collapsed');
                icon.textContent = isCollapsed ? '' : '';
                this.trackBehavior('preview_collapse', { collapsed: isCollapsed });
            },
            
            // ==================== ERROR AUTO-FIX QUEUE (Now uses unified taskQueue) ====================
            
            // Queue an error for auto-fixing
            queueErrorFix(errorInfo) {
                try {
                    if (!errorInfo) return;
                    
                    const errorMessage = errorInfo.error?.message || errorInfo.message || 'Unknown error';
                    
                    // Check for duplicates in unified task queue
                    const exists = this.taskQueue.some(t => 
                        t.type === this.TASK_TYPES.ERROR && 
                        t.text.includes(errorMessage.substring(0, 50))
                    );
                    
                    if (!exists) {
                        // Add to unified task queue
                        this.addErrorFixTask(errorInfo);
                        console.log('[ErrorQueue] Queued error fix:', errorMessage.substring(0, 50));
                    }
                    
                    // Legacy: also add to old errorFixQueue for backward compatibility
                    if (!Array.isArray(this.errorFixQueue)) {
                        this.errorFixQueue = [];
                    }
                    
                    const fixTask = {
                        id: 'fix-' + Date.now(),
                        type: 'auto_fix',
                        description: `Fix error: ${errorMessage}`,
                        error: errorInfo,
                        source: errorInfo.source || 'preview',
                        status: 'pending',
                        timestamp: new Date().toISOString()
                    };
                    
                    const existsInOld = this.errorFixQueue.some(e => 
                        e.description === fixTask.description
                    );
                    if (!existsInOld && this.errorFixQueue.length < 50) {
                        this.errorFixQueue.push(fixTask);
                    }
                } catch (e) {
                    console.error('[ErrorQueue] Error queueing fix:', e);
                }
            },
            
            // Queue a specific error as a task
            queueErrorAsTask(errorId) {
                const error = this.errorFixQueue.find(e => e.id === errorId);
                if (!error) return;
                
                error.status = 'queued';
                
                // Add to feedback queue as a fix task
                this.queueFeedback(`Fix error: ${error.description}`);
            },
            
            // ==================== DEBUG MODE ====================
            
            // Toggle debug mode
            toggleDebugMode() {
                try {
                    // Ensure debugMode object exists
                    if (!this.debugMode) {
                        this.debugMode = { enabled: true, options: {} };
                    }
                    
                    const toggle = document.getElementById('debugModeToggle');
                    this.debugMode.enabled = toggle?.checked ?? !this.debugMode.enabled;
                    
                    const status = this.debugMode.enabled ? 'enabled' : 'disabled';
                    console.log('[DebugMode]', status);
                    this.addMessage('system', ` Debug mode ${status} - AI will ${this.debugMode.enabled ? 'generate verbose logging code' : 'generate normal code'}`);
                } catch (e) {
                    console.error('[DebugMode] Toggle error:', e);
                }
            },
            
            // Get debug mode instructions for AI prompts
            getDebugModeInstructions() {
                if (!this.debugMode?.enabled) return '';
                
                return `
IMPORTANT - DEBUG MODE IS ON. Generate code with comprehensive logging:
1. Add console.log() at function entry/exit with parameters
2. Wrap async operations in try-catch with detailed error logging
3. Add event listeners that log user interactions
4. Use descriptive log prefixes like [DEBUG:FunctionName]

Example pattern:
function handleClick(e) {
    console.log('[DEBUG:handleClick] Called with:', e.target);
    try {
        // ... code
        console.log('[DEBUG:handleClick] Success');
    } catch (err) {
        console.error('[DEBUG:handleClick] Error:', err);
    }
}

`;
            },
            
            // ==================== SMART FEEDBACK QUEUE (Now uses unified taskQueue) ====================
            
            // Queue feedback - adds to unified task queue with smart prioritization
            queueFeedback(message) {
                try {
                    if (!message || typeof message !== 'string' || !message.trim()) {
                        console.warn('[FeedbackQueue] Empty or invalid message');
                        return;
                    }
                    
                    // Use the unified task queue
                    const task = this.addUserFeedbackTask(message.trim());
                    
                    if (task) {
                        // Show confirmation in chat
                        const truncated = message.length > 50 ? message.substring(0, 50) + '...' : message;
                        this.addMessage('system', ` Feedback queued: "${truncated}"`);
                    }
                    
                    // Legacy: also add to old feedbackQueue for backward compatibility
                    if (!Array.isArray(this.feedbackQueue)) {
                        this.feedbackQueue = [];
                    }
                    
                    const feedbackItem = {
                        id: task?.id || 'feedback-' + Date.now(),
                        text: message.trim(),
                        timestamp: new Date().toISOString(),
                        phase: this.cycleState?.currentPhase || null,
                        status: 'pending'
                    };
                    
                    this.feedbackQueue.push(feedbackItem);
                    this.addFeedbackMessage(feedbackItem);
                    this.updateFeedbackPanel();
                } catch (e) {
                    console.error('[FeedbackQueue] Error queueing feedback:', e);
                }
            },
            
            // Inject feedback as an immediate task in the todo list
            injectFeedbackAsTask(feedbackItem) {
                try {
                    if (!feedbackItem || !feedbackItem.text) {
                        console.warn('[FeedbackQueue] Invalid feedback item');
                        return;
                    }
                    
                    const newTask = {
                        task: feedbackItem.text,
                        status: 'pending',
                        feedbackId: feedbackItem.id,
                        isUserFeedback: true
                    };
                    
                    // Ensure todos array exists
                    if (!Array.isArray(this.cycleState?.todos)) {
                        if (!this.cycleState) this.cycleState = {};
                        this.cycleState.todos = [];
                    }
                    
                    const currentIdx = this.cycleState.currentTodoIndex || 0;
                    this.cycleState.todos.splice(currentIdx + 1, 0, newTask);
                    
                    feedbackItem.status = 'queued_as_task';
                    
                    // Ensure queue exists
                    if (!Array.isArray(this.feedbackQueue)) {
                        this.feedbackQueue = [];
                    }
                    this.feedbackQueue.push(feedbackItem);
                    
                    console.log('[FeedbackQueue] Injected as next task:', feedbackItem.text);
                } catch (e) {
                    console.error('[FeedbackQueue] Error injecting task:', e);
                }
            },
            
            // Display feedback in chat with checkbox and actions
            addFeedbackMessage(feedbackItem) {
                const msgHtml = `
                    <div class="feedback-item" id="feedback-msg-${feedbackItem.id}" data-feedback-id="${feedbackItem.id}">
                        <span class="feedback-checkbox" id="checkbox-${feedbackItem.id}"></span>
                        <span class="feedback-text" id="text-${feedbackItem.id}">${this.escapeHtml(feedbackItem.text)}</span>
                        <span class="feedback-status pending" id="status-${feedbackItem.id}">queued</span>
                        <div class="feedback-actions" id="actions-${feedbackItem.id}">
                            <button class="feedback-btn edit" onclick="GSXCreate.editFeedback('${feedbackItem.id}')" title="Edit"></button>
                            <button class="feedback-btn cancel" onclick="GSXCreate.cancelFeedback('${feedbackItem.id}')" title="Cancel"></button>
                        </div>
                    </div>
                `;
                this.addMessage('system', msgHtml, null, true);
            },
            
            // Edit pending feedback
            editFeedback(feedbackId) {
                try {
                    if (!feedbackId || !Array.isArray(this.feedbackQueue)) return;
                    
                    const item = this.feedbackQueue.find(f => f.id === feedbackId);
                    if (!item || (item.status !== 'pending' && item.status !== 'queued_as_task')) {
                        this.addMessage('error', 'Cannot edit - feedback already in progress or completed');
                        return;
                    }
                    
                    // Use prompt for now (could be replaced with a modal)
                    const newText = prompt('Edit your feedback:', item.text || '');
                    if (newText && newText.trim()) {
                        this.updateFeedbackText(feedbackId, newText.trim());
                    }
                } catch (e) {
                    console.error('[Feedback] Edit error:', e);
                }
            },
            
            // Cancel pending feedback
            cancelFeedback(feedbackId) {
                try {
                    if (!feedbackId || !Array.isArray(this.feedbackQueue)) return;
                    
                    const item = this.feedbackQueue.find(f => f.id === feedbackId);
                    if (!item) return;
                    
                    if (item.status === 'in_progress') {
                        this.addMessage('error', 'Cannot cancel - feedback is currently being executed');
                        return;
                    }
                    
                    // Remove from queue
                    this.feedbackQueue = this.feedbackQueue.filter(f => f.id !== feedbackId);
                    
                    // Remove from todos if it was injected
                    if (item.status === 'queued_as_task' && Array.isArray(this.cycleState?.todos)) {
                        this.cycleState.todos = this.cycleState.todos.filter(t => t.feedbackId !== feedbackId);
                    }
                    
                    // Update UI
                    this.updateFeedbackStatus(feedbackId, 'cancelled');
                    this.updateFeedbackPanel();
                    this.addMessage('system', ' Feedback cancelled');
                } catch (e) {
                    console.error('[Feedback] Cancel error:', e);
                }
            },
            
            // Update feedback text
            updateFeedbackText(feedbackId, newText) {
                try {
                    if (!feedbackId || !newText || !Array.isArray(this.feedbackQueue)) return;
                    
                    const item = this.feedbackQueue.find(f => f.id === feedbackId);
                    if (!item) return;
                    
                    item.text = newText;
                    
                    // Update in todos if injected
                    const todo = this.cycleState?.todos?.find(t => t.feedbackId === feedbackId);
                    if (todo) {
                        todo.task = newText;
                    }
                    
                    // Update chat display
                    const textEl = document.getElementById(`text-${feedbackId}`);
                    if (textEl) textEl.textContent = newText;
                    
                    // Update sidebar panel
                    this.updateFeedbackPanel();
                    this.addMessage('system', ' Feedback updated');
                } catch (e) {
                    console.error('[Feedback] Update text error:', e);
                }
            },
            
            // Update feedback status (checkbox and badge)
            updateFeedbackStatus(feedbackId, newStatus) {
                try {
                    if (!feedbackId || !newStatus) return;
                    
                    if (Array.isArray(this.feedbackQueue)) {
                        const item = this.feedbackQueue.find(f => f.id === feedbackId);
                        if (item) item.status = newStatus;
                    }
                    
                    const checkbox = document.getElementById(`checkbox-${feedbackId}`);
                    const statusEl = document.getElementById(`status-${feedbackId}`);
                    const actionsEl = document.getElementById(`actions-${feedbackId}`);
                    const msgEl = document.getElementById(`feedback-msg-${feedbackId}`);
                    
                    if (newStatus === 'completed') {
                        if (checkbox) { checkbox.textContent = ''; checkbox.classList.add('completed'); }
                        if (statusEl) { statusEl.textContent = 'completed'; statusEl.className = 'feedback-status completed'; }
                        if (actionsEl) actionsEl.style.display = 'none';
                        if (msgEl) msgEl.classList.add('completed');
                        // Notify user their feedback was implemented
                        const item = Array.isArray(this.feedbackQueue) ? this.feedbackQueue.find(f => f.id === feedbackId) : null;
                        if (item?.text) {
                            const truncated = item.text.length > 40 ? item.text.substring(0, 40) + '...' : item.text;
                            this.addMessage('system', ` Feedback complete: "${truncated}"`);
                        }
                    } else if (newStatus === 'in_progress') {
                        if (checkbox) checkbox.textContent = '';
                        if (statusEl) { statusEl.textContent = 'in progress...'; statusEl.className = 'feedback-status in-progress'; }
                        if (actionsEl) actionsEl.style.display = 'none';
                    } else if (newStatus === 'cancelled') {
                        if (checkbox) { checkbox.textContent = ''; checkbox.classList.add('cancelled'); }
                        if (statusEl) { statusEl.textContent = 'cancelled'; statusEl.className = 'feedback-status cancelled'; }
                        if (actionsEl) actionsEl.style.display = 'none';
                        if (msgEl) msgEl.classList.add('cancelled');
                    }
                    
                    this.updateFeedbackPanel();
                } catch (e) {
                    console.error('[Feedback] Update status error:', e);
                }
            },
            
            // Get checkbox icon for status
            getCheckboxIcon(status) {
                switch (status) {
                    case 'completed': return '';
                    case 'in_progress': return '';
                    case 'cancelled': return '';
                    default: return '';
                }
            },
            
            // Update feedback panel in sidebar
            updateFeedbackPanel() {
                try {
                    const body = document.getElementById('feedbackPanelBody');
                    const count = document.getElementById('feedbackCount');
                    if (!body) return;
                    
                    // Ensure queue exists
                    if (!Array.isArray(this.feedbackQueue)) {
                        this.feedbackQueue = [];
                    }
                    
                    const pending = this.feedbackQueue.filter(f => f.status === 'pending' || f.status === 'queued_as_task');
                    if (count) count.textContent = pending.length;
                    
                    if (this.feedbackQueue.length === 0) {
                        body.innerHTML = '<div class="no-feedback">No feedback items. Submit feedback after testing.</div>';
                        return;
                    }
                    
                    body.innerHTML = this.feedbackQueue.map(item => {
                        const text = item.text || '';
                        const truncated = text.length > 50 ? text.substring(0, 50) + '...' : text;
                        const escapedText = this.escapeHtml ? this.escapeHtml(truncated) : truncated;
                        const status = item.status || 'pending';
                        const id = item.id || '';
                        
                        return `
                            <div class="panel-feedback-item ${status}">
                                <span class="panel-checkbox">${this.getCheckboxIcon(status)}</span>
                                <span class="panel-text">${escapedText}</span>
                                ${status === 'pending' || status === 'queued_as_task' ? `
                                    <div class="panel-actions">
                                        <button onclick="GSXCreate.editFeedback('${id}')">Edit</button>
                                        <button onclick="GSXCreate.cancelFeedback('${id}')">Cancel</button>
                                    </div>
                                ` : `<span class="panel-status">${status}</span>`}
                            </div>
                        `;
                    }).join('');
                } catch (e) {
                    console.error('[FeedbackPanel] Update error:', e);
                }
            },
            
            // Toggle feedback panel collapse (DEPRECATED)
            toggleFeedbackPanel() {
                const body = document.getElementById('feedbackPanelBody');
                const toggle = document.getElementById('feedbackPanelToggle');
                if (body && toggle) {
                    const isHidden = body.style.display === 'none';
                    body.style.display = isHidden ? 'block' : 'none';
                    toggle.textContent = isHidden ? '' : '';
                }
            },
            
            // ==================== UNIFIED TASK QUEUE SYSTEM ====================
            // The heart of the system - all tasks flow through here
            
            // Show quick add input
            showQuickAddInput() {
                const container = document.getElementById('taskQuickAddContainer');
                const input = document.getElementById('taskQuickAddInput');
                if (container) {
                    container.classList.remove('hidden');
                    if (input) {
                        input.focus();
                        input.value = '';
                    }
                }
            },
            
            // Hide quick add input
            hideQuickAddInput() {
                const container = document.getElementById('taskQuickAddContainer');
                if (container) {
                    container.classList.add('hidden');
                }
            },
            
            // Submit quick add task
            submitQuickAdd() {
                const input = document.getElementById('taskQuickAddInput');
                const text = input?.value?.trim();
                
                if (text) {
                    this.addTask(this.TASK_TYPES.USER, text, { source: 'quick_add' });
                    this.addMessage('system', ` Task added: "${text.substring(0, 50)}${text.length > 50 ? '...' : ''}"`);
                }
                
                this.hideQuickAddInput();
            },
            
            // Add a task to the queue with smart prioritization
            addTask(type, text, context = {}) {
                try {
                    if (!text || typeof text !== 'string' || !text.trim()) {
                        console.warn('[TaskQueue] Empty or invalid task text');
                        return null;
                    }
                    
                    const task = {
                        id: 'task-' + Date.now() + '-' + Math.random().toString(36).substr(2, 5),
                        text: text.trim(),
                        type: type || this.TASK_TYPES.BUILD,
                        status: 'pending',
                        priority: this.calculatePriority(type, context),
                        duration: null,
                        createdAt: Date.now(),
                        completedAt: null,
                        isOptimizing: false,  // Flag for LLM optimization in progress
                        context: {
                            phase: this.cycleState?.currentPhase || null,
                            relatedFiles: context.relatedFiles || [],
                            dependencies: context.dependencies || [],
                            source: context.source || 'system',
                            ...context
                        }
                    };
                    
                    // STEP 1: Instant insertion using rules (fast, ~0ms)
                    const insertIndex = this.findOptimalInsertIndex(task);
                    this.taskQueue.splice(insertIndex, 0, task);
                    
                    // Update stats
                    this.queueStats.total = this.taskQueue.length;
                    
                    // Update UI immediately
                    this.renderTaskQueue();
                    
                    // Play add sound for user-initiated tasks
                    const isUserTask = task.context?.source === 'quick_add' || 
                                       task.context?.source === 'user_feedback' ||
                                       type === this.TASK_TYPES.USER;
                    if (isUserTask) {
                        this.playTaskSound('add');
                        
                        // STEP 2: Background LLM re-prioritization (async, ~2-3s)
                        this.optimizeTaskPositionWithAI(task);
                    }
                    
                    console.log('[TaskQueue] Added task:', task.text.substring(0, 50), 'at index:', insertIndex);
                    return task;
                } catch (e) {
                    console.error('[TaskQueue] Error adding task:', e);
                    return null;
                }
            },
            
            // Background LLM prioritization - runs async, repositions if needed
            async optimizeTaskPositionWithAI(task) {
                // Don't optimize if queue is too small or task already running
                const pendingTasks = this.taskQueue.filter(t => t.status === 'pending' && t.id !== task.id);
                if (pendingTasks.length < 2) return;
                
                try {
                    task.isOptimizing = true;
                    this.renderTaskQueue();  // Show optimizing indicator
                    
                    // Build context for LLM
                    const taskList = pendingTasks.map((t, i) => `${i + 1}. ${t.text}`).join('\n');
                    const objective = this.cycleState?.objective || 'the current project';
                    
                    const prompt = `You are a task prioritization assistant. Given the current pending tasks for "${objective}":

${taskList}

A user just added this new task:
"${task.text}"

Where should it be inserted to maintain logical flow? Consider:
- Dependencies (what needs to happen first?)
- Efficiency (group related work together)
- User intent (this was explicitly requested)

Reply with ONLY a number (1-${pendingTasks.length + 1}) indicating the position.
1 = first (highest priority), ${pendingTasks.length + 1} = last.
If unsure, reply with the middle position.`;

                    // Call LLM (use evaluate for quick response)
                    const result = await window.aider.evaluate({
                        systemPrompt: 'You are a task prioritization assistant. Reply with only a single number.',
                        userPrompt: prompt,
                        maxTokens: 10
                    });
                    
                    // Parse response
                    const suggestedPosition = parseInt(result?.trim());
                    
                    if (!isNaN(suggestedPosition) && suggestedPosition >= 1 && suggestedPosition <= pendingTasks.length + 1) {
                        // Calculate actual index in queue (accounting for completed/running tasks)
                        const currentIndex = this.taskQueue.findIndex(t => t.id === task.id);
                        const firstPendingIndex = this.taskQueue.findIndex(t => t.status === 'pending');
                        const targetIndex = firstPendingIndex + suggestedPosition - 1;
                        
                        // Only move if position is different
                        if (currentIndex !== targetIndex && task.status === 'pending') {
                            // Remove from current position
                            this.taskQueue.splice(currentIndex, 1);
                            // Insert at new position (adjust if needed after removal)
                            const adjustedTarget = targetIndex > currentIndex ? targetIndex - 1 : targetIndex;
                            this.taskQueue.splice(adjustedTarget, 0, task);
                            
                            console.log('[TaskQueue] AI repositioned task from', currentIndex, 'to', adjustedTarget);
                        }
                    }
                    
                } catch (e) {
                    console.log('[TaskQueue] AI optimization skipped:', e.message);
                } finally {
                    task.isOptimizing = false;
                    this.renderTaskQueue();
                }
            },
            
            // Calculate priority based on task type and context
            calculatePriority(type, context) {
                const basePriorities = {
                    [this.TASK_TYPES.EVALUATE]: 10,
                    [this.TASK_TYPES.RESEARCH]: 20,
                    [this.TASK_TYPES.PLAN]: 30,
                    [this.TASK_TYPES.DESIGN]: 40,
                    [this.TASK_TYPES.BUILD]: 50,
                    [this.TASK_TYPES.TEST]: 70,
                    [this.TASK_TYPES.IMPROVE]: 80,
                    [this.TASK_TYPES.USER]: 55,  // User tasks get priority similar to build
                    [this.TASK_TYPES.ERROR]: 45  // Errors fixed before more building
                };
                return basePriorities[type] || 50;
            },
            
            // Find optimal insertion point for a new task
            findOptimalInsertIndex(newTask) {
                // Find first task with higher priority (lower number = higher priority)
                // Insert before tasks with lower priority
                
                // First, skip all completed tasks
                let startIndex = 0;
                while (startIndex < this.taskQueue.length && 
                       this.taskQueue[startIndex].status === 'completed') {
                    startIndex++;
                }
                
                // Don't insert before the currently running task
                if (startIndex < this.taskQueue.length && 
                    this.taskQueue[startIndex].status === 'running') {
                    startIndex++;
                }
                
                // Now find position based on priority and type grouping
                for (let i = startIndex; i < this.taskQueue.length; i++) {
                    const existingTask = this.taskQueue[i];
                    
                    // Skip completed/running tasks
                    if (existingTask.status !== 'pending') continue;
                    
                    // Group user tasks with similar build tasks
                    if (newTask.type === this.TASK_TYPES.USER) {
                        // Insert user tasks after current build tasks but before tests
                        if (existingTask.type === this.TASK_TYPES.TEST || 
                            existingTask.type === this.TASK_TYPES.IMPROVE) {
                            return i;
                        }
                    }
                    
                    // Insert error fixes early
                    if (newTask.type === this.TASK_TYPES.ERROR) {
                        if (existingTask.priority > 45) {
                            return i;
                        }
                    }
                    
                    // Default: insert based on priority
                    if (existingTask.priority > newTask.priority) {
                        return i;
                    }
                }
                
                // Append at end
                return this.taskQueue.length;
            },
            
            // Get the next executable task (respects dependencies)
            getNextTask() {
                for (const task of this.taskQueue) {
                    if (task.status !== 'pending') continue;
                    
                    // Check dependencies
                    const deps = task.context?.dependencies || [];
                    const allDepsComplete = deps.every(depId => {
                        const depTask = this.taskQueue.find(t => t.id === depId);
                        return depTask && depTask.status === 'completed';
                    });
                    
                    if (allDepsComplete) {
                        return task;
                    }
                }
                return null;
            },
            
            // Main executor loop - processes tasks until queue is empty
            async runQueue() {
                console.log('[TaskQueue] Starting queue execution');
                this.queueStats.startTime = Date.now();
                
                while (true) {
                    // Check if cycle is paused or stopped
                    if (!this.cycleState.active) {
                        console.log('[TaskQueue] Cycle stopped, exiting queue');
                        break;
                    }
                    
                    if (this.cycleState.paused) {
                        console.log('[TaskQueue] Cycle paused, waiting...');
                        await new Promise(r => setTimeout(r, 500));
                        continue;
                    }
                    
                    // Get next task
                    const task = this.getNextTask();
                    if (!task) {
                        console.log('[TaskQueue] No more tasks, queue complete');
                        break;
                    }
                    
                    // Execute task
                    await this.executeQueueTask(task);
                    
                    // Brief pause between tasks
                    await new Promise(r => setTimeout(r, 300));
                }
                
                // Queue complete
                this.onQueueComplete();
            },
            
            // Execute a single task from the queue
            async executeQueueTask(task) {
                const startTime = Date.now();
                
                try {
                    // Mark as running
                    task.status = 'running';
                    this.currentTaskId = task.id;
                    this.renderTaskQueue();
                    
                    console.log('[TaskQueue] Executing:', task.text.substring(0, 60));
                    this.addMessage('system', ` ${task.text.substring(0, 80)}${task.text.length > 80 ? '...' : ''}`);
                    
                    // Update HUD with current task
                    const completed = this.taskQueue.filter(t => t.status === 'completed').length;
                    this.setHUDTask(task.text, completed + 1, this.taskQueue.length);
                    
                    // Set consciousness to thinking
                    this.setConsciousnessThinking?.(true);
                    
                    // Execute based on task type
                    await this.executeTaskByType(task);
                    
                    // Mark as completed
                    task.status = 'completed';
                    task.completedAt = Date.now();
                    task.duration = Math.round((task.completedAt - startTime) / 1000);
                    
                    // Update stats
                    this.queueStats.completed++;
                    this.updateQueueStats();
                    
                    // Animate completion
                    this.animateTaskComplete(task.id);
                    
                    // Update HUD with completed task
                    this.completeHUDTask(task.text.substring(0, 40));
                    
                    console.log('[TaskQueue] Completed:', task.text.substring(0, 40), 'in', task.duration, 's');
                    
                } catch (e) {
                    console.error('[TaskQueue] Task failed:', e);
                    task.status = 'completed';  // Mark as complete anyway to continue
                    task.completedAt = Date.now();
                    task.error = e.message;
                    this.addMessage('error', `Task failed: ${e.message}`);
                } finally {
                    this.currentTaskId = null;
                    this.setConsciousnessThinking?.(false);
                    this.renderTaskQueue();
                }
            },
            
            // Execute task based on its type
            async executeTaskByType(task) {
                
                switch (task.type) {
                    case this.TASK_TYPES.EVALUATE:
                        await this.executeEvaluateTask(task);
                        break;
                    case this.TASK_TYPES.RESEARCH:
                        await this.executeResearchTask(task);
                        break;
                    case this.TASK_TYPES.PLAN:
                        await this.executePlanTask(task);
                        break;
                    case this.TASK_TYPES.DESIGN:
                        await this.executeDesignTask(task);
                        break;
                    case this.TASK_TYPES.BUILD:
                    case this.TASK_TYPES.USER:
                    case this.TASK_TYPES.ERROR:
                    case this.TASK_TYPES.IMPROVE:
                        await this.executeBuildTask(task);
                        break;
                    case this.TASK_TYPES.TEST:
                        await this.executeTestTask(task);
                        break;
                    default:
                        await this.executeBuildTask(task);
                }
            },
            
            // Execute evaluate task
            async executeEvaluateTask(task) {
                // Run a simple evaluation prompt
                const evalPrompt = `Evaluate the current state of the project for: ${task.text}
                    
                    Check for:
                    1. Code quality and structure
                    2. UI/UX issues
                    3. Missing functionality
                    4. Bugs or errors
                    
                    Provide a brief assessment and list any issues found.`;
                    
                await this.executeTask(evalPrompt);
            },
            
            // Execute research task
            async executeResearchTask(task) {
                // Research is typically informational - might update constitutional memory
                const prompt = `Research and document: ${task.text}. 
                    Provide key insights and best practices.
                    Focus on practical implementation guidance.`;
                    
                await this.executeTask(prompt);
            },
            
            // Execute plan task - this generates build tasks
            async executePlanTask(task) {
                const objective = this.cycleState.objective || task.text;
                
                // Generate a detailed plan
                const planPrompt = `Create a detailed implementation plan for: ${objective}
                    
                    Output a numbered list of specific, actionable tasks.
                    Each task should be one discrete piece of work.
                    Format: 1. [Task description]`;
                    
                await this.executeTask(planPrompt);
                
                // The plan output will be visible in chat, but we also need to add build tasks
                // For now, add generic build tasks based on objective
                this.addTask(this.TASK_TYPES.BUILD, `Implement: ${objective}`, { source: 'plan' });
                this.addTestTasks();
            },
            
            // Execute design task
            async executeDesignTask(task) {
                // Design tasks may generate mockups or style decisions
                const designPrompt = `Design task: ${task.text}
                    Create the necessary design elements, styles, or mockups.`;
                    
                await this.executeTask(designPrompt);
            },
            
            // Execute build task (also handles user, error, improve)
            async executeBuildTask(task) {
                const prompt = this.buildTaskPrompt(task);
                await this.executeTask(prompt);
            },
            
            // Build prompt for a task
            buildTaskPrompt(task) {
                let prompt = task.text;
                
                // Add debug mode instructions if enabled
                if (this.debugMode?.enabled) {
                    prompt += '\n\nInclude verbose console.log statements for debugging.';
                }
                
                // Add context from constitutional memory
                if (this.constitutionalMemory?.styleGuide) {
                    prompt += `\n\nFollow this style guide: ${this.constitutionalMemory.styleGuide.substring(0, 500)}`;
                }
                
                return prompt;
            },
            
            // Execute test task
            async executeTestTask(task) {
                // Run a test/verification prompt
                const testPrompt = `Test and verify the implementation: ${task.text}
                    
                    Check that:
                    1. The feature works as expected
                    2. There are no console errors
                    3. The UI renders correctly
                    4. Edge cases are handled
                    
                    Fix any issues you find.`;
                    
                await this.executeTask(testPrompt);
            },
            
            // Called when queue is complete
            onQueueComplete() {
                const duration = this.queueStats.startTime 
                    ? Math.round((Date.now() - this.queueStats.startTime) / 1000)
                    : 0;
                    
                this.addMessage('system', ` All tasks complete! (${this.queueStats.completed} tasks in ${this.formatDuration(duration)})`);
                
                // Reset HUD when queue completes
                this.resetHUD();
                
                // Optionally start a new cycle if in auto mode
                if (this.cycleState.autoCycle) {
                    this.addMessage('system', ' Auto-cycle enabled, evaluating for next iteration...');
                    this.addTask(this.TASK_TYPES.EVALUATE, 'Evaluate current state and determine if improvements needed');
                    this.runQueue();
                }
            },
            
            // Animate task completion
            animateTaskComplete(taskId) {
                const taskEl = document.querySelector(`[data-task-id="${taskId}"]`);
                if (taskEl) {
                    taskEl.classList.add('completing');
                    
                    // Play satisfying completion sound
                    this.playTaskSound('complete');
                    
                    setTimeout(() => {
                        taskEl.classList.remove('completing');
                        this.renderTaskQueue();
                    }, 500);
                }
            },
            
            // Update queue statistics
            updateQueueStats() {
                const completed = this.taskQueue.filter(t => t.status === 'completed').length;
                const total = this.taskQueue.length;
                const pending = total - completed;
                
                this.queueStats.completed = completed;
                this.queueStats.total = total;
                
                // Calculate progress percentage
                const progress = total > 0 ? Math.round((completed / total) * 100) : 0;
                
                // Estimate remaining time based on average task duration
                const completedTasks = this.taskQueue.filter(t => t.status === 'completed' && t.duration);
                const avgDuration = completedTasks.length > 0
                    ? completedTasks.reduce((sum, t) => sum + t.duration, 0) / completedTasks.length
                    : 60;  // Default 60 seconds
                this.queueStats.estimatedRemaining = Math.round(pending * avgDuration);
                
                // Update UI
                const progressBar = document.getElementById('taskQueueProgressBar');
                const progressText = document.getElementById('taskQueueProgressText');
                const countEl = document.getElementById('taskQueueCount');
                const completedEl = document.getElementById('taskStatCompleted');
                const remainingEl = document.getElementById('taskStatRemaining');
                const timeEl = document.getElementById('taskStatTime');
                
                if (progressBar) progressBar.style.width = `${progress}%`;
                if (progressText) progressText.textContent = `${progress}%`;
                if (countEl) countEl.textContent = pending;
                if (completedEl) completedEl.textContent = completed;
                if (remainingEl) remainingEl.textContent = pending;
                if (timeEl) timeEl.textContent = this.formatDuration(this.queueStats.estimatedRemaining);
            },
            
            // Format duration in seconds to human readable
            formatDuration(seconds) {
                if (seconds < 60) return `${seconds}s`;
                if (seconds < 3600) return `${Math.round(seconds / 60)} min`;
                return `${Math.round(seconds / 3600)}h`;
            },
            
            // Render the task queue UI
            renderTaskQueue() {
                const listEl = document.getElementById('taskQueueList');
                if (!listEl) return;
                
                if (this.taskQueue.length === 0) {
                    listEl.innerHTML = `
                        <div class="task-queue-empty">
                            <div class="empty-icon"></div>
                            <div>No tasks yet</div>
                            <div class="empty-hint">Start a cycle or click [+] to add a task</div>
                        </div>
                    `;
                    this.updateQueueStats();
                    return;
                }
                
                // Calculate average duration for estimates
                const completedTasks = this.taskQueue.filter(t => t.status === 'completed' && t.duration);
                const avgDuration = completedTasks.length > 0
                    ? Math.round(completedTasks.reduce((sum, t) => sum + t.duration, 0) / completedTasks.length)
                    : 45;
                
                listEl.innerHTML = this.taskQueue.map((task, index) => {
                    const isRunning = task.status === 'running';
                    const isCompleted = task.status === 'completed';
                    const isPending = task.status === 'pending';
                    const isUserTask = task.type === this.TASK_TYPES.USER;
                    const isErrorTask = task.type === this.TASK_TYPES.ERROR;
                    const isOptimizing = task.isOptimizing;
                    
                    const dotClass = isRunning ? 'running' : (isCompleted ? 'completed' : 
                                    (isOptimizing ? 'optimizing' :
                                    (isUserTask ? 'user pending' : (isErrorTask ? 'error pending' : 'pending'))));
                    
                    const itemClass = isRunning ? 'current' : (isCompleted ? 'completed' : (isOptimizing ? 'optimizing' : ''));
                    
                    // Truncate text for display, full text in tooltip
                    const displayText = task.text.length > 45 ? task.text.substring(0, 45) + '...' : task.text;
                    const fullText = this.escapeHtml(task.text);
                    
                    // Find index among pending tasks for reorder buttons
                    const pendingTasks = this.taskQueue.filter(t => t.status === 'pending');
                    const pendingIndex = pendingTasks.findIndex(t => t.id === task.id);
                    const canMoveUp = isPending && !isOptimizing && pendingIndex > 0;
                    const canMoveDown = isPending && !isOptimizing && pendingIndex < pendingTasks.length - 1;
                    
                    return `
                        <div class="task-item ${itemClass}" data-task-id="${task.id}" title="${fullText}">
                            <div class="task-dot ${dotClass}"></div>
                            <div class="task-content">
                                <div class="task-text">${this.escapeHtml(displayText)}</div>
                                <div class="task-meta">
                                    ${isUserTask ? '<span class="task-type-badge user">user</span>' : ''}
                                    ${isErrorTask ? '<span class="task-type-badge error">fix</span>' : ''}
                                    ${isOptimizing ? '<span class="task-optimizing"> prioritizing...</span>' : ''}
                                    ${isCompleted && task.duration ? `<span class="task-duration">${task.duration}s</span>` : ''}
                                    ${isPending && !isOptimizing ? `<span class="task-estimate">~${avgDuration}s</span>` : ''}
                                    ${isRunning ? '<span class="task-running-text">running...</span>' : ''}
                                </div>
                            </div>
                            <div class="task-actions">
                                ${isRunning ? `
                                    <button class="task-action-btn pause" onclick="GSXCreate.pauseCycle()" title="Pause"></button>
                                ` : ''}
                                ${isPending ? `
                                    ${canMoveUp ? `<button class="task-action-btn move" onclick="GSXCreate.moveTaskUp('${task.id}')" title="Move up"></button>` : ''}
                                    ${canMoveDown ? `<button class="task-action-btn move" onclick="GSXCreate.moveTaskDown('${task.id}')" title="Move down"></button>` : ''}
                                    <button class="task-action-btn cancel" onclick="GSXCreate.cancelTask('${task.id}')" title="Cancel"></button>
                                ` : ''}
                            </div>
                        </div>
                    `;
                }).join('');
                
                this.updateQueueStats();
                
                // Persist task queue to storage
                this.saveTaskQueue();
            },
            
            // Cancel a pending task
            cancelTask(taskId) {
                const index = this.taskQueue.findIndex(t => t.id === taskId);
                if (index === -1) return;
                
                const task = this.taskQueue[index];
                if (task.status !== 'pending') {
                    this.addMessage('warning', 'Can only cancel pending tasks');
                    return;
                }
                
                // Remove from queue
                this.taskQueue.splice(index, 1);
                this.queueStats.total = this.taskQueue.length;
                
                // Play cancel sound
                this.playTaskSound('cancel');
                
                this.renderTaskQueue();
                this.addMessage('system', ` Cancelled: "${task.text.substring(0, 40)}..."`);
            },
            
            // Move a task up in priority
            moveTaskUp(taskId) {
                const pendingTasks = this.taskQueue.filter(t => t.status === 'pending');
                const pendingIndex = pendingTasks.findIndex(t => t.id === taskId);
                
                if (pendingIndex <= 0) return;
                
                // Find actual indices in main queue
                const currentIndex = this.taskQueue.findIndex(t => t.id === taskId);
                const targetId = pendingTasks[pendingIndex - 1].id;
                const targetIndex = this.taskQueue.findIndex(t => t.id === targetId);
                
                // Swap
                [this.taskQueue[currentIndex], this.taskQueue[targetIndex]] = 
                [this.taskQueue[targetIndex], this.taskQueue[currentIndex]];
                
                this.renderTaskQueue();
            },
            
            // Move a task down in priority
            moveTaskDown(taskId) {
                const pendingTasks = this.taskQueue.filter(t => t.status === 'pending');
                const pendingIndex = pendingTasks.findIndex(t => t.id === taskId);
                
                if (pendingIndex >= pendingTasks.length - 1) return;
                
                // Find actual indices in main queue
                const currentIndex = this.taskQueue.findIndex(t => t.id === taskId);
                const targetId = pendingTasks[pendingIndex + 1].id;
                const targetIndex = this.taskQueue.findIndex(t => t.id === targetId);
                
                // Swap
                [this.taskQueue[currentIndex], this.taskQueue[targetIndex]] = 
                [this.taskQueue[targetIndex], this.taskQueue[currentIndex]];
                
                this.renderTaskQueue();
            },
            
            // Play task-related sounds
            playTaskSound(type) {
                try {
                    if (!this.consciousnessAudio) {
                        this.consciousnessAudio = this.initConsciousnessAudio?.() || null;
                    }
                    if (!this.consciousnessAudio?.ctx) return;
                    
                    const ctx = this.consciousnessAudio.ctx;
                    const now = ctx.currentTime;
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    
                    switch(type) {
                        case 'complete':
                            // Satisfying completion ding
                            osc.type = 'sine';
                            osc.frequency.setValueAtTime(880, now);
                            osc.frequency.setValueAtTime(1108, now + 0.1);
                            gain.gain.setValueAtTime(0.1, now);
                            gain.gain.linearRampToValueAtTime(0, now + 0.3);
                            osc.start(now);
                            osc.stop(now + 0.3);
                            break;
                        case 'cancel':
                            // Soft thud
                            osc.type = 'sine';
                            osc.frequency.setValueAtTime(200, now);
                            gain.gain.setValueAtTime(0.05, now);
                            gain.gain.linearRampToValueAtTime(0, now + 0.15);
                            osc.start(now);
                            osc.stop(now + 0.15);
                            break;
                        case 'add':
                            // Quick blip
                            osc.type = 'sine';
                            osc.frequency.setValueAtTime(660, now);
                            gain.gain.setValueAtTime(0.06, now);
                            gain.gain.linearRampToValueAtTime(0, now + 0.1);
                            osc.start(now);
                            osc.stop(now + 0.1);
                            break;
                    }
                } catch (e) {
                    // Audio not available, silent fail
                }
            },
            
            // Expand a plan response into individual build tasks
            expandPlanToTasks(planText) {
                // Parse numbered list from plan
                const lines = planText.split('\n');
                const taskLines = lines.filter(line => /^\d+[\.\)]\s/.test(line.trim()));
                
                taskLines.forEach(line => {
                    const taskText = line.replace(/^\d+[\.\)]\s*/, '').trim();
                    if (taskText.length > 5) {  // Skip very short lines
                        this.addTask(this.TASK_TYPES.BUILD, taskText, { source: 'plan' });
                    }
                });
                
                // Add test task at the end
                this.addTestTasks();
            },
            
            // Seed initial tasks when cycle starts
            seedInitialTasks(objective) {
                console.log('[TaskQueue] Seeding initial tasks for:', objective);
                
                // Clear any existing tasks
                this.clearTaskQueue();
                
                // Add initial evaluation/planning tasks
                this.addTask(this.TASK_TYPES.EVALUATE, 
                    `Evaluate requirements for: "${objective}"`, 
                    { source: 'cycle_start' });
                
                this.addTask(this.TASK_TYPES.RESEARCH, 
                    `Research best practices and patterns for: "${objective}"`, 
                    { source: 'cycle_start' });
                
                this.addTask(this.TASK_TYPES.PLAN, 
                    `Create detailed implementation plan for: "${objective}"`, 
                    { source: 'cycle_start' });
                
                // Design task if we have design assets
                if (this.constitutionalMemory?.styleGuide || this.evaluatedStyleGuide) {
                    this.addTask(this.TASK_TYPES.DESIGN, 
                        `Apply style guide and create UI structure for: "${objective}"`, 
                        { source: 'cycle_start' });
                }
                
                console.log('[TaskQueue] Seeded', this.taskQueue.length, 'initial tasks');
                this.renderTaskQueue();
            },
            
            // Add standard test tasks
            addTestTasks() {
                this.addTask(this.TASK_TYPES.TEST, 
                    'Run visual tests and verify UI looks correct', 
                    { source: 'test_phase' });
                
                this.addTask(this.TASK_TYPES.TEST, 
                    'Check for console errors and fix any issues', 
                    { source: 'test_phase' });
                
                this.addTask(this.TASK_TYPES.EVALUATE, 
                    'Evaluate overall quality and determine if improvements needed', 
                    { source: 'test_phase' });
            },
            
            // Add error fix task from detected errors
            addErrorFixTask(errorInfo) {
                const description = errorInfo.message || errorInfo.description || 'Unknown error';
                this.addTask(this.TASK_TYPES.ERROR, 
                    `Fix error: ${description}`, 
                    { 
                        source: 'error_detection',
                        error: errorInfo,
                        relatedFiles: errorInfo.file ? [errorInfo.file] : []
                    });
            },
            
            // Add user feedback as a task
            addUserFeedbackTask(feedbackText) {
                
                const task = this.addTask(this.TASK_TYPES.USER, 
                    feedbackText, 
                    { source: 'user_feedback' });
                
                
                return task;
            },
            
            // Clear the task queue
            clearTaskQueue() {
                this.taskQueue = [];
                this.currentTaskId = null;
                this.queueStats = { completed: 0, total: 0, startTime: null, estimatedRemaining: 0 };
                this.renderTaskQueue();
            },
            
            // ==================== END TASK QUEUE SYSTEM ====================
            
            setPreviewMode(mode) {
                document.querySelectorAll('.preview-tab').forEach(t => t.classList.remove('active'));
                event.target.classList.add('active');
            },
            
            async openInBrowser() {
                if (this.currentPreviewFile) {
                    await window.aider.openFile(this.currentPreviewFile);
                }
            },
            
            // Screenshot and AI Review
            async captureAndAnalyze() {
                if (!this.currentPreviewFile) {
                    this.addMessage('error', 'No file is being previewed. Select a file first.');
                    return;
                }
                
                const ext = this.currentPreviewFile.split('.').pop().toLowerCase();
                if (ext !== 'html' && ext !== 'htm') {
                    this.addMessage('error', 'Screenshot capture only works with HTML files.');
                    return;
                }
                
                this.addMessage('system', ' Capturing screenshot for AI review...');
                
                try {
                    // Read the HTML content
                    const htmlContent = await window.aider.readFile(this.currentPreviewFile);
                    
                    if (!htmlContent) {
                        this.addMessage('error', 'Could not read file content.');
                        return;
                    }
                    
                    // Capture screenshot (pass file path, not content)
                    const screenshotResult = await window.aider.capturePreviewScreenshot(this.currentPreviewFile);
                    
                    if (!screenshotResult.success) {
                        this.addMessage('error', 'Screenshot capture failed: ' + (screenshotResult.error || 'Unknown error'));
                        return;
                    }
                    
                    this.addMessage('system', ' Sending screenshot to AI for visual analysis...');
                    
                    // Send to AI for analysis
                    const analysisPrompt = `Please analyze this screenshot of the UI and provide feedback on:
1. Visual design and aesthetics
2. Layout and spacing
3. Usability and UX issues
4. Any bugs or rendering problems you can see
5. Suggestions for improvement

Be specific about what you see in the image.`;
                    
                    const analysisResult = await window.aider.analyzeScreenshot(
                        screenshotResult.screenshot,
                        analysisPrompt
                    );
                    
                    if (analysisResult.success) {
                        // Store the analysis for later use with implement requests
                        this.lastVisualAnalysis = analysisResult.analysis;
                        this.lastVisualAnalysisTime = Date.now();
                        
                        // Create message with implement button
                        const analysisHtml = ` **Visual Analysis:**\n\n${analysisResult.analysis}\n\n<button class="btn btn-primary btn-sm" onclick="GSXCreate.implementVisualFixes()" style="margin-top: 12px;"> Implement These Changes</button>`;
                        this.addMessage('ai', analysisHtml, null, true);
                        
                        // Record cost if tokens provided
                        if (analysisResult.usage) {
                            const model = 'claude-sonnet-4-5-20250929'; // Vision model
                            await this.recordApiCost(
                                model,
                                analysisResult.usage.input_tokens || 0,
                                analysisResult.usage.output_tokens || 0,
                                'vision',
                                'Screenshot analysis'
                            );
                        }
                    } else {
                        this.addMessage('error', 'AI analysis failed: ' + (analysisResult.error || 'Unknown error'));
                    }
                } catch (error) {
                    console.error('[GSX Create] Screenshot analysis error:', error);
                    this.addMessage('error', 'Screenshot analysis failed: ' + error.message);
                }
            },
            
            // Implement Visual Fixes
            async implementVisualFixes() {
                if (!this.lastVisualAnalysis) {
                    this.addMessage('error', 'No visual analysis available. Run " AI Review" first.');
                    return;
                }
                
                // Set the prompt and trigger send
                const input = document.getElementById('promptInput');
                input.value = 'Please implement ALL the improvements from the visual analysis. Start with the High Priority items, then Medium Priority. Make all necessary code changes to the HTML/CSS/JS.';
                this.sendPrompt();
            },
            
            // Code Intelligence Tools
            showCodeTools() {
                document.getElementById('codeToolsModal').classList.add('active');
            },
            
            selectCodeTool(tool) {
                // Update tabs
                document.querySelectorAll('.code-tool-tab').forEach(t => {
                    t.classList.toggle('active', t.dataset.tool === tool);
                });
                // Update panels
                document.querySelectorAll('.code-tool-panel').forEach(p => {
                    p.classList.toggle('active', p.id === 'codeTool' + tool.charAt(0).toUpperCase() + tool.slice(1));
                });
            },
            
            // ============================================
            // TEST AGENT
            // ============================================
            testPlan: null,
            testResults: null,
            visualBaseline: null,
            lastInteractiveAnalysis: null,
            
            showTestAgent() {
                if (!this.currentPreviewFile) {
                    this.addMessage('error', 'Please preview an HTML file first to run tests on it.');
                    return;
                }
                document.getElementById('testAgentModal').classList.add('active');
            },
            
            selectTestTab(tab) {
                document.querySelectorAll('.test-tab').forEach(t => {
                    t.classList.toggle('active', t.dataset.test === tab);
                });
                document.querySelectorAll('.test-panel').forEach(p => {
                    p.classList.toggle('active', p.id === 'testPanel' + tab.charAt(0).toUpperCase() + tab.slice(1));
                });
            },
            
            async generateTestPlan() {
                if (!this.currentPreviewFile) {
                    this.addMessage('error', 'No file to test. Preview an HTML file first.');
                    return;
                }
                
                const useAI = document.getElementById('useAIForTests').checked;
                const planList = document.getElementById('testPlanList');
                const planDisplay = document.getElementById('testPlanDisplay');
                
                planList.innerHTML = '<p style="color: var(--text-muted);">Generating test plan...</p>';
                planDisplay.style.display = 'block';
                
                try {
                    const result = await window.testAgent.generatePlan(this.currentPreviewFile, useAI);
                    
                    if (result.success && result.testPlan) {
                        this.testPlan = result.testPlan;
                        document.getElementById('runTestsBtn').disabled = false;
                        
                        planList.innerHTML = `
                            <div style="margin-bottom: 8px; color: var(--text-primary); font-weight: 600;">${result.testPlan.name}</div>
                            ${result.testPlan.tests.map((t, i) => `
                                <div style="padding: 6px 8px; background: var(--bg-secondary); border-radius: 4px; margin-bottom: 4px; font-size: 11px;">
                                    <span style="color: var(--text-muted);">#${i + 1}</span>
                                    <span style="margin-left: 8px;">${t.name}</span>
                                    <span style="float: right; color: var(--accent);">${t.action}</span>
                                </div>
                            `).join('')}
                        `;
                    } else {
                        planList.innerHTML = `<p style="color: var(--error);">Failed: ${result.error || 'Unknown error'}</p>`;
                    }
                } catch (error) {
                    planList.innerHTML = `<p style="color: var(--error);">Error: ${error.message}</p>`;
                }
            },
            
            async runFunctionalTests() {
                if (!this.currentPreviewFile || !this.testPlan) {
                    return;
                }
                
                const browser = document.getElementById('browserSelect').value;
                const resultsDisplay = document.getElementById('testResultsDisplay');
                const summaryDiv = document.getElementById('testSummary');
                const resultsList = document.getElementById('testResultsList');
                
                resultsDisplay.style.display = 'block';
                summaryDiv.innerHTML = `<p style="color: var(--text-muted);">Running tests in ${browser}...</p>`;
                resultsList.innerHTML = '';
                
                // Listen for progress updates
                window.testAgent.onProgress((result) => {
                    const statusIcon = result.status === 'passed' ? '' : '';
                    resultsList.innerHTML += `
                        <div class="test-result-item ${result.status}">
                            <span class="test-status-icon">${statusIcon}</span>
                            <span class="test-name">${result.name}</span>
                            <span class="test-duration">${result.duration}ms</span>
                        </div>
                    `;
                });
                
                try {
                    const result = await window.testAgent.runTests(this.currentPreviewFile, { browser });
                    
                    if (result.success) {
                        this.testResults = result.results || [];
                        const summary = result.summary;
                        
                        // Enable fix button if there are failures
                        const fixBtn = document.getElementById('fixFailedTestsBtn');
                        if (fixBtn) fixBtn.disabled = summary.failed === 0;
                        
                        summaryDiv.innerHTML = `
                            <div style="text-align: center;">
                                <div style="font-size: 24px; font-weight: 700; color: ${summary.passRate >= 80 ? 'var(--success)' : summary.passRate >= 50 ? '#f59e0b' : 'var(--error)'};">
                                    ${summary.passRate}%
                                </div>
                                <div style="font-size: 11px; color: var(--text-muted);">Pass Rate</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="font-size: 24px; font-weight: 700; color: var(--success);">${summary.passed}</div>
                                <div style="font-size: 11px; color: var(--text-muted);">Passed</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="font-size: 24px; font-weight: 700; color: var(--error);">${summary.failed}</div>
                                <div style="font-size: 11px; color: var(--text-muted);">Failed</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="font-size: 24px; font-weight: 700; color: var(--text-primary);">${summary.duration}ms</div>
                                <div style="font-size: 11px; color: var(--text-muted);">Duration</div>
                            </div>
                        `;
                        
                        // Add to chat
                        this.addMessage('system', ` Test Results: ${summary.passed}/${summary.total} passed (${summary.passRate}%) in ${summary.duration}ms`);
                    } else {
                        summaryDiv.innerHTML = `<p style="color: var(--error);">Tests failed: ${result.error}</p>`;
                    }
                } catch (error) {
                    summaryDiv.innerHTML = `<p style="color: var(--error);">Error: ${error.message}</p>`;
                }
            },
            
            async captureBaseline() {
                if (!this.currentPreviewFile) return;
                
                const resultsDiv = document.getElementById('visualTestResults');
                resultsDiv.innerHTML = '<p style="color: var(--text-muted);">Capturing baseline...</p>';
                
                try {
                    const result = await window.testAgent.runVisualTest(this.currentPreviewFile);
                    
                    if (result.success) {
                        this.visualBaseline = result.currentScreenshot;
                        resultsDiv.innerHTML = `
                            <div style="text-align: center;">
                                <p style="color: var(--success); margin-bottom: 12px;"> Baseline captured!</p>
                                <img src="data:image/png;base64,${result.currentScreenshot}" 
                                     style="max-width: 100%; border-radius: 6px; border: 1px solid var(--border);">
                            </div>
                        `;
                    } else {
                        resultsDiv.innerHTML = `<p style="color: var(--error);">Failed: ${result.error}</p>`;
                    }
                } catch (error) {
                    resultsDiv.innerHTML = `<p style="color: var(--error);">Error: ${error.message}</p>`;
                }
            },
            
            async compareVisual() {
                if (!this.currentPreviewFile || !this.visualBaseline) {
                    document.getElementById('visualTestResults').innerHTML = 
                        '<p style="color: var(--text-muted);">Capture a baseline first</p>';
                    return;
                }
                
                const resultsDiv = document.getElementById('visualTestResults');
                resultsDiv.innerHTML = '<p style="color: var(--text-muted);">Comparing...</p>';
                
                try {
                    const result = await window.testAgent.runVisualTest(this.currentPreviewFile, this.visualBaseline);
                    
                    if (result.success) {
                        resultsDiv.innerHTML = `
                            <div style="display: flex; gap: 16px; flex-wrap: wrap;">
                                <div style="flex: 1; min-width: 300px;">
                                    <h4 style="font-size: 12px; margin-bottom: 8px;">Baseline</h4>
                                    <img src="data:image/png;base64,${this.visualBaseline}" 
                                         style="max-width: 100%; border-radius: 6px; border: 1px solid var(--border);">
                                </div>
                                <div style="flex: 1; min-width: 300px;">
                                    <h4 style="font-size: 12px; margin-bottom: 8px;">Current</h4>
                                    <img src="data:image/png;base64,${result.currentScreenshot}" 
                                         style="max-width: 100%; border-radius: 6px; border: 1px solid var(--border);">
                                </div>
                            </div>
                            <p style="margin-top: 12px; text-align: center; color: ${result.hasDifferences ? 'var(--error)' : 'var(--success)'};">
                                ${result.hasDifferences ? ' Visual differences detected!' : ' No visual changes'}
                            </p>
                        `;
                    } else {
                        resultsDiv.innerHTML = `<p style="color: var(--error);">Failed: ${result.error}</p>`;
                    }
                } catch (error) {
                    resultsDiv.innerHTML = `<p style="color: var(--error);">Error: ${error.message}</p>`;
                }
            },
            
            async runCrossBrowserTest() {
                if (!this.currentPreviewFile) return;
                
                const resultsDiv = document.getElementById('visualTestResults');
                resultsDiv.innerHTML = '<p style="color: var(--text-muted);"> Testing across Chrome, Firefox, and Safari...</p>';
                
                try {
                    const result = await window.testAgent.runCrossBrowserTest(this.currentPreviewFile);
                    
                    if (result.success) {
                        const browsers = result.browsers;
                        resultsDiv.innerHTML = `
                            <div style="display: flex; gap: 16px; flex-wrap: wrap; width: 100%;">
                                ${Object.entries(browsers).map(([browser, data]) => `
                                    <div style="flex: 1; min-width: 250px;">
                                        <h4 style="font-size: 12px; margin-bottom: 8px; display: flex; align-items: center; gap: 6px;">
                                            ${browser === 'chromium' ? '' : browser === 'firefox' ? '' : ''}
                                            ${browser.charAt(0).toUpperCase() + browser.slice(1)}
                                            ${data.success ? '<span style="color: var(--success);"></span>' : '<span style="color: var(--error);"></span>'}
                                        </h4>
                                        ${data.success 
                                            ? `<img src="data:image/png;base64,${data.screenshot}" style="max-width: 100%; border-radius: 6px; border: 1px solid var(--border);">` 
                                            : `<p style="color: var(--error); font-size: 11px;">${data.error}</p>`
                                        }
                                    </div>
                                `).join('')}
                            </div>
                        `;
                        
                        this.addMessage('system', ' Cross-browser test complete: Chrome, Firefox, Safari');
                    } else {
                        resultsDiv.innerHTML = `<p style="color: var(--error);">Failed: ${result.error}</p>`;
                    }
                } catch (error) {
                    resultsDiv.innerHTML = `<p style="color: var(--error);">Error: ${error.message}</p>`;
                }
            },
            
            async runAccessibilityTest() {
                if (!this.currentPreviewFile) return;
                
                const resultsDiv = document.getElementById('accessibilityResults');
                resultsDiv.innerHTML = '<p style="color: var(--text-muted);">Running accessibility audit...</p>';
                
                try {
                    const result = await window.testAgent.runAccessibilityTest(this.currentPreviewFile);
                    
                    if (result.success) {
                        // Store results for fixing
                        this.lastAccessibilityResults = result;
                        
                        // Enable fix button if there are issues
                        const fixBtn = document.getElementById('fixAccessibilityBtn');
                        if (fixBtn) fixBtn.disabled = result.issues.length === 0;
                        
                        if (result.issues.length === 0) {
                            resultsDiv.innerHTML = '<p style="color: var(--success);"> No accessibility issues found!</p>';
                        } else {
                            resultsDiv.innerHTML = `
                                <div style="margin-bottom: 12px; padding: 12px; background: var(--bg-tertiary); border-radius: 6px;">
                                    <span style="color: var(--error); font-weight: 600;">${result.summary.errors} errors</span>
                                    <span style="margin-left: 12px; color: #f59e0b; font-weight: 600;">${result.summary.warnings} warnings</span>
                                </div>
                                ${result.issues.map(issue => `
                                    <div class="accessibility-issue ${issue.severity}">
                                        <div style="font-weight: 600; margin-bottom: 4px;">${issue.type}</div>
                                        <div style="color: var(--text-secondary);">${issue.message}</div>
                                        <code style="font-size: 10px; color: var(--text-muted); display: block; margin-top: 4px; word-break: break-all;">
                                            ${this.escapeHtml(issue.element || '')}
                                        </code>
                                    </div>
                                `).join('')}
                            `;
                        }
                        
                        this.addMessage('system', ` Accessibility: ${result.summary.errors} errors, ${result.summary.warnings} warnings`);
                    } else {
                        resultsDiv.innerHTML = `<p style="color: var(--error);">Failed: ${result.error}</p>`;
                    }
                } catch (error) {
                    resultsDiv.innerHTML = `<p style="color: var(--error);">Error: ${error.message}</p>`;
                }
            },
            
            async runPerformanceTest() {
                if (!this.currentPreviewFile) return;
                
                const resultsDiv = document.getElementById('performanceResults');
                resultsDiv.innerHTML = '<p style="color: var(--text-muted);">Running performance test...</p>';
                
                try {
                    const result = await window.testAgent.runPerformanceTest(this.currentPreviewFile);
                    
                    if (result.success) {
                        // Store results for fixing
                        this.lastPerformanceResults = result;
                        
                        // Enable optimize button if score is below threshold
                        const fixBtn = document.getElementById('fixPerformanceBtn');
                        if (fixBtn) fixBtn.disabled = result.score >= 80;
                        
                        const scoreClass = result.score >= 80 ? 'good' : result.score >= 50 ? 'ok' : 'bad';
                        
                        resultsDiv.innerHTML = `
                            <div class="performance-score ${scoreClass}">${result.score}</div>
                            <div style="text-align: center; margin-bottom: 16px; color: var(--text-muted);">Performance Score</div>
                            
                            <div class="performance-metric">
                                <span>Load Time</span>
                                <span style="font-weight: 600;">${result.loadTime}ms</span>
                            </div>
                            <div class="performance-metric">
                                <span>DOM Nodes</span>
                                <span style="font-weight: 600;">${result.domStats.nodeCount}</span>
                            </div>
                            <div class="performance-metric">
                                <span>Scripts</span>
                                <span style="font-weight: 600;">${result.domStats.scriptCount}</span>
                            </div>
                            <div class="performance-metric">
                                <span>Stylesheets</span>
                                <span style="font-weight: 600;">${result.domStats.styleCount}</span>
                            </div>
                            <div class="performance-metric">
                                <span>Images</span>
                                <span style="font-weight: 600;">${result.domStats.imageCount}</span>
                            </div>
                        `;
                        
                        this.addMessage('system', ` Performance: Score ${result.score}/100, Load time ${result.loadTime}ms`);
                    } else {
                        resultsDiv.innerHTML = `<p style="color: var(--error);">Failed: ${result.error}</p>`;
                    }
                } catch (error) {
                    resultsDiv.innerHTML = `<p style="color: var(--error);">Error: ${error.message}</p>`;
                }
            },
            
            async runInteractiveTest() {
                if (!this.currentPreviewFile) return;
                
                const resultsDiv = document.getElementById('interactiveResults');
                resultsDiv.innerHTML = '<p style="color: var(--text-muted);"> AI is analyzing your UI...</p>';
                
                try {
                    const result = await window.testAgent.runInteractiveTest(this.currentPreviewFile);
                    
                    if (result.success) {
                        this.lastInteractiveAnalysis = result.aiAnalysis;
                        document.getElementById('implementFixesBtn').disabled = !result.aiAnalysis;
                        
                        let html = '';
                        
                        if (result.consoleErrors && result.consoleErrors.length > 0) {
                            html += `
                                <div style="margin-bottom: 16px; padding: 12px; background: rgba(239, 68, 68, 0.1); border-radius: 6px; border-left: 3px solid var(--error);">
                                    <div style="font-weight: 600; margin-bottom: 8px;">Console Errors (${result.consoleErrors.length})</div>
                                    ${result.consoleErrors.map(e => `<div style="font-size: 11px; color: var(--error);">${this.escapeHtml(e)}</div>`).join('')}
                                </div>
                            `;
                        }
                        
                        if (result.screenshot) {
                            html += `
                                <div style="margin-bottom: 16px;">
                                    <img src="data:image/png;base64,${result.screenshot}" 
                                         style="max-width: 100%; max-height: 200px; border-radius: 6px; border: 1px solid var(--border);">
                                </div>
                            `;
                        }
                        
                        if (result.aiAnalysis) {
                            html += `
                                <div style="padding: 12px; background: var(--bg-tertiary); border-radius: 6px; white-space: pre-wrap; font-size: 12px;">
                                    ${this.escapeHtml(result.aiAnalysis)}
                                </div>
                            `;
                        } else {
                            html += '<p style="color: var(--text-muted);">AI analysis not available (check API key)</p>';
                        }
                        
                        resultsDiv.innerHTML = html;
                    } else {
                        resultsDiv.innerHTML = `<p style="color: var(--error);">Failed: ${result.error}</p>`;
                    }
                } catch (error) {
                    resultsDiv.innerHTML = `<p style="color: var(--error);">Error: ${error.message}</p>`;
                }
            },
            
            // ==================== AI EVALS ====================
            aiEvalsHistory: [],
            
            async runAIEvals() {
                const resultsDisplay = document.getElementById('aiEvalsResults');
                const resultsList = document.getElementById('aiEvalsResultsList');
                const profile = document.getElementById('evalProfileSelect')?.value || 'standard';
                
                resultsDisplay.style.display = 'block';
                resultsList.innerHTML = '<p style="color: var(--text-muted);"> Running AI evaluations...</p>';
                
                try {
                    // Get current content (either preview file or active input)
                    const content = this.currentPreviewFile 
                        ? await this.getFileContent(this.currentPreviewFile)
                        : document.getElementById('messageInput')?.value || '';
                    
                    if (!content || content.length < 10) {
                        resultsList.innerHTML = '<p style="color: var(--error);">No content to evaluate. Preview a file or enter some code.</p>';
                        return;
                    }
                    
                    const result = await this.runEvaluation(content, {
                        profile,
                        filePath: this.currentPreviewFile,
                        context: { source: 'ai-evals-tab' }
                    });
                    
                    if (result && !result.error) {
                        // Add to history
                        this.aiEvalsHistory.unshift({
                            timestamp: new Date().toISOString(),
                            score: result.aggregateScore,
                            profile,
                            agentCount: result.agentScores?.length || 0
                        });
                        this.updateAIEvalsHistory();
                        
                        // Display results
                        resultsList.innerHTML = this.formatEvalResults(result);
                    } else {
                        resultsList.innerHTML = `<p style="color: var(--error);">Evaluation failed: ${result?.error || 'Unknown error'}</p>`;
                    }
                } catch (error) {
                    console.error('[AI Evals] Error:', error);
                    resultsList.innerHTML = `<p style="color: var(--error);">Error: ${error.message}</p>`;
                }
            },
            
            async runMultiAgentEval() {
                const content = this.currentPreviewFile 
                    ? await this.getFileContent(this.currentPreviewFile)
                    : document.getElementById('messageInput')?.value || '';
                
                if (!content || content.length < 10) {
                    this.addMessage('error', 'No content to evaluate. Preview a file or enter some code.');
                    return;
                }
                
                this.addMessage('system', ' Starting multi-agent evaluation...');
                
                try {
                    const result = await this.runEvaluation(content, {
                        profile: 'deep',
                        filePath: this.currentPreviewFile,
                        weightingStrategy: 'contextual'
                    });
                    
                    if (result) {
                        this.addMessage('system', ` Evaluation complete: Score ${Math.round(result.aggregateScore)}/100 (${result.confidence} confidence)`);
                        
                        // Show conflicts if any
                        if (result.conflicts?.length > 0) {
                            this.addMessage('info', ` ${result.conflicts.length} agent conflicts detected`);
                        }
                        
                        // Show top suggestions
                        if (result.suggestions?.length > 0) {
                            const topSuggestions = result.suggestions.slice(0, 3).map(s => ` ${s.text}`).join('\n');
                            this.addMessage('info', ` Top suggestions:\n${topSuggestions}`);
                        }
                    }
                } catch (error) {
                    this.addMessage('error', `Multi-agent evaluation failed: ${error.message}`);
                }
            },
            
            formatEvalResults(result) {
                const scoreColor = result.aggregateScore >= 70 ? 'var(--success)' : 
                                   result.aggregateScore >= 50 ? '#f59e0b' : 'var(--error)';
                
                let html = `
                    <div style="display: flex; gap: 16px; margin-bottom: 16px;">
                        <div style="text-align: center; padding: 12px; background: var(--bg-secondary); border-radius: 8px;">
                            <div style="font-size: 32px; font-weight: 700; color: ${scoreColor};">${Math.round(result.aggregateScore)}</div>
                            <div style="font-size: 11px; color: var(--text-muted);">Overall Score</div>
                        </div>
                        <div style="flex: 1;">
                            <div style="font-size: 12px; margin-bottom: 8px;">
                                <strong>Confidence:</strong> 
                                <span style="color: ${result.confidence === 'high' ? 'var(--success)' : result.confidence === 'medium' ? '#f59e0b' : 'var(--error)'};">
                                    ${result.confidence}
                                </span>
                            </div>
                            <div style="font-size: 12px;"><strong>Agents:</strong> ${result.agentScores?.length || 0}</div>
                            ${result.epistemicFraming?.recommendsHumanReview ? 
                                '<div style="font-size: 11px; color: #f59e0b; margin-top: 4px;"> Human review recommended</div>' : ''}
                        </div>
                    </div>
                `;
                
                // Agent scores
                if (result.agentScores?.length > 0) {
                    html += `<div style="font-size: 11px; font-weight: 600; margin-bottom: 8px; color: var(--text-secondary);">AGENT SCORES</div>`;
                    html += '<div style="display: flex; flex-wrap: wrap; gap: 6px; margin-bottom: 12px;">';
                    result.agentScores.forEach(agent => {
                        const agentColor = agent.score >= 70 ? 'rgba(34, 197, 94, 0.2)' : 
                                          agent.score >= 50 ? 'rgba(245, 158, 11, 0.2)' : 'rgba(239, 68, 68, 0.2)';
                        html += `
                            <div style="padding: 6px 10px; background: ${agentColor}; border-radius: 6px; font-size: 11px;">
                                ${agent.agentType}: <strong>${Math.round(agent.score)}</strong>
                            </div>
                        `;
                    });
                    html += '</div>';
                }
                
                // Rationale
                if (result.epistemicFraming?.rationale) {
                    html += `
                        <div style="font-size: 11px; font-weight: 600; margin-bottom: 6px; color: var(--text-secondary);">RATIONALE</div>
                        <div style="font-size: 12px; padding: 10px; background: rgba(99, 102, 241, 0.1); border-left: 3px solid rgba(99, 102, 241, 0.5); border-radius: 0 6px 6px 0; margin-bottom: 12px;">
                            ${result.epistemicFraming.rationale}
                        </div>
                    `;
                }
                
                // Top suggestions
                if (result.suggestions?.length > 0) {
                    html += `<div style="font-size: 11px; font-weight: 600; margin-bottom: 6px; color: var(--text-secondary);">SUGGESTIONS</div>`;
                    result.suggestions.slice(0, 5).forEach(s => {
                        const priorityColor = s.priority === 'high' ? 'var(--error)' : s.priority === 'medium' ? '#f59e0b' : 'var(--success)';
                        html += `
                            <div style="display: flex; align-items: flex-start; gap: 8px; padding: 8px; background: var(--bg-secondary); border-radius: 6px; margin-bottom: 4px; font-size: 11px;">
                                <span style="width: 6px; height: 6px; border-radius: 50%; background: ${priorityColor}; margin-top: 4px; flex-shrink: 0;"></span>
                                <span style="flex: 1;">${s.text}</span>
                            </div>
                        `;
                    });
                }
                
                return html;
            },
            
            updateAIEvalsHistory() {
                const historyList = document.getElementById('aiEvalsHistoryList');
                if (!historyList) return;
                
                if (this.aiEvalsHistory.length === 0) {
                    historyList.innerHTML = 'No evaluations run yet';
                    return;
                }
                
                historyList.innerHTML = this.aiEvalsHistory.slice(0, 5).map(h => {
                    const date = new Date(h.timestamp);
                    const time = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                    const scoreColor = h.score >= 70 ? 'var(--success)' : h.score >= 50 ? '#f59e0b' : 'var(--error)';
                    return `
                        <div style="display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid var(--border);">
                            <span>${time} - ${h.profile}</span>
                            <span style="color: ${scoreColor}; font-weight: 600;">${Math.round(h.score)}</span>
                        </div>
                    `;
                }).join('');
            },
            
            async getFileContent(filePath) {
                try {
                    if (window.electronAPI?.invoke) {
                        const result = await window.electronAPI.invoke('read-file', filePath);
                        return result?.content || '';
                    }
                } catch (error) {
                    console.error('[AI Evals] Failed to read file:', error);
                }
                return '';
            },
            
            // Store last test results for fixing
            lastTestResults: null,
            lastAccessibilityResults: null,
            lastPerformanceResults: null,
            lastInteractiveAnalysis: null,
            
            // Test state
            testPlan: null,
            testResults: [],
            currentTestIndex: 0,
            fixQueue: [],
            
            // Quick Test - comprehensive AI-driven testing flow
            async runQuickTest() {
                if (!this.currentPreviewFile) {
                    this.addMessage('error', 'Please select a file to preview first');
                    return;
                }
                
                this.trackBehavior('test_run', { file: this.currentPreviewFile.split('/').pop() });
                
                const testBtn = document.getElementById('testBtn');
                testBtn.classList.add('running');
                testBtn.disabled = true;
                
                try {
                    // Phase 1: Generate Test Plan
                    this.addMessage('system', ' Phase 1: Generating test plan...');
                    const planResult = await window.testAgent.generatePlan(this.currentPreviewFile, true);
                    
                    if (planResult.success && planResult.testPlan) {
                        this.testPlan = planResult.testPlan;
                        const testCount = this.testPlan.tests?.length || 0;
                        this.addMessage('system', ` Test plan created: ${testCount} tests to run`);
                        
                        // Show test plan summary
                        if (testCount > 0) {
                            const planSummary = this.testPlan.tests.slice(0, 5).map((t, i) => 
                                `  ${i+1}. ${t.name} (${t.action})`
                            ).join('\n');
                            this.addMessage('system', `Tests:\n${planSummary}${testCount > 5 ? `\n  ...and ${testCount - 5} more` : ''}`);
                        }
                    }
                    
                    // Phase 2: Run Functional Tests
                    this.addMessage('system', ' Phase 2: Running functional tests...');
                    const testResult = await window.testAgent.runTests(this.currentPreviewFile, { 
                        browser: 'chromium',
                        captureScreenshots: true 
                    });
                    
                    if (testResult.success) {
                        this.testResults = testResult.results || [];
                        const passed = testResult.summary?.passed || 0;
                        const failed = testResult.summary?.failed || 0;
                        const passRate = testResult.summary?.passRate || 0;
                        
                        const statusIcon = passRate >= 80 ? '' : passRate >= 50 ? '' : '';
                        this.addMessage('system', `${statusIcon} Functional tests: ${passed} passed, ${failed} failed (${passRate}%)`);
                        
                        // Show failed tests
                        const failedTests = this.testResults.filter(t => t.status === 'failed');
                        if (failedTests.length > 0) {
                            const failedSummary = failedTests.slice(0, 3).map(t => 
                                `   ${t.name}: ${t.error || 'Failed'}`
                            ).join('\n');
                            this.addMessage('error', `Failed tests:\n${failedSummary}`);
                        }
                    }
                    
                    // Phase 3: Visual Analysis with AI
                    this.addMessage('system', ' Phase 3: Capturing screenshots for AI analysis...');
                    const visualResult = await window.testAgent.runInteractiveTest(this.currentPreviewFile);
                    
                    if (visualResult.success) {
                        // Show console errors if any
                        if (visualResult.consoleErrors && visualResult.consoleErrors.length > 0) {
                            this.addMessage('error', ` Console Errors (${visualResult.consoleErrors.length}):\n${visualResult.consoleErrors.slice(0, 3).join('\n')}`);
                        }
                        
                        if (visualResult.aiAnalysis) {
                            this.lastInteractiveAnalysis = visualResult.aiAnalysis;
                            this.lastVisualAnalysis = visualResult.aiAnalysis;
                            this.lastVisualAnalysisTime = Date.now();
                            
                            // Phase 4: Parse recommendations into fix queue
                            this.addMessage('system', ' Phase 4: Analyzing recommendations...');
                            this.fixQueue = this.parseRecommendations(visualResult.aiAnalysis);
                            
                            // Show comprehensive results
                            const msgHtml = `
                                <div style="margin-bottom: 12px;">
                                    <strong> AI Analysis Complete</strong>
                                    <div style="font-size: 11px; color: var(--text-muted); margin-top: 4px;">
                                        Found ${this.fixQueue.length} issues to fix
                                    </div>
                                </div>
                                <div style="white-space: pre-wrap; font-size: 12px; max-height: 300px; overflow-y: auto; padding: 12px; background: var(--bg-tertiary); border-radius: 6px; margin-bottom: 12px;">
${this.escapeHtml(visualResult.aiAnalysis)}
                                </div>
                                <div style="display: flex; gap: 8px;">
                                    <button class="btn btn-success" onclick="GSXCreate.implementQuickFixes()" style="flex: 1;">
                                         Fix All Issues
                                    </button>
                                    <button class="btn btn-primary" onclick="GSXCreate.implementFixesOneByOne()" style="flex: 1;">
                                         Fix One-by-One
                                    </button>
                                </div>
                            `;
                            this.addMessage('ai', msgHtml, null, true);
                        } else {
                            this.addMessage('error', 'AI analysis not available. Check your API key in Config.');
                        }
                    } else {
                        this.addMessage('error', `Visual analysis failed: ${visualResult.error}`);
                    }
                    
                } catch (error) {
                    this.addMessage('error', `Test error: ${error.message}`);
                } finally {
                    testBtn.classList.remove('running');
                    testBtn.disabled = false;
                }
            },
            
            // Parse AI recommendations into actionable fix items
            parseRecommendations(analysis) {
                const fixes = [];
                const lines = analysis.split('\n');
                let currentCategory = '';
                let priority = 1;
                
                for (const line of lines) {
                    const trimmed = line.trim();
                    
                    // Detect category headers
                    if (trimmed.match(/^#+\s*\d*\.?\s*(bug|error|issue|fix|problem)/i)) {
                        currentCategory = 'bug';
                        priority = 1;
                    } else if (trimmed.match(/^#+\s*\d*\.?\s*(ux|usability|user experience)/i)) {
                        currentCategory = 'ux';
                        priority = 2;
                    } else if (trimmed.match(/^#+\s*\d*\.?\s*(visual|design|aesthetic|style)/i)) {
                        currentCategory = 'visual';
                        priority = 3;
                    } else if (trimmed.match(/^#+\s*\d*\.?\s*(access|a11y|accessibility)/i)) {
                        currentCategory = 'accessibility';
                        priority = 4;
                    } else if (trimmed.match(/^#+\s*\d*\.?\s*(suggest|improve|recommend)/i)) {
                        currentCategory = 'improvement';
                        priority = 5;
                    }
                    
                    // Detect list items as fixes
                    const listMatch = trimmed.match(/^[-*]\s*(.+)$/) || trimmed.match(/^\d+\.\s*(.+)$/);
                    if (listMatch && listMatch[1].length > 10) {
                        fixes.push({
                            id: fixes.length + 1,
                            category: currentCategory || 'general',
                            priority,
                            description: listMatch[1],
                            status: 'pending'
                        });
                    }
                }
                
                // Sort by priority
                fixes.sort((a, b) => a.priority - b.priority);
                return fixes;
            },
            
            async implementQuickFixes() {
                if (!this.lastVisualAnalysis) {
                    this.addMessage('error', 'No analysis available. Run test first.');
                    return;
                }
                
                const input = document.getElementById('promptInput');
                input.value = `Please implement ALL the fixes and improvements from this analysis:

${this.lastVisualAnalysis}

Address each issue systematically:
1. Fix any bugs or errors first
2. Then address UX/usability issues  
3. Then visual/aesthetic improvements
4. Finally accessibility concerns

Make the changes directly to the file.`;
                
                this.sendPrompt();
            },
            
            // Fix issues one by one with testing after each
            async implementFixesOneByOne() {
                if (!this.fixQueue || this.fixQueue.length === 0) {
                    this.addMessage('error', 'No fixes in queue. Run test first.');
                    return;
                }
                
                this.currentTestIndex = 0;
                await this.implementNextFix();
            },
            
            async implementNextFix() {
                if (this.currentTestIndex >= this.fixQueue.length) {
                    this.addMessage('system', ' All fixes implemented! Running final verification...');
                    // Run a final test to verify
                    await this.runQuickTest();
                    return;
                }
                
                const fix = this.fixQueue[this.currentTestIndex];
                const remaining = this.fixQueue.length - this.currentTestIndex;
                
                this.addMessage('system', ` Fixing issue ${this.currentTestIndex + 1}/${this.fixQueue.length}: ${fix.description.substring(0, 50)}...`);
                
                const input = document.getElementById('promptInput');
                input.value = `Please fix this specific issue:

Category: ${fix.category}
Issue: ${fix.description}

Make ONLY this change. After you're done, I'll test and move to the next issue.
There are ${remaining - 1} more issues to fix after this one.`;
                
                // Store callback for after fix is applied
                this.pendingFixCallback = async () => {
                    fix.status = 'completed';
                    this.currentTestIndex++;
                    
                    // Brief pause then continue
                    this.addMessage('system', ` Fix applied. Testing...`);
                    
                    // Quick verification screenshot
                    try {
                        const verifyResult = await window.testAgent.runVisualTest(this.currentPreviewFile);
                        if (verifyResult.success) {
                            this.addMessage('system', ` Verified. Moving to next fix...`);
                        }
                    } catch (e) {
                        // Continue anyway
                    }
                    
                    // Continue to next fix
                    setTimeout(() => this.implementNextFix(), 1000);
                };
                
                this.sendPrompt();
            },
            
            // Called after prompt completes to continue fix chain
            onPromptComplete() {
                if (this.pendingFixCallback) {
                    const callback = this.pendingFixCallback;
                    this.pendingFixCallback = null;
                    callback();
                }
            },
            
            async implementTestFixes() {
                if (!this.lastInteractiveAnalysis) {
                    this.addMessage('error', 'No AI analysis available. Run "AI Analyze & Test" first.');
                    return;
                }
                
                // Store for sendPrompt to pick up
                this.lastVisualAnalysis = this.lastInteractiveAnalysis;
                this.lastVisualAnalysisTime = Date.now();
                
                // Close modal and trigger implementation
                this.closeModal('testAgentModal');
                
                const input = document.getElementById('promptInput');
                input.value = 'Please implement the fixes and improvements identified in the AI analysis. Address any bugs, UX issues, and suggested improvements.';
                this.sendPrompt();
            },
            
            async fixAccessibilityIssues() {
                if (!this.lastAccessibilityResults || !this.lastAccessibilityResults.issues) {
                    this.addMessage('error', 'No accessibility issues found. Run accessibility test first.');
                    return;
                }
                
                const issues = this.lastAccessibilityResults.issues;
                if (issues.length === 0) {
                    this.addMessage('system', ' No accessibility issues to fix!');
                    return;
                }
                
                // Format issues for AI
                const issueList = issues.map((issue, i) => 
                    `${i + 1}. [${issue.severity.toUpperCase()}] ${issue.type}: ${issue.message}\n   Element: ${issue.element || 'N/A'}\n   Selector: ${issue.selector || 'N/A'}`
                ).join('\n\n');
                
                this.closeModal('testAgentModal');
                
                const prompt = `Please fix the following accessibility issues in the HTML file:

${issueList}

For each issue:
1. Find the element using the selector or element snippet
2. Apply the appropriate fix (add alt text, aria-label, tabindex, etc.)
3. Ensure the fix follows WCAG 2.1 guidelines

Focus on errors first, then warnings.`;
                
                const input = document.getElementById('promptInput');
                input.value = prompt;
                this.sendPrompt();
            },
            
            async fixPerformanceIssues() {
                if (!this.lastPerformanceResults) {
                    this.addMessage('error', 'No performance data. Run performance test first.');
                    return;
                }
                
                const perf = this.lastPerformanceResults;
                const issues = [];
                
                if (perf.loadTime > 3000) issues.push(`- Load time is ${perf.loadTime}ms (should be < 3000ms)`);
                if (perf.domStats?.nodeCount > 1500) issues.push(`- DOM has ${perf.domStats.nodeCount} nodes (should be < 1500)`);
                if (perf.domStats?.scriptCount > 10) issues.push(`- ${perf.domStats.scriptCount} script tags (consider bundling)`);
                if (perf.domStats?.styleCount > 5) issues.push(`- ${perf.domStats.styleCount} stylesheets (consider combining)`);
                
                if (issues.length === 0) {
                    this.addMessage('system', ' No major performance issues to fix!');
                    return;
                }
                
                this.closeModal('testAgentModal');
                
                const prompt = `Please optimize the HTML file for better performance. Issues found:

${issues.join('\n')}

Current metrics:
- Load time: ${perf.loadTime}ms
- DOM nodes: ${perf.domStats?.nodeCount || 'N/A'}
- Scripts: ${perf.domStats?.scriptCount || 'N/A'}
- Stylesheets: ${perf.domStats?.styleCount || 'N/A'}
- Performance score: ${perf.score}/100

Suggestions:
1. Minimize DOM complexity where possible
2. Combine/minify CSS and JS
3. Defer non-critical scripts
4. Optimize images (lazy loading, proper sizing)
5. Remove unused CSS/JS`;
                
                const input = document.getElementById('promptInput');
                input.value = prompt;
                this.sendPrompt();
            },
            
            async fixFailedTests() {
                if (!this.testResults || this.testResults.length === 0) {
                    this.addMessage('error', 'No test results. Run functional tests first.');
                    return;
                }
                
                const failed = this.testResults.filter(t => t.status === 'failed');
                if (failed.length === 0) {
                    this.addMessage('system', ' All tests passed! Nothing to fix.');
                    return;
                }
                
                const failedList = failed.map((t, i) => 
                    `${i + 1}. Test: ${t.name}\n   Error: ${t.error}\n   Selector: ${t.selector || 'N/A'}`
                ).join('\n\n');
                
                this.closeModal('testAgentModal');
                
                const prompt = `The following functional tests failed. Please fix the issues:

${failedList}

For each failed test:
1. Identify why the element or interaction failed
2. Fix the HTML/CSS/JS to make the test pass
3. Ensure the fix doesn't break other functionality`;
                
                const input = document.getElementById('promptInput');
                input.value = prompt;
                this.sendPrompt();
            },
            
            async searchCode() {
                const pattern = document.getElementById('searchPattern').value.trim();
                const glob = document.getElementById('searchGlob').value.trim() || null;
                const resultsDiv = document.getElementById('searchResults');
                
                if (!pattern) {
                    resultsDiv.innerHTML = '<p style="color: var(--text-muted);">Enter a search pattern</p>';
                    return;
                }
                
                resultsDiv.innerHTML = '<p>Searching...</p>';
                
                try {
                    const result = await window.aider.searchCode(pattern, glob);
                    console.log('[GSX Create] Search result:', result);
                    
                    if (result.success && result.matches && result.matches.length > 0) {
                        resultsDiv.innerHTML = result.matches.map(match => `
                            <div class="code-result-item" onclick="GSXCreate.previewFile('${match.file}')">
                                <div class="code-result-file">${match.file}</div>
                                <div class="code-result-line">Line ${match.line}</div>
                                <div class="code-result-content">${this.escapeHtml(match.content)}</div>
                            </div>
                        `).join('');
                    } else if (result.success) {
                        resultsDiv.innerHTML = '<p style="color: var(--text-muted);">No matches found</p>';
                    } else {
                        resultsDiv.innerHTML = '<p style="color: var(--danger);">Error: ' + (result.error || 'Search failed') + '</p>';
                    }
                } catch (error) {
                    console.error('[GSX Create] Search error:', error);
                    resultsDiv.innerHTML = '<p style="color: var(--danger);">Error: ' + error.message + '</p>';
                }
            },
            
            async findDefinition() {
                const symbol = document.getElementById('definitionSymbol').value.trim();
                const resultsDiv = document.getElementById('definitionResults');
                
                if (!symbol) {
                    resultsDiv.innerHTML = '<p style="color: var(--text-muted);">Enter a symbol name</p>';
                    return;
                }
                
                resultsDiv.innerHTML = '<p>Searching...</p>';
                
                try {
                    const result = await window.aider.findDefinition(symbol);
                    console.log('[GSX Create] Definition result:', result);
                    
                    if (result.success && result.definitions && result.definitions.length > 0) {
                        resultsDiv.innerHTML = result.definitions.map(def => `
                            <div class="code-result-item" onclick="GSXCreate.previewFile('${def.file}')">
                                <div class="code-result-file">${def.file}</div>
                                <div class="code-result-line">Line ${def.line}</div>
                                <div class="code-result-content">${this.escapeHtml(def.content)}</div>
                            </div>
                        `).join('');
                    } else if (result.success) {
                        resultsDiv.innerHTML = '<p style="color: var(--text-muted);">No definition found for "' + symbol + '"</p>';
                    } else {
                        resultsDiv.innerHTML = '<p style="color: var(--danger);">Error: ' + (result.error || 'Search failed') + '</p>';
                    }
                } catch (error) {
                    console.error('[GSX Create] Find definition error:', error);
                    resultsDiv.innerHTML = '<p style="color: var(--danger);">Error: ' + error.message + '</p>';
                }
            },
            
            async findUsages() {
                const symbol = document.getElementById('usagesSymbol').value.trim();
                const resultsDiv = document.getElementById('usagesResults');
                
                if (!symbol) {
                    resultsDiv.innerHTML = '<p style="color: var(--text-muted);">Enter a symbol name</p>';
                    return;
                }
                
                resultsDiv.innerHTML = '<p>Searching...</p>';
                
                try {
                    const result = await window.aider.findUsages(symbol);
                    console.log('[GSX Create] Usages result:', result);
                    
                    if (result.success && result.usages && result.usages.length > 0) {
                        resultsDiv.innerHTML = `
                            <p style="margin-bottom: 12px; color: var(--success);">Found ${result.usages.length} usage(s)</p>
                            ${result.usages.map(usage => `
                                <div class="code-result-item" onclick="GSXCreate.previewFile('${usage.file}')">
                                    <div class="code-result-file">${usage.file}</div>
                                    <div class="code-result-line">Line ${usage.line}</div>
                                    <div class="code-result-content">${this.escapeHtml(usage.content)}</div>
                                </div>
                            `).join('')}
                        `;
                    } else if (result.success) {
                        resultsDiv.innerHTML = '<p style="color: var(--text-muted);">No usages found for "' + symbol + '"</p>';
                    } else {
                        resultsDiv.innerHTML = '<p style="color: var(--danger);">Error: ' + (result.error || 'Search failed') + '</p>';
                    }
                } catch (error) {
                    console.error('[GSX Create] Find usages error:', error);
                    resultsDiv.innerHTML = '<p style="color: var(--danger);">Error: ' + error.message + '</p>';
                }
            },
            
            async getRepoMap() {
                const resultsDiv = document.getElementById('repomapResults');
                
                resultsDiv.innerHTML = '<p>Generating repository map...</p>';
                
                try {
                    const result = await window.aider.getRepoMap();
                    console.log('[GSX Create] Repo map result:', result);
                    
                    if (result.success && result.repo_map) {
                        resultsDiv.innerHTML = `<pre style="margin: 0; color: var(--text-primary);">${this.escapeHtml(result.repo_map)}</pre>`;
                    } else if (result.success) {
                        resultsDiv.innerHTML = '<p style="color: var(--text-muted);">No repository map available</p>';
                    } else {
                        resultsDiv.innerHTML = '<p style="color: var(--danger);">Error: ' + (result.error || 'Failed to generate map') + '</p>';
                    }
                } catch (error) {
                    console.error('[GSX Create] Repo map error:', error);
                    resultsDiv.innerHTML = '<p style="color: var(--danger);">Error: ' + error.message + '</p>';
                }
            },
            
            // Cost Tracking
            async loadCostSummary() {
                try {
                    console.log('[GSX Create] Loading cost summary for space:', this.currentSpaceId);
                    const result = await window.aider.txdbGetSummary(this.currentSpaceId, 30);
                    console.log('[GSX Create] Cost summary result:', result);
                    if (result.success) {
                        this.costSummary = result.summary || { totalCost: 0, totalCalls: 0 };
                        this.updateCostDisplay();
                    } else {
                        console.error('[GSX Create] Cost summary failed:', result.error);
                    }
                } catch (error) {
                    console.error('[GSX Create] Cost load error:', error);
                }
            },
            
            updateCostDisplay() {
                const costBadge = document.getElementById('costBadge');
                const budgetBadge = document.getElementById('budgetBadge');
                const budgetFill = document.getElementById('budgetFill');
                
                if (!costBadge) return;
                
                const total = this.costSummary.totalCost || 0;
                const budget = this.cycleState.cycleBudget;
                
                console.log('[GSX Create] Updating cost display:', total, 'budget:', budget);
                
                // Update cost badge
                costBadge.textContent = '$' + total.toFixed(2);
                costBadge.classList.remove('warning', 'danger');
                
                // Update budget badge
                if (budgetBadge) {
                    budgetBadge.textContent = budget ? '$' + budget.toFixed(2) : '';
                }
                
                // Update progress bar
                if (budgetFill) {
                    if (budget && budget > 0) {
                        const percentage = Math.min((total / budget) * 100, 100);
                        budgetFill.style.width = percentage + '%';
                        budgetFill.classList.remove('warning', 'danger');
                        
                        if (percentage >= 90) {
                            budgetFill.classList.add('danger');
                            costBadge.classList.add('danger');
                        } else if (percentage >= 70) {
                            budgetFill.classList.add('warning');
                            costBadge.classList.add('warning');
                        }
                    } else {
                        budgetFill.style.width = '0%';
                    }
                }
            },
            
            // Show budget modal
            showBudgetModal() {
                const modal = document.getElementById('budgetModal');
                modal.classList.add('active');
                
                // Update current values
                const total = this.costSummary.totalCost || 0;
                const budget = this.cycleState.cycleBudget;
                const buffer = this.cycleState.budgetBuffer || 0;
                
                document.getElementById('budgetCurrentCost').textContent = '$' + total.toFixed(4);
                document.getElementById('budgetLimit').textContent = budget ? '$' + budget.toFixed(2) : ' (No limit)';
                
                // Calculate percentage
                let percentage = 0;
                if (budget && budget > 0) {
                    percentage = Math.min((total / budget) * 100, 100);
                }
                document.getElementById('budgetPercentage').textContent = budget ? percentage.toFixed(1) + '%' : 'N/A';
                document.getElementById('budgetModalFill').style.width = percentage + '%';
                
                // Set input values
                document.getElementById('budgetInput').value = budget || '';
                document.getElementById('budgetBufferInput').value = buffer || '';
                document.getElementById('budgetBufferDisplay').textContent = '$' + buffer.toFixed(2);
                
                // Calculate cycle statistics
                this.updateCycleStatistics();
            },
            
            // Update cycle statistics in budget modal
            async updateCycleStatistics() {
                const cyclesCompleted = this.cycleState.currentVersion - 1;
                const totalCost = this.costSummary.totalCost || 0;
                const budget = this.cycleState.cycleBudget;
                const buffer = this.cycleState.budgetBuffer || 0;
                
                document.getElementById('cyclesCompleted').textContent = cyclesCompleted;
                
                // Calculate average cost per cycle from version history (more accurate)
                let avgCost = 0;
                const versions = this.cycleState.versions || [];
                const versionsWithCost = versions.filter(v => v.cost > 0);
                
                if (versionsWithCost.length > 0) {
                    const totalVersionCost = versionsWithCost.reduce((sum, v) => sum + v.cost, 0);
                    avgCost = totalVersionCost / versionsWithCost.length;
                } else if (cyclesCompleted > 0) {
                    // Fallback to overall average
                    avgCost = totalCost / cyclesCompleted;
                }
                document.getElementById('avgCostPerCycle').textContent = '$' + avgCost.toFixed(4);
                
                // Estimate remaining cycles (accounting for buffer)
                let estRemaining = '';
                if (budget && avgCost > 0) {
                    const availableBudget = budget - buffer - totalCost;
                    const remaining = availableBudget / avgCost;
                    estRemaining = remaining > 0 ? Math.floor(remaining).toString() : '0';
                }
                document.getElementById('estCyclesRemaining').textContent = estRemaining;
            },
            
            // Set budget from input
            setBudget() {
                const input = document.getElementById('budgetInput');
                const value = parseFloat(input.value);
                
                if (isNaN(value) || value <= 0) {
                    this.cycleState.cycleBudget = null;
                    this.addMessage('system', ' Budget limit removed (unlimited)');
                } else {
                    this.cycleState.cycleBudget = value;
                    this.addMessage('system', ` Budget set to $${value.toFixed(2)}`);
                }
                
                this.updateCostDisplay();
                this.closeModal('budgetModal');
            },
            
            // Set quick budget
            setQuickBudget(amount) {
                this.cycleState.cycleBudget = amount;
                document.getElementById('budgetInput').value = amount || '';
                
                if (amount) {
                    this.addMessage('system', ` Budget set to $${amount.toFixed(2)}`);
                } else {
                    this.addMessage('system', ' Budget limit removed (unlimited)');
                }
                
                this.updateCostDisplay();
                this.showBudgetModal(); // Refresh the modal display
            },
            
            // Set budget buffer for fixes
            setBudgetBuffer() {
                const input = document.getElementById('budgetBufferInput');
                const value = parseFloat(input.value);
                
                if (isNaN(value) || value <= 0) {
                    this.cycleState.budgetBuffer = 0;
                    this.addMessage('system', ' Budget buffer removed');
                } else {
                    this.cycleState.budgetBuffer = value;
                    this.addMessage('system', ` Budget buffer set to $${value.toFixed(2)}`);
                }
                
                this.updateCostDisplay();
                this.showBudgetModal(); // Refresh the modal display
            },
            
            // Quick set buffer
            setQuickBudgetBuffer(amount) {
                this.cycleState.budgetBuffer = amount || 0;
                document.getElementById('budgetBufferInput').value = amount || '';
                
                if (amount) {
                    this.addMessage('system', ` Budget buffer set to $${amount.toFixed(2)}`);
                } else {
                    this.addMessage('system', ' Budget buffer removed');
                }
                
                this.updateCostDisplay();
                this.showBudgetModal(); // Refresh the modal display
            },
            
            async recordApiCost(model, inputTokens, outputTokens, type, promptPreview, actualCost = null) {
                let cost = actualCost;
                let costBreakdown = null;
                
                // Use unified pricing API if no actual cost provided
                if (!cost || cost === 0) {
                    try {
                        // Use the unified pricing-config via IPC
                        costBreakdown = await window.aider.pricingCalculate(model, inputTokens, outputTokens);
                        cost = costBreakdown.totalCost;
                    } catch (pricingError) {
                        // Fallback: calculate locally if IPC fails
                        console.warn('[GSX Create] Pricing API failed, using fallback:', pricingError);
                        const fallbackCosts = {
                            'claude-opus-4-5-20251101': { input: 15/1000000, output: 75/1000000 },
                            'claude-sonnet-4-5-20250929': { input: 3/1000000, output: 15/1000000 }
                        };
                        const modelCosts = fallbackCosts[model] || { input: 3/1000000, output: 15/1000000 };
                        cost = (inputTokens * modelCosts.input) + (outputTokens * modelCosts.output);
                    }
                }
                
                console.log('[GSX Create] Recording cost:', { model, inputTokens, outputTokens, cost, wasActual: actualCost !== null });
                
                try {
                    // Record to EventDB (episodic memory) - it will delegate to BudgetManager
                    const result = await window.aider.txdbRecordTransaction({
                        spaceId: this.currentSpaceId,
                        spaceName: this.currentSpaceName,
                        type, 
                        model, 
                        inputTokens, 
                        outputTokens, 
                        cost,
                        feature: 'gsx-create',
                        status: 'success',
                        promptPreview: promptPreview ? String(promptPreview).substring(0, 200) : '',
                        costBreakdown
                    });
                        
                    console.log('[GSX Create] Cost record result:', result);
                    
                    // Update local display
                    this.costSummary.totalCost = (this.costSummary.totalCost || 0) + cost;
                    this.costSummary.totalCalls = (this.costSummary.totalCalls || 0) + 1;
                    this.updateCostDisplay();
                    this.loadEpisodicMemory(); // Refresh sidebar
                } catch (error) {
                    console.error('[GSX Create] Cost record error:', error);
                }
            },
            
            // Helper to track cost for a task based on prompt/response
            async trackTaskCost(prompt, response, type = 'task') {
                const model = document.getElementById('modelSelect')?.value || 'claude-opus-4-5-20251101';
                
                // Ensure prompt and response are strings
                const safePrompt = String(prompt || '');
                const safeResponse = String(response || '');
                
                // Try to parse actual token counts from Aider's output
                let inputTokens = 0;
                let outputTokens = 0;
                let actualCost = 0;
                
                // Look for "Tokens: 15k sent, 2.1k received. Cost: $0.08 message"
                const tokenMatch = safeResponse.match(/Tokens:\s*([\d.]+)k?\s*sent,\s*([\d.]+)k?\s*received/i);
                const costMatch = safeResponse.match(/Cost:\s*\$([\d.]+)\s*message/i);
                
                if (tokenMatch) {
                    inputTokens = parseFloat(tokenMatch[1]);
                    outputTokens = parseFloat(tokenMatch[2]);
                    // Handle "15k" format
                    if (safeResponse.match(/[\d.]+k\s*sent/i)) inputTokens *= 1000;
                    if (safeResponse.match(/[\d.]+k\s*received/i)) outputTokens *= 1000;
                }
                
                if (costMatch) {
                    actualCost = parseFloat(costMatch[1]);
                }
                
                // Fallback to estimates if parsing failed
                if (inputTokens === 0) inputTokens = Math.ceil(safePrompt.length / 4);
                if (outputTokens === 0) outputTokens = Math.ceil(safeResponse.length / 4);
                
                // Record the cost
                await this.recordApiCost(model, inputTokens, outputTokens, type, safePrompt.substring(0, 100), actualCost);
            },
            
            async showTransactionLogs() {
                const modal = document.getElementById('logModal');
                const tbody = document.getElementById('logTableBody');
                
                modal.classList.add('active');
                tbody.innerHTML = '<tr><td colspan="6">Loading...</td></tr>';
                
                try {
                    const result = await window.aider.txdbGetTransactions({ spaceId: this.currentSpaceId, limit: 100 });
                    
                    if (result.success && result.transactions.length > 0) {
                        tbody.innerHTML = result.transactions.map(tx => `
                            <tr>
                                <td>${new Date(tx.timestamp).toLocaleString()}</td>
                                <td>${tx.type}</td>
                                <td>${tx.model || '-'}</td>
                                <td>${tx.input_tokens || 0}/${tx.output_tokens || 0}</td>
                                <td>$${(tx.cost || 0).toFixed(6)}</td>
                                <td style="color: ${tx.status === 'success' ? 'var(--success)' : 'var(--danger)'}">${tx.status}</td>
                            </tr>
                        `).join('');
                    } else {
                        tbody.innerHTML = '<tr><td colspan="6" style="text-align: center;">No transactions yet</td></tr>';
                    }
                } catch (error) {
                    tbody.innerHTML = `<tr><td colspan="6" style="color: var(--danger);">Error: ${error.message}</td></tr>`;
                }
            },
            
            // Episodic Memory - Todo list state
            todos: [],
            
            // Load Episodic Memory for sidebar (History tab)
            async loadEpisodicMemory() {
                const listEl = document.getElementById('episodicMemoryList');
                const countEl = document.getElementById('historyCount');
                
                if (!listEl) return;
                
                try {
                    const result = await window.aider.txdbGetTransactions({ spaceId: this.currentSpaceId, limit: 10 });
                    
                    if (result.success && result.transactions && result.transactions.length > 0) {
                        if (countEl) countEl.textContent = result.transactions.length;
                        
                        listEl.innerHTML = result.transactions.map(tx => {
                            const time = new Date(tx.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                            const statusIcon = tx.status === 'success' ? '' : '';
                            const statusColor = tx.status === 'success' ? 'var(--success)' : 'var(--danger)';
                            const cost = tx.cost ? `$${tx.cost.toFixed(4)}` : '';
                            const typeLabel = tx.type === 'chat' ? '' : tx.type === 'code' ? '' : '';
                            
                            return `
                                <div class="episodic-item" style="padding: 6px 8px; margin-bottom: 4px; background: var(--bg-tertiary); border-radius: 4px; font-size: 10px; cursor: pointer;" onclick="GSXCreate.showTransactionLogs()">
                                    <div style="display: flex; justify-content: space-between; align-items: center;">
                                        <span>${typeLabel} <span style="color: ${statusColor};">${statusIcon}</span></span>
                                        <span style="color: var(--text-muted);">${time}</span>
                                    </div>
                                    <div style="display: flex; justify-content: space-between; margin-top: 2px; color: var(--text-secondary);">
                                        <span>${tx.input_tokens || 0}/${tx.output_tokens || 0} tokens</span>
                                        <span style="color: var(--accent);">${cost}</span>
                                    </div>
                                </div>
                            `;
                        }).join('');
                    } else {
                        if (countEl) countEl.textContent = '0';
                        listEl.innerHTML = '<div style="color: var(--text-muted); font-size: 11px;">No history yet</div>';
                    }
                } catch (error) {
                    console.error('[GSX Create] Load episodic memory error:', error);
                    listEl.innerHTML = '<div style="color: var(--text-muted); font-size: 11px;">No history yet</div>';
                }
                
                // Also load todos
                this.loadTodos();
            },
            
            // Switch between History and Plan tabs
            switchEpisodicTab(tab) {
                const historyPanel = document.getElementById('historyPanel');
                const planPanel = document.getElementById('planPanel');
                const historyTab = document.getElementById('historyTab');
                const planTab = document.getElementById('planTab');
                
                if (tab === 'history') {
                    historyPanel.style.display = 'block';
                    planPanel.style.display = 'none';
                    historyTab.classList.add('active');
                    planTab.classList.remove('active');
                } else {
                    historyPanel.style.display = 'none';
                    planPanel.style.display = 'block';
                    historyTab.classList.remove('active');
                    planTab.classList.add('active');
                }
            },
            
            // Load todos from storage
            loadTodos() {
                const storageKey = `gsx-todos-${this.currentSpaceId || 'default'}`;
                const stored = localStorage.getItem(storageKey);
                this.todos = stored ? JSON.parse(stored) : [];
                this.renderTodos();
            },
            
            // Save todos to storage
            saveTodos() {
                const storageKey = `gsx-todos-${this.currentSpaceId || 'default'}`;
                localStorage.setItem(storageKey, JSON.stringify(this.todos));
            },
            
            // ========== TASK QUEUE PERSISTENCE ==========
            
            // Load task queue from storage
            loadTaskQueue() {
                if (!this.currentSpaceId) {
                    console.log('[TaskQueue] No space selected, skipping load');
                    return;
                }
                
                try {
                    const storageKey = `gsx-taskqueue-${this.currentSpaceId}`;
                    const stored = localStorage.getItem(storageKey);
                    
                    if (stored) {
                        const parsed = JSON.parse(stored);
                        // Filter out completed tasks older than 24 hours to prevent bloat
                        const oneDayAgo = Date.now() - (24 * 60 * 60 * 1000);
                        this.taskQueue = parsed.filter(task => {
                            if (task.status === 'completed' && task.completedAt) {
                                return new Date(task.completedAt).getTime() > oneDayAgo;
                            }
                            return true;
                        });
                        
                        // Reset any "running" tasks to "pending" (they were interrupted)
                        this.taskQueue.forEach(task => {
                            if (task.status === 'running') {
                                task.status = 'pending';
                            }
                        });
                        
                        // Update stats
                        this.queueStats.total = this.taskQueue.length;
                        this.queueStats.completed = this.taskQueue.filter(t => t.status === 'completed').length;
                        
                        console.log('[TaskQueue] Loaded', this.taskQueue.length, 'tasks from storage');
                    } else {
                        this.taskQueue = [];
                        console.log('[TaskQueue] No saved queue, starting fresh');
                    }
                    
                    this.renderTaskQueue();
                } catch (error) {
                    console.error('[TaskQueue] Failed to load:', error);
                    this.taskQueue = [];
                }
            },
            
            // Save task queue to storage
            saveTaskQueue() {
                if (!this.currentSpaceId) return;
                
                try {
                    const storageKey = `gsx-taskqueue-${this.currentSpaceId}`;
                    // Only save pending and recently completed tasks
                    const tasksToSave = this.taskQueue.filter(task => {
                        if (task.status === 'completed') {
                            // Keep completed tasks from last 24 hours
                            const oneDayAgo = Date.now() - (24 * 60 * 60 * 1000);
                            return task.completedAt && new Date(task.completedAt).getTime() > oneDayAgo;
                        }
                        return task.status === 'pending' || task.status === 'running';
                    });
                    localStorage.setItem(storageKey, JSON.stringify(tasksToSave));
                } catch (error) {
                    console.error('[TaskQueue] Failed to save:', error);
                }
            },
            
            // Add a new todo
            addTodo() {
                const input = document.getElementById('newTodoInput');
                const text = input.value.trim();
                
                if (!text) return;
                
                this.todos.unshift({
                    id: Date.now(),
                    text: text,
                    done: false,
                    created: new Date().toISOString()
                });
                
                input.value = '';
                this.saveTodos();
                this.renderTodos();
            },
            
            // Toggle todo completion
            toggleTodo(id) {
                const todo = this.todos.find(t => t.id === id);
                if (todo) {
                    todo.done = !todo.done;
                    if (todo.done) {
                        todo.completed = new Date().toISOString();
                    }
                    this.saveTodos();
                    this.renderTodos();
                }
            },
            
            // Remove a todo
            removeTodo(id) {
                this.todos = this.todos.filter(t => t.id !== id);
                this.saveTodos();
                this.renderTodos();
            },
            
            // Render todos list
            renderTodos() {
                const listEl = document.getElementById('todoList');
                const countEl = document.getElementById('planCount');
                
                if (!listEl) return;
                
                const pendingCount = this.todos.filter(t => !t.done).length;
                if (countEl) countEl.textContent = pendingCount;
                
                if (this.todos.length === 0) {
                    listEl.innerHTML = '<div style="color: var(--text-muted); font-size: 11px;">No tasks planned</div>';
                    return;
                }
                
                listEl.innerHTML = this.todos.map(todo => {
                    const cycleIndicator = todo.fromCycle ? '<span style="color: var(--accent); margin-right: 4px;" title="From Meta Learning Cycle"></span>' : '';
                    return `
                    <div class="todo-item" style="padding: 4px 6px; margin-bottom: 3px; background: var(--bg-tertiary); border-radius: 4px; font-size: 10px; display: flex; align-items: center; gap: 6px; ${todo.done ? 'opacity: 0.5;' : ''} ${todo.fromCycle ? 'border-left: 2px solid var(--accent);' : ''}">
                        <input type="checkbox" ${todo.done ? 'checked' : ''} onchange="GSXCreate.toggleTodo(${todo.id})" style="margin: 0; cursor: pointer;">
                        <span style="flex: 1; ${todo.done ? 'text-decoration: line-through;' : ''}">${cycleIndicator}${todo.text}</span>
                        <button onclick="GSXCreate.removeTodo(${todo.id})" style="background: none; border: none; color: var(--text-muted); cursor: pointer; padding: 0; font-size: 12px;" title="Remove"></button>
                    </div>
                `}).join('');
            },
            
            // Mark a cycle task as complete in Episodic Memory
            markCycleTaskComplete(taskText) {
                const todo = this.todos.find(t => t.text === taskText && !t.done);
                if (todo) {
                    todo.done = true;
                    todo.completed = new Date().toISOString();
                    this.saveTodos();
                    this.renderTodos();
                }
            },
            
            // Show event logs (errors, warnings, info)
            async showEventLogs() {
                try {
                    const result = await window.aider.txdbGetEventLogs({ limit: 50 });
                    
                    if (!result.success || !result.logs || result.logs.length === 0) {
                        this.addMessage('system', ' No event logs found');
                        return;
                    }
                    
                    // Build HTML for logs
                    const logsHtml = result.logs.map(log => {
                        const typeIcon = log.type === 'error' ? '' : log.type === 'warning' ? '' : '';
                        const time = new Date(log.timestamp).toLocaleString();
                        const summary = log.summary || log.message?.substring(0, 50) || 'No summary';
                        
                        return `
                            <div style="padding: 10px; margin-bottom: 8px; background: var(--bg-tertiary); border-radius: 6px; border-left: 3px solid ${log.type === 'error' ? 'var(--danger)' : log.type === 'warning' ? 'var(--warning)' : 'var(--accent)'};">
                                <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                                    <span style="font-weight: 500;">${typeIcon} ${summary}</span>
                                    <span style="font-size: 10px; color: var(--text-muted);">${time}</span>
                                </div>
                                ${log.aiSummary ? `<div style="font-size: 11px; color: var(--text-secondary); margin-top: 6px;">${log.aiSummary.substring(0, 200)}...</div>` : ''}
                                ${log.userNotes ? `<div style="font-size: 11px; color: var(--accent); margin-top: 4px;"> ${log.userNotes}</div>` : ''}
                            </div>
                        `;
                    }).join('');
                    
                    // Show in a modal or chat
                    const html = `
                        <div style="max-height: 400px; overflow-y: auto;">
                            <div style="font-size: 13px; font-weight: 600; margin-bottom: 12px;"> Event Logs (${result.logs.length})</div>
                            ${logsHtml}
                        </div>
                    `;
                    
                    this.addMessage('system', html, null, true);
                    
                } catch (error) {
                    console.error('[GSX Create] Show event logs error:', error);
                    this.addMessage('error', `Failed to load event logs: ${error.message}`);
                }
            },
            
            // Global Instructions
            async loadGlobalInstructions() {
                const key = `gsx-global-instructions-${this.currentSpaceId}`;
                this.globalInstructionsText = localStorage.getItem(key) || '';
                document.getElementById('globalInstructions').value = this.globalInstructionsText;
            },
            
            saveGlobalInstructions() {
                const text = document.getElementById('globalInstructions').value;
                this.globalInstructionsText = text;
                const key = `gsx-global-instructions-${this.currentSpaceId}`;
                localStorage.setItem(key, text);
                this.addMessage('system', 'Global instructions saved');
            },
            
            // Load Cycle State from storage
            async loadCycleState() {
                
                if (!this.currentSpaceId) {
                    console.log('[GSX Create] No space selected, skipping cycle state load');
                    return;
                }
                
                try {
                    const key = `gsx-cycle-state-${this.currentSpaceId}`;
                    const savedState = localStorage.getItem(key);
                    
                    if (savedState) {
                        const parsed = JSON.parse(savedState);
                        // Merge saved state with defaults (to handle new properties)
                        this.cycleState = {
                            ...this.cycleState,  // Keep defaults
                            ...parsed,           // Override with saved values
                            active: false,       // Always start inactive
                            paused: false        // Always start unpaused
                        };

                        // Guardrails: normalize versions array and ensure entries are well-formed
                        if (!Array.isArray(this.cycleState.versions)) this.cycleState.versions = [];
                        const byVersion = new Map();
                        this.cycleState.versions.forEach(v => {
                            const num = Number(v && v.version) || null;
                            if (!num) return;
                            // Merge with default shape used by the Version Timeline
                            const merged = {
                                version: num,
                                timestamp: null,
                                objective: null,
                                releaseNotes: '',
                                phaseSummary: '',
                                score: null,
                                scoreDelta: null,
                                cost: null,
                                costAtStart: null,
                                costAtEnd: null,
                                costDelta: null,
                                testsSummary: '',
                                filesChanged: [],
                                ...(v || {})
                            };
                            // Normalize arrays
                            if (!Array.isArray(merged.filesChanged)) merged.filesChanged = [];
                            byVersion.set(num, merged);
                        });
                        this.cycleState.versions = Array.from(byVersion.values()).sort((a, b) => Number(a.version) - Number(b.version));
                        // Ensure placeholders exist up to currentVersion
                        const maxV = Math.max(Number(this.cycleState.currentVersion) || 1, 1);
                        for (let i = 1; i <= maxV; i++) this.ensureVersionEntry(i);
                        console.log('[GSX Create] Cycle state loaded:', {
                            version: this.cycleState.currentVersion,
                            score: this.cycleState.currentScore,
                            objective: this.cycleState.objective?.substring(0, 50)
                        });
                    } else {
                        // Reset to defaults for new space
                        this.cycleState.currentVersion = 1;
                        this.cycleState.currentScore = 0;
                        this.cycleState.objective = null;
                        this.cycleState.todos = [];
                        console.log('[GSX Create] No saved cycle state, using defaults');
                    }
                    
                    // Update UI to reflect loaded state
                    this.updateCycleUI();
                    
                    
                } catch (error) {
                    console.error('[GSX Create] Failed to load cycle state:', error);
                }
            },
            
            // Save Cycle State to storage
            saveCycleState() {
                if (!this.currentSpaceId) return;
                
                try {
                    const key = `gsx-cycle-state-${this.currentSpaceId}`;
                    const stateToSave = {
                        currentVersion: this.cycleState.currentVersion,
                        currentScore: this.cycleState.currentScore,
                        objective: this.cycleState.objective,
                        todos: this.cycleState.todos,
                        targetScore: this.cycleState.targetScore,
                        cycleBudget: this.cycleState.cycleBudget,
                        versions: this.cycleState.versions,
                        parallelCount: this.cycleState.parallelCount
                    };
                    localStorage.setItem(key, JSON.stringify(stateToSave));
                } catch (error) {
                    console.error('[GSX Create] Failed to save cycle state:', error);
                }
            },
            
            // ========== GRACEFUL SHUTDOWN ==========
            
            // Save all state for graceful shutdown
            saveAllStateForShutdown() {
                console.log('[GSX Create] Saving all state for shutdown...');
                
                try {
                    // Save task queue
                    this.saveTaskQueue();
                    
                    // Save cycle state
                    this.saveCycleState();
                    
                    // Save todos
                    this.saveTodos();
                    
                    // Save global instructions
                    const instructionsEl = document.getElementById('globalInstructions');
                    if (instructionsEl && this.currentSpaceId) {
                        const key = `gsx-global-instructions-${this.currentSpaceId}`;
                        localStorage.setItem(key, instructionsEl.value);
                    }
                    
                    console.log('[GSX Create] All state saved');
                } catch (error) {
                    console.error('[GSX Create] Error saving state for shutdown:', error);
                }
            },
            
            // Handle graceful shutdown request from main process
            handleShutdownRequest() {
                console.log('[GSX Create] Shutdown request received');
                
                // Save all state
                this.saveAllStateForShutdown();
                
                // Signal ready to close
                if (window.aider && window.aider.sendShutdownReady) {
                    window.aider.sendShutdownReady();
                }
            },
            
            // Set up shutdown listener
            setupShutdownListener() {
                if (window.aider && window.aider.onShutdownRequest) {
                    window.aider.onShutdownRequest(() => {
                        this.handleShutdownRequest();
                    });
                    console.log('[GSX Create] Shutdown listener registered');
                }
            },
            
            // ========== VERSION BACKUP SYSTEM ==========
            
            // Load available version backups
            async loadVersionBackups() {
                if (!this.repoPath) return;
                
                try {
                    const result = await window.aider.listBackups(this.repoPath);
                    if (result.success) {
                        this.cycleState.backups = result.backups || [];
                        console.log('[GSX Create] Loaded backups:', this.cycleState.backups.length);
                        this.renderVersionBackups();
                    }
                } catch (error) {
                    console.error('[GSX Create] Load backups error:', error);
                }
            },
            
            // Render version backups in the version timeline
            renderVersionBackups() {
                const timeline = document.getElementById('versionTimeline');
                if (!timeline) return;
                
                const backups = this.cycleState.backups || [];
                const currentVersion = this.cycleState.currentVersion || 1;
                
                // Create version pills including backups
                const versions = [];
                for (let i = 1; i <= currentVersion; i++) {
                    const backup = backups.find(b => Number(b.version) === i);
                    versions.push({
                        version: i,
                        hasBackup: !!backup,
                        score: backup?.score || 0,
                        timestamp: backup?.timestamp || null
                    });
                }
                
                timeline.innerHTML = versions.map(v => `
                    <div class="version-pill ${v.version === currentVersion ? 'active' : ''} ${v.hasBackup ? 'has-backup' : ''}" 
                         onclick="GSXCreate.showVersionTimeline(${v.version})"
                         title="${v.hasBackup ? `v${v.version} - Score: ${v.score}% (backed up)` : `v${v.version}`}">
                        v${v.version}
                        ${v.hasBackup ? '<span style="font-size: 8px; margin-left: 2px;"></span>' : ''}
                    </div>
                `).join('');
            },
            
            // Restore to a specific version
            async restoreVersion(version) {
                if (!this.repoPath) {
                    this.addMessage('error', 'No project loaded');
                    return;
                }
                
                const backup = this.cycleState.backups.find(b => Number(b.version) === Number(version));
                if (!backup) {
                    this.addMessage('error', `No backup found for v${version}`);
                    return;
                }
                
                // Confirm with user
                const currentVersion = this.cycleState.currentVersion;
                if (!confirm(`Restore to v${version}?\n\nThis will replace current files with v${version} backup.\nCurrent version: v${currentVersion}\n\nContinue?`)) {
                    return;
                }
                
                this.addMessage('system', ` Restoring to v${version}...`);
                
                try {
                    // First backup current state if it's newer
                    if (currentVersion > version) {
                        this.addMessage('system', `    Backing up current v${currentVersion} first...`);
                        await window.aider.backupVersion(this.repoPath, currentVersion, {
                            score: this.cycleState.currentScore,
                            objective: this.cycleState.objective,
                            model: this.selectedModel
                        });
                    }
                    
                    // Restore the selected version
                    const result = await window.aider.restoreVersion(this.repoPath, version);
                    
                    if (result.success) {
                        this.addMessage('system', `    Restored ${result.files?.length || 0} files from v${version}`);
                        
                        // Update cycle state to reflect restored version
                        this.cycleState.currentVersion = Number(version);
                        this.cycleState.currentScore = backup.score || 0;
                        this.cycleState.objective = backup.objective || this.cycleState.objective;
                        this.saveCycleState();
                        
                        // Refresh UI
                        await this.loadProjectFiles();
                        this.updateCycleUI();
                        this.renderVersionBackups();
                        
                        // Refresh preview if one is open
                        if (this.currentPreviewFile) {
                            await this.refreshPreview();
                        }
                        
                        this.addMessage('system', ` Successfully restored to v${version}`);
                    } else {
                        this.addMessage('error', `Restore failed: ${result.error}`);
                    }
                } catch (error) {
                    console.error('[GSX Create] Restore error:', error);
                    this.addMessage('error', `Restore failed: ${error.message}`);
                }
            },
            
            // Quick switch to view a version (without full restore)
            async previewVersion(version) {
                const backup = this.cycleState.backups.find(b => Number(b.version) === Number(version));
                if (!backup) {
                    this.addMessage('system', `No backup for v${version} to preview`);
                    return;
                }
                
                // Show version info
                const info = [
                    ` **Version ${version} Info:**`,
                    `   Score: ${backup.score || 0}%`,
                    `   Objective: ${backup.objective || 'Not set'}`,
                    `   Model: ${backup.model || 'Unknown'}`,
                    `   Created: ${backup.timestamp ? new Date(backup.timestamp).toLocaleString() : 'Unknown'}`,
                    `   Files: ${backup.files?.length || 0}`,
                    '',
                    `   [Restore v${version}] to switch to this version`
                ].join('\n');
                
                this.addMessage('system', info);
            },
            
            // ========== BRANCH SYSTEM FOR PARALLEL VERSIONS ==========
            
            // Load active branches
            async loadBranches() {
                if (!this.repoPath) return;
                
                this.logBranchEvent('load:start', { action: 'loadBranches' });
                
                try {
                    const result = await window.aider.listBranches(this.repoPath);
                    if (result.success) {
                        const previousCount = this.cycleState.branches?.length || 0;
                        this.cycleState.branches = result.branches || [];
                        
                        this.logBranchEvent('load:success', { 
                            action: 'loadBranches',
                            previousCount,
                            newCount: this.cycleState.branches.length,
                            branchIds: this.cycleState.branches.map(b => b.branchId)
                        });
                        
                        console.log('[GSX Create] Loaded branches:', this.cycleState.branches.length);
                        this.renderBranchTabs();
                        this.renderMultiProgress();
                        
                        // Start sync if we have branches
                        if (this.cycleState.branches.length > 0) {
                            this.startBranchSync();
                        } else {
                            this.stopBranchSync();
                        }
                    } else {
                        this.logBranchEvent('load:failed', { 
                            action: 'loadBranches',
                            error: result.error || 'Unknown error'
                        });
                    }
                } catch (error) {
                    this.logBranchEvent('load:error', { 
                        action: 'loadBranches',
                        error: error.message,
                        stack: error.stack
                    });
                    console.error('[GSX Create] Load branches error:', error);
                }
            },
            
            // Create parallel branches for exploration
            async createParallelBranches(approaches) {
                if (!this.repoPath) {
                    this.logBranchEvent('create:rejected', { 
                        action: 'createParallelBranches',
                        reason: 'No project loaded'
                    });
                    this.addMessage('error', 'No project loaded');
                    return [];
                }
                
                const version = this.cycleState.currentVersion;
                const branchCount = Math.min(approaches.length, this.cycleState.parallelCount || 2);
                
                this.logBranchEvent('create:start', { 
                    action: 'createParallelBranches',
                    version,
                    approachCount: approaches.length,
                    branchCount,
                    parallelCount: this.cycleState.parallelCount,
                    approaches: approaches.map(a => ({
                        title: a.title,
                        focus: a.focus,
                        complexity: a.complexity,
                        model: a.model
                    }))
                });
                
                this.addMessage('system', ` Creating ${branchCount} parallel branches for v${version}...`);
                
                const createdBranches = [];
                
                for (let i = 0; i < branchCount; i++) {
                    const approach = approaches[i];
                    const branchId = `v${version}.${i + 1}`;
                    
                    // Full branch metadata including approach info
                    const branchData = {
                        branchId: branchId,
                        title: approach.title || `Approach ${i + 1}`,
                        description: approach.description || '',
                        focus: approach.focus || '',
                        complexity: approach.complexity || 'medium',
                        model: approach.model || this.selectedModel,
                        instructions: approach.instructions || '',
                        parentVersion: version,
                        status: 'pending',
                        progress: 0,
                        currentPhase: null,
                        totalCost: 0,
                        costByPhase: {},
                        createdAt: new Date().toISOString()
                    };
                    
                    this.logBranchEvent('create:branch:attempt', { 
                        action: 'createBranch',
                        branchId,
                        branchIndex: i,
                        title: branchData.title,
                        focus: branchData.focus,
                        model: branchData.model
                    });
                    
                    try {
                        const result = await window.aider.createBranch(this.repoPath, branchId, branchData);
                        
                        if (result.success) {
                            createdBranches.push(branchData);
                            this.logBranchEvent('create:branch:success', { 
                                action: 'createBranch',
                                branchId,
                                title: branchData.title
                            });
                            this.addMessage('system', `    Branch ${branchId}: ${approach.title}`);
                        } else {
                            this.logBranchEvent('create:branch:failed', { 
                                action: 'createBranch',
                                branchId,
                                error: result.error
                            });
                            this.addMessage('error', `    Failed to create ${branchId}: ${result.error}`);
                        }
                    } catch (error) {
                        this.logBranchEvent('create:branch:error', { 
                            action: 'createBranch',
                            branchId,
                            error: error.message,
                            stack: error.stack
                        });
                        console.error('[GSX Create] Branch creation error:', error);
                        this.addMessage('error', `    Error creating ${branchId}: ${error.message}`);
                    }
                }
                
                // Add branches to local state immediately (don't wait for loadBranches)
                console.log('[GSX Create] createParallelBranches: Adding', createdBranches.length, 'branches to state');
                console.log('[GSX Create] createParallelBranches: Branch IDs:', createdBranches.map(b => b.branchId));
                
                this.cycleState.branches = [...(this.cycleState.branches || []), ...createdBranches];
                console.log('[GSX Create] createParallelBranches: Total branches now:', this.cycleState.branches.length);
                
                
                // Create chat tabs for each new branch
                createdBranches.forEach((branch, i) => {
                    const icons = ['', '', '', '', ''];
                    const icon = icons[i % icons.length];
                    this.createBranchChatTab(branch.branchId, branch.title || branch.branchId, icon);
                });
                
                this.logBranchEvent('create:complete', { 
                    action: 'createParallelBranches',
                    createdCount: createdBranches.length,
                    totalBranches: this.cycleState.branches.length,
                    createdBranchIds: createdBranches.map(b => b.branchId)
                });
                
                this.saveCycleState();
                
                // Update the timeline display
                this.renderBranchTimeline();
                
                return createdBranches;
            },
            
            // Phase definitions with order for progress calculation
            phaseOrder: ['evaluate', 'research', 'plan', 'execute', 'test', 'improve', 'finalize'],
            
            // Render Gantt-style branch timeline - DEPRECATED
            // Now using tabbed UI where each branch has its own tab
            renderBranchTimeline() {
                // DEPRECATED: This function is no longer used.
                // Branch management is now handled by TabManager.
                // Each branch gets its own independent tab.
                return;
                
                // Legacy code below (kept for reference):
                const controlPanel = document.getElementById('branchControlPanel');
                const timeline = document.getElementById('branchTimeline');
                if (!controlPanel || !timeline) return;
                
                const branches = this.cycleState.branches || [];
                const focusedBranchId = this.cycleState.focusedBranch || 'main';
                
                // Debug logging
                console.log('[GSX Create] renderBranchTimeline: branches count =', branches.length, 'branches:', branches.map(b => b.branchId));
                
                // Show panel when session is active (has repoPath) or has branches
                // This lets users see the timeline even before starting parallel branches
                if (!this.repoPath && branches.length === 0) {
                    controlPanel.classList.remove('visible');
                    return;
                }
                
                controlPanel.classList.add('visible');
                
                // Update budget indicator
                this.updateBranchBudgetDisplay();
                
                // Build main branch row
                const mainScore = this.cycleState.currentScore || 0;
                const mainCost = this.cycleState.mainCost || 0;
                
                // Build all branch rows
                const allBranches = [
                    {
                        branchId: 'main',
                        title: 'Main',
                        status: 'completed',
                        currentPhase: 'finalize',
                        progress: 100,
                        totalCost: mainCost,
                        model: this.selectedModel,
                        costByPhase: this.cycleState.mainCostByPhase || {},
                        isMain: true
                    },
                    ...branches
                ];
                
                timeline.innerHTML = allBranches.map(b => {
                    const isFocused = focusedBranchId === b.branchId;
                    const isMain = b.isMain || b.branchId === 'main';
                    const status = b.status || 'pending';
                    const currentPhase = b.currentPhase || 'evaluate';
                    const totalCost = b.totalCost || 0;
                    
                    // Calculate cost class
                    let costClass = '';
                    if (totalCost > 0.5) costClass = 'very-high';
                    else if (totalCost > 0.2) costClass = 'high';
                    
                    // Build phase segments
                    const phaseSegments = this.phaseOrder.map(phase => {
                        const phaseIndex = this.phaseOrder.indexOf(phase);
                        const currentIndex = this.phaseOrder.indexOf(currentPhase);
                        let segmentClass = 'pending';
                        if (phaseIndex < currentIndex || status === 'completed') segmentClass = 'completed';
                        else if (phaseIndex === currentIndex && status !== 'completed') segmentClass = 'current';
                        
                        return `<div class="phase-segment ${phase} ${segmentClass}" 
                                     style="flex: 1;" 
                                     title="${phase}"></div>`;
                    }).join('');
                    
                    // Status label
                    let statusLabel = currentPhase;
                    let statusClass = 'running';
                    if (status === 'completed') { statusLabel = 'Done'; statusClass = 'completed'; }
                    else if (status === 'failed') { statusLabel = 'Failed'; statusClass = 'failed'; }
                    else if (status === 'pending') { statusLabel = 'Queued'; statusClass = ''; }
                    
                    // Actions (only for non-main branches)
                    const actions = isMain ? '' : `
                        <div class="branch-actions">
                            ${status === 'completed' ? `<button class="promote" onclick="event.stopPropagation(); GSXCreate.promoteBranch('${b.branchId}')" title="Promote to main"></button>` : ''}
                            <button class="delete" onclick="event.stopPropagation(); GSXCreate.deleteBranch('${b.branchId}')" title="Delete"></button>
                        </div>
                    `;
                    
                    // Tooltip with rationale (for parallel branches)
                    const description = b.description || '';
                    const focus = b.focus || '';
                    const tooltip = (!isMain && (description || focus)) ? `
                        <div class="branch-tooltip">
                            <div class="tooltip-title">${this.escapeHtml(b.title || b.branchId)}</div>
                            ${description ? `<div class="tooltip-desc">${this.escapeHtml(description)}</div>` : ''}
                            ${focus ? `<div class="tooltip-focus"><span>${this.escapeHtml(focus)}</span> ${b.complexity || ''}</div>` : ''}
                        </div>
                    ` : '';
                    
                    return `
                        <div class="branch-row ${isFocused ? 'focused' : ''} ${isMain ? 'main-branch' : ''}"
                             onclick="GSXCreate.focusBranch('${b.branchId}')"
                             ondblclick="GSXCreate.showBranchComparison('${b.branchId}')">
                            ${tooltip}
                            <div class="branch-selector"></div>
                            <span class="branch-name" title="${b.title || b.branchId}">${isMain ? ' Main' : b.title || b.branchId}</span>
                            <div class="branch-gantt-bar">
                                ${phaseSegments}
                            </div>
                            <span class="branch-cost ${costClass}">$${totalCost.toFixed(2)}</span>
                            <span class="branch-phase-label ${statusClass}">${statusLabel}</span>
                            ${actions}
                        </div>
                    `;
                }).join('');
                
                // Also update cost breakdown for focused branch
                this.renderCostBreakdown(focusedBranchId);
            },
            
            // Update the budget display in the branch control panel header
            updateBranchBudgetDisplay() {
                const branches = this.cycleState.branches || [];
                const totalSpent = (this.cycleState.mainCost || 0) + 
                    branches.reduce((sum, b) => sum + (b.totalCost || 0), 0);
                const budget = this.budgetAmount || 5;
                const percentage = Math.min((totalSpent / budget) * 100, 100);
                
                const spentEl = document.getElementById('branchBudgetSpent');
                const totalEl = document.getElementById('branchBudgetTotal');
                const fillEl = document.getElementById('branchBudgetFill');
                
                if (spentEl) spentEl.textContent = `$${totalSpent.toFixed(2)}`;
                if (totalEl) totalEl.textContent = `$${budget.toFixed(2)}`;
                if (fillEl) {
                    fillEl.style.width = `${percentage}%`;
                    fillEl.classList.remove('warning', 'danger');
                    if (percentage > 90) fillEl.classList.add('danger');
                    else if (percentage > 70) fillEl.classList.add('warning');
                }
            },
            
            // Render cost breakdown for a specific branch
            renderCostBreakdown(branchId) {
                const panel = document.getElementById('costBreakdownPanel');
                const nameEl = document.getElementById('focusedBranchName');
                const modelEl = document.getElementById('focusedBranchModel');
                const grid = document.getElementById('costBreakdownGrid');
                if (!panel || !grid) return;
                
                let branch;
                if (branchId === 'main') {
                    branch = {
                        title: 'Main',
                        model: this.selectedModel,
                        currentPhase: 'finalize',
                        costByPhase: this.cycleState.mainCostByPhase || {},
                        description: 'Primary development branch',
                        focus: 'Main'
                    };
                } else {
                    branch = this.cycleState.branches?.find(b => b.branchId === branchId);
                }
                
                if (!branch) {
                    panel.classList.remove('visible');
                    return;
                }
                
                panel.classList.add('visible');
                if (nameEl) nameEl.textContent = branch.title || branchId;
                if (modelEl) modelEl.textContent = branch.model || 'Unknown';
                
                // Add rationale section before the cost grid
                let rationaleHtml = '';
                if (branch.description || branch.focus) {
                    rationaleHtml = `
                        <div class="branch-rationale">
                            ${branch.focus ? `<span class="focus-tag">${this.escapeHtml(branch.focus)}</span>` : ''}
                            ${branch.description ? this.escapeHtml(branch.description) : ''}
                            ${branch.instructions ? `<div style="margin-top: 6px; font-size: 10px; color: var(--text-muted); font-style: italic;"> ${this.escapeHtml(branch.instructions)}</div>` : ''}
                        </div>
                    `;
                }
                
                const costByPhase = branch.costByPhase || {};
                const currentPhase = branch.currentPhase || 'evaluate';
                
                const costGridHtml = this.phaseOrder.map(phase => {
                    const cost = costByPhase[phase] || 0;
                    const isCurrent = phase === currentPhase;
                    return `
                        <div class="cost-breakdown-item ${isCurrent ? 'current' : ''}">
                            <div class="phase-name">${phase.substring(0, 4)}</div>
                            <div class="phase-cost">$${cost.toFixed(3)}</div>
                        </div>
                    `;
                }).join('');
                
                grid.innerHTML = rationaleHtml + `<div class="cost-breakdown-grid">${costGridHtml}</div>`;
            },
            
            // Legacy alias for backward compatibility
            renderBranchTabs() {
                this.renderBranchTimeline();
            },
            
            // Focus on a specific branch (for preview and cost breakdown)
            async focusBranch(branchId) {
                const previousFocus = this.cycleState.focusedBranch;
                this.cycleState.focusedBranch = branchId;
                this.cycleState.activeBranch = branchId === 'main' ? null : branchId;
                
                // Log focus change
                if (previousFocus !== branchId) {
                    this.logBranchEvent('focus:change', { 
                        action: 'focusBranch',
                        previousBranch: previousFocus,
                        newBranch: branchId,
                        isMain: branchId === 'main'
                    });
                }
                
                // Re-render timeline to show focus state
                this.renderBranchTimeline();
                
                // Update cost breakdown panel
                this.renderCostBreakdown(branchId);
                
                // Switch to the corresponding chat tab
                this.switchChatTab(branchId);
                
                // Refresh preview to show the focused branch's files
                if (this.currentPreviewFile) {
                    await this.refreshPreview();
                }
            },
            
            // Switch chat tab to show a specific branch's messages
            switchChatTab(branchId) {
                // Update tab active states
                const tabs = document.querySelectorAll('.branch-tab');
                tabs.forEach(tab => {
                    if (tab.dataset.branch === branchId) {
                        tab.classList.add('active');
                    } else {
                        tab.classList.remove('active');
                    }
                });
                
                // Show the correct messages container
                const messageContainers = document.querySelectorAll('.messages.branch-messages');
                messageContainers.forEach(container => {
                    if (container.dataset.branch === branchId) {
                        container.classList.add('active');
                    } else {
                        container.classList.remove('active');
                    }
                });
                
                // Scroll the active messages to bottom
                const activeMessages = document.querySelector(`.messages.branch-messages.active`);
                if (activeMessages) {
                    activeMessages.scrollTop = activeMessages.scrollHeight;
                }
            },
            
            // Create a new chat tab for a branch
            createBranchChatTab(branchId, title, icon = '') {
                
                const tabsContainer = document.getElementById('branchChatTabs');
                const messagesWrapper = document.getElementById('messagesWrapper');
                
                
                if (!tabsContainer || !messagesWrapper) {
                    return;
                }
                
                // Show tabs container
                tabsContainer.style.display = 'flex';
                
                // Check if tab already exists
                const existingTab = document.querySelector(`.branch-tab[data-branch="${branchId}"]`);
                if (existingTab) {
                    return;
                }
                
                // Create tab
                const tab = document.createElement('div');
                tab.className = 'branch-tab';
                tab.dataset.branch = branchId;
                tab.onclick = () => this.focusBranch(branchId);
                tab.innerHTML = `
                    <span class="branch-tab-icon">${icon}</span>
                    <span class="branch-tab-name">${title}</span>
                    <span class="branch-tab-status"></span>
                `;
                tabsContainer.appendChild(tab);
                
                
                // Create messages container for this branch
                const messagesDiv = document.createElement('div');
                messagesDiv.className = 'messages branch-messages';
                messagesDiv.id = `messages-${branchId}`;
                messagesDiv.dataset.branch = branchId;
                messagesDiv.innerHTML = `
                    <div class="message">
                        <span class="message-time">${new Date().toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit' })}</span>
                        <span class="message-type system">SYS</span>
                        <span class="message-content">Branch <strong>${title}</strong> initialized.</span>
                    </div>
                `;
                messagesWrapper.appendChild(messagesDiv);
            },
            
            // Update branch tab status
            updateBranchTabStatus(branchId, status) {
                const tab = document.querySelector(`.branch-tab[data-branch="${branchId}"]`);
                if (!tab) return;
                
                const statusEl = tab.querySelector('.branch-tab-status');
                if (statusEl) {
                    statusEl.className = 'branch-tab-status ' + status;
                }
            },
            
            // Legacy alias
            async switchToBranch(branchId) {
                await this.focusBranch(branchId || 'main');
            },
            
            // Promote a branch to become the main version
            async promoteBranch(branchId) {
                if (!this.repoPath || !branchId) {
                    this.logBranchEvent('promote:rejected', { 
                        action: 'promoteBranch',
                        branchId,
                        reason: !this.repoPath ? 'No repo path' : 'No branch ID'
                    });
                    return;
                }
                
                const branch = this.cycleState.branches.find(b => b.branchId === branchId);
                if (!branch) {
                    this.logBranchEvent('promote:failed', { 
                        action: 'promoteBranch',
                        branchId,
                        reason: 'Branch not found'
                    });
                    this.addMessage('error', `Branch ${branchId} not found`);
                    return;
                }
                
                if (!confirm(`Promote ${branchId} to main version?\n\nThis will:\n1. Backup current main as v${this.cycleState.currentVersion}\n2. Replace main with ${branchId} files\n3. Increment version to v${this.cycleState.currentVersion + 1}`)) {
                    this.logBranchEvent('promote:cancelled', { 
                        action: 'promoteBranch',
                        branchId,
                        reason: 'User cancelled'
                    });
                    return;
                }
                
                this.logBranchEvent('promote:start', { 
                    action: 'promoteBranch',
                    branchId,
                    branchTitle: branch.title,
                    branchScore: branch.score,
                    currentVersion: this.cycleState.currentVersion,
                    targetVersion: this.cycleState.currentVersion + 1
                });
                
                this.addMessage('system', ` Promoting ${branchId} to main...`);
                
                try {
                    // Backup current main first
                    const currentVersion = this.cycleState.currentVersion;
                    
                    this.logBranchEvent('promote:backup', { 
                        action: 'promoteBranch',
                        branchId,
                        backupVersion: currentVersion
                    });
                    
                    await window.aider.backupVersion(this.repoPath, currentVersion, {
                        score: this.cycleState.currentScore,
                        objective: this.cycleState.objective,
                        model: this.selectedModel,
                        note: `Before promoting ${branchId}`
                    });
                    
                    // Promote the branch
                    const result = await window.aider.promoteBranch(this.repoPath, branchId);
                    
                    if (result.success) {
                        // Increment version
                        this.cycleState.currentVersion = currentVersion + 1;
                        this.cycleState.currentScore = branch.score || 0;
                        this.cycleState.activeBranch = null;
                        this.saveCycleState();
                        
                        // Clean up promoted branch
                        await window.aider.deleteBranch(this.repoPath, branchId);
                        
                        // Refresh
                        await this.loadBranches();
                        await this.loadVersionBackups();
                        await this.loadProjectFiles();
                        this.updateCycleUI();
                        
                        this.logBranchEvent('promote:success', { 
                            action: 'promoteBranch',
                            branchId,
                            branchTitle: branch.title,
                            previousVersion: currentVersion,
                            newVersion: this.cycleState.currentVersion,
                            score: branch.score
                        });
                        
                        this.addMessage('system', ` ${branchId} promoted to v${this.cycleState.currentVersion}`);
                    } else {
                        this.logBranchEvent('promote:failed', { 
                            action: 'promoteBranch',
                            branchId,
                            error: result.error
                        });
                        this.addMessage('error', `Promote failed: ${result.error}`);
                    }
                } catch (error) {
                    this.logBranchEvent('promote:error', { 
                        action: 'promoteBranch',
                        branchId,
                        error: error.message,
                        stack: error.stack
                    });
                    console.error('[GSX Create] Promote error:', error);
                    this.addMessage('error', `Promote failed: ${error.message}`);
                }
            },
            
            // Delete a branch
            async deleteBranch(branchId) {
                if (!confirm(`Delete branch ${branchId}?`)) {
                    this.logBranchEvent('delete:cancelled', { 
                        action: 'deleteBranch',
                        branchId,
                        reason: 'User cancelled'
                    });
                    return;
                }
                
                this.logBranchEvent('delete:start', { 
                    action: 'deleteBranch',
                    branchId
                });
                
                const result = await window.aider.deleteBranch(this.repoPath, branchId);
                if (result.success) {
                    this.logBranchEvent('delete:success', { 
                        action: 'deleteBranch',
                        branchId
                    });
                    this.addMessage('system', ` Deleted branch ${branchId}`);
                    await this.loadBranches();
                } else {
                    this.logBranchEvent('delete:failed', { 
                        action: 'deleteBranch',
                        branchId,
                        error: result.error || 'Unknown error'
                    });
                    this.addMessage('error', `Failed to delete ${branchId}: ${result.error || 'Unknown error'}`);
                }
            },
            
            // ========== COMPARISON VIEW ==========
            
            // Show comparison modal for all branches
            async showBranchComparison() {
                const branches = this.cycleState.branches || [];
                
                if (branches.length === 0) {
                    this.addMessage('system', 'No branches to compare');
                    return;
                }
                
                const modal = document.getElementById('comparisonModal');
                const body = document.getElementById('comparisonModalBody');
                
                if (!modal || !body) {
                    this.createComparisonModal();
                    return this.showBranchComparison();
                }
                
                // Sort branches by score (if available)
                const sortedBranches = [...branches].sort((a, b) => (b.score || 0) - (a.score || 0));
                
                body.innerHTML = `
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 16px;">
                        ${sortedBranches.map((b, i) => `
                            <div class="comparison-card" style="border: 1px solid var(--border); border-radius: 12px; overflow: hidden; background: var(--bg-secondary);">
                                <div style="padding: 12px; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center;">
                                    <div>
                                        <div style="font-weight: 700; font-size: 14px;">${b.branchId}</div>
                                        <div style="font-size: 11px; color: var(--text-muted);">${b.approach || 'No approach set'}</div>
                                    </div>
                                    ${i === 0 ? '<span style="background: var(--accent); color: white; padding: 2px 8px; border-radius: 10px; font-size: 10px;"> Best</span>' : ''}
                                </div>
                                
                                <div style="padding: 12px;">
                                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 12px;">
                                        <div style="text-align: center; padding: 8px; background: var(--bg-primary); border-radius: 8px;">
                                            <div style="font-size: 20px; font-weight: 700; color: ${(b.score || 0) >= 80 ? 'var(--success)' : (b.score || 0) >= 60 ? 'var(--warning)' : 'var(--error)'};">
                                                ${b.score || 0}%
                                            </div>
                                            <div style="font-size: 10px; color: var(--text-muted);">Score</div>
                                        </div>
                                        <div style="text-align: center; padding: 8px; background: var(--bg-primary); border-radius: 8px;">
                                            <div style="font-size: 14px; font-weight: 600;">$${(b.cost || 0).toFixed(3)}</div>
                                            <div style="font-size: 10px; color: var(--text-muted);">Cost</div>
                                        </div>
                                    </div>
                                    
                                    <div style="font-size: 11px; margin-bottom: 8px;">
                                        <span style="color: var(--text-muted);">Model:</span> ${b.model || 'Default'}
                                    </div>
                                    <div style="font-size: 11px; margin-bottom: 12px;">
                                        <span style="color: var(--text-muted);">Status:</span> 
                                        <span style="color: ${b.status === 'completed' ? 'var(--success)' : b.status === 'failed' ? 'var(--error)' : 'var(--accent)'};">
                                            ${b.status || 'pending'}
                                        </span>
                                    </div>
                                    
                                    <div style="display: flex; gap: 6px; flex-wrap: wrap;">
                                        <button class="btn btn-sm" onclick="GSXCreate.previewBranch('${b.branchId}')" style="flex: 1;">
                                             Preview
                                        </button>
                                        <button class="btn btn-sm" onclick="GSXCreate.showBranchDiff('${b.branchId}')" style="flex: 1;">
                                             Diff
                                        </button>
                                        <button class="btn btn-sm btn-primary" onclick="GSXCreate.promoteBranch('${b.branchId}'); GSXCreate.closeModal('comparisonModal');" style="flex: 1;">
                                             Use This
                                        </button>
                                    </div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                    
                    <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--border); text-align: center;">
                        <button class="btn btn-secondary" onclick="GSXCreate.closeModal('comparisonModal')">Close</button>
                    </div>
                `;
                
                modal.classList.add('active');
            },
            
            // Create comparison modal
            createComparisonModal() {
                const modal = document.createElement('div');
                modal.id = 'comparisonModal';
                modal.className = 'modal';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 900px;">
                        <div class="modal-header">
                            <h3> Compare Branches</h3>
                            <button class="modal-close" onclick="GSXCreate.closeModal('comparisonModal')"></button>
                        </div>
                        <div class="modal-body" id="comparisonModalBody">
                            Loading...
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
            },
            
            // Preview a branch in the preview panel
            async previewBranch(branchId) {
                this.cycleState.activeBranch = branchId;
                this.renderBranchTabs();
                
                // Find the main HTML file in the branch
                const branchPath = `${this.repoPath}/branches/${branchId}`;
                const htmlFile = await this.findHtmlFileInPath(branchPath);
                
                if (htmlFile) {
                    await this.previewFile(htmlFile);
                    this.addMessage('system', ` Previewing branch ${branchId}`);
                } else {
                    this.addMessage('system', `No HTML file found in branch ${branchId}`);
                }
                
                this.closeModal('comparisonModal');
            },
            
            // Find HTML file in a path
            async findHtmlFileInPath(dirPath) {
                try {
                    const result = await window.aider.listProjectFiles(dirPath);
                    if (result.success && result.files) {
                        const htmlFile = result.files.find(f => 
                            !f.isDirectory && (f.name.endsWith('.html') || f.name.endsWith('.htm'))
                        );
                        return htmlFile ? htmlFile.path : null;
                    }
                } catch (e) {
                    console.error('[GSX Create] Find HTML error:', e);
                }
                return null;
            },
            
            // Show diff between branch and main
            async showBranchDiff(branchId) {
                const modal = document.getElementById('diffModal');
                const body = document.getElementById('diffModalBody');
                
                if (!modal || !body) {
                    this.createDiffModal();
                    return this.showBranchDiff(branchId);
                }
                
                body.innerHTML = '<div style="text-align: center; padding: 20px;">Loading diff...</div>';
                modal.classList.add('active');
                
                try {
                    // Get main file
                    const mainFile = this.currentPreviewFile || await this.findMainHtmlFile();
                    if (!mainFile) {
                        body.innerHTML = '<div style="color: var(--error);">No main file found for comparison</div>';
                        return;
                    }
                    
                    const mainContent = await window.aider.readFile(mainFile);
                    const fileName = mainFile.split('/').pop();
                    
                    // Get branch file
                    const branchFile = `${this.repoPath}/branches/${branchId}/${fileName}`;
                    let branchContent = '';
                    try {
                        branchContent = await window.aider.readFile(branchFile);
                    } catch (e) {
                        body.innerHTML = `<div style="color: var(--error);">File ${fileName} not found in branch ${branchId}</div>`;
                        return;
                    }
                    
                    // Generate simple diff
                    const diff = this.generateSimpleDiff(mainContent, branchContent);
                    
                    body.innerHTML = `
                        <div style="margin-bottom: 12px; font-size: 12px; color: var(--text-muted);">
                            Comparing <strong>${fileName}</strong>: Main  ${branchId}
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; max-height: 500px;">
                            <div>
                                <div style="font-size: 11px; font-weight: 600; margin-bottom: 4px; color: var(--text-muted);">Main (Current)</div>
                                <pre style="background: var(--bg-primary); padding: 12px; border-radius: 8px; font-size: 11px; overflow: auto; max-height: 450px; margin: 0;">${this.escapeHtml(mainContent.substring(0, 5000))}${mainContent.length > 5000 ? '\n\n... (truncated)' : ''}</pre>
                            </div>
                            <div>
                                <div style="font-size: 11px; font-weight: 600; margin-bottom: 4px; color: var(--accent);">${branchId}</div>
                                <pre style="background: var(--bg-primary); padding: 12px; border-radius: 8px; font-size: 11px; overflow: auto; max-height: 450px; margin: 0;">${this.escapeHtml(branchContent.substring(0, 5000))}${branchContent.length > 5000 ? '\n\n... (truncated)' : ''}</pre>
                            </div>
                        </div>
                        <div style="margin-top: 12px; font-size: 11px; color: var(--text-muted);">
                            ${diff.stats}
                        </div>
                    `;
                    
                } catch (error) {
                    body.innerHTML = `<div style="color: var(--error);">Error loading diff: ${error.message}</div>`;
                }
            },
            
            // Create diff modal
            createDiffModal() {
                const modal = document.createElement('div');
                modal.id = 'diffModal';
                modal.className = 'modal';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 1000px;">
                        <div class="modal-header">
                            <h3> Code Diff</h3>
                            <button class="modal-close" onclick="GSXCreate.closeModal('diffModal')"></button>
                        </div>
                        <div class="modal-body" id="diffModalBody">
                            Loading...
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
            },
            
            // Generate simple diff stats
            generateSimpleDiff(text1, text2) {
                const lines1 = text1.split('\n');
                const lines2 = text2.split('\n');
                
                const added = lines2.length - lines1.length;
                const sizeDiff = text2.length - text1.length;
                
                return {
                    stats: `Lines: ${lines1.length}  ${lines2.length} (${added >= 0 ? '+' : ''}${added}) | Size: ${text1.length}  ${text2.length} (${sizeDiff >= 0 ? '+' : ''}${sizeDiff} chars)`
                };
            },
            
            // ========== SIDE-BY-SIDE LIVE PREVIEW ==========
            
            // Show side-by-side live preview of two branches
            async showSideBySidePreview(branch1Id = null, branch2Id = null) {
                const branches = this.cycleState.branches || [];
                
                // Default to first two completed branches
                if (!branch1Id && branches.length > 0) {
                    branch1Id = branches[0]?.branchId || null;
                }
                if (!branch2Id && branches.length > 1) {
                    branch2Id = branches[1]?.branchId || null;
                }
                
                const modal = document.getElementById('sideBySideModal');
                const body = document.getElementById('sideBySideModalBody');
                
                if (!modal || !body) {
                    this.createSideBySideModal();
                    return this.showSideBySidePreview(branch1Id, branch2Id);
                }
                
                // Build branch selector options
                const branchOptions = [
                    { id: 'main', label: 'Main (Current)' },
                    ...branches.map(b => ({ id: b.branchId, label: `${b.branchId} (${b.score || 0}%)` }))
                ];
                
                // Find HTML files
                const mainHtmlFile = this.currentPreviewFile || await this.findMainHtmlFile();
                const file1 = branch1Id === 'main' ? mainHtmlFile : await this.findHtmlFileInPath(`${this.repoPath}/branches/${branch1Id}`);
                const file2 = branch2Id === 'main' ? mainHtmlFile : (branch2Id ? await this.findHtmlFileInPath(`${this.repoPath}/branches/${branch2Id}`) : null);
                
                body.innerHTML = `
                    <div style="display: flex; gap: 8px; margin-bottom: 12px; padding-bottom: 12px; border-bottom: 1px solid var(--border);">
                        <div style="flex: 1; display: flex; align-items: center; gap: 8px;">
                            <span style="font-size: 11px; color: var(--text-muted);">Left:</span>
                            <select id="sideBySideLeft" onchange="GSXCreate.updateSideBySidePreview()"
                                    style="flex: 1; padding: 4px 8px; font-size: 11px; background: var(--bg-primary); border: 1px solid var(--border); border-radius: 4px;">
                                ${branchOptions.map(b => `<option value="${b.id}" ${b.id === branch1Id ? 'selected' : ''}>${b.label}</option>`).join('')}
                            </select>
                        </div>
                        <div style="flex: 1; display: flex; align-items: center; gap: 8px;">
                            <span style="font-size: 11px; color: var(--text-muted);">Right:</span>
                            <select id="sideBySideRight" onchange="GSXCreate.updateSideBySidePreview()"
                                    style="flex: 1; padding: 4px 8px; font-size: 11px; background: var(--bg-primary); border: 1px solid var(--border); border-radius: 4px;">
                                ${branchOptions.map(b => `<option value="${b.id}" ${b.id === (branch2Id || 'main') ? 'selected' : ''}>${b.label}</option>`).join('')}
                            </select>
                        </div>
                        <button onclick="GSXCreate.refreshSideBySide()" style="padding: 4px 8px; background: var(--bg-primary); border: 1px solid var(--border); border-radius: 4px; cursor: pointer;">
                            
                        </button>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; height: 500px;">
                        <div style="display: flex; flex-direction: column; border: 1px solid var(--border); border-radius: 8px; overflow: hidden;">
                            <div id="sideBySideLeftLabel" style="padding: 6px 10px; background: var(--bg-secondary); font-size: 11px; font-weight: 600; border-bottom: 1px solid var(--border);">
                                ${branch1Id || 'main'}
                            </div>
                            <iframe id="sideBySideLeftFrame" 
                                    src="${file1 ? 'file://' + file1 : 'about:blank'}" 
                                    style="flex: 1; border: none; background: white;"></iframe>
                        </div>
                        <div style="display: flex; flex-direction: column; border: 1px solid var(--border); border-radius: 8px; overflow: hidden;">
                            <div id="sideBySideRightLabel" style="padding: 6px 10px; background: var(--bg-secondary); font-size: 11px; font-weight: 600; border-bottom: 1px solid var(--border);">
                                ${branch2Id || 'main'}
                            </div>
                            <iframe id="sideBySideRightFrame" 
                                    src="${file2 ? 'file://' + file2 : 'about:blank'}" 
                                    style="flex: 1; border: none; background: white;"></iframe>
                        </div>
                    </div>
                    
                    <div style="margin-top: 12px; display: flex; gap: 8px; justify-content: flex-end;">
                        <button class="btn btn-secondary" onclick="GSXCreate.closeModal('sideBySideModal')">Close</button>
                    </div>
                `;
                
                modal.classList.add('active');
            },
            
            // Create side-by-side modal
            createSideBySideModal() {
                const modal = document.createElement('div');
                modal.id = 'sideBySideModal';
                modal.className = 'modal';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 1200px; width: 95%;">
                        <div class="modal-header">
                            <h3> Side-by-Side Preview</h3>
                            <button class="modal-close" onclick="GSXCreate.closeModal('sideBySideModal')"></button>
                        </div>
                        <div class="modal-body" id="sideBySideModalBody">
                            Loading...
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
            },
            
            // Update side-by-side preview based on selectors
            async updateSideBySidePreview() {
                const leftSelect = document.getElementById('sideBySideLeft');
                const rightSelect = document.getElementById('sideBySideRight');
                const leftFrame = document.getElementById('sideBySideLeftFrame');
                const rightFrame = document.getElementById('sideBySideRightFrame');
                const leftLabel = document.getElementById('sideBySideLeftLabel');
                const rightLabel = document.getElementById('sideBySideRightLabel');
                
                if (!leftSelect || !rightSelect) return;
                
                const leftId = leftSelect.value;
                const rightId = rightSelect.value;
                
                // Update labels
                if (leftLabel) leftLabel.textContent = leftId;
                if (rightLabel) rightLabel.textContent = rightId;
                
                // Find HTML files
                const mainHtmlFile = this.currentPreviewFile || await this.findMainHtmlFile();
                
                const leftFile = leftId === 'main' ? mainHtmlFile : await this.findHtmlFileInPath(`${this.repoPath}/branches/${leftId}`);
                const rightFile = rightId === 'main' ? mainHtmlFile : await this.findHtmlFileInPath(`${this.repoPath}/branches/${rightId}`);
                
                // Update iframes
                if (leftFrame && leftFile) {
                    leftFrame.src = 'file://' + leftFile;
                }
                if (rightFrame && rightFile) {
                    rightFrame.src = 'file://' + rightFile;
                }
            },
            
            // Refresh both side-by-side previews
            refreshSideBySide() {
                const leftFrame = document.getElementById('sideBySideLeftFrame');
                const rightFrame = document.getElementById('sideBySideRightFrame');
                
                if (leftFrame) leftFrame.contentWindow?.location.reload();
                if (rightFrame) rightFrame.contentWindow?.location.reload();
            },
            
            // Set number of parallel versions to create
            setParallelCount(count) {
                this.cycleState.parallelCount = Math.max(1, Math.min(4, count));
                this.saveCycleState();
                
                // Update all UI controls that show parallel count
                const control = document.getElementById('parallelCountControl');
                if (control) control.value = this.cycleState.parallelCount;
                
                const planningSelect = document.getElementById('parallelCountSelect');
                if (planningSelect) planningSelect.value = this.cycleState.parallelCount;
                
                const branchPanelSelect = document.getElementById('branchParallelCount');
                if (branchPanelSelect) branchPanelSelect.value = this.cycleState.parallelCount;
            },
            
            // ========== AI PLANNING PHASE ==========
            
            // Available models for branch selection - Only Claude 4.5 Opus and Sonnet
            availableModels: [
                { id: 'claude-opus-4-5-20251101', name: 'Claude Opus 4.5', speed: 'thorough' },
                { id: 'claude-sonnet-4-5-20250929', name: 'Claude Sonnet 4.5', speed: 'fast' }
            ],
            
            // Generate approach proposals using AI
            async generateApproachProposals(objective) {
                this.addMessage('system', ' Analyzing objective and generating approach proposals...');
                
                try {
                    const systemPrompt = `You are a senior software architect. Analyze the objective and propose 2-4 different approaches to achieve it. Each approach should be distinct with different trade-offs.`;
                    
                    const userPrompt = `Objective: ${objective}

Current file: ${this.currentPreviewFile || 'Not selected'}
Current version: v${this.cycleState.currentVersion}

Generate 2-4 different approaches to achieve this objective. For each approach, provide:
1. A short title (5-10 words)
2. Description (1-2 sentences)
3. Focus area (e.g., "Performance", "UX", "Simplicity", "Maintainability")
4. Recommended model (claude-opus-4-5-20251101, claude-sonnet-4-5-20250929)
5. Estimated complexity (low/medium/high)

Format as JSON array:
[
  {
    "title": "Approach title",
    "description": "What this approach does differently",
    "focus": "Main focus area",
    "model": "model-id",
    "complexity": "medium",
    "selected": true
  }
]`;

                    const response = await this.callEvaluationAPI(systemPrompt, userPrompt);
                    
                    console.log('[GSX Create] Approach API response:', typeof response, response ? response.substring(0, 200) : 'null');
                    
                    if (response && typeof response === 'string') {
                        const jsonMatch = response.match(/\[[\s\S]*\]/);
                        console.log('[GSX Create] JSON match found:', !!jsonMatch);
                        if (jsonMatch) {
                            const approaches = JSON.parse(jsonMatch[0]);
                            console.log('[GSX Create] Parsed approaches:', approaches.length);
                            // Auto-select approaches based on parallelCount
                            const parallelCount = this.cycleState.parallelCount || 2;
                            console.log('[GSX Create] parallelCount from state:', this.cycleState.parallelCount, 'using:', parallelCount);
                            approaches.forEach((approach, i) => {
                                approach.selected = i < parallelCount;
                            });
                            console.log('[GSX Create] Auto-selected', Math.min(parallelCount, approaches.length), 'approaches for parallel execution');
                            console.log('[GSX Create] Approaches selected states:', approaches.map(a => ({ title: a.title, selected: a.selected })));
                            return approaches;
                        }
                    }
                } catch (error) {
                    console.error('[GSX Create] Approach generation failed:', error);
                }
                
                // Fallback approaches if AI fails - auto-select based on parallelCount
                console.log('[GSX Create] Using fallback approaches, parallelCount:', this.cycleState.parallelCount);
                const parallelCount = this.cycleState.parallelCount || 2;
                const fallbackApproaches = [
                    {
                        title: 'Standard Implementation',
                        description: 'Direct implementation following best practices',
                        focus: 'Reliability',
                        model: this.selectedModel,
                        complexity: 'medium',
                        selected: parallelCount >= 1
                    },
                    {
                        title: 'Simplified Approach',
                        description: 'Minimal implementation focusing on core functionality',
                        focus: 'Simplicity',
                        model: 'claude-sonnet-4-5-20250929',
                        complexity: 'low',
                        selected: parallelCount >= 2
                    },
                    {
                        title: 'Performance-Focused',
                        description: 'Optimized for speed and efficiency',
                        focus: 'Performance',
                        model: this.selectedModel,
                        complexity: 'high',
                        selected: parallelCount >= 3
                    }
                ];
                return fallbackApproaches;
            },
            
            // Show planning modal with approach proposals
            async showPlanningModal(objective) {
                // Generate proposals
                const proposals = await this.generateApproachProposals(objective);
                this.cycleState.proposedApproaches = proposals;
                
                const modal = document.getElementById('planningModal');
                const body = document.getElementById('planningModalBody');
                if (!modal || !body) {
                    // Create modal if it doesn't exist
                    this.createPlanningModal();
                    return this.showPlanningModal(objective);
                }
                
                const parallelCount = this.cycleState.parallelCount || 2;
                
                body.innerHTML = `
                    <div style="margin-bottom: 16px;">
                        <div style="font-size: 14px; font-weight: 600; margin-bottom: 8px;"> Objective</div>
                        <div style="padding: 12px; background: var(--bg-primary); border-radius: 8px; font-size: 13px;">
                            ${this.escapeHtml(objective)}
                        </div>
                    </div>
                    
                    <div style="margin-bottom: 16px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <span style="font-size: 14px; font-weight: 600;"> Parallel Branches</span>
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <span style="font-size: 11px; color: var(--text-muted);">Run up to:</span>
                                <select id="parallelCountSelect" onchange="GSXCreate.setParallelCount(parseInt(this.value))" 
                                        style="padding: 4px 8px; font-size: 11px; background: var(--bg-primary); border: 1px solid var(--border); border-radius: 4px;">
                                    ${[1,2,3,4].map(n => `<option value="${n}" ${n === parallelCount ? 'selected' : ''}>${n} branch${n > 1 ? 'es' : ''}</option>`).join('')}
                                </select>
                            </div>
                        </div>
                    </div>
                    
                    <div style="margin-bottom: 16px;">
                        <div style="font-size: 14px; font-weight: 600; margin-bottom: 12px;"> Proposed Approaches</div>
                        <div style="display: flex; flex-direction: column; gap: 10px;">
                            ${proposals.map((p, i) => `
                                <div class="approach-card" id="approach-card-${i}" style="padding: 12px; border: 1px solid var(--border); border-radius: 8px; background: ${p.selected ? 'rgba(59, 130, 246, 0.1)' : 'transparent'};">
                                    <div style="display: flex; align-items: flex-start; gap: 10px;">
                                        <input type="checkbox" id="approach-${i}" ${p.selected ? 'checked' : ''} 
                                               onchange="GSXCreate.toggleApproach(${i})"
                                               style="margin-top: 3px; width: 16px; height: 16px;">
                                        <div style="flex: 1;">
                                            <div style="display: flex; align-items: center; gap: 8px;">
                                                <input type="text" id="approach-title-${i}" value="${this.escapeHtml(p.title)}"
                                                       onchange="GSXCreate.updateApproachTitle(${i}, this.value)"
                                                       style="font-weight: 600; font-size: 13px; background: transparent; border: none; border-bottom: 1px dashed var(--border); flex: 1; color: var(--text-primary);">
                                                <button onclick="GSXCreate.toggleApproachEdit(${i})" 
                                                        style="padding: 2px 6px; font-size: 10px; background: var(--bg-primary); border: 1px solid var(--border); border-radius: 4px; cursor: pointer;">
                                                    
                                                </button>
                                            </div>
                                            <div style="font-size: 12px; color: var(--text-secondary); margin-top: 4px;">
                                                ${this.escapeHtml(p.description)}
                                            </div>
                                            <div style="display: flex; gap: 12px; margin-top: 8px; font-size: 11px;">
                                                <span style="color: var(--accent);"> ${this.escapeHtml(p.focus)}</span>
                                                <span style="color: var(--text-muted);"> ${p.complexity}</span>
                                            </div>
                                            <!-- Editable Instructions (collapsed by default) -->
                                            <div id="approach-instructions-${i}" style="display: none; margin-top: 10px;">
                                                <label style="font-size: 10px; color: var(--text-muted); display: block; margin-bottom: 4px;">
                                                    Additional Instructions:
                                                </label>
                                                <textarea id="approach-instr-text-${i}" 
                                                          placeholder="Add specific instructions for this approach..."
                                                          onchange="GSXCreate.updateApproachInstructions(${i}, this.value)"
                                                          style="width: 100%; min-height: 60px; padding: 8px; font-size: 11px; background: var(--bg-primary); border: 1px solid var(--border); border-radius: 6px; resize: vertical; color: var(--text-primary);">${p.instructions || ''}</textarea>
                                            </div>
                                        </div>
                                        <div style="display: flex; flex-direction: column; gap: 4px;">
                                            <select id="model-${i}" onchange="GSXCreate.setApproachModel(${i}, this.value)"
                                                    style="padding: 4px 6px; font-size: 10px; background: var(--bg-primary); border: 1px solid var(--border); border-radius: 4px;">
                                                ${this.availableModels.map(m => `
                                                    <option value="${m.id}" ${m.id === p.model ? 'selected' : ''}>${m.name}</option>
                                                `).join('')}
                                            </select>
                                            <span style="font-size: 9px; color: var(--text-muted); text-align: center;">
                                                ${this.availableModels.find(m => m.id === p.model)?.speed || ''}
                                            </span>
                                        </div>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                    
                    <div style="display: flex; gap: 8px; justify-content: flex-end; margin-top: 16px;">
                        <button class="btn btn-secondary" onclick="GSXCreate.closeModal('planningModal')">Cancel</button>
                        <button class="btn btn-primary" onclick="GSXCreate.startParallelExecution()">
                             Start ${Math.min(proposals.filter(p => p.selected).length, parallelCount)} Branch${parallelCount > 1 ? 'es' : ''}
                        </button>
                    </div>
                `;
                
                modal.classList.add('active');
            },
            
            // Create the planning modal element
            createPlanningModal() {
                const modal = document.createElement('div');
                modal.id = 'planningModal';
                modal.className = 'modal';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 600px;">
                        <div class="modal-header">
                            <h3> AI Planning</h3>
                            <button class="modal-close" onclick="GSXCreate.closeModal('planningModal')"></button>
                        </div>
                        <div class="modal-body" id="planningModalBody">
                            Loading...
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
            },
            
            // Toggle approach selection
            toggleApproach(index) {
                if (!this.cycleState.proposedApproaches) return;
                this.cycleState.proposedApproaches[index].selected = !this.cycleState.proposedApproaches[index].selected;
                
                // Update card background
                const card = document.getElementById(`approach-card-${index}`);
                if (card) {
                    card.style.background = this.cycleState.proposedApproaches[index].selected 
                        ? 'rgba(59, 130, 246, 0.1)' 
                        : 'transparent';
                }
            },
            
            // Set model for an approach
            setApproachModel(index, modelId) {
                if (!this.cycleState.proposedApproaches) return;
                this.cycleState.proposedApproaches[index].model = modelId;
            },
            
            // Update approach title
            updateApproachTitle(index, title) {
                if (!this.cycleState.proposedApproaches) return;
                this.cycleState.proposedApproaches[index].title = title;
            },
            
            // Update approach instructions
            updateApproachInstructions(index, instructions) {
                if (!this.cycleState.proposedApproaches) return;
                this.cycleState.proposedApproaches[index].instructions = instructions;
            },
            
            // Toggle instruction edit panel visibility
            toggleApproachEdit(index) {
                const panel = document.getElementById(`approach-instructions-${index}`);
                if (panel) {
                    panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
                }
            },
            
            // Start parallel execution with selected approaches
            async startParallelExecution() {
                const approaches = this.cycleState.proposedApproaches || [];
                const selected = approaches.filter(a => a.selected);
                const parallelCount = this.cycleState.parallelCount || 2;
                const toExecute = selected.slice(0, parallelCount);
                
                // Debug logging
                console.log('[GSX Create] startParallelExecution called');
                console.log('[GSX Create] Total approaches:', approaches.length);
                console.log('[GSX Create] Selected approaches:', selected.length);
                console.log('[GSX Create] Parallel count setting:', parallelCount);
                console.log('[GSX Create] Approaches to execute:', toExecute.length);
                console.log('[GSX Create] Selected titles:', selected.map(a => a.title));
                
                this.logBranchEvent('execution:start', { 
                    action: 'startParallelExecution',
                    totalApproaches: approaches.length,
                    selectedCount: selected.length,
                    parallelCount,
                    toExecuteCount: toExecute.length,
                    selectedApproaches: toExecute.map(a => ({
                        title: a.title,
                        focus: a.focus,
                        model: a.model
                    }))
                });
                
                if (toExecute.length === 0) {
                    this.logBranchEvent('execution:rejected', { 
                        action: 'startParallelExecution',
                        reason: 'No approaches selected'
                    });
                    this.addMessage('error', 'Please select at least one approach');
                    return;
                }
                
                this.closeModal('planningModal');
                
                if (toExecute.length === 1) {
                    // Single approach - run normally
                    this.logBranchEvent('execution:single', { 
                        action: 'startParallelExecution',
                        mode: 'single',
                        approach: toExecute[0].title,
                        model: toExecute[0].model
                    });
                    this.addMessage('system', ` Using approach: ${toExecute[0].title}`);
                    this.selectedModel = toExecute[0].model;
                    await this.runPhase('execute');
                } else {
                    // Multiple approaches - create branches
                    this.logBranchEvent('execution:parallel', { 
                        action: 'startParallelExecution',
                        mode: 'parallel',
                        branchCount: toExecute.length
                    });
                    this.addMessage('system', ` Starting ${toExecute.length} parallel branches...`);
                    
                    const branches = await this.createParallelBranches(toExecute);
                    
                    if (branches && branches.length > 0) {
                        // Start executing all branches in parallel
                        this.addMessage('system', `    Created ${branches.length} branches`);
                        
                        this.logBranchEvent('execution:branches:launching', { 
                            action: 'startParallelExecution',
                            branchCount: branches.length,
                            branchIds: branches.map(b => b.branchId)
                        });
                        
                        // Execute each branch (in parallel)
                        const promises = branches.map((b, i) => 
                            this.executeBranch(b.branchId, toExecute[i])
                        );
                        
                        // Don't await - let them run in parallel
                        Promise.all(promises).then(() => {
                            this.logBranchEvent('execution:branches:allComplete', { 
                                action: 'startParallelExecution',
                                branchCount: branches.length
                            });
                            this.addMessage('system', ' All branches completed! Review and select the best one.');
                            this.renderBranchTabs();
                            this.renderMultiProgress();
                        }).catch(e => {
                            this.logBranchEvent('execution:branches:error', { 
                                action: 'startParallelExecution',
                                error: e.message,
                                stack: e.stack
                            });
                            this.addMessage('error', `Branch execution error: ${e.message}`);
                        });
                    }
                }
            },
            
            // Branch execution queue - each branch gets its own sandboxed Aider
            branchQueue: [],
            branchExecuting: false,
            
            // Execute a single branch with SANDBOXED Aider execution
            async executeBranch(branchId, approach) {
                console.log('[GSX Create] Executing branch (SANDBOXED):', branchId, approach.title);
                
                const startTime = Date.now();
                const branchPath = `${this.repoPath}/branches/${branchId}`;
                
                this.logBranchEvent('execute:start', { 
                    action: 'executeBranch',
                    branchId,
                    approachTitle: approach.title,
                    approachFocus: approach.focus,
                    approachModel: approach.model,
                    branchPath,
                    sandboxed: true
                });
                
                // Update chat tab status to running
                this.updateBranchTabStatus(branchId, 'running');
                
                // Add start message to branch's chat
                this.addBranchMessage(branchId, 'system', ` Starting execution: **${approach.title}**\nFocus: ${approach.focus || 'General'}\n Sandboxed mode enabled`);
                
                try {
                    // Update branch status
                    await this.updateBranchProgress(branchId, 5, 'initializing', 'running');
                    
                    this.logBranchEvent('execute:phase:init', { 
                        action: 'executeBranch',
                        branchId,
                        phase: 'initializing',
                        branchModel: approach.model
                    });
                    
                    // === SANDBOXED AIDER INITIALIZATION ===
                    // Get shared journey map path (read-only for branches)
                    const journeyMapPath = `${this.repoPath}/journey-map.md`;
                    
                    
                    // Initialize sandboxed Aider for this branch
                    this.addBranchMessage(branchId, 'system', ` Initializing sandboxed Aider...`);
                    const initResult = await window.aider.initBranchAider(
                        branchPath,
                        branchId,
                        approach.model || 'claude-opus-4-5-20251101',
                        [journeyMapPath]  // Read-only access to journey map
                    );
                    
                    
                    if (!initResult.success) {
                        throw new Error(`Failed to initialize sandboxed Aider: ${initResult.error}`);
                    }
                    
                    this.logBranchEvent('execute:aider:initialized', { 
                        action: 'executeBranch',
                        branchId,
                        sandboxed: true,
                        branchPath
                    });
                    
                    // Find the main HTML file in the branch
                    const branchHtmlFile = await this.findHtmlFileInPath(branchPath);
                    if (!branchHtmlFile) {
                        this.logBranchEvent('execute:error:noFile', { 
                            action: 'executeBranch',
                            branchId,
                            error: 'No HTML file found in branch',
                            branchPath
                        });
                        throw new Error('No HTML file found in branch');
                    }
                    
                    const fileName = branchHtmlFile.split('/').pop();
                    
                    this.logBranchEvent('execute:phase:planning', { 
                        action: 'executeBranch',
                        branchId,
                        phase: 'planning',
                        targetFile: fileName,
                        fullPath: branchHtmlFile
                    });
                    
                    // Phase 1: Build implementation prompt
                    // NOTE: With sandboxing, we don't need to specify full paths - the branch directory IS the root
                    await this.updateBranchProgress(branchId, 15, 'planning', 'running');
                    
                    // Get journey map content to inject (shared, read-only)
                    let journeyMapContext = '';
                    try {
                        const journeyMap = await window.aider.readFile(journeyMapPath);
                        if (journeyMap) {
                            journeyMapContext = `\n## SHARED JOURNEY MAP (Reference Only - DO NOT MODIFY)\n${journeyMap}\n`;
                        }
                    } catch (e) {
                        console.log('[GSX Create] No journey map found, continuing without it');
                    }
                    
                    // Simplified prompt - Aider is sandboxed to branch directory
                    const implementPrompt = `You are implementing a specific approach for this objective.
${journeyMapContext}
## OBJECTIVE
${this.cycleState.objective}

## YOUR APPROACH
- **Title**: ${approach.title}
- **Description**: ${approach.description}
- **Focus Area**: ${approach.focus}
${approach.instructions ? `- **Additional Instructions**: ${approach.instructions}` : ''}

## YOUR TASK
Edit ${fileName} to implement this approach.
You are working in an isolated sandbox - all files here belong to this branch only.
The style-guide.md in your directory can be modified if needed for your approach.

Be thorough and complete. Focus on ${approach.focus.toLowerCase()}.`;

                    // Phase 2: Execute implementation using sandboxed Aider
                    await this.updateBranchProgress(branchId, 25, 'implementing', 'running');
                    this.addMessage('system', `    ${branchId}: Implementing "${approach.title}"...`, null, false, 'main');
                    this.addBranchMessage(branchId, 'assistant', `Starting implementation of **${approach.title}**...`);
                    
                    this.logBranchEvent('execute:phase:implementing', { 
                        action: 'executeBranch',
                        branchId,
                        phase: 'implementing',
                        promptLength: implementPrompt.length,
                        sandboxed: true
                    });
                    
                    // Run the implementation prompt on the sandboxed Aider
                    const implementStartTime = Date.now();
                    const implementResult = await this.executeBranchPromptSandboxed(branchId, implementPrompt);
                    const implementDuration = Date.now() - implementStartTime;
                    
                    this.logBranchEvent('execute:implement:complete', { 
                        action: 'executeBranch',
                        branchId,
                        success: implementResult.success,
                        durationMs: implementDuration,
                        error: implementResult.error || null
                    });
                    
                    if (!implementResult.success) {
                        throw new Error(implementResult.error || 'Implementation failed');
                    }
                    
                    await this.updateBranchProgress(branchId, 60, 'testing', 'running');
                    
                    this.logBranchEvent('execute:phase:testing', { 
                        action: 'executeBranch',
                        branchId,
                        phase: 'testing'
                    });
                    
                    // Phase 3: Evaluate the branch
                    await this.updateBranchProgress(branchId, 75, 'evaluating', 'running');
                    this.addMessage('system', `    ${branchId}: Evaluating results...`);
                    
                    this.logBranchEvent('execute:phase:evaluating', { 
                        action: 'executeBranch',
                        branchId,
                        phase: 'evaluating',
                        targetFile: branchHtmlFile
                    });
                    
                    const evalStartTime = Date.now();
                    const score = await this.evaluateBranch(branchId, branchHtmlFile);
                    const evalDuration = Date.now() - evalStartTime;
                    
                    this.logBranchEvent('execute:evaluate:complete', { 
                        action: 'executeBranch',
                        branchId,
                        score,
                        evalDurationMs: evalDuration
                    });
                    
                    // Phase 4: Complete
                    await this.updateBranchProgress(branchId, 100, 'complete', 'completed');
                    
                    // Update branch with final score
                    await window.aider.updateBranch(this.repoPath, branchId, {
                        status: 'completed',
                        progress: 100,
                        score: score,
                        completedAt: new Date().toISOString()
                    });
                    
                    const totalDuration = Date.now() - startTime;
                    
                    this.logBranchEvent('execute:success', { 
                        action: 'executeBranch',
                        branchId,
                        approachTitle: approach.title,
                        finalScore: score,
                        totalDurationMs: totalDuration,
                        implementDurationMs: implementDuration,
                        evalDurationMs: evalDuration
                    });
                    
                    // Refresh UI
                    await this.loadBranches();
                    this.renderBranchTabs();
                    this.renderMultiProgress();
                    
                    // Update chat tab status and add completion message to branch chat
                    this.updateBranchTabStatus(branchId, 'complete');
                    this.addBranchMessage(branchId, 'system', ` **Completed** with score ${score}%`);
                    
                    // Also add to main chat
                    this.addMessage('system', `    ${branchId}: Completed with score ${score}%`, null, false, 'main');
                    
                    return { success: true, score: score };
                    
                } catch (error) {
                    const totalDuration = Date.now() - startTime;
                    
                    this.logBranchEvent('execute:failed', { 
                        action: 'executeBranch',
                        branchId,
                        approachTitle: approach.title,
                        error: error.message,
                        stack: error.stack,
                        totalDurationMs: totalDuration
                    });
                    
                    console.error('[GSX Create] Branch execution error:', error);
                    
                    await window.aider.updateBranch(this.repoPath, branchId, {
                        status: 'failed',
                        error: error.message
                    });
                    
                    // Update chat tab status and add error message to branch chat
                    this.updateBranchTabStatus(branchId, 'error');
                    this.addBranchMessage(branchId, 'error', ` **Failed**: ${error.message}`);
                    
                    // Also add to main chat
                    this.addMessage('error', `    ${branchId}: Failed - ${error.message}`, null, false, 'main');
                    
                    await this.loadBranches();
                    this.renderBranchTabs();
                    this.renderMultiProgress();
                    
                    return { success: false, error: error.message };
                    
                } finally {
                    // === CLEANUP SANDBOXED AIDER ===
                    // Always cleanup the sandboxed Aider instance for this branch
                    try {
                        await window.aider.cleanupBranchAider(branchId);
                        this.logBranchEvent('execute:cleanup', { 
                            action: 'executeBranch',
                            branchId,
                            status: 'cleaned'
                        });
                    } catch (cleanupError) {
                        console.warn('[GSX Create] Branch cleanup warning:', cleanupError);
                    }
                }
            },
            
            // Execute a prompt on a SANDBOXED branch Aider (streaming)
            async executeBranchPromptSandboxed(branchId, prompt) {
                this.logBranchEvent('prompt:start:sandboxed', { 
                    action: 'executeBranchPromptSandboxed',
                    branchId,
                    promptLength: prompt.length,
                    promptPreview: prompt.substring(0, 200)
                });
                
                const startTime = Date.now();
                
                return new Promise((resolve) => {
                    let response = '';
                    let tokenCount = 0;
                    
                    // Use the sandboxed branch-specific Aider
                    window.aider.runBranchPromptStreaming(
                        branchId,
                        prompt,
                        (data) => {
                            if (data.type === 'token') {
                                response += data.token;
                                tokenCount++;
                                // Stream token to branch chat
                                // (Could show live output in branch chat here)
                            } else if (data.type === 'done') {
                                const duration = Date.now() - startTime;
                                this.logBranchEvent('prompt:complete:sandboxed', { 
                                    action: 'executeBranchPromptSandboxed',
                                    branchId,
                                    success: data.result?.success,
                                    durationMs: duration,
                                    responseLength: response.length,
                                    tokenCount,
                                    fileDetails: data.result?.file_details?.length || 0
                                });
                                this.addBranchMessage(branchId, 'system', `Implementation complete. ${data.result?.file_details?.length || 0} files modified.`);
                                resolve(data.result);
                            } else if (data.type === 'error') {
                                const duration = Date.now() - startTime;
                                this.logBranchEvent('prompt:error:sandboxed', { 
                                    action: 'executeBranchPromptSandboxed',
                                    branchId,
                                    error: data.error,
                                    durationMs: duration
                                });
                                resolve({ success: false, error: data.error });
                            }
                        }
                    ).catch(error => {
                        const duration = Date.now() - startTime;
                        this.logBranchEvent('prompt:error:sandboxed', { 
                            action: 'executeBranchPromptSandboxed',
                            branchId,
                            error: error.message,
                            durationMs: duration,
                            responseLength: response.length
                        });
                        resolve({ success: false, error: error.message });
                    });
                });
            },
            
            // Execute a prompt for a specific branch (streaming) - LEGACY: uses shared Aider
            async executeBranchPrompt(branchId, prompt) {
                this.logBranchEvent('prompt:start', { 
                    action: 'executeBranchPrompt',
                    branchId,
                    promptLength: prompt.length,
                    promptPreview: prompt.substring(0, 200)
                });
                
                const startTime = Date.now();
                
                return new Promise((resolve) => {
                    let response = '';
                    let tokenCount = 0;
                    
                    window.aider.runPromptStreaming(
                        prompt,
                        (token) => {
                            response += token;
                            tokenCount++;
                            // Could update progress based on response here
                        },
                        { include_thinking: false }
                    ).then(result => {
                        const duration = Date.now() - startTime;
                        this.logBranchEvent('prompt:complete', { 
                            action: 'executeBranchPrompt',
                            branchId,
                            success: result.success,
                            durationMs: duration,
                            responseLength: response.length,
                            tokenCount,
                            fileDetails: result.file_details?.length || 0
                        });
                        resolve(result);
                    }).catch(error => {
                        const duration = Date.now() - startTime;
                        this.logBranchEvent('prompt:error', { 
                            action: 'executeBranchPrompt',
                            branchId,
                            error: error.message,
                            durationMs: duration,
                            responseLength: response.length
                        });
                        resolve({ success: false, error: error.message });
                    });
                });
            },
            
            // Evaluate a branch and return a score
            async evaluateBranch(branchId, htmlFilePath) {
                this.logBranchEvent('evaluate:start', { 
                    action: 'evaluateBranch',
                    branchId,
                    htmlFilePath,
                    objective: this.cycleState.objective
                });
                
                const startTime = Date.now();
                
                try {
                    // Read the branch's HTML file
                    const content = await window.aider.readFile(htmlFilePath);
                    
                    this.logBranchEvent('evaluate:fileRead', { 
                        action: 'evaluateBranch',
                        branchId,
                        contentLength: content?.length || 0
                    });
                    
                    if (!content || content.length < 100) {
                        this.logBranchEvent('evaluate:minimalContent', { 
                            action: 'evaluateBranch',
                            branchId,
                            contentLength: content?.length || 0,
                            score: 50
                        });
                        return 50; // Minimal content
                    }
                    
                    // Use AI to evaluate
                    const systemPrompt = `You are a code quality evaluator. Rate the implementation on a scale of 0-100.`;
                    const userPrompt = `Evaluate this implementation for the objective: "${this.cycleState.objective}"

Rate on these criteria (each 0-20 points):
1. Functionality - Does it work?
2. Code Quality - Is it clean and well-structured?
3. UX/UI - Is it user-friendly?
4. Completeness - Is the feature complete?
5. Best Practices - Does it follow best practices?

HTML Content (first 3000 chars):
${content.substring(0, 3000)}

Respond with ONLY a single number 0-100 representing the total score.`;

                    const response = await this.callEvaluationAPI(systemPrompt, userPrompt);
                    const duration = Date.now() - startTime;
                    
                    if (response) {
                        const match = response.match(/\d+/);
                        if (match) {
                            const score = Math.min(100, Math.max(0, parseInt(match[0])));
                            this.logBranchEvent('evaluate:success', { 
                                action: 'evaluateBranch',
                                branchId,
                                score,
                                durationMs: duration,
                                responsePreview: response.substring(0, 100)
                            });
                            return score;
                        }
                    }
                    
                    this.logBranchEvent('evaluate:fallback', { 
                        action: 'evaluateBranch',
                        branchId,
                        reason: 'No valid score in response',
                        score: 70,
                        durationMs: duration
                    });
                    return 70; // Default fallback score
                    
                } catch (error) {
                    const duration = Date.now() - startTime;
                    this.logBranchEvent('evaluate:error', { 
                        action: 'evaluateBranch',
                        branchId,
                        error: error.message,
                        stack: error.stack,
                        durationMs: duration,
                        fallbackScore: 60
                    });
                    console.error('[GSX Create] Branch evaluation error:', error);
                    return 60; // Error fallback score
                }
            },
            
            // Helper delay function
            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            },
            
            // Show parallel planning when objective is set
            async onObjectiveSet(objective) {
                // If parallel count > 1, show planning modal
                if (this.cycleState.parallelCount > 1) {
                    await this.showPlanningModal(objective);
                } else {
                    // Single branch - proceed normally
                    this.cycleState.objective = objective;
                    await this.runPhase('plan');
                }
            },
            
            // Start parallel planning from the Branch Control Panel
            async startParallelPlanning() {
                // DEPRECATED: This function is replaced by the tabbed UI.
                // Redirect users to create new branches via TabManager.
                console.log('[GSX Create] startParallelPlanning is deprecated. Use TabManager.showNewBranchModal() instead.');
                TabManager.showNewBranchModal();
                return;
                
                // Legacy code below (kept for reference):
                this.logBranchEvent('planning:start', { 
                    action: 'startParallelPlanning',
                    parallelCount: this.cycleState.parallelCount
                });
                
                // Show custom prompt modal for objective
                const objective = await this.showObjectivePrompt();
                
                if (!objective || !objective.trim()) {
                    this.logBranchEvent('planning:cancelled', { 
                        action: 'startParallelPlanning',
                        reason: 'User cancelled objective input'
                    });
                    return; // User cancelled
                }
                
                this.cycleState.objective = objective.trim();
                
                this.logBranchEvent('planning:objectiveSet', { 
                    action: 'startParallelPlanning',
                    objective: objective.trim(),
                    objectiveLength: objective.trim().length
                });
                
                // Always show planning modal from this entry point
                await this.showPlanningModal(objective.trim());
            },
            
            // Custom prompt modal (replaces native prompt() which is blocked in Electron)
            showObjectivePrompt() {
                return new Promise((resolve) => {
                    // Create modal
                    const modal = document.createElement('div');
                    modal.id = 'objectivePromptModal';
                    modal.className = 'modal active';
                    modal.innerHTML = `
                        <div class="modal-content" style="max-width: 500px;">
                            <div class="modal-header">
                                <h3> New Exploration</h3>
                                <button class="modal-close" onclick="window.resolveObjectivePrompt(null)"></button>
                            </div>
                            <div class="modal-body">
                                <p style="color: var(--text-secondary); margin-bottom: 12px; font-size: 13px;">
                                    What would you like to explore? Describe the feature, fix, or improvement you want to implement.
                                </p>
                                <textarea id="objectiveInput" 
                                    placeholder="e.g., Add a dark mode toggle with smooth transitions..."
                                    style="width: 100%; min-height: 100px; padding: 12px; font-size: 13px; 
                                           background: var(--bg-primary); border: 1px solid var(--border); 
                                           border-radius: 8px; resize: vertical; color: var(--text-primary);
                                           font-family: inherit;"></textarea>
                                <div style="display: flex; gap: 8px; justify-content: flex-end; margin-top: 16px;">
                                    <button class="btn btn-secondary" onclick="window.resolveObjectivePrompt(null)">Cancel</button>
                                    <button class="btn btn-primary" onclick="window.resolveObjectivePrompt(document.getElementById('objectiveInput').value)">
                                        Continue 
                                    </button>
                                </div>
                            </div>
                        </div>
                    `;
                    
                    document.body.appendChild(modal);
                    
                    // Focus the input
                    setTimeout(() => {
                        const input = document.getElementById('objectiveInput');
                        if (input) input.focus();
                    }, 100);
                    
                    // Handle Enter key
                    const input = document.getElementById('objectiveInput');
                    if (input) {
                        input.addEventListener('keydown', (e) => {
                            if (e.key === 'Enter' && e.ctrlKey) {
                                window.resolveObjectivePrompt(input.value);
                            }
                        });
                    }
                    
                    // Set up resolver
                    window.resolveObjectivePrompt = (value) => {
                        const modalEl = document.getElementById('objectivePromptModal');
                        if (modalEl) modalEl.remove();
                        delete window.resolveObjectivePrompt;
                        resolve(value);
                    };
                });
            },
            
            
            // Legacy multi-progress - now uses unified timeline
            renderMultiProgress() {
                // Redirect to the new unified timeline
                this.renderBranchTimeline();
            },
            
            // Get unique color for branch
            getBranchColor(branchId) {
                const colors = ['var(--accent)', '#10b981', '#f59e0b', '#ef4444'];
                const index = branchId.split('.').pop() - 1;
                return colors[index % colors.length];
            },
            
            // Update branch progress
            async updateBranchProgress(branchId, progress, phase, status, phaseCost = 0) {
                if (!this.repoPath) return;
                
                // Update local state first
                const branch = this.cycleState.branches.find(b => b.branchId === branchId);
                const previousPhase = branch?.currentPhase;
                const previousProgress = branch?.progress;
                
                if (branch) {
                    branch.progress = progress;
                    branch.currentPhase = phase;
                    branch.status = status;
                    
                    // Track cost by phase
                    if (!branch.costByPhase) branch.costByPhase = {};
                    if (phaseCost > 0) {
                        branch.costByPhase[phase] = (branch.costByPhase[phase] || 0) + phaseCost;
                        branch.totalCost = Object.values(branch.costByPhase).reduce((a, b) => a + b, 0);
                    }
                }
                
                // Log progress update (granular tracking)
                this.logBranchEvent('progress:update', { 
                    action: 'updateBranchProgress',
                    branchId,
                    previousPhase,
                    previousProgress,
                    newPhase: phase,
                    newProgress: progress,
                    status,
                    phaseCost,
                    totalCost: branch?.totalCost || 0,
                    costByPhase: branch?.costByPhase || {}
                });
                
                // Persist to file system
                await window.aider.updateBranch(this.repoPath, branchId, {
                    progress: progress,
                    currentPhase: phase,
                    status: status,
                    costByPhase: branch?.costByPhase || {},
                    totalCost: branch?.totalCost || 0
                });
                
                // Update the unified timeline display
                this.renderBranchTimeline();
                
                // Sync state for cross-browser updates
                await this.syncBranchState();
            },
            
            // Track cost for main branch phases
            async trackMainPhaseCost(phase, cost) {
                if (!this.cycleState.mainCostByPhase) {
                    this.cycleState.mainCostByPhase = {};
                }
                this.cycleState.mainCostByPhase[phase] = (this.cycleState.mainCostByPhase[phase] || 0) + cost;
                this.cycleState.mainCost = Object.values(this.cycleState.mainCostByPhase).reduce((a, b) => a + b, 0);
                
                // Update display
                this.renderBranchTimeline();
                this.saveCycleState();
            },
            
            // ========== CROSS-BROWSER SYNC ==========
            
            syncInterval: null,
            lastSyncHash: null,
            
            // Start polling for branch state changes
            startBranchSync() {
                if (this.syncInterval) return;
                
                // Poll every 2 seconds
                this.syncInterval = setInterval(() => {
                    this.checkForBranchUpdates();
                }, 2000);
                
                console.log('[GSX Create] Branch sync started');
            },
            
            // Stop polling
            stopBranchSync() {
                if (this.syncInterval) {
                    clearInterval(this.syncInterval);
                    this.syncInterval = null;
                }
            },
            
            // Write current branch state to sync file
            async syncBranchState() {
                if (!this.repoPath) return;
                
                try {
                    const syncData = {
                        timestamp: Date.now(),
                        currentVersion: this.cycleState.currentVersion,
                        branches: this.cycleState.branches.map(b => ({
                            branchId: b.branchId,
                            status: b.status,
                            progress: b.progress,
                            currentPhase: b.currentPhase,
                            score: b.score,
                            model: b.model,
                            approach: b.approach
                        })),
                        activeBranch: this.cycleState.activeBranch
                    };
                    
                    await window.aider.writeFile(
                        `${this.repoPath}/.gsx-sync.json`,
                        JSON.stringify(syncData, null, 2)
                    );
                    
                    this.lastSyncHash = JSON.stringify(syncData.branches);
                    
                } catch (error) {
                    console.error('[GSX Create] Sync write error:', error);
                }
            },
            
            // Check for updates from other browsers
            async checkForBranchUpdates() {
                if (!this.repoPath) return;
                
                try {
                    const syncFile = `${this.repoPath}/.gsx-sync.json`;
                    const content = await window.aider.readFile(syncFile);
                    
                    if (!content) return;
                    
                    const syncData = JSON.parse(content);
                    const currentHash = JSON.stringify(syncData.branches);
                    
                    // Check if data has changed
                    if (currentHash !== this.lastSyncHash) {
                        console.log('[GSX Create] Branch updates detected from sync');
                        
                        // Update local state
                        if (syncData.branches) {
                            for (const syncBranch of syncData.branches) {
                                const localBranch = this.cycleState.branches.find(
                                    b => b.branchId === syncBranch.branchId
                                );
                                
                                if (localBranch) {
                                    Object.assign(localBranch, syncBranch);
                                } else {
                                    // New branch from another browser
                                    this.cycleState.branches.push(syncBranch);
                                }
                            }
                        }
                        
                        this.lastSyncHash = currentHash;
                        
                        // Update UI
                        this.renderBranchTabs();
                        this.renderMultiProgress();
                    }
                    
                } catch (error) {
                    // File might not exist yet, that's ok
                    if (!error.message?.includes('ENOENT')) {
                        console.error('[GSX Create] Sync check error:', error);
                    }
                }
            },
            
            toggleGlobalInstructions() {
                document.getElementById('globalInstructionsPanel').classList.toggle('active');
            },
            
            toggleConfig() {
                document.getElementById('configPanel').classList.toggle('active');
            },
            
            applyTemplate(type) {
                const templates = {
                    typescript: 'Use TypeScript with strict types. Prefer interfaces over types. Use async/await. Add JSDoc comments.',
                    react: 'Use functional components with hooks. Use TypeScript. Follow React best practices. Use CSS modules or styled-components.',
                    python: 'Use Python 3.10+. Add type hints. Follow PEP 8. Use docstrings. Handle exceptions properly.'
                };
                document.getElementById('globalInstructions').value = templates[type] || '';
            },
            
            // Snapshot
            async takeSnapshot() {
                if (!this.currentPreviewFile) {
                    this.addMessage('system', 'No file being previewed');
                    return;
                }
                
                try {
                    const content = await window.aider.readFile(this.currentPreviewFile);
                    this.addMessage('system', `Snapshot taken: ${this.currentPreviewFile.split('/').pop()}`);
                    
                    // Store snapshot for context
                    if (!this.snapshots) this.snapshots = [];
                    this.snapshots.push({
                        file: this.currentPreviewFile,
                        content: content,
                        time: new Date().toISOString()
                    });
                } catch (error) {
                    this.addMessage('error', 'Failed to take snapshot: ' + error.message);
                }
            },
            
            // Version History
            async showVersionHistory() {
                if (!this.currentPreviewFile) {
                    this.addMessage('system', 'No file selected');
                    return;
                }
                
                const modal = document.getElementById('historyModal');
                const body = document.getElementById('historyModalBody');
                
                modal.classList.add('active');
                body.innerHTML = '<p>Loading...</p>';
                
                try {
                    const result = await window.aider.getFileVersions(this.repoPath, this.currentPreviewFile);
                    
                    if (result.success && result.versions.length > 0) {
                        body.innerHTML = result.versions.map(v => `
                            <div style="padding: 10px; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <div style="font-size: 12px;">${new Date(v.timestamp).toLocaleString()}</div>
                                    <div style="font-size: 11px; color: var(--text-secondary);">${v.description || 'No description'}</div>
                                </div>
                                <button class="btn btn-sm btn-secondary" onclick="GSXCreate.rollbackToVersion('${v.id}')">Restore</button>
                            </div>
                        `).join('');
                    } else {
                        body.innerHTML = '<p style="text-align: center; color: var(--text-muted);">No version history available</p>';
                    }
                } catch (error) {
                    body.innerHTML = `<p style="color: var(--danger);">Error: ${error.message}</p>`;
                }
            },
            
            async rollbackToVersion(versionId) {
                try {
                    await window.aider.rollbackFile(this.repoPath, this.currentPreviewFile, versionId);
                    this.addMessage('system', 'File restored to previous version');
                    this.refreshPreview();
                    this.closeModal('historyModal');
                } catch (error) {
                    this.addMessage('error', 'Rollback failed: ' + error.message);
                }
            },
            
            // Tools Detection
            async detectTools() {
                try {
                    const result = await window.aider.detectProjectTools(this.repoPath);
                    if (result.success) {
                        if (result.lintCmd) document.getElementById('lintCmd').value = result.lintCmd;
                        if (result.testCmd) document.getElementById('testCmd').value = result.testCmd;
                        this.addMessage('system', 'Detected tools: ' + (result.lintCmd || 'none') + ', ' + (result.testCmd || 'none'));
                    }
                } catch (error) {
                    console.error('[GSX Create] Detect tools error:', error);
                }
            },
            
            // UI Helpers
            updateStatus(text, connected) {
                document.getElementById('statusText').textContent = text;
                document.getElementById('statusDot').classList.toggle('active', connected);
            },
            
            toggleSidebar() {
                const sidebar = document.getElementById('sidebar');
                const icon = document.getElementById('sidebarToggleIcon');
                
                sidebar.classList.toggle('collapsed');
                const isCollapsed = sidebar.classList.contains('collapsed');
                icon.textContent = isCollapsed ? '' : '';
                
                this.trackBehavior('sidebar_toggle', { collapsed: isCollapsed });
                localStorage.setItem('gsx-sidebar-collapsed', isCollapsed);
            },
            
            restoreSidebarState() {
                const collapsed = localStorage.getItem('gsx-sidebar-collapsed') === 'true';
                if (collapsed) {
                    document.getElementById('sidebar').classList.add('collapsed');
                    document.getElementById('sidebarToggleIcon').textContent = '';
                }
            },
            
            // Toggle Configuration section collapse/expand
            toggleConfigSection() {
                const content = document.getElementById('configSectionContent');
                const icon = document.getElementById('configToggleIcon');
                const isHidden = content.style.display === 'none';
                
                content.style.display = isHidden ? 'block' : 'none';
                icon.style.transform = isHidden ? 'rotate(90deg)' : 'rotate(0deg)';
            },
            
            // Generic section toggle for collapsible sidebar sections
            toggleSection(sectionId) {
                const contentMap = {
                    'refMemory': 'refMemoryContent',
                    'context': 'contextContent',
                    'episodic': 'episodicContent'
                };
                const iconMap = {
                    'refMemory': 'refMemoryToggleIcon',
                    'context': 'contextToggleIcon',
                    'episodic': 'episodicToggleIcon'
                };
                
                const content = document.getElementById(contentMap[sectionId]);
                const icon = document.getElementById(iconMap[sectionId]);
                
                if (!content || !icon) return;
                
                const isHidden = content.style.display === 'none';
                content.style.display = isHidden ? 'block' : 'none';
                icon.style.transform = isHidden ? 'rotate(90deg)' : 'rotate(0deg)';
                
                // Save state to localStorage
                localStorage.setItem(`gsx-section-${sectionId}`, isHidden ? 'expanded' : 'collapsed');
            },
            
            // Restore section states from localStorage
            restoreSectionStates() {
                ['refMemory', 'context', 'episodic'].forEach(sectionId => {
                    const state = localStorage.getItem(`gsx-section-${sectionId}`);
                    if (state === 'expanded') {
                        this.toggleSection(sectionId);
                    }
                });
            },
            
            closeModal(id) {
                document.getElementById(id).classList.remove('active');
            },
            
            // ========== ERROR ANALYZER & GLOBAL LOGGING ==========
            
            // Console log buffer for context
            consoleLogBuffer: [],
            maxLogBufferSize: 100,
            
            // Setup error interceptors and console capture
            setupErrorAnalyzer() {
                if (!this.errorAnalyzer.enabled) return;
                
                // Intercept ALL console methods to build context buffer
                const self = this;
                ['log', 'info', 'warn', 'error', 'debug'].forEach(method => {
                    const original = console[method];
                    console[method] = function(...args) {
                        original.apply(console, args);
                        
                        // Add to buffer
                        const message = args.map(a => {
                            if (a instanceof Error) return `${a.name}: ${a.message}`;
                            if (typeof a === 'object') {
                                try { return JSON.stringify(a).substring(0, 200); }
                                catch { return String(a); }
                            }
                            return String(a);
                        }).join(' ');
                        
                        self.consoleLogBuffer.push({
                            type: method,
                            message: message.substring(0, 500),
                            timestamp: new Date().toISOString()
                        });
                        
                        // Trim buffer
                        if (self.consoleLogBuffer.length > self.maxLogBufferSize) {
                            self.consoleLogBuffer.shift();
                        }
                        
                        // Capture errors
                        if (method === 'error' && self.isSignificantError(message)) {
                            self.captureError('console.error', message, new Error().stack);
                        }
                    };
                });
                
                // Intercept unhandled errors
                window.addEventListener('error', (event) => {
                    if (this.isSignificantError(event.message)) {
                        this.captureError('uncaught', event.message, event.error?.stack, {
                            file: event.filename,
                            line: event.lineno,
                            col: event.colno
                        });
                    }
                });
                
                // Intercept unhandled promise rejections
                window.addEventListener('unhandledrejection', (event) => {
                    const message = event.reason?.message || String(event.reason);
                    if (this.isSignificantError(message)) {
                        this.captureError('promise', message, event.reason?.stack);
                    }
                });
                
                // Listen for main process errors via IPC
                if (window.aider && window.aider.onMainProcessError) {
                    window.aider.onMainProcessError((error) => {
                        this.captureError('main-process', error.message, error.stack, {
                            file: error.file,
                            line: error.line
                        });
                    });
                }
                
                // Add error count badge to UI
                this.updateErrorBadge();
                
                // Expose global logging function
                window.logEvent = this.logEvent.bind(this);
                window.logError = (error, context) => this.logEvent('error', error, context);
                window.logWarning = (message, context) => this.logEvent('warning', message, context);
                window.logInfo = (message, context) => this.logEvent('info', message, context);
                
                console.log('[ErrorAnalyzer] Initialized with console capture');
            },
            
            // ========== GLOBAL LOG EVENT FUNCTION ==========
            // Call from anywhere: window.logEvent('error', error, { context })
            
            async logEvent(type, errorOrMessage, context = {}) {
                const isError = errorOrMessage instanceof Error;
                const message = isError ? errorOrMessage.message : String(errorOrMessage);
                const stack = isError ? errorOrMessage.stack : new Error().stack;
                
                // Get recent console logs for context
                const recentLogs = this.consoleLogBuffer.slice(-20);
                
                // Build log entry
                const logEntry = {
                    id: Date.now(),
                    type: type, // 'error', 'warning', 'info'
                    message: message,
                    stack: stack,
                    context: {
                        ...context,
                        currentFile: this.currentPreviewFile,
                        phase: this.cycleState?.currentPhase,
                        version: this.cycleState?.currentVersion,
                        recentLogs: recentLogs
                    },
                    timestamp: new Date().toISOString(),
                    aiSummary: null,
                    userNotes: ''
                };
                
                // Store for quick log modal
                this.pendingLogEntry = logEntry;
                
                // Show quick log modal
                this.showQuickLogModal(logEntry);
                
                // Generate AI summary in background
                this.generateLogSummary(logEntry);
            },
            
            // Show quick log modal
            showQuickLogModal(entry) {
                const modal = document.getElementById('quickLogModal');
                const typeEl = document.getElementById('quickLogType');
                const summaryEl = document.getElementById('quickLogSummary');
                const aiEl = document.getElementById('quickLogAI');
                const notesEl = document.getElementById('quickLogNotes');
                
                // Set type badge
                typeEl.textContent = entry.type;
                typeEl.className = `quick-log-type ${entry.type}`;
                
                // Pre-fill summary with error message
                summaryEl.value = entry.message.substring(0, 100);
                
                // Reset AI and notes
                aiEl.textContent = ' Analyzing with recent console logs...';
                aiEl.classList.add('loading');
                notesEl.value = '';
                
                modal.classList.add('active');
            },
            
            // Close quick log modal
            closeQuickLog() {
                document.getElementById('quickLogModal').classList.remove('active');
                this.pendingLogEntry = null;
            },
            
            // Generate AI summary with console log context
            async generateLogSummary(entry) {
                const aiEl = document.getElementById('quickLogAI');
                
                try {
                    // Format recent logs for AI
                    const logsContext = entry.context.recentLogs
                        .map(l => `[${l.type}] ${l.message}`)
                        .join('\n');
                    
                    const prompt = `Analyze this ${entry.type} and provide a brief, human-readable summary:

**${entry.type.toUpperCase()}:** ${entry.message}

**Recent Console Logs (for context):**
${logsContext || 'No recent logs'}

**Stack Trace:**
${entry.stack?.substring(0, 500) || 'No stack trace'}

**Current Context:**
- File: ${entry.context.currentFile || 'None'}
- Phase: ${entry.context.phase || 'None'}

Please provide:
1. A one-sentence summary of what happened
2. The likely cause
3. Suggested action (if applicable)

Keep it concise and actionable.`;

                    const result = await window.aider.analyzeScreenshot(null, prompt);
                    
                    if (result.success && result.analysis) {
                        entry.aiSummary = result.analysis;
                        aiEl.innerHTML = this.formatAIAnalysis(result.analysis);
                        aiEl.classList.remove('loading');
                        
                        // Auto-update summary field with AI's one-liner
                        const firstLine = result.analysis.split('\n')[0].replace(/^\d+\.\s*/, '').substring(0, 100);
                        if (firstLine) {
                            document.getElementById('quickLogSummary').value = firstLine;
                        }
                    } else {
                        aiEl.textContent = 'AI analysis unavailable';
                        aiEl.classList.remove('loading');
                    }
                } catch (e) {
                    aiEl.textContent = `Analysis failed: ${e.message}`;
                    aiEl.classList.remove('loading');
                }
            },
            
            // Save quick log entry
            async saveQuickLog() {
                const entry = this.pendingLogEntry;
                if (!entry) return;
                
                // Get user inputs
                entry.summary = document.getElementById('quickLogSummary').value;
                entry.userNotes = document.getElementById('quickLogNotes').value;
                
                // Save to transaction DB
                try {
                    await window.aider.txdbLogEvent({
                        type: entry.type,
                        summary: entry.summary,
                        message: entry.message,
                        aiSummary: entry.aiSummary,
                        userNotes: entry.userNotes,
                        context: JSON.stringify(entry.context),
                        stack: entry.stack,
                        timestamp: entry.timestamp
                    });
                    
                    this.addMessage('system', ` Logged: ${entry.summary.substring(0, 50)}...`);
                } catch (e) {
                    console.error('[LogEvent] Save failed:', e);
                    this.addMessage('error', 'Failed to save log entry');
                }
                
                this.closeQuickLog();
            },
            
            // Get recent console logs (for external use)
            getRecentLogs(count = 20) {
                return this.consoleLogBuffer.slice(-count);
            },
            
            // ========== USER BEHAVIOR TRACKING ==========
            
            // Track user behavior for debugging
            trackBehavior(action, details = {}) {
                const event = {
                    action,
                    details,
                    timestamp: new Date().toISOString(),
                    context: {
                        currentFile: this.currentPreviewFile,
                        spaceId: this.currentSpaceId,
                        phase: this.cycleState?.currentPhase,
                        version: this.cycleState?.currentVersion
                    }
                };
                
                // Add to console log buffer for context
                this.consoleLogBuffer.push({
                    type: 'behavior',
                    message: `[USER] ${action}: ${JSON.stringify(details).substring(0, 100)}`,
                    timestamp: event.timestamp
                });
                
                // Trim buffer
                if (this.consoleLogBuffer.length > this.maxLogBufferSize) {
                    this.consoleLogBuffer.shift();
                }
                
                // Log to console in dev mode
                console.log(`[Behavior] ${action}`, details);
                
                // Optionally save to database (for important actions)
                if (this.shouldPersistBehavior(action)) {
                    this.persistBehavior(event);
                }
            },
            
            // Determine if behavior should be persisted to database
            shouldPersistBehavior(action) {
                const persistActions = [
                    'session_start', 'session_end',
                    'space_selected', 'space_created',
                    'cycle_started', 'cycle_completed', 'cycle_stopped',
                    'phase_completed', 'phase_failed',
                    'prompt_sent', 'prompt_completed',
                    'test_run', 'test_completed',
                    'file_created', 'file_edited',
                    'error_fixed', 'settings_changed'
                ];
                return persistActions.includes(action);
            },
            
            // Persist behavior to database
            async persistBehavior(event) {
                try {
                    await window.aider.txdbLogEvent({
                        type: 'behavior',
                        summary: `${event.action}: ${JSON.stringify(event.details).substring(0, 50)}`,
                        message: event.action,
                        context: JSON.stringify(event),
                        timestamp: event.timestamp
                    });
                } catch (e) {
                    // Silent fail - don't interrupt user
                }
            },
            
            // Setup behavior tracking on UI elements
            setupBehaviorTracking() {
                // Track all button clicks
                document.addEventListener('click', (e) => {
                    const target = e.target.closest('button, .btn, [onclick]');
                    if (target) {
                        const action = target.textContent?.trim().substring(0, 30) || 
                                       target.getAttribute('onclick')?.substring(0, 30) ||
                                       target.className;
                        this.trackBehavior('button_click', { 
                            text: action,
                            id: target.id,
                            class: target.className?.substring(0, 50)
                        });
                    }
                });
                
                // Track select changes
                document.addEventListener('change', (e) => {
                    if (e.target.tagName === 'SELECT') {
                        this.trackBehavior('select_change', {
                            id: e.target.id,
                            value: e.target.value?.substring(0, 50)
                        });
                    }
                });
                
                // Track keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    if (e.metaKey || e.ctrlKey) {
                        this.trackBehavior('keyboard_shortcut', {
                            key: e.key,
                            meta: e.metaKey,
                            ctrl: e.ctrlKey,
                            shift: e.shiftKey
                        });
                    }
                });
                
                // Track visibility changes (tab switches)
                document.addEventListener('visibilitychange', () => {
                    this.trackBehavior('visibility_change', {
                        hidden: document.hidden
                    });
                });
                
                // Track window focus
                window.addEventListener('focus', () => {
                    this.trackBehavior('window_focus', {});
                });
                
                window.addEventListener('blur', () => {
                    this.trackBehavior('window_blur', {});
                });
                
                console.log('[BehaviorTracking] Initialized');
            },
            
            // ========== END USER BEHAVIOR TRACKING ==========
            
            // ========== GSX FRAMEWORK INTEGRATION ==========
            
            // Telemetry data received from preview
            previewTelemetry: {
                errors: [],
                events: [],
                consoleLogs: []
            },
            
            // Setup listener for telemetry from preview iframe
            setupPreviewTelemetryListener() {
                window.addEventListener('message', (event) => {
                    if (event.data?.source === 'gsx-telemetry') {
                        this.handlePreviewTelemetry(event.data);
                    }
                });
                console.log('[GSX Framework] Preview telemetry listener active');
            },
            
            // Handle telemetry data from preview
            handlePreviewTelemetry(data) {
                var type = data.type;
                var payload = data.data;
                var sid = data.sid;
                var ts = data.ts;
                
                switch (type) {
                    case 'error':
                        this.previewTelemetry.errors.push(payload);
                        this.trackBehavior('preview_error', { 
                            message: payload.message ? payload.message.substring(0, 50) : 'Unknown error',
                            type: payload.type || 'error'
                        });
                        // Show error in chat
                        this.addMessage('error', ' Preview Error: ' + (payload.message || 'Unknown error'));
                        // Update error badge
                        this.updateErrorBadge();
                        // Auto-save error with session context to logs
                        this.saveErrorWithSession(payload);
                        // Queue for auto-fix (Smart Testing Mode)
                        this.queueErrorFix({
                            error: payload,
                            source: 'preview',
                            autoDetected: true
                        });
                        break;
                        
                    case 'start':
                        console.log('[GSX Telemetry] Preview session started:', sid);
                        this.previewTelemetry = { 
                            errors: [], 
                            events: [], 
                            clicks: [],
                            rrEvents: [],
                            sessionId: sid,
                            startTime: ts
                        };
                        break;
                        
                    case 'session':
                        console.log('[GSX Telemetry] Session data received:', payload.errors?.length, 'errors,', payload.rrEvents?.length, 'rrweb events');
                        // Store full session data including rrweb events
                        this.previewTelemetry.errors = payload.errors || [];
                        this.previewTelemetry.clicks = payload.clicks || [];
                        this.previewTelemetry.rrEvents = payload.rrEvents || [];
                        // Save session to logs if there were errors
                        if (payload.errors && payload.errors.length > 0) {
                            this.saveSessionToLogs(payload);
                        }
                        break;
                        
                    default:
                        // Store other events
                        if (payload) {
                            this.previewTelemetry.events.push({ type: type, payload: payload, ts: ts });
                        }
                }
            },
            
            // Save error with session context to event logs
            async saveErrorWithSession(error) {
                try {
                    var sessionContext = {
                        recentClicks: this.previewTelemetry.clicks ? this.previewTelemetry.clicks.slice(-10) : [],
                        rrEventCount: this.previewTelemetry.rrEvents ? this.previewTelemetry.rrEvents.length : 0,
                        sessionId: this.previewTelemetry.sessionId
                    };
                    
                    await window.aider.txdbLogEvent({
                        type: 'error',
                        summary: 'Preview Error: ' + (error.message || 'Unknown').substring(0, 100),
                        message: error.message,
                        context: JSON.stringify({
                            error: error,
                            session: sessionContext,
                            file: this.currentPreviewFile
                        }),
                        timestamp: new Date().toISOString()
                    });
                    console.log('[GSX Telemetry] Error saved to logs with session context');
                } catch (e) {
                    console.warn('[GSX Telemetry] Could not save error to logs:', e);
                }
            },
            
            // Save full session to logs (for debugging)
            async saveSessionToLogs(session) {
                try {
                    // Compress rrweb events for storage (keep last 500)
                    var compressedSession = {
                        sid: session.sid,
                        errors: session.errors,
                        clicks: session.clicks,
                        rrEventCount: session.rrEvents ? session.rrEvents.length : 0,
                        // Store subset of rrweb events around errors
                        rrEventsPreview: session.rrEvents ? session.rrEvents.slice(-100) : []
                    };
                    
                    await window.aider.txdbLogEvent({
                        type: 'session',
                        summary: 'Session with ' + session.errors.length + ' errors, ' + (session.rrEvents ? session.rrEvents.length : 0) + ' recorded events',
                        message: 'Full session recording available',
                        context: JSON.stringify(compressedSession),
                        timestamp: new Date().toISOString()
                    });
                    console.log('[GSX Telemetry] Session saved to logs');
                } catch (e) {
                    console.warn('[GSX Telemetry] Could not save session to logs:', e);
                }
            },
            
            // Get AI instructions for including framework
            getFrameworkInstructions() {
                return 'IMPORTANT: All HTML files should include error tracking.\n' +
                    'Add window.onerror and window.onunhandledrejection handlers to capture errors.\n' +
                    'The GSX framework will be auto-injected during build.';
            },
            
            // Inject framework into HTML content
            injectFrameworkIntoHtml(html) {
                // Skip if already has framework
                if (html.includes('__GSX_TELEMETRY_INITIALIZED__') || html.includes('GSX Telemetry')) {
                    return html;
                }
                
                // Full telemetry script with rrweb session recording
                var telemetryScript = this.getFullTelemetryScript();
                
                // Use <\/script> to avoid breaking HTML parser
                var scriptTag = '<!-- GSX Telemetry --><script>' + telemetryScript + '<' + '/script>';
                
                if (html.includes('</head>')) {
                    return html.replace('</head>', scriptTag + '</head>');
                } else if (html.indexOf('<body') !== -1) {
                    return html.replace(/<body[^>]*>/, function(match) { return match + scriptTag; });
                }
                return scriptTag + html;
            },
            
            // Get the full telemetry script (built dynamically to avoid escaping issues)
            getFullTelemetryScript() {
                // This script includes: error tracking, click tracking, rrweb loading, and session recording
                return [
                    '(function(w,d){',
                    'if(w.__GSX_TELEMETRY_INITIALIZED__)return;',
                    'w.__GSX_TELEMETRY_INITIALIZED__=true;',
                    'var T={',
                    '  sid:"gsx_"+Date.now().toString(36),',
                    '  events:[],',
                    '  errors:[],',
                    '  clicks:[],',
                    '  rrEvents:[],',
                    '  rrStop:null,',
                    '  report:function(type,data){',
                    '    try{w.parent.postMessage({source:"gsx-telemetry",type:type,data:data,sid:this.sid,ts:Date.now()},"*");}catch(e){}',
                    '  },',
                    '  error:function(msg,file,line,col,err){',
                    '    var e={message:msg,filename:file,lineno:line,colno:col,stack:err?err.stack:"",ts:Date.now()};',
                    '    this.errors.push(e);',
                    '    this.report("error",e);',
                    '  },',
                    '  click:function(el){',
                    '    var c={tag:el.tagName,id:el.id,class:el.className,text:(el.textContent||"").substring(0,30),ts:Date.now()};',
                    '    this.clicks.push(c);',
                    '    if(this.clicks.length>100)this.clicks.shift();',
                    '  },',
                    '  loadRrweb:function(){',
                    '    var s=d.createElement("script");',
                    '    s.src="https://cdn.jsdelivr.net/npm/rrweb@2.0.0-alpha.11/dist/rrweb.min.js";',
                    '    s.onload=function(){T.startRecording();};',
                    '    d.head.appendChild(s);',
                    '  },',
                    '  startRecording:function(){',
                    '    if(!w.rrweb)return;',
                    '    try{',
                    '      this.rrStop=w.rrweb.record({',
                    '        emit:function(ev){',
                    '          T.rrEvents.push(ev);',
                    '          if(T.rrEvents.length>5000)T.rrEvents=T.rrEvents.slice(-5000);',
                    '        },',
                    '        sampling:{mousemove:false,scroll:150,input:"last"},',
                    '        blockClass:"gsx-no-record",',
                    '        maskAllInputs:false,',
                    '        maskInputOptions:{password:true}',
                    '      });',
                    '      console.log("[GSX] rrweb recording started");',
                    '    }catch(e){console.warn("[GSX] rrweb error:",e);}',
                    '  },',
                    '  getSession:function(){',
                    '    return{sid:this.sid,errors:this.errors,clicks:this.clicks.slice(-20),rrEvents:this.rrEvents.slice(-1000)};',
                    '  }',
                    '};',
                    'w.onerror=function(m,f,l,c,e){T.error(m,f,l,c,e);};',
                    'w.onunhandledrejection=function(e){T.error("Promise: "+(e.reason?e.reason.message:e.reason),"",0,0,e.reason);};',
                    'd.addEventListener("click",function(e){',
                    '  var t=e.target.closest("button,a,[onclick],input[type=submit]");',
                    '  if(t)T.click(t);',
                    '},{passive:true});',
                    'w.addEventListener("beforeunload",function(){T.report("session",T.getSession());});',
                    'T.loadRrweb();',
                    'T.report("start",{url:location.href,ua:navigator.userAgent});',
                    'w.GSXTelemetry=T;',
                    'console.log("[GSX Telemetry] Active with rrweb");',
                    '})(window,document);'
                ].join('');
            },
            
            // Get preview telemetry summary for evaluation
            getPreviewTelemetrySummary() {
                return {
                    errorCount: this.previewTelemetry.errors.length,
                    errors: this.previewTelemetry.errors.slice(-10),
                    eventCount: this.previewTelemetry.events.length,
                    consoleErrors: this.previewTelemetry.consoleLogs.filter(function(l) { return l.level === 'error'; }),
                    consoleWarnings: this.previewTelemetry.consoleLogs.filter(function(l) { return l.level === 'warn'; })
                };
            },
            
            // ========== END GSX FRAMEWORK INTEGRATION ==========
            
            // Check if error is significant (not noise)
            isSignificantError(message) {
                if (!message) return false;
                
                const noisePatterns = [
                    'ResizeObserver',
                    'Script error',
                    'Autofill',
                    'Extension context',
                    'chrome-extension',
                    'moz-extension',
                    'net::ERR_',
                    'favicon.ico',
                    'Loading module',
                    'DevTools',
                    'Violation'
                ];
                
                return !noisePatterns.some(pattern => message.includes(pattern));
            },
            
            // Update error count badge in UI
            updateErrorBadge() {
                const errorCount = this.errorAnalyzer.errorLog.filter(e => !e.fixed).length;
                let badge = document.getElementById('errorBadge');
                
                if (!badge) {
                    // Create badge next to status
                    const statusDiv = document.querySelector('.status');
                    if (statusDiv) {
                        badge = document.createElement('span');
                        badge.id = 'errorBadge';
                        badge.style.cssText = 'display: none; background: var(--danger); color: white; font-size: 10px; padding: 2px 6px; border-radius: 10px; margin-left: 8px; cursor: pointer;';
                        badge.onclick = () => this.showEventLogs();
                        statusDiv.appendChild(badge);
                    }
                }
                
                if (badge) {
                    if (errorCount > 0) {
                        badge.textContent = `${errorCount} error${errorCount > 1 ? 's' : ''}`;
                        badge.style.display = 'inline';
                    } else {
                        badge.style.display = 'none';
                    }
                }
            },
            
            // Show error log (in-memory session errors)
            showErrorLog() {
                const errors = this.errorAnalyzer.errorLog.slice(0, 10);
                if (errors.length === 0) {
                    this.addMessage('system', 'No errors in current session. Click the error badge to view saved logs.');
                    return;
                }
                
                const errorList = errors.map((e, i) => 
                    `${i + 1}. [${e.type}] ${e.message.substring(0, 50)}... ${e.fixed ? '' : ''}`
                ).join('\n');
                
                this.addMessage('system', ` Session Errors:\n${errorList}\n\n Tip: Use window.logError(error) to save errors permanently.`);
            },
            
            // Capture and analyze an error
            async captureError(type, message, stack, location = {}) {
                // Skip if this error is suppressed
                const errorKey = `${type}:${message}`;
                if (this.errorAnalyzer.suppressedErrors.has(errorKey)) return;
                
                // Skip certain noise errors
                if (message.includes('ResizeObserver') || 
                    message.includes('Script error') ||
                    message.includes('Autofill')) return;
                
                const error = {
                    id: Date.now(),
                    type,
                    message,
                    stack: stack || 'No stack trace',
                    file: location.file || this.parseFileFromStack(stack),
                    line: location.line || this.parseLineFromStack(stack),
                    timestamp: new Date().toISOString(),
                    context: {
                        currentFile: this.currentPreviewFile,
                        phase: this.cycleState.currentPhase,
                        version: this.cycleState.currentVersion
                    },
                    aiAnalysis: null,
                    suggestedFix: null
                };
                
                // Add to log
                this.errorAnalyzer.errorLog.unshift(error);
                if (this.errorAnalyzer.errorLog.length > this.errorAnalyzer.maxLogSize) {
                    this.errorAnalyzer.errorLog.pop();
                }
                
                // Store current error
                this.errorAnalyzer.currentError = error;
                
                // Update error badge
                this.updateErrorBadge();
                
                // Show modal
                this.showErrorModal(error);
                
                // Analyze with AI
                await this.analyzeErrorWithAI(error);
            },
            
            // Parse file from stack trace
            parseFileFromStack(stack) {
                if (!stack) return 'Unknown';
                const match = stack.match(/at\s+.*?\s+\(?(.*?):(\d+):(\d+)\)?/);
                if (match) {
                    return match[1].split('/').pop();
                }
                return 'Unknown';
            },
            
            // Parse line from stack trace
            parseLineFromStack(stack) {
                if (!stack) return '-';
                const match = stack.match(/at\s+.*?\s+\(?(.*?):(\d+):(\d+)\)?/);
                if (match) {
                    return match[2];
                }
                return '-';
            },
            
            // Show error modal
            showErrorModal(error) {
                const modal = document.getElementById('errorAnalyzerModal');
                const msgEl = document.getElementById('errorMessage');
                const fileEl = document.getElementById('errorFile');
                const lineEl = document.getElementById('errorLine');
                const stackEl = document.getElementById('errorStack');
                const analysisEl = document.getElementById('errorAIAnalysis');
                const fixBtn = document.getElementById('errorFixBtn');
                
                msgEl.textContent = error.message;
                fileEl.textContent = error.file || 'Unknown';
                lineEl.textContent = error.line || '-';
                stackEl.textContent = error.stack || 'No stack trace';
                analysisEl.textContent = ' Analyzing error...';
                analysisEl.classList.add('loading');
                fixBtn.disabled = true;
                
                modal.classList.add('active');
            },
            
            // Close error modal
            closeErrorModal() {
                document.getElementById('errorAnalyzerModal').classList.remove('active');
            },
            
            // Analyze error with AI - with web search for up-to-date info
            async analyzeErrorWithAI(error) {
                const analysisEl = document.getElementById('errorAIAnalysis');
                const fixBtn = document.getElementById('errorFixBtn');
                
                try {
                    // Step 1: Build search query from error to get up-to-date info
                    analysisEl.textContent = ' Searching for up-to-date solutions...';
                    
                    // Extract key terms from error for web search
                    const searchTerms = this.extractSearchTermsFromError(error);
                    let webSearchContext = '';
                    
                    if (searchTerms && window.aider && window.aider.webSearch) {
                        try {
                            console.log('[ErrorAnalyzer] Searching web for:', searchTerms);
                            const searchResult = await window.aider.webSearch(searchTerms, { maxResults: 5 });
                            
                            if (searchResult.success && searchResult.results.length > 0) {
                                webSearchContext = `\n\n## Recent Web Search Results (${new Date().toLocaleDateString()}):\n`;
                                searchResult.results.forEach((r, i) => {
                                    webSearchContext += `${i + 1}. **${r.title}**\n`;
                                    if (r.snippet) webSearchContext += `   ${r.snippet}\n`;
                                    webSearchContext += `   Source: ${r.url}\n\n`;
                                });
                                console.log('[ErrorAnalyzer] Found', searchResult.results.length, 'web results');
                            }
                        } catch (searchErr) {
                            console.log('[ErrorAnalyzer] Web search failed (continuing with AI):', searchErr.message);
                        }
                    }
                    
                    // Step 2: Build AI prompt with search context
                    analysisEl.textContent = ' Analyzing with AI...';
                    
                    const prompt = `Analyze this JavaScript error and provide:
1. A clear explanation of what caused it
2. The likely root cause
3. A specific fix suggestion

IMPORTANT: Use the web search results below for up-to-date information about APIs, library versions, and current best practices. Do NOT rely on potentially outdated training data for version-specific information.

Error Type: ${error.type}
Error Message: ${error.message}
File: ${error.file}
Line: ${error.line}
Stack Trace:
${error.stack}

Context:
- Current file being edited: ${error.context.currentFile || 'None'}
- Development phase: ${error.context.phase || 'None'}
${webSearchContext}

Please provide a concise analysis and actionable fix. If the web search results contain relevant solutions or updated API information, incorporate that into your response.`;

                    // Use the vision API for analysis (it can handle text too)
                    const result = await window.aider.analyzeScreenshot(null, prompt);
                    
                    if (result.success && result.analysis) {
                        error.aiAnalysis = result.analysis;
                        error.suggestedFix = this.extractFixFromAnalysis(result.analysis);
                        error.searchContext = webSearchContext; // Store for reference
                        
                        analysisEl.innerHTML = this.formatAIAnalysis(result.analysis);
                        analysisEl.classList.remove('loading');
                        
                        if (error.suggestedFix) {
                            fixBtn.disabled = false;
                        }
                    } else {
                        analysisEl.textContent = 'AI analysis unavailable. Check API configuration.';
                        analysisEl.classList.remove('loading');
                    }
                } catch (e) {
                    console.log('[ErrorAnalyzer] AI analysis failed:', e);
                    analysisEl.textContent = `AI analysis failed: ${e.message}`;
                    analysisEl.classList.remove('loading');
                }
            },
            
            // Extract search terms from error for web search
            extractSearchTermsFromError(error) {
                const terms = [];
                
                // Get the core error type
                if (error.type) {
                    terms.push(error.type);
                }
                
                // Extract key phrases from error message
                const message = error.message || '';
                
                // Look for API/library names
                const apiPatterns = /(?:@[\w-]+\/[\w-]+|[\w-]+\.js|[\w-]+SDK|API|Claude|GPT|OpenAI|Anthropic|Electron|Node|npm|webpack|react|vue|angular)/gi;
                const apiMatches = message.match(apiPatterns);
                if (apiMatches) {
                    terms.push(...apiMatches);
                }
                
                // Look for version numbers
                const versionPatterns = /v?\d+\.\d+(?:\.\d+)?/g;
                const versionMatches = message.match(versionPatterns);
                if (versionMatches) {
                    terms.push(...versionMatches.slice(0, 2)); // Limit versions
                }
                
                // Look for common error patterns
                const errorPatterns = /(cannot read|undefined|is not a function|ENOENT|EACCES|TypeError|ReferenceError|SyntaxError|module not found|deprecated|breaking change)/gi;
                const errorMatches = message.match(errorPatterns);
                if (errorMatches) {
                    terms.push(errorMatches[0]);
                }
                
                // Extract quoted strings (often contain important identifiers)
                const quotedMatches = message.match(/['"]([^'"]+)['"]/g);
                if (quotedMatches) {
                    terms.push(...quotedMatches.slice(0, 2).map(q => q.replace(/['"]/g, '')));
                }
                
                // Get file extension context
                const file = error.file || '';
                if (file.endsWith('.ts') || file.endsWith('.tsx')) {
                    terms.push('TypeScript');
                } else if (file.endsWith('.js') || file.endsWith('.jsx')) {
                    terms.push('JavaScript');
                }
                
                // Build search query
                const uniqueTerms = [...new Set(terms)].slice(0, 6);
                const searchQuery = uniqueTerms.join(' ') + ' fix solution 2024 2025';
                
                return searchQuery.length > 10 ? searchQuery : `${error.type} ${message.slice(0, 50)} fix`;
            },
            
            // Format AI analysis for display
            formatAIAnalysis(analysis) {
                // Simple markdown-like formatting
                return analysis
                    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                    .replace(/`(.*?)`/g, '<code style="background: var(--bg-primary); padding: 2px 6px; border-radius: 3px;">$1</code>')
                    .replace(/\n/g, '<br>');
            },
            
            // Extract fix suggestion from analysis
            extractFixFromAnalysis(analysis) {
                // Look for code blocks or fix suggestions
                const codeMatch = analysis.match(/```[\s\S]*?```/);
                if (codeMatch) {
                    return codeMatch[0].replace(/```\w*\n?/g, '').trim();
                }
                
                // Look for "fix:" or "solution:" patterns
                const fixMatch = analysis.match(/(?:fix|solution|change|replace):\s*(.+?)(?:\n|$)/i);
                if (fixMatch) {
                    return fixMatch[1].trim();
                }
                
                return null;
            },
            
            // Fix the error using Aider
            async fixError() {
                const error = this.errorAnalyzer.currentError;
                if (!error || !error.aiAnalysis) return;
                
                this.closeErrorModal();
                
                // Add message to chat
                this.addMessage('system', ` Fixing error: ${error.message.substring(0, 50)}...`);
                
                // Create fix prompt
                const fixPrompt = `Please fix this error in the code:

Error: ${error.message}
File: ${error.file}
Line: ${error.line}

AI Analysis:
${error.aiAnalysis}

Please make the necessary code changes to fix this error.`;
                
                // Send to Aider
                try {
                    await this.executeTask(fixPrompt);
                    this.addMessage('system', ' Fix applied');
                    
                    // Mark as addressed in error log
                    error.fixed = true;
                    error.fixedAt = new Date().toISOString();
                } catch (e) {
                    this.addMessage('error', `Fix failed: ${e.message}`);
                }
            },
            
            // Save error to log file
            async saveErrorToLog() {
                const error = this.errorAnalyzer.currentError;
                if (!error) return;
                
                // Format error for log
                const logEntry = `
## Error - ${new Date(error.timestamp).toLocaleString()}

**Type:** ${error.type}
**Message:** ${error.message}
**File:** ${error.file}
**Line:** ${error.line}

### Stack Trace
\`\`\`
${error.stack}
\`\`\`

### AI Analysis
${error.aiAnalysis || 'Not analyzed'}

---
`;
                
                // Append to error log file
                const logFile = `${this.repoPath}/error-log.md`;
                try {
                    let existingLog = await this.loadCycleFile('errorLog', false) || '# Error Log\n\n';
                    existingLog += logEntry;
                    await this.executeTask(`Update error-log.md with this error entry:\n\n${logEntry}`);
                    this.addMessage('system', ' Error saved to error-log.md');
                } catch (e) {
                    console.error('[ErrorAnalyzer] Save failed:', e);
                }
                
                this.closeErrorModal();
            },
            
            // Suppress an error (don't show again)
            suppressError() {
                const error = this.errorAnalyzer.currentError;
                if (error) {
                    const errorKey = `${error.type}:${error.message}`;
                    this.errorAnalyzer.suppressedErrors.add(errorKey);
                }
                this.closeErrorModal();
            },
            
            // ========== END ERROR ANALYZER ==========
            
            getFileIcon(filename) {
                const ext = filename.split('.').pop().toLowerCase();
                const icons = { html: '', css: '', js: '', ts: '', py: '', json: '', md: '' };
                return icons[ext] || '';
            },
            
            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            },
            
            setupEventListeners() {
                const input = document.getElementById('promptInput');
                
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        this.sendPrompt();
                    }
                });
                
                input.addEventListener('input', function() {
                    this.style.height = 'auto';
                    this.style.height = Math.min(this.scrollHeight, 120) + 'px';
                });
                
                // File change listener - refresh preview when files change
                if (window.aider.onFileChanged) {
                    window.aider.onFileChanged((filePath) => {
                        console.log('[GSX Create] File changed:', filePath);
                        // Refresh preview if it's the current file
                        if (this.currentPreviewFile && filePath === this.currentPreviewFile) {
                            this.refreshPreview();
                        }
                        // Also refresh file list
                        this.loadProjectFiles();
                    });
                }
                
                // Resize handle for preview panel
                this.setupResizeHandle();
            },
            
            setupResizeHandle() {
                // Preview panel resize only
                const previewHandle = document.getElementById('previewResizeHandle');
                const previewPanel = document.getElementById('previewPanel');
                
                if (!previewHandle || !previewPanel) return;
                
                let isResizing = false;
                let startX, startWidth;
                
                // Create overlay to prevent iframe from capturing mouse events
                const overlay = document.createElement('div');
                overlay.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; z-index: 9999; cursor: ew-resize; display: none;';
                document.body.appendChild(overlay);
                
                const stopResize = () => {
                    if (isResizing) {
                        isResizing = false;
                        previewHandle.classList.remove('dragging');
                        overlay.style.display = 'none';
                        document.body.style.userSelect = '';
                    }
                };
                
                previewHandle.addEventListener('mousedown', (e) => {
                    isResizing = true;
                    startX = e.clientX;
                    startWidth = previewPanel.offsetWidth;
                    previewHandle.classList.add('dragging');
                    overlay.style.display = 'block';
                    document.body.style.userSelect = 'none';
                    e.preventDefault();
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (!isResizing) return;
                    // Dragging left edge - moving left increases width
                    const diff = startX - e.clientX;
                    const newWidth = Math.max(200, Math.min(startWidth + diff, window.innerWidth * 0.7));
                    previewPanel.style.width = newWidth + 'px';
                });
                
                document.addEventListener('mouseup', stopResize);
            },
            
            // ========== META LEARNING CYCLE METHODS ==========
            
            // Required files for each phase
            phaseRequiredFiles: {
                evaluate: [
                    { name: 'evaluation-criteria.md', description: 'Evaluation criteria for rating the app' },
                    { name: 'user-feedback.md', description: 'User feedback (end-user, advocate, AI-generated)' }
                ],
                research: [
                    { name: 'research-notes.md', description: 'Research findings and insights' }
                ],
                plan: [
                    { name: 'todo.md', description: 'Task list for current iteration' }
                ],
                execute: [
                    { name: 'style-guide.md', description: 'Style guide for consistent design' }
                ],
                test: [
                    { name: 'TEST-PLAN.md', description: 'Test plan tracking all tests' }
                ],
                improve: []
            },
            
            // Check and create required files for a phase
            async checkPhaseRequiredFiles(phaseName) {
                var requiredFiles = this.phaseRequiredFiles[phaseName] || [];
                if (requiredFiles.length === 0) return true;
                
                this.addMessage('system', ' Checking required files for ' + phaseName + ' phase...');
                
                var missingFiles = [];
                var existingFiles = [];
                
                for (var i = 0; i < requiredFiles.length; i++) {
                    var file = requiredFiles[i];
                    var filePath = this.repoPath + '/' + file.name;
                    try {
                        var content = await window.aider.readFile(filePath);
                        if (content && content.trim().length > 0) {
                            existingFiles.push(file);
                        } else {
                            missingFiles.push(file);
                        }
                    } catch (e) {
                        missingFiles.push(file);
                    }
                }
                
                for (var i = 0; i < existingFiles.length; i++) {
                    this.addMessage('system', '    ' + existingFiles[i].name);
                }
                
                if (missingFiles.length > 0) {
                    this.addMessage('system', '');
                    this.addMessage('system', ' Missing required files:');
                    for (var i = 0; i < missingFiles.length; i++) {
                        this.addMessage('system', '    ' + missingFiles[i].name + ' - ' + missingFiles[i].description);
                    }
                    this.addMessage('system', '');
                    
                    for (var i = 0; i < missingFiles.length; i++) {
                        await this.createRequiredFile(missingFiles[i]);
                    }
                    return false;
                }
                return true;
            },
            
            // Create a required file with template
            async createRequiredFile(file) {
                var filePath = this.repoPath + '/' + file.name;
                var template = this.getFileTemplate(file.name);
                
                try {
                    await window.aider.writeFile(filePath, template);
                    this.addMessage('system', ' Created: ' + file.name);
                    
                    // Refresh the file list so new file appears in sidebar
                    await this.loadProjectFiles();
                    
                    // Show preview
                    this.addMessage('system', ''.repeat(40));
                    var lines = template.split('\n').slice(0, 10);
                    for (var i = 0; i < lines.length; i++) {
                        this.addMessage('system', '   ' + lines[i]);
                    }
                    if (template.split('\n').length > 10) {
                        this.addMessage('system', '   ... (more content)');
                    }
                    this.addMessage('system', ''.repeat(40));
                } catch (e) {
                    this.addMessage('system', ' Failed to create ' + file.name + ': ' + e.message);
                }
            },
            
            // Get template for a file
            getFileTemplate(fileName) {
                var templates = {
                    'evaluation-criteria.md': '# Evaluation Criteria\n\nRate each criterion from 1-10 (10 = excellent)\n\n## Functionality\n- [ ] Core features work as expected\n- [ ] No JavaScript errors in console\n- [ ] Forms submit correctly\n- [ ] Navigation works properly\n\n## User Experience\n- [ ] Intuitive and easy to use\n- [ ] Clear visual hierarchy\n- [ ] Responsive design\n- [ ] Accessible (keyboard, screen reader)\n\n## Performance\n- [ ] Loads quickly (< 3 seconds)\n- [ ] Smooth animations\n- [ ] No lag or stuttering\n\n## Code Quality\n- [ ] Clean, readable code\n- [ ] Proper error handling\n- [ ] No deprecated APIs\n\n## Design\n- [ ] Visually appealing\n- [ ] Consistent styling\n- [ ] Good use of color and typography\n\n---\n*Edit this file to customize evaluation criteria for your project*\n',
                    
                    'user-feedback.md': '# User Feedback\n\n## End-User Feedback\n<!-- Feedback from actual users -->\n\n### Unaddressed\n- (No feedback yet)\n\n### Addressed\n- (None)\n\n---\n\n## Advocate Feedback\n<!-- Feedback from stakeholders -->\n\n### Unaddressed\n- (No feedback yet)\n\n### Addressed\n- (None)\n\n---\n\n## AI-Generated Feedback\n<!-- Feedback from Meta Learning Agent -->\n\n### Unaddressed\n- (Will be populated during Evaluate phase)\n\n### Addressed\n- (None)\n\n---\n*Add feedback in the appropriate section. Mark as addressed after fixed.*\n',
                    
                    'research-notes.md': '# Research Notes\n\n## Version History\n| Version | Date | Focus Area |\n|---------|------|------------|\n| v1 | ' + new Date().toISOString().split('T')[0] + ' | Initial research |\n\n---\n\n## Current Research (v1)\n\n### Problem Statement\n(What issues need to be addressed?)\n\n### Findings\n(Research findings go here)\n\n### Recommendations\n(Recommended solutions)\n\n### Resources\n- (Links and references)\n\n---\n*Updated each cycle with new research findings*\n',
                    
                    'todo.md': '# Todo List\n\n## Version: v1\n**Status:** Planning\n\n---\n\n## Tasks\n\n### Pending\n- [ ] (Tasks will be added during Plan phase)\n\n### In Progress\n- (None)\n\n### Completed\n- (None)\n\n---\n\n## Notes\n(Additional notes)\n\n---\n*Updated during Plan and Execute phases*\n',
                    
                    'style-guide.md': '# Style Guide\n\n## Colors\n\n### Primary\n- Primary: #3b82f6 (Blue)\n- Primary Light: #60a5fa\n- Primary Dark: #2563eb\n\n### Neutral\n- Background: #ffffff\n- Surface: #f8fafc\n- Border: #e2e8f0\n- Text: #1e293b\n\n### Semantic\n- Success: #22c55e\n- Warning: #f59e0b\n- Error: #ef4444\n\n---\n\n## Typography\n\n### Fonts\n- Headings: System UI, sans-serif\n- Body: System UI, sans-serif\n- Code: Menlo, Monaco, monospace\n\n### Sizes\n- h1: 2rem\n- h2: 1.5rem\n- h3: 1.25rem\n- body: 1rem\n\n---\n\n## Spacing\n- sm: 0.5rem\n- md: 1rem\n- lg: 1.5rem\n- xl: 2rem\n\n---\n*Customize this for your project*\n',
                    
                    'TEST-PLAN.md': '# Test Plan\n\n## Overview\n| Metric | Count |\n|--------|-------|\n| Total Tests | 0 |\n| Passing | 0 |\n| Failing | 0 |\n\n---\n\n## UI Tests\n| Test | Status | Last Run |\n|------|--------|----------|\n| (Tests will be added) | - | - |\n\n---\n\n## API Tests\n| Endpoint | Method | Status |\n|----------|--------|--------|\n| (API tests will be added) | - | - |\n\n---\n\n## Integration Tests\n| Test | Status |\n|------|--------|\n| (Integration tests will be added) | - |\n\n---\n*Auto-updated by Meta Learning Agent*\n'
                };
                return templates[fileName] || '# ' + fileName + '\n\n(Content goes here)\n';
            },
            
            // Wait for user approval of created files
            async waitForFileApproval() {
                var self = this;
                return new Promise(function(resolve) {
                    self.addMessage('system', '');
                    self.addMessage('system', ' **Review the created files above**');
                    self.addMessage('system', '');
                    self.addMessage('system', '   Edit these files in the sidebar to customize them.');
                    self.addMessage('system', '   When ready, click  to continue.');
                    self.addMessage('system', '');
                    
                    self.cycleState.paused = true;
                    self.cycleState.waitingForApproval = true;
                    self.cycleState.approvalCallback = resolve;
                    self.updateCycleUI();
                });
            },
            
            // Initialize cycle panel (call after session starts)
            initCyclePanel() {
                const cyclePanel = document.getElementById('cyclePanel');
                cyclePanel.classList.add('visible');
                this.renderVersionTimeline();
                this.updateCycleUI();
            },
            
            // Render version timeline pills
            renderVersionTimeline() {
                const timeline = document.getElementById('versionTimeline');
                if (!timeline) return;
                
                const versions = [];
                for (let i = 1; i <= Math.max(this.cycleState.currentVersion, 1); i++) {
                    versions.push(i);
                }
                
                timeline.innerHTML = versions.map(v => `
                    <div class="version-pill ${v === this.cycleState.currentVersion ? 'active' : ''}" 
                         onclick="GSXCreate.goToVersion(${v})"
                         title="Version ${v}">
                        v${v}
                    </div>
                `).join('');
            },
            
            // Ensure a version entry exists in cycleState.versions (source of truth for timeline details)
            ensureVersionEntry(version) {
                const v = Number(version) || 1;
                if (!Array.isArray(this.cycleState.versions)) this.cycleState.versions = [];
                let entry = this.cycleState.versions.find(x => Number(x.version) === v);
                if (!entry) {
                    entry = {
                        version: v,
                        timestamp: null,
                        objective: null,
                        releaseNotes: '',
                        phaseSummary: '',
                        scoreDelta: null,
                        costDelta: null,
                        testsSummary: '',
                        filesChanged: []
                    };
                    this.cycleState.versions.push(entry);
                    // Keep stable ordering
                    this.cycleState.versions.sort((a, b) => Number(a.version) - Number(b.version));
                    this.saveCycleState();
                }
                return entry;
            },

            // Open the Version Timeline modal (Tesla-style release trail)
            showVersionTimeline(selectedVersion = null) {
                const modal = document.getElementById('versionTimelineModal');
                const body = document.getElementById('versionTimelineModalBody');
                if (!modal || !body) return;

                // Make sure we have at least placeholder entries up to currentVersion
                const maxV = Math.max(this.cycleState.currentVersion || 1, 1);
                for (let i = 1; i <= maxV; i++) this.ensureVersionEntry(i);

                const versions = (this.cycleState.versions || []).slice().sort((a, b) => Number(b.version) - Number(a.version));
                const activeV = Number(selectedVersion || this.cycleState.currentVersion || (versions[0] && versions[0].version) || 1);

                const renderBadge = (entry) => {
                    const count = Array.isArray(entry.filesChanged) ? entry.filesChanged.length : 0;
                    if (!count) return `<span style="opacity:0.7; font-size: 11px;">No change data</span>`;
                    const big = count >= 5;
                    return `<span style="font-size: 11px; padding: 2px 8px; border-radius: 999px; border: 1px solid var(--border); background: rgba(255,255,255,0.06);">${big ? 'Big update' : 'Small update'}</span>`;
                };

                const safe = (s) => this.escapeHtml(String(s || ''));
                const formatWhen = (ts) => {
                    if (!ts) return '';
                    try { return new Date(ts).toLocaleString(); } catch { return String(ts); }
                };

                const activeEntry = versions.find(v => Number(v.version) === activeV) || versions[0] || this.ensureVersionEntry(1);
                const activeFiles = Array.isArray(activeEntry.filesChanged) ? activeEntry.filesChanged : [];
                const filesHtml = activeFiles.length
                    ? `<ul style="margin: 8px 0 0 18px;">${activeFiles.slice(0, 50).map(f => `<li style="margin: 2px 0;">${safe(f)}</li>`).join('')}</ul>`
                    : `<div style="opacity:0.75; font-size: 12px; margin-top: 8px;">No files recorded for this version.</div>`;

                body.innerHTML = `
                    <div style="display:flex; gap: 16px;">
                        <div style="width: 320px; border-right: 1px solid var(--border); padding-right: 12px; max-height: 520px; overflow: auto;">
                            ${versions.map(v => {
                                const isActive = Number(v.version) === Number(activeEntry.version);
                                const title = v.objective ? safe(v.objective).substring(0, 60) : `Version v${v.version}`;
                                const notes = (v.releaseNotes || '').trim();
                                const notesPreview = notes ? safe(notes).split('<br>')[0].substring(0, 80) : 'No notes yet';
                                return `
                                    <div onclick="GSXCreate.showVersionTimeline(${Number(v.version)})"
                                         style="cursor:pointer; padding: 10px 10px; border-radius: 10px; border: 1px solid var(--border); margin-bottom: 10px; background: ${isActive ? 'rgba(255,255,255,0.06)' : 'transparent'};">
                                        <div style="display:flex; justify-content: space-between; align-items:center;">
                                            <div style="font-weight: 700;">v${Number(v.version)}</div>
                                            ${renderBadge(v)}
                                        </div>
                                        <div style="font-size: 12px; opacity: 0.9; margin-top: 6px;">${title}</div>
                                        <div style="font-size: 11px; opacity: 0.7; margin-top: 4px;">${notesPreview}</div>
                                        <div style="font-size: 10px; opacity: 0.6; margin-top: 6px;">${safe(formatWhen(v.timestamp))}</div>
                                    </div>
                                `;
                            }).join('')}
                        </div>

                        <div style="flex: 1; max-height: 520px; overflow: auto;">
                            <div style="display:flex; align-items:center; justify-content: space-between; gap: 12px;">
                                <div>
                                    <div style="font-size: 18px; font-weight: 800;">v${Number(activeEntry.version)}</div>
                                    <div style="font-size: 12px; opacity: 0.8; margin-top: 2px;">
                                        ${safe(formatWhen(activeEntry.timestamp))}
                                    </div>
                                </div>
                                <div style="display:flex; gap: 8px; flex-wrap: wrap;">
                                    ${Number(activeEntry.version) !== this.cycleState.currentVersion ? `
                                        <button class="btn btn-primary btn-sm" onclick="GSXCreate.restoreVersion(${Number(activeEntry.version)}); GSXCreate.closeModal('versionTimelineModal');" 
                                                title="Restore files from this version">
                                             Restore v${Number(activeEntry.version)}
                                        </button>
                                    ` : `
                                        <span class="btn btn-secondary btn-sm" style="opacity: 0.5; cursor: default;">Current Version</span>
                                    `}
                                    <button class="btn btn-secondary btn-sm" onclick="GSXCreate.previewVersion(${Number(activeEntry.version)}); GSXCreate.closeModal('versionTimelineModal');">
                                         View Info
                                    </button>
                                </div>
                            </div>

                            <div style="margin-top: 14px; border: 1px solid var(--border); border-radius: 12px; padding: 12px;">
                                <div style="font-weight: 700; margin-bottom: 6px;">What changed</div>
                                <div style="font-size: 12px; opacity: 0.9;">
                                    ${(activeEntry.releaseNotes || '').trim()
                                        ? safe(activeEntry.releaseNotes).replace(/\\n/g, '<br>')
                                        : '<span style="opacity:0.75;">No release notes yet for this version.</span>'}
                                </div>
                            </div>

                            <div style="margin-top: 12px; display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                                <div style="border: 1px solid var(--border); border-radius: 12px; padding: 12px;">
                                    <div style="font-weight: 700; margin-bottom: 6px;">Progress</div>
                                    <div style="font-size: 12px; opacity: 0.9;">
                                        <div><span style="opacity:0.7;">Objective:</span> ${activeEntry.objective ? safe(activeEntry.objective) : ''}</div>
                                        <div><span style="opacity:0.7;">Phase summary:</span> ${activeEntry.phaseSummary ? safe(activeEntry.phaseSummary) : ''}</div>
                                        <div><span style="opacity:0.7;">Score delta:</span> ${activeEntry.scoreDelta ?? ''}</div>
                                        <div><span style="opacity:0.7;">Cost delta:</span> ${activeEntry.costDelta ?? ''}</div>
                                    </div>
                                </div>

                                <div style="border: 1px solid var(--border); border-radius: 12px; padding: 12px;">
                                    <div style="font-weight: 700; margin-bottom: 6px;">Tests</div>
                                    <div style="font-size: 12px; opacity: 0.9;">
                                        ${(activeEntry.testsSummary || '').trim()
                                            ? safe(activeEntry.testsSummary).replace(/\\n/g, '<br>')
                                            : '<span style="opacity:0.75;">No test summary recorded.</span>'}
                                    </div>
                                </div>
                            </div>

                            <div style="margin-top: 12px; border: 1px solid var(--border); border-radius: 12px; padding: 12px;">
                                <div style="font-weight: 700; margin-bottom: 6px;">Files changed</div>
                                <div style="font-size: 12px; opacity: 0.9;">${filesHtml}</div>
                            </div>
                        </div>
                    </div>
                `;

                modal.classList.add('active');
            },
            
            // Update cycle UI state
            updateCycleUI() {
                // Update consciousness button state
                const ctrlBtn = document.getElementById('cycleCtrlBtn');
                
                if (ctrlBtn) {
                    // Remove all state classes
                    ctrlBtn.classList.remove('alive', 'paused', 'thinking', 'igniting', 'running');
                    
                    if (this.cycleState.active && !this.cycleState.paused) {
                        // Active and running - consciousness alive
                        ctrlBtn.classList.add('alive');
                        ctrlBtn.title = 'Consciousness active - click to pause';
                    } else if (this.cycleState.active && this.cycleState.paused) {
                        // Active but paused - resting
                        ctrlBtn.classList.add('paused');
                        ctrlBtn.title = 'Resting - click to resume';
                    } else {
                        // Dormant - waiting to awaken
                        ctrlBtn.title = 'Awaken consciousness';
                    }
                }
                
                // Update score display
                const scoreEl = document.getElementById('cycleScore');
                if (scoreEl) {
                    scoreEl.textContent = `${this.cycleState.currentScore || 0}%`;
                }
                
                // Update progress bar
                const progressFill = document.getElementById('cycleProgressFill');
                if (progressFill) {
                    progressFill.style.width = `${this.cycleState.currentScore || 0}%`;
                }
                
                // Update version display
                const versionLabel = document.getElementById('cycleVersion');
                if (versionLabel) versionLabel.textContent = `v${this.cycleState.currentVersion}`;
                
                // Re-render version timeline
                this.renderVersionTimeline();
            },
            
            // Go to specific version
            goToVersion(version) {
                this.cycleState.currentVersion = version;
                this.updateCycleUI();
                this.addMessage('system', `Switched to version ${version}`);
            },
            
            // Set consciousness thinking state (for active processing)
            setConsciousnessThinking(isThinking) {
                const ctrlBtn = document.getElementById('cycleCtrlBtn');
                if (!ctrlBtn || !this.cycleState.active) return;
                
                if (isThinking) {
                    ctrlBtn.classList.add('thinking');
                    ctrlBtn.classList.remove('alive');
                } else {
                    ctrlBtn.classList.remove('thinking');
                    ctrlBtn.classList.add('alive');
                }
            },
            
            // Play consciousness sounds (subtle audio feedback)
            playConsciousnessSound(type) {
                if (!this.consciousnessAudio) {
                    this.consciousnessAudio = this.initConsciousnessAudio();
                }
                
                const audio = this.consciousnessAudio;
                if (!audio || !audio.ctx) return;
                
                const ctx = audio.ctx;
                const now = ctx.currentTime;
                
                try {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    
                    switch(type) {
                        case 'ignite':
                            // Rising tone - like a breath in
                            osc.type = 'sine';
                            osc.frequency.setValueAtTime(220, now);
                            osc.frequency.exponentialRampToValueAtTime(440, now + 0.3);
                            gain.gain.setValueAtTime(0, now);
                            gain.gain.linearRampToValueAtTime(0.08, now + 0.1);
                            gain.gain.linearRampToValueAtTime(0, now + 0.5);
                            osc.start(now);
                            osc.stop(now + 0.5);
                            break;
                            
                        case 'rest':
                            // Falling tone - like an exhale
                            osc.type = 'sine';
                            osc.frequency.setValueAtTime(440, now);
                            osc.frequency.exponentialRampToValueAtTime(220, now + 0.4);
                            gain.gain.setValueAtTime(0.06, now);
                            gain.gain.linearRampToValueAtTime(0, now + 0.4);
                            osc.start(now);
                            osc.stop(now + 0.4);
                            break;
                            
                        case 'pulse':
                            // Subtle pulse - for thinking
                            osc.type = 'sine';
                            osc.frequency.setValueAtTime(330, now);
                            gain.gain.setValueAtTime(0, now);
                            gain.gain.linearRampToValueAtTime(0.03, now + 0.1);
                            gain.gain.linearRampToValueAtTime(0, now + 0.2);
                            osc.start(now);
                            osc.stop(now + 0.2);
                            break;
                    }
                } catch (e) {
                    console.log('[Consciousness] Audio error:', e);
                }
            },
            
            // Initialize Web Audio context for consciousness sounds
            initConsciousnessAudio() {
                try {
                    const ctx = new (window.AudioContext || window.webkitAudioContext)();
                    return { ctx };
                } catch (e) {
                    console.log('[Consciousness] Audio init error:', e);
                    return null;
                }
            },
            
            // Log cycle event to event database
            async logCycleEvent(action, details = {}) {
                const eventData = {
                    type: 'cycle',
                    summary: `[Cycle] ${action}`,
                    message: action,
                    context: JSON.stringify({
                        ...details,
                        version: this.cycleState.currentVersion,
                        phase: this.cycleState.currentPhase,
                        score: this.cycleState.currentScore,
                        objective: this.cycleState.objective
                    }),
                    timestamp: new Date().toISOString()
                };
                
                try {
                    await window.aider.txdbLogEvent(eventData);
                } catch (e) {
                    console.log('[Cycle] Event log error:', e);
                }
                
                // Also track behavior for UI
                this.trackBehavior(`cycle_${action.toLowerCase().replace(/\s+/g, '_')}`, details);
            },
            
            // Start meta learning cycle
            // Check if there's enough budget for another cycle based on recent costs
            checkBudgetForNextCycle() {
                const budget = this.cycleState.cycleBudget;
                const buffer = this.cycleState.budgetBuffer || 0;
                const currentCost = this.costSummary.totalCost || 0;
                
                // No budget set = unlimited
                if (!budget) {
                    return { canStart: true, reason: 'No budget limit set' };
                }
                
                // Get costs from last 3 versions to estimate next cycle cost
                const versions = this.cycleState.versions || [];
                const recentVersions = versions.slice(-3).filter(v => v.cost > 0);
                
                let estimatedCycleCost = 0;
                if (recentVersions.length > 0) {
                    const totalRecentCost = recentVersions.reduce((sum, v) => sum + v.cost, 0);
                    estimatedCycleCost = totalRecentCost / recentVersions.length;
                } else {
                    // Fallback estimate for first few cycles
                    estimatedCycleCost = 0.10; // $0.10 default estimate
                }
                
                // Available budget = budget - buffer - currentCost
                const availableBudget = budget - buffer - currentCost;
                
                if (availableBudget < estimatedCycleCost) {
                    return {
                        canStart: false,
                        reason: 'Insufficient budget',
                        availableBudget: availableBudget,
                        estimatedCost: estimatedCycleCost,
                        buffer: buffer
                    };
                }
                
                return {
                    canStart: true,
                    reason: 'Budget available',
                    availableBudget: availableBudget,
                    estimatedCost: estimatedCycleCost,
                    buffer: buffer
                };
            },
            
            // Toggle cycle - start, pause, or resume
            toggleCycle() {
                if (!this.cycleState.active) {
                    // Not active - start the cycle
                    this.startCycle();
                } else if (this.cycleState.paused) {
                    // Active but paused - resume
                    this.resumeCycle();
                } else {
                    // Active and running - pause
                    this.pauseCycle();
                }
            },
            
            async startCycle() {
                if (this.cycleState.active) return;
                
                // Check budget before starting
                const budgetCheck = this.checkBudgetForNextCycle();
                if (!budgetCheck.canStart) {
                    this.addMessage('warning', ` **Budget Warning**: Cannot start cycle.
                    
**Available:** $${budgetCheck.availableBudget.toFixed(2)}
**Estimated cost:** $${budgetCheck.estimatedCost.toFixed(2)}
**Buffer reserved:** $${budgetCheck.buffer.toFixed(2)}

Increase your budget or reduce the buffer to continue.`);
                    return;
                }
                
                // Play ignition animation - the awakening moment
                const ctrlBtn = document.getElementById('cycleCtrlBtn');
                if (ctrlBtn) {
                    ctrlBtn.classList.add('igniting');
                    // Play ignition sound if available
                    this.playConsciousnessSound('ignite');
                    // Wait for ignition animation to complete
                    await new Promise(resolve => setTimeout(resolve, 600));
                    ctrlBtn.classList.remove('igniting');
                }
                
                await this.logCycleEvent('Cycle Started', { version: this.cycleState.currentVersion });
                
                this.cycleState.active = true;
                this.cycleState.paused = false;
                this.cycleState.costAtCycleStart = this.costSummary.totalCost || 0;
                
                // Create initial version if none exists
                if (this.cycleState.versions.length === 0) {
                    await this.createVersion('Initial version');
                }
                
                // Save state at cycle start
                this.saveCycleState();
                
                // Start auto-refresh for preview
                this.startAutoRefresh();
                
                this.updateCycleUI();
                this.addMessage('system', ` Meta Learning Cycle v${this.cycleState.currentVersion} started`);
                
                // ===== QUEUE-CENTRIC APPROACH =====
                // Get or prompt for objective
                let objective = this.cycleState.objective;
                
                
                if (!objective) {
                    // Try to extract from journey map
                    objective = await this.getObjectiveFromContext();
                    
                }
                
                if (!objective) {
                    // Prompt user for objective
                    objective = await this.promptForObjective();
                    
                }
                
                if (!objective) {
                    this.addMessage('error', 'No objective provided. Cycle stopped.');
                    this.cycleState.active = false;
                    this.updateCycleUI();
                    return;
                }
                
                this.cycleState.objective = objective;
                this.addMessage('system', ` Objective: ${objective}`);
                
                // Seed initial tasks and run the queue
                this.seedInitialTasks(objective);
                await this.runQueue();
            },
            
            // Get objective from journey map or other context
            async getObjectiveFromContext() {
                
                // Try journey map first
                const journeyMap = this.constitutionalMemory?.journeyMap || 
                                   this.evaluatedJourneyMap?.content;
                
                
                if (journeyMap) {
                    const objective = await this.extractObjectiveFromJourneyMap(journeyMap);
                    
                    
                    if (objective && typeof objective === 'string' && !objective.toLowerCase().includes('template')) {
                        return objective;
                    }
                }
                
                return null;
            },
            
            // Prompt user for objective using modal
            async promptForObjective() {
                return new Promise((resolve) => {
                    this.showActionModal({
                        title: 'What should we build?',
                        message: 'Enter the objective for this cycle:',
                        showInput: true,
                        inputPlaceholder: 'e.g., Build a todo app with dark mode',
                        confirmText: 'Start Building',
                        cancelText: 'Cancel',
                        onConfirm: (inputValue) => {
                            resolve(inputValue?.trim() || null);
                        },
                        onCancel: () => {
                            resolve(null);
                        }
                    });
                });
            },
            
            // Pause cycle
            pauseCycle() {
                this.cycleState.paused = true;
                this.stopAutoRefresh();
                this.playConsciousnessSound('rest');
                this.updateCycleUI();
                this.addMessage('system', ' Meta learning cycle paused.');
            },
            
            // Resume cycle
            resumeCycle() {
                // Check if waiting for file selection
                if (this.cycleState.waitingForFile) {
                    if (!this.currentPreviewFile) {
                        this.addMessage('system', ' Please select a file first');
                        return;
                    }
                    this.cycleState.waitingForFile = false;
                }
                
                // Check if waiting for file approval
                if (this.cycleState.waitingForApproval) {
                    this.cycleState.waitingForApproval = false;
                    if (this.cycleState.approvalCallback) {
                        var callback = this.cycleState.approvalCallback;
                        this.cycleState.approvalCallback = null;
                        this.cycleState.paused = false;
                        this.updateCycleUI();
                        this.addMessage('system', ' Files approved. Continuing...');
                        callback(); // Resume the phase
                        return;
                    }
                }
                
                this.cycleState.paused = false;
                this.startAutoRefresh();
                this.playConsciousnessSound('ignite');
                this.updateCycleUI();
                this.addMessage('system', ' Meta learning cycle resumed.');
                
                // Continue from current phase
                if (this.cycleState.currentPhase) {
                    this.runPhase(this.cycleState.currentPhase);
                }
            },
            
            // Stop cycle
            stopCycle() {
                this.logCycleEvent('Cycle Stopped', { 
                    version: this.cycleState.currentVersion,
                    phase: this.cycleState.currentPhase,
                    score: this.cycleState.currentScore
                });
                
                this.cycleState.active = false;
                this.cycleState.paused = false;
                this.cycleState.currentPhase = null;
                this.stopAutoRefresh();
                this.updateCycleUI();
                this.addMessage('system', ' Meta learning cycle stopped.');
            },
            
            // Start auto-refresh for preview (every 5 seconds)
            startAutoRefresh() {
                this.stopAutoRefresh(); // Clear any existing interval
                this.autoRefreshInterval = setInterval(() => {
                    // Skip if user is in testing mode
                    if (this.userTestingState?.isActive) {
                        this.userTestingState.pendingUpdates = (this.userTestingState.pendingUpdates || 0) + 1;
                        this.updateTestingBanner?.();
                        return;
                    }
                    if (this.cycleState?.active && !this.cycleState?.paused) {
                        // Respect user interaction; defer if user is active in preview
                        this.refreshPreview({ force: false, reason: 'auto_refresh' });
                    }
                }, 5000);
                console.log('[GSX Create] Auto-refresh started');
            },
            
            // Stop auto-refresh
            stopAutoRefresh() {
                if (this.autoRefreshInterval) {
                    clearInterval(this.autoRefreshInterval);
                    this.autoRefreshInterval = null;
                    console.log('[GSX Create] Auto-refresh stopped');
                }
            },
            
            // Run a specific phase
            async runPhase(phase) {
                if (!this.cycleState.active || this.cycleState.paused) return;
                
                await this.logCycleEvent('Phase Started', { phase });
                
                this.cycleState.currentPhase = phase;
                this.updateCycleUI();
                
                // Phase icons and names for display
                const phaseInfo = {
                    evaluate: { icon: '', name: 'Evaluate' },
                    research: { icon: '', name: 'Research' },
                    plan: { icon: '', name: 'Plan' },
                    execute: { icon: '', name: 'Execute' },
                    test: { icon: '', name: 'Test' },
                    improve: { icon: '', name: 'Improve' },
                    finalize: { icon: '', name: 'Finalize' }
                };
                
                const info = phaseInfo[phase];
                this.addMessage('system', ` ${info.icon} ${info.name.toUpperCase()} PHASE `);
                
                // Update HUD with phase
                this.setHUDPhase(info.name, this.taskQueue?.length || 0);
                
                const phaseNode = document.getElementById(`phase-${phase}`);
                if (phaseNode) {
                    document.querySelectorAll('.phase-dot').forEach(n => n.classList.remove('active'));
                    phaseNode.classList.add('active');
                }
                
                try {
                    switch (phase) {
                        case 'evaluate':
                            await this.phaseEvaluate();
                            break;
                        case 'research':
                            await this.phaseResearch();
                            break;
                        case 'plan':
                            await this.phasePlan();
                            break;
                        case 'execute':
                            await this.phaseExecute();
                            break;
                        case 'test':
                            await this.phaseTest();
                            break;
                        case 'improve':
                            await this.phaseImprove();
                            break;
                        case 'finalize':
                            await this.phaseFinalize();
                            break;
                    }
                    
                    // Only mark complete if not paused (waiting for user input)
                    if (!this.cycleState.paused) {
                        if (phaseNode) phaseNode.classList.add('completed');
                        this.addMessage('system', ` ${info.name} phase complete`);
                        await this.logCycleEvent('Phase Completed', { phase });
                    }
                    
                } catch (error) {
                    console.error(`[Cycle] Phase ${phase} error:`, error);
                    if (phaseNode) phaseNode.classList.add('failed');
                    this.addMessage('error', ` ${info.name} phase failed: ${error.message}`);
                    await this.logCycleEvent('Phase Failed', { phase, error: error.message });
                }
            },
            
            // Evaluate Phase - Comprehensive evaluation with tests, logs, and feedback
            async phaseEvaluate() {
                // Check required files for this phase
                var filesReady = await this.checkPhaseRequiredFiles('evaluate');
                if (!filesReady) {
                    await this.waitForFileApproval();
                }
                
                // If no file selected, try to auto-select main HTML file
                if (!this.currentPreviewFile) {
                    this.addMessage('system', ' No file selected, looking for main HTML file...');
                    
                    // Try to find an HTML file in the project
                    const htmlFile = await this.findMainHtmlFile();
                    
                    if (htmlFile) {
                        this.addMessage('system', `    Found: ${htmlFile.split('/').pop()}`);
                        await this.previewFile(htmlFile);
                        await this.delay(500);
                    } else {
                        // Pause and ask user to select a file
                            this.addMessage('system', ' No HTML file found. Please select a file to evaluate.');
                            this.addMessage('system', '   Click a file in the sidebar, then press  to continue.');
                            this.cycleState.paused = true;
                            this.cycleState.waitingForFile = true;
                            this.updateCycleUI();
                            return;
                    }
                }
                
                const evaluation = {
                    screenshot: null,
                    testResults: null,
                    consoleLogs: [],
                    feedback: { endUser: [], advocate: [], generated: [] },
                    criteria: [],
                    scores: {}
                };
                
                // Step 1: Screenshot
                this.addMessage('system', ' Capturing screenshot...');
                try {
                    const screenshotResult = await window.aider.capturePreviewScreenshot(this.currentPreviewFile);
                    if (screenshotResult.success) {
                        evaluation.screenshot = screenshotResult.screenshot;
                        this.addMessage('system', `    Screenshot captured (${Math.round(screenshotResult.size / 1024)}KB)`);
                        await this.logCycleEvent('Screenshot Captured', { size: screenshotResult.size, file: this.currentPreviewFile });
                    } else {
                        this.addMessage('system', `    Screenshot failed: ${screenshotResult.error || 'Unknown error'}`);
                        await this.logCycleEvent('Screenshot Failed', { error: screenshotResult.error });
                    }
                } catch (e) {
                    console.error('[Cycle] Screenshot error:', e);
                    this.addMessage('system', `    Screenshot failed: ${e.message}`);
                    await this.logCycleEvent('Screenshot Error', { error: e.message });
                }
                await this.delay(300);
                
                // Step 2: Run Playwright tests
                this.addMessage('system', ' Running Playwright tests...');
                try {
                    const testResult = await window.testAgent.runTests(this.currentPreviewFile, { 
                        browser: 'chromium',
                        captureScreenshots: false 
                    });
                    if (testResult.success) {
                        evaluation.testResults = testResult;
                        const passed = testResult.summary?.passed || 0;
                        const failed = testResult.summary?.failed || 0;
                        this.addMessage('system', `    Tests: ${passed} passed, ${failed} failed`);
                        await this.logCycleEvent('Tests Completed', { passed, failed });
                    }
                } catch (e) {
                    this.addMessage('system', '    Tests skipped: ' + e.message);
                    await this.logCycleEvent('Tests Skipped', { error: e.message });
                }
                await this.delay(300);
                
                // Step 3: Check console logs
                this.addMessage('system', ' Checking console logs...');
                try {
                    const interactiveResult = await window.testAgent.runInteractiveTest(this.currentPreviewFile);
                    if (interactiveResult.success) {
                        evaluation.consoleLogs = interactiveResult.consoleErrors || [];
                        const errorCount = evaluation.consoleLogs.length;
                        if (errorCount > 0) {
                            this.addMessage('system', `    ${errorCount} console error(s) found`);
                            await this.logCycleEvent('Console Errors Found', { errorCount, errors: evaluation.consoleLogs.slice(0, 5) });
                        } else {
                            this.addMessage('system', '    No console errors');
                            await this.logCycleEvent('Console Check Passed', { errorCount: 0 });
                        }
                        // Store AI analysis
                        if (interactiveResult.aiAnalysis) {
                            evaluation.aiAnalysis = interactiveResult.aiAnalysis;
                        }
                    }
                } catch (e) {
                    this.addMessage('system', '    Console check failed');
                    await this.logCycleEvent('Console Check Failed', { error: e.message });
                }
                await this.delay(300);
                
                // Step 4: Load feedback from file
                this.addMessage('system', ' Loading user feedback...');
                const feedbackFile = `${this.repoPath}/user-feedback.md`;
                const feedback = await this.loadUserFeedback(feedbackFile);
                
                if (!feedback) {
                    // Create feedback file if it doesn't exist
                    this.addMessage('system', '    Creating user-feedback.md...');
                    await this.createFeedbackFile(feedbackFile);
                    evaluation.feedback = { endUser: [], advocate: [], generated: [] };
                } else {
                    evaluation.feedback = feedback;
                    const totalFeedback = feedback.endUser.length + feedback.advocate.length + feedback.generated.length;
                    const pendingFeedback = [...feedback.endUser, ...feedback.advocate, ...feedback.generated]
                        .filter(f => f.status === 'pending').length;
                    this.addMessage('system', `    ${totalFeedback} feedback items (${pendingFeedback} pending)`);
                }
                await this.delay(300);
                
                // Step 5: Generate AI feedback and save to file
                this.addMessage('system', ' Generating AI feedback...');
                if (evaluation.aiAnalysis) {
                    const aiFeedback = this.parseAIFeedbackForEval(evaluation.aiAnalysis);
                    evaluation.feedback.generated = aiFeedback;
                    this.addMessage('system', `    ${aiFeedback.length} AI suggestions generated`);
                    
                    // Add to feedback file
                    await this.addGeneratedFeedback(evaluation.aiAnalysis);
                }
                await this.delay(300);
                
                // Step 6: Review Journey Map alignment
                this.addMessage('system', ' Reviewing Journey Map alignment...');
                evaluation.journeyMapAnalysis = null;
                try {
                    // Get selected journey map or find one in project
                    const journeyMapSelect = document.getElementById('journeyMapSelect');
                    let journeyMapContent = null;
                    let journeyMapName = null;
                    
                    // First check if we have an evaluated journey map from sidebar selection
                    if (this.evaluatedJourneyMap && this.evaluatedJourneyMap.content) {
                        journeyMapContent = this.evaluatedJourneyMap.content;
                        journeyMapName = this.evaluatedJourneyMap.name || 'Evaluated Journey Map';
                    }
                    // Then check dropdown selection
                    else if (journeyMapSelect && journeyMapSelect.value) {
                        // Try spaceItems first (new system)
                        const jm = this.spaceItems?.find(j => j.id === journeyMapSelect.value);
                        if (jm && jm.content) {
                            journeyMapContent = jm.content;
                            journeyMapName = jm.name || jm.title;
                        }
                        // Fallback to journeyMaps (legacy)
                        else {
                            const jmLegacy = this.journeyMaps?.find(j => j.id === journeyMapSelect.value);
                            if (jmLegacy && jmLegacy.content) {
                                journeyMapContent = jmLegacy.content;
                                journeyMapName = jmLegacy.name;
                            }
                        }
                    }
                    
                    // Also check for journey-map.md file in project
                    if (!journeyMapContent) {
                        const journeyMapFile = `${this.repoPath}/journey-map.md`;
                        try {
                            const fileContent = await window.aider.readFile(journeyMapFile);
                            if (fileContent) {
                                journeyMapContent = fileContent;
                                journeyMapName = 'journey-map.md';
                            }
                        } catch (e) {
                            // File doesn't exist, that's ok
                        }
                    }
                    
                    if (journeyMapContent && evaluation.screenshot) {
                        this.addMessage('system', `    Found: ${journeyMapName}`);
                        
                        // Analyze screenshot against journey map
                        const journeyPrompt = `Analyze this UI screenshot against the following Journey Map. 
                        
Identify:
1. Which journey map steps/flows are visible in the UI
2. Any missing UI elements needed for the journey
3. UX issues that could block user flows
4. Alignment score (0-100) of UI to journey map

Journey Map:
${journeyMapContent}

Respond with a brief analysis.`;

                        const journeyAnalysis = await window.aider.analyzeScreenshot(evaluation.screenshot, journeyPrompt);
                        if (journeyAnalysis.success && journeyAnalysis.analysis) {
                            evaluation.journeyMapAnalysis = {
                                name: journeyMapName,
                                analysis: journeyAnalysis.analysis
                            };
                            this.addMessage('system', `    Journey Map alignment analyzed`);
                            await this.logCycleEvent('Journey Map Analyzed', { journeyMap: journeyMapName });
                        }
                    } else if (!journeyMapContent) {
                        this.addMessage('system', '    No Journey Map found - skipping alignment check');
                        this.addMessage('system', '    Select a Journey Map or create journey-map.md');
                        await this.logCycleEvent('Journey Map Not Found', {});
                    } else {
                        this.addMessage('system', '    No screenshot for Journey Map analysis');
                    }
                } catch (e) {
                    console.error('[Cycle] Journey Map analysis error:', e);
                    this.addMessage('system', '    Journey Map analysis failed');
                    await this.logCycleEvent('Journey Map Analysis Failed', { error: e.message });
                }
                await this.delay(300);
                
                // Step 7: Load criteria
                const criteriaFile = `${this.repoPath}/evaluation-criteria.md`;
                let criteria = await this.loadEvaluationCriteria(criteriaFile);
                
                if (!criteria || criteria.length === 0) {
                    // Try to auto-generate criteria from evaluated assets
                    if (this.evaluatedJourneyMap || this.evaluatedStyleGuide) {
                        this.addMessage('system', ' Generating evaluation criteria from assets...');
                        criteria = await this.generateCriteriaFromAssets();
                    }
                    
                    // If still no criteria, ask user
                    if (!criteria || criteria.length === 0) {
                        this.addMessage('system', ' No evaluation criteria found');
                        this.showCreateCriteriaUI(criteriaFile);
                        this.cycleState.paused = true;
                        this.cycleState.waitingForCriteria = true;
                        this.cycleState.pendingEvaluation = evaluation;
                        this.updateCycleUI();
                        return;
                    }
                }
                
                evaluation.criteria = criteria;
                
                // Step 7: Calculate scores
                this.addMessage('system', ' Calculating scores...');
                evaluation.scores = this.calculateEvaluationScores(evaluation);
                
                // Store evaluation
                this.cycleState.evaluation = evaluation;
                this.cycleState.evaluationScores = evaluation.scores;
                
                // Show comprehensive results
                this.showComprehensiveEvaluationResults(evaluation);
                
                // Calculate overall score
                const scoreValues = Object.values(evaluation.scores);
                const avgScore = scoreValues.length > 0 
                    ? scoreValues.reduce((a, b) => a + b, 0) / scoreValues.length 
                    : 50;
                this.cycleState.currentScore = Math.round(avgScore);
                this.updateCycleUI();
                
                // Log evaluation results
                await this.logCycleEvent('Evaluation Completed', {
                    scores: evaluation.scores,
                    overallScore: this.cycleState.currentScore,
                    testsPassed: evaluation.testResults?.summary?.passed || 0,
                    testsFailed: evaluation.testResults?.summary?.failed || 0,
                    consoleErrors: evaluation.consoleLogs?.length || 0,
                    feedbackItems: (evaluation.feedback?.endUser?.length || 0) + 
                                   (evaluation.feedback?.advocate?.length || 0) + 
                                   (evaluation.feedback?.generated?.length || 0)
                });
                
                this.addMessage('system', ` Overall Score: ${this.cycleState.currentScore}% `);
                await this.delay(500);
                
                await this.runPhase('research');
            },
            
            // Load user feedback from file
            async loadUserFeedback(filePath) {
                try {
                    const content = await window.aider.readFile(filePath);
                    if (!content) return null;
                    
                    const feedback = { endUser: [], advocate: [], generated: [] };
                    let currentBucket = null;
                    
                    const lines = content.split('\n');
                    for (const line of lines) {
                        // Check for bucket headers
                        if (line.includes('## End User Feedback')) currentBucket = 'endUser';
                        else if (line.includes('## Advocate Feedback')) currentBucket = 'advocate';
                        else if (line.includes('## Generated Feedback')) currentBucket = 'generated';
                        
                        // Parse feedback items: - [ ] or - [x] feedback text
                        const match = line.match(/^[\s]*-\s*\[([ x])\]\s*(.+)$/i);
                        if (match && currentBucket) {
                            feedback[currentBucket].push({
                                text: match[2].trim(),
                                status: match[1].toLowerCase() === 'x' ? 'addressed' : 'pending'
                            });
                        }
                    }
                    
                    return feedback;
                } catch (e) {
                    console.log('[Cycle] Load feedback error:', e);
                    return null;
                }
            },
            
            // Create feedback file
            async createFeedbackFile(filePath) {
                const template = `# User Feedback

Track feedback from different sources. Mark items as [x] when addressed.

## End User Feedback
<!-- Feedback from actual end users -->
- [ ] Example: Button text is hard to read

## Advocate Feedback  
<!-- Feedback from internal advocates/testers -->
- [ ] Example: Navigation could be more intuitive

## Generated Feedback
<!-- AI-generated feedback (auto-populated during evaluation) -->
- [ ] Waiting for AI analysis...

---
*Edit this file to add feedback. Items marked [x] are considered addressed.*
`;
                
                try {
                    await this.executeTask(`Create a new file called user-feedback.md with this content:\n\n${template}`);
                } catch (e) {
                    console.log('[Cycle] Create feedback file error:', e);
                }
            },
            
            // Parse AI analysis into feedback items (for Evaluate phase)
            parseAIFeedbackForEval(aiAnalysis) {
                const feedback = [];
                const lines = aiAnalysis.split('\n');
                
                for (const line of lines) {
                    // Look for bullet points or numbered items that suggest improvements
                    const match = line.match(/^[\s]*[-*]\s*(.+)$/) || line.match(/^\d+\.\s*(.+)$/);
                    if (match) {
                        const text = match[1].trim();
                        // Filter for actionable feedback
                        if (text.length > 10 && text.length < 150 && (
                            text.toLowerCase().includes('should') ||
                            text.toLowerCase().includes('could') ||
                            text.toLowerCase().includes('consider') ||
                            text.toLowerCase().includes('add') ||
                            text.toLowerCase().includes('improve') ||
                            text.toLowerCase().includes('fix') ||
                            text.toLowerCase().includes('issue') ||
                            text.toLowerCase().includes('missing')
                        )) {
                            feedback.push({ text, status: 'pending' });
                        }
                    }
                }
                
                return feedback.slice(0, 10); // Limit to 10 items
            },
            
            // Calculate scores based on all evaluation data
            calculateEvaluationScores(evaluation) {
                const scores = {};
                
                // Test score
                if (evaluation.testResults?.summary) {
                    const passRate = evaluation.testResults.summary.passRate || 0;
                    scores['Functional Tests'] = passRate;
                }
                
                // Console errors score
                const errorCount = evaluation.consoleLogs?.length || 0;
                scores['Console Errors'] = errorCount === 0 ? 100 : Math.max(0, 100 - (errorCount * 20));
                
                // Feedback score (based on pending vs addressed)
                const allFeedback = [
                    ...evaluation.feedback.endUser,
                    ...evaluation.feedback.advocate,
                    ...evaluation.feedback.generated
                ];
                if (allFeedback.length > 0) {
                    const addressed = allFeedback.filter(f => f.status === 'addressed').length;
                    scores['Feedback Addressed'] = Math.round((addressed / allFeedback.length) * 100);
                }
                
                // Criteria scores (from AI analysis)
                if (evaluation.criteria && evaluation.aiAnalysis) {
                    const analysis = evaluation.aiAnalysis.toLowerCase();
                    evaluation.criteria.forEach(criterion => {
                        let score = 70;
                        if (analysis.includes('excellent') || analysis.includes('great')) score = 90;
                        else if (analysis.includes('good')) score = 80;
                        else if (analysis.includes('needs improvement')) score = 60;
                        else if (analysis.includes('poor') || analysis.includes('broken')) score = 40;
                        scores[criterion] = score;
                    });
                }
                
                return scores;
            },
            
            // Show comprehensive evaluation results
            showComprehensiveEvaluationResults(evaluation) {
                // Scores section
                const scoresHtml = Object.entries(evaluation.scores).map(([key, score]) => {
                    const color = score >= 80 ? 'var(--success)' : score >= 60 ? 'var(--warning)' : 'var(--danger)';
                    const icon = score >= 80 ? '' : score >= 60 ? '' : '';
                    return `
                        <div style="display: flex; align-items: center; gap: 8px; padding: 4px 0;">
                            <span style="color: ${color}; width: 14px; font-size: 10px;">${icon}</span>
                            <span style="flex: 1; font-size: 10px;">${key}</span>
                            <span style="font-size: 10px; font-weight: 600; color: ${color};">${score}%</span>
                        </div>
                    `;
                }).join('');
                
                // Pending feedback section
                const pendingFeedback = [
                    ...evaluation.feedback.endUser.filter(f => f.status === 'pending').map(f => ({ ...f, type: '' })),
                    ...evaluation.feedback.advocate.filter(f => f.status === 'pending').map(f => ({ ...f, type: '' })),
                    ...evaluation.feedback.generated.filter(f => f.status === 'pending').map(f => ({ ...f, type: '' }))
                ].slice(0, 5);
                
                const feedbackHtml = pendingFeedback.length > 0 
                    ? pendingFeedback.map(f => `
                        <div style="display: flex; gap: 6px; padding: 4px 0; font-size: 10px;">
                            <span>${f.type}</span>
                            <span style="color: var(--text-secondary);">${f.text.substring(0, 60)}${f.text.length > 60 ? '...' : ''}</span>
                        </div>
                    `).join('')
                    : '<div style="font-size: 10px; color: var(--text-muted);">No pending feedback</div>';
                
                // Journey Map analysis section
                let journeyMapHtml = '';
                if (evaluation.journeyMapAnalysis) {
                    const analysis = evaluation.journeyMapAnalysis.analysis;
                    const preview = analysis.length > 150 ? analysis.substring(0, 150) + '...' : analysis;
                    journeyMapHtml = `
                        <div style="border-top: 1px solid var(--border); margin-top: 8px; padding-top: 8px;">
                            <div style="font-size: 11px; font-weight: 600; margin-bottom: 6px;"> Journey Map Alignment</div>
                            <div style="font-size: 10px; color: var(--text-secondary);">${preview}</div>
                        </div>
                    `;
                }
                
                const html = `
                    <div style="margin: 8px 0; background: var(--bg-tertiary); padding: 12px; border-radius: 6px;">
                        <div style="font-size: 11px; font-weight: 600; margin-bottom: 8px;"> Evaluation Scores</div>
                        ${scoresHtml}
                        <div style="border-top: 1px solid var(--border); margin-top: 8px; padding-top: 8px;">
                            <div style="font-size: 11px; font-weight: 600; margin-bottom: 6px;"> Pending Feedback</div>
                            ${feedbackHtml}
                        </div>
                        ${journeyMapHtml}
                    </div>
                `;
                
                this.addMessage('system', html, null, true);
            },
            
            // Load evaluation criteria from file
            async loadEvaluationCriteria(filePath) {
                try {
                    const content = await window.aider.readFile(filePath);
                    if (!content) return null;
                    
                    const lines = content.split('\n');
                    const criteria = [];
                    
                    for (const line of lines) {
                        const match = line.match(/^[\s]*[-*][\s]+(.+)$/) || line.match(/^[\s]*\d+\.[\s]+(.+)$/);
                        if (match) {
                            const text = match[1].trim();
                            if (text && !text.startsWith('#') && !text.startsWith('[')) {
                                criteria.push(text);
                            }
                        }
                    }
                    
                    return criteria;
                } catch (e) {
                    console.log('[Cycle] Load criteria error:', e);
                    return null;
                }
            },
            
            // Show UI to create criteria file
            showCreateCriteriaUI(filePath) {
                const defaultCriteria = [
                    'Visual design is clean and professional',
                    'UI is responsive on different screen sizes',
                    'Navigation is intuitive',
                    'Interactive elements work correctly',
                    'Error states handled gracefully',
                    'Accessibility standards met',
                    'Performance is acceptable',
                    'No console errors'
                ];
                
                const html = `
                    <div style="margin: 12px 0;">
                        <div style="font-size: 11px; color: var(--text-muted); margin-bottom: 8px;">
                            Create evaluation-criteria.md?
                        </div>
                        <div style="display: flex; gap: 8px;">
                            <button onclick="GSXCreate.createDefaultCriteria('${filePath}')" 
                                    style="flex: 1; padding: 8px; background: var(--success); color: #000; border: none; border-radius: 6px; cursor: pointer; font-size: 12px;">
                                 Create & Continue
                            </button>
                            <button onclick="GSXCreate.skipEvaluation()" 
                                    style="padding: 8px 12px; background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border); border-radius: 6px; cursor: pointer; font-size: 11px;">
                                Skip
                            </button>
                        </div>
                    </div>
                `;
                
                this.addMessage('system', html, null, true);
            },
            
            // Create default criteria file
            async createDefaultCriteria(filePath) {
                const content = `# Evaluation Criteria

## Visual & UX
1. Visual design is clean and professional
2. UI is responsive on different screen sizes
3. Navigation is intuitive
4. Color scheme and typography are consistent

## Functionality
5. Interactive elements work correctly
6. Error states handled gracefully
7. Loading states shown appropriately
8. Forms validate input properly

## Technical
9. Accessibility standards met
10. Performance is acceptable
11. Code is well-organized
12. No console errors

---
*Edit to customize criteria*
`;
                
                try {
                    await this.executeTask(`Create evaluation-criteria.md with:\n\n${content}`);
                    this.addMessage('system', ' Created evaluation-criteria.md');
                    
                    this.cycleState.paused = false;
                    this.cycleState.waitingForCriteria = false;
                    this.updateCycleUI();
                    
                    await this.runPhase('evaluate');
                } catch (e) {
                    this.addMessage('error', 'Failed: ' + e.message);
                }
            },
            
            // Skip evaluation
            skipEvaluation() {
                this.addMessage('system', ' Skipping evaluation');
                this.cycleState.paused = false;
                this.cycleState.waitingForCriteria = false;
                this.updateCycleUI();
                this.runPhase('research');
            },
            
            // ========== CONSTITUTIONAL MEMORY MANAGEMENT ==========
            
            // Load all constitutional memory files
            async loadConstitutionalMemory() {
                console.log('[Constitutional] Loading constitutional memory...');
                
                try {
                    // Load style guide
                    const styleGuide = await this.loadCycleFile('styleGuide', false);
                    this.constitutionalMemory.styleGuide = styleGuide;
                    
                    // Load journey map
                    const journeyMap = await this.loadCycleFile('journeyMap', false);
                    this.constitutionalMemory.journeyMap = journeyMap;
                    
                    // Load evaluation criteria
                    const criteria = await this.loadCycleFile('evaluationCriteria', false);
                    this.constitutionalMemory.evaluationCriteria = criteria;
                    
                    console.log('[Constitutional] Loaded:', {
                        hasStyleGuide: !!styleGuide,
                        hasJourneyMap: !!journeyMap,
                        hasCriteria: !!criteria
                    });
                    
                    // Update sidebar status display
                    this.updateConstitutionalStatus();
                    
                    return true;
                } catch (error) {
                    console.error('[Constitutional] Load error:', error);
                    return false;
                }
            },
            
            // Summarize constitutional memory for a specific task
            async summarizeConstitutionalMemory(task) {
                console.log('[Constitutional] Summarizing for task:', task);
                
                // Check if we need to re-summarize
                const needsResummarize = !this.constitutionalMemory.currentSummary || 
                                         this.constitutionalMemory.lastTask !== task;
                
                if (!needsResummarize) {
                    console.log('[Constitutional] Using cached summary');
                    return this.constitutionalMemory.currentSummary;
                }
                
                // Ensure constitutional files are loaded
                if (!this.constitutionalMemory.styleGuide && !this.constitutionalMemory.journeyMap) {
                    await this.loadConstitutionalMemory();
                }
                
                // Build context from all constitutional sources
                let constitutionalContext = '';
                
                if (this.constitutionalMemory.styleGuide) {
                    constitutionalContext += '=== STYLE GUIDE ===\n' + this.constitutionalMemory.styleGuide + '\n\n';
                }
                
                if (this.constitutionalMemory.journeyMap) {
                    constitutionalContext += '=== JOURNEY MAP ===\n' + this.constitutionalMemory.journeyMap + '\n\n';
                }
                
                if (this.constitutionalMemory.evaluationCriteria) {
                    constitutionalContext += '=== EVALUATION CRITERIA ===\n' + this.constitutionalMemory.evaluationCriteria + '\n\n';
                }
                
                // If no constitutional data exists, return empty
                if (!constitutionalContext.trim()) {
                    console.log('[Constitutional] No constitutional data found');
                    this.constitutionalMemory.currentSummary = '';
                    return '';
                }
                
                // Generate task-specific summary using AI
                try {
                    const summaryPrompt = `You are summarizing project guidelines for a specific task. 
                    
CURRENT TASK: ${task}

CONSTITUTIONAL MEMORY (project guidelines, standards, and principles):
${constitutionalContext}

Create a BRIEF, FOCUSED summary (max 200 words) that:
1. Extracts ONLY the guidelines relevant to this specific task
2. Prioritizes actionable rules and constraints
3. Highlights any specific patterns or conventions to follow
4. Omits irrelevant sections entirely

Format as a concise bullet list. Start directly with the bullets, no preamble.`;

                    // Use evaluate API instead of chat (chat doesn't exist)
                    if (window.aider && typeof window.aider.evaluate === 'function') {
                        const systemPrompt = 'You are a helpful assistant that summarizes guidelines concisely.';
                        const result = await window.aider.evaluate(systemPrompt, summaryPrompt, this.selectedModel);
                        
                        if (result.success && result.content) {
                            this.constitutionalMemory.currentSummary = result.content;
                            this.constitutionalMemory.lastTask = task;
                            this.constitutionalMemory.lastSummarizedAt = new Date().toISOString();
                            
                            // Update sidebar status
                            this.updateConstitutionalStatus();
                            
                            console.log('[Constitutional] Summary generated:', result.content.substring(0, 100) + '...');
                            return result.content;
                        }
                    } else {
                        console.warn('[Constitutional] Aider evaluate API not ready, skipping summary generation');
                    }
                } catch (error) {
                    console.error('[Constitutional] Summary generation error:', error);
                }
                
                // Fallback: return truncated raw content
                const fallback = constitutionalContext.substring(0, 500) + '...';
                this.constitutionalMemory.currentSummary = fallback;
                return fallback;
            },
            
            // Get constitutional context for inclusion in prompts
            // Combines: Constitutional Memory (feature reduced) + User's Global Instructions
            getConstitutionalContext() {
                let systemPrompt = '';
                
                // Add Constitutional Memory summary (feature reduced)
                if (this.constitutionalMemory.currentSummary) {
                    systemPrompt += `=== PROJECT GUIDELINES (Constitutional Memory) ===
${this.constitutionalMemory.currentSummary}
=== END GUIDELINES ===

`;
                }
                
                // Append User's Global Instructions
                if (this.globalInstructionsText && this.globalInstructionsText.trim()) {
                    systemPrompt += `=== USER INSTRUCTIONS ===
${this.globalInstructionsText}
=== END USER INSTRUCTIONS ===

`;
                }
                
                return systemPrompt;
            },
            
            // Force refresh of constitutional memory
            async refreshConstitutionalMemory() {
                this.constitutionalMemory.currentSummary = null;
                this.constitutionalMemory.lastTask = null;
                await this.loadConstitutionalMemory();
                this.updateConstitutionalStatus();
                this.addMessage('system', ' Constitutional memory refreshed');
            },
            
            // Log the dynamic system prompt for debugging/transparency
            async logDynamicSystemPrompt(task, systemPrompt) {
                // Log to console
                console.log('[Constitutional] Dynamic System Prompt for task:', task);
                console.log('[Constitutional] System Prompt Content:\n', systemPrompt);
                
                // Log to cycle events (Episodic Memory)
                await this.logCycleEvent('Dynamic System Prompt Generated', {
                    task: task,
                    promptLength: systemPrompt.length,
                    hasConstitutional: systemPrompt.includes('PROJECT GUIDELINES'),
                    hasUserInstructions: systemPrompt.includes('USER INSTRUCTIONS'),
                    preview: systemPrompt.substring(0, 300) + (systemPrompt.length > 300 ? '...' : '')
                });
                
                // Show collapsible preview in chat
                if (systemPrompt.trim()) {
                    const previewHtml = `
                        <details style="margin: 4px 0; font-size: 11px;">
                            <summary style="cursor: pointer; color: var(--text-muted);">
                                 Dynamic System Prompt (${systemPrompt.length} chars) - click to expand
                            </summary>
                            <pre style="margin: 8px 0; padding: 8px; background: var(--bg-tertiary); border-radius: 4px; font-size: 10px; white-space: pre-wrap; max-height: 200px; overflow-y: auto;">${this.escapeHtml(systemPrompt)}</pre>
                        </details>
                    `;
                    this.addMessage('system', previewHtml, null, true);
                }
            },
            
            // Escape HTML for safe display
            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            },
            
            // Update Constitutional Memory status display in sidebar
            updateConstitutionalStatus() {
                // Update file status indicators
                const styleStatus = document.getElementById('styleGuideStatus');
                const journeyStatus = document.getElementById('journeyMapStatus');
                const criteriaStatus = document.getElementById('criteriaStatus');
                const summaryStatus = document.getElementById('summaryStatus');
                
                if (styleStatus) {
                    styleStatus.textContent = this.constitutionalMemory.styleGuide ? '' : '';
                    styleStatus.style.color = this.constitutionalMemory.styleGuide ? 'var(--success)' : 'var(--text-muted)';
                }
                
                if (journeyStatus) {
                    journeyStatus.textContent = this.constitutionalMemory.journeyMap ? '' : '';
                    journeyStatus.style.color = this.constitutionalMemory.journeyMap ? 'var(--success)' : 'var(--text-muted)';
                }
                
                if (criteriaStatus) {
                    criteriaStatus.textContent = this.constitutionalMemory.evaluationCriteria ? '' : '';
                    criteriaStatus.style.color = this.constitutionalMemory.evaluationCriteria ? 'var(--success)' : 'var(--text-muted)';
                }
                
                if (summaryStatus) {
                    if (this.constitutionalMemory.currentSummary) {
                        const task = this.constitutionalMemory.lastTask || 'general';
                        const time = this.constitutionalMemory.lastSummarizedAt 
                            ? new Date(this.constitutionalMemory.lastSummarizedAt).toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'})
                            : '';
                        summaryStatus.innerHTML = `<span style="color: var(--success);"></span> Summary ready<br><span style="font-size: 9px;">Task: ${task.substring(0, 30)}${task.length > 30 ? '...' : ''}</span>`;
                    } else {
                        summaryStatus.textContent = 'No summary loaded';
                    }
                }
            },
            
            // ========== CYCLE FILE MANAGEMENT ==========
            
            // Get versioned file path
            getCycleFilePath(fileKey) {
                const version = this.cycleState.currentVersion;
                const template = this.cycleState.files[fileKey];
                if (!template) return null;
                return `${this.repoPath}/${template.replace('{version}', version)}`;
            },
            
            // Get non-versioned file path (persistent across cycles)
            getPersistentFilePath(fileKey) {
                const template = this.cycleState.files[fileKey];
                if (!template) return null;
                // Remove version placeholder for persistent files
                return `${this.repoPath}/${template.replace('-v{version}', '')}`;
            },
            
            // Load a cycle file
            async loadCycleFile(fileKey, versioned = true) {
                const filePath = versioned ? this.getCycleFilePath(fileKey) : this.getPersistentFilePath(fileKey);
                try {
                    const content = await window.aider.readFile(filePath);
                    return content || null;
                } catch (e) {
                    return null;
                }
            },
            
            // Save a cycle file via Aider
            async saveCycleFile(fileKey, content, versioned = true) {
                const filePath = versioned ? this.getCycleFilePath(fileKey) : this.getPersistentFilePath(fileKey);
                const fileName = filePath.split('/').pop();
                try {
                    await this.executeTask(`Update ${fileName} with this content:\n\n${content}`);
                    return true;
                } catch (e) {
                    console.log(`[Cycle] Save ${fileKey} error:`, e);
                    return false;
                }
            },
            
            // Update user feedback file - mark items as addressed
            async updateFeedbackFile(addressedItems = []) {
                const filePath = this.getPersistentFilePath('userFeedback');
                let content = await this.loadCycleFile('userFeedback', false);
                
                if (!content) {
                    // Create initial feedback file
                    content = this.generateFeedbackTemplate();
                }
                
                // Mark addressed items
                for (const item of addressedItems) {
                    // Replace [ ] with [x] for matching items
                    const escapedItem = item.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    const regex = new RegExp(`- \\[ \\] ${escapedItem}`, 'gi');
                    content = content.replace(regex, `- [x] ${item}`);
                }
                
                await this.saveCycleFile('userFeedback', content, false);
            },
            
            // Generate feedback file template
            generateFeedbackTemplate() {
                const version = this.cycleState.currentVersion;
                return `# User Feedback
*Last updated: v${version} - ${new Date().toLocaleDateString()}*

## End User Feedback
<!-- Feedback from actual end users -->
- [ ] No end user feedback yet

## Advocate Feedback
<!-- Feedback from internal advocates/testers -->
- [ ] No advocate feedback yet

## Generated Feedback (AI)
<!-- AI-generated feedback from evaluation -->
- [ ] Waiting for AI evaluation...

---
**Legend:** [ ] = Pending, [x] = Addressed
`;
            },
            
            // Generate style guide template
            generateStyleGuideTemplate() {
                return `# Style Guide
*Version: ${this.cycleState.currentVersion}*

## Colors
- Primary: #4A90E2
- Secondary: #2C3E50
- Background: #1a1a2e
- Text: #E8E8E8

## Typography
- Headings: System UI, -apple-system
- Body: 14px, line-height 1.5

## Components
- Buttons: Rounded corners, hover states
- Cards: Subtle shadows, consistent padding
- Forms: Clear labels, validation states

## Spacing
- Base unit: 8px
- Sections: 24px gap
- Components: 16px gap

---
*Update this guide as the design evolves*
`;
            },
            
            // Generate journey map template
            generateJourneyMapTemplate() {
                return `# User Journey Map
*Version: ${this.cycleState.currentVersion}*

## Primary User Flow

### 1. Entry
- User lands on the page
- First impression: [describe]

### 2. Discovery
- User explores features
- Key actions: [list]

### 3. Engagement
- User interacts with core features
- Pain points: [identify]

### 4. Completion
- User achieves goal
- Exit points: [describe]

## Pain Points
- [ ] None identified yet

## Opportunities
- [ ] None identified yet

---
*Update after each cycle based on testing*
`;
            },
            
            // Generate research notes template
            generateResearchTemplate(objective, feedback) {
                const version = this.cycleState.currentVersion;
                const feedbackList = feedback.length > 0 
                    ? feedback.map(f => `- ${f.text}`).join('\n')
                    : '- No pending feedback';
                    
                return `# Research Notes - v${version}
*Date: ${new Date().toLocaleDateString()}*
*Objective: ${objective}*

## Feedback to Address
${feedbackList}

## Research Findings
<!-- AI will populate this section -->

## Proposed Solutions
<!-- AI will populate this section -->

## Resources
<!-- Links and references -->

## Next Steps
<!-- Action items for Plan phase -->

---
*This file is auto-generated and updated by the Research phase*
`;
            },
            
            // Generate test results template
            generateTestResultsTemplate(results) {
                const version = this.cycleState.currentVersion;
                return `# Test Results - v${version}
*Date: ${new Date().toLocaleDateString()}*

## Summary
- Total Tests: ${results.total || 0}
- Passed: ${results.passed || 0}
- Failed: ${results.failed || 0}
- Score: ${results.score || 0}%

## Console Errors
${results.consoleErrors?.length > 0 
    ? results.consoleErrors.map(e => `-  ${e}`).join('\n')
    : '-  No console errors'}

## Failed Tests
${results.failedTests?.length > 0
    ? results.failedTests.map(t => `-  ${t}`).join('\n')
    : '-  All tests passed'}

## AI Analysis
${results.aiAnalysis || 'No AI analysis available'}

---
*Auto-generated by Test phase*
`;
            },
            
            // Update TODO file with completion status
            async updateTodoFile(completedTasks = []) {
                const filePath = this.getCycleFilePath('todoList');
                let content = await this.loadCycleFile('todoList', true);
                
                if (!content) return;
                
                // Mark completed tasks
                for (const task of completedTasks) {
                    const escapedTask = task.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    const regex = new RegExp(`- \\[ \\] ${escapedTask}`, 'gi');
                    content = content.replace(regex, `- [x] ${task}`);
                }
                
                await this.saveCycleFile('todoList', content, true);
            },
            
            // Update cycle files with completed work
            async updateCycleFiles() {
                const version = this.cycleState.currentVersion;
                
                // Get completed todos
                const completedTasks = (this.cycleState.todos || [])
                    .filter(t => t.completed)
                    .map(t => t.task);
                
                if (completedTasks.length > 0) {
                    this.addMessage('system', ` Updating TODO file...`);
                    await this.updateTodoFileWithCompleted(completedTasks);
                }
                
                // Update feedback file - mark addressed items
                const addressedFeedback = (this.cycleState.pendingFeedback || [])
                    .filter(f => completedTasks.some(t => 
                        t.toLowerCase().includes(f.text.toLowerCase().substring(0, 20))
                    ))
                    .map(f => f.text);
                
                if (addressedFeedback.length > 0) {
                    this.addMessage('system', ` Updating feedback file (${addressedFeedback.length} addressed)...`);
                    await this.updateFeedbackFile(addressedFeedback);
                }
                
                // Add AI-generated feedback from this cycle
                if (this.lastVisualAnalysis) {
                    await this.addGeneratedFeedback(this.lastVisualAnalysis);
                }
            },
            
            // Update TODO file with completed tasks
            async updateTodoFileWithCompleted(completedTasks) {
                const filePath = this.getCycleFilePath('todoList');
                let content = await this.loadCycleFile('todoList', true);
                
                if (!content) return;
                
                for (const task of completedTasks) {
                    // Escape special regex characters
                    const escapedTask = task.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    // Match the task with checkbox
                    const regex = new RegExp(`- \\[ \\] ${escapedTask}`, 'gi');
                    content = content.replace(regex, `- [x] ${task}`);
                }
                
                await this.saveCycleFile('todoList', content, true);
            },
            
            // Add AI-generated feedback to feedback file
            async addGeneratedFeedback(aiAnalysis) {
                const filePath = this.getPersistentFilePath('userFeedback');
                let content = await this.loadCycleFile('userFeedback', false);
                
                if (!content) return;
                
                // Parse new feedback items from AI analysis
                const newFeedback = this.parseAIFeedback(aiAnalysis);
                if (newFeedback.length === 0) return;
                
                // Find the Generated Feedback section
                const generatedSection = content.indexOf('## Generated Feedback');
                if (generatedSection === -1) return;
                
                // Find the next section or end
                const nextSection = content.indexOf('##', generatedSection + 20);
                const endPos = nextSection > -1 ? nextSection : content.indexOf('---', generatedSection);
                
                // Build new feedback items
                const newItems = newFeedback
                    .slice(0, 5) // Limit to 5 new items
                    .map(f => `- [ ] ${f.text}`)
                    .join('\n');
                
                // Insert after the section header
                const insertPos = content.indexOf('\n', generatedSection) + 1;
                const beforeInsert = content.substring(0, insertPos);
                const afterInsert = content.substring(insertPos);
                
                // Check if we need to add (avoid duplicates)
                if (!content.includes(newFeedback[0]?.text?.substring(0, 30))) {
                    content = beforeInsert + newItems + '\n' + afterInsert;
                    await this.saveCycleFile('userFeedback', content, false);
                    this.addMessage('system', `    Added ${newFeedback.length} AI suggestions to feedback`);
                }
            },
            
            // Parse AI feedback (helper)
            parseAIFeedback(aiAnalysis) {
                const feedback = [];
                const lines = aiAnalysis.split('\n');
                
                for (const line of lines) {
                    const match = line.match(/^[\s]*[-*]\s*(.+)$/) || line.match(/^\d+\.\s*(.+)$/);
                    if (match) {
                        const text = match[1].trim();
                        if (text.length > 10 && text.length < 100 && (
                            text.toLowerCase().includes('should') ||
                            text.toLowerCase().includes('could') ||
                            text.toLowerCase().includes('consider') ||
                            text.toLowerCase().includes('add') ||
                            text.toLowerCase().includes('improve') ||
                            text.toLowerCase().includes('fix') ||
                            text.toLowerCase().includes('missing')
                        )) {
                            feedback.push({ text, status: 'pending' });
                        }
                    }
                }
                
                return feedback.slice(0, 10);
            },
            
            // Finalize cycle - update all persistent files with current version
            async finalizeCycle() {
                const version = this.cycleState.currentVersion;
                const score = this.cycleState.currentScore;
                const date = new Date().toLocaleDateString();
                const timestamp = new Date().toISOString();
                
                this.addMessage('system', ` Finalizing v${version} files...`);
                
                // Update style guide with version
                let styleGuide = await this.loadCycleFile('styleGuide', false);
                if (styleGuide) {
                    styleGuide = styleGuide.replace(/\*Version: \d+\*/, `*Version: ${version}*`);
                    await this.saveCycleFile('styleGuide', styleGuide, false);
                }
                
                // Update journey map with version
                let journeyMap = await this.loadCycleFile('journeyMap', false);
                if (journeyMap) {
                    journeyMap = journeyMap.replace(/\*Version: \d+\*/, `*Version: ${version}*`);
                    await this.saveCycleFile('journeyMap', journeyMap, false);
                }
                
                // Update feedback file timestamp
                let feedback = await this.loadCycleFile('userFeedback', false);
                if (feedback) {
                    feedback = feedback.replace(
                        /\*Last updated:.*\*/,
                        `*Last updated: v${version} - ${date}*`
                    );
                    await this.saveCycleFile('userFeedback', feedback, false);
                }
                
                this.addMessage('system', `    Files updated to v${version}`);
                
                // Generate Release Notes
                this.addMessage('system', ` Generating release notes...`);
                await this.generateReleaseNotes(version, score);
                
                // Update README/Documentation
                this.addMessage('system', ` Updating documentation...`);
                await this.updateDocumentation(version, score);
            },
            
            // Generate release notes for a version
            async generateReleaseNotes(version, score) {
                const date = new Date().toLocaleDateString();
                const timestamp = new Date().toISOString();
                const releaseNotesPath = `${this.repoPath}/RELEASE-NOTES.md`;
                
                // Gather information for release notes
                const objective = this.cycleState.objective || 'No objective specified';
                const completedTodos = this.cycleState.todos.filter(t => t.status === 'completed');
                const versions = this.cycleState.versions || [];
                
                // Build the release entry
                let releaseEntry = `
## v${version} - ${date}

**Score:** ${score}%  
**Objective:** ${objective}

### Changes
${completedTodos.length > 0 
    ? completedTodos.map(t => `-  ${t.text || t.description || 'Task completed'}`).join('\n')
    : '- Initial release'}

### Files Modified
${this.projectFiles.slice(0, 10).map(f => `- \`${f.name}\``).join('\n')}

### Quality Metrics
- Evaluation Score: ${score}%
- Target Score: ${this.cycleState.targetScore}%
- Iterations: ${version}

---
`;

                try {
                    // Read existing release notes or create new
                    let existingNotes = '';
                    try {
                        existingNotes = await window.aider.readFile(releaseNotesPath);
                    } catch (e) {
                        // File doesn't exist yet
                    }
                    
                    if (existingNotes) {
                        // Prepend new release after the header
                        const headerMatch = existingNotes.match(/^#[^\n]+\n/);
                        if (headerMatch) {
                            existingNotes = headerMatch[0] + releaseEntry + existingNotes.substring(headerMatch[0].length);
                        } else {
                            existingNotes = `# Release Notes\n${releaseEntry}\n${existingNotes}`;
                        }
                    } else {
                        existingNotes = `# Release Notes

*Auto-generated by GSX Create Meta Learning Cycle*

${releaseEntry}`;
                    }
                    
                    await window.aider.writeFile(releaseNotesPath, existingNotes);
                    this.addMessage('system', `    Release notes created: RELEASE-NOTES.md`);
                } catch (error) {
                    console.error('[Cycle] Release notes error:', error);
                    this.addMessage('system', `    Could not create release notes`);
                }
            },
            
            // Update project documentation
            async updateDocumentation(version, score) {
                const readmePath = `${this.repoPath}/README.md`;
                const date = new Date().toLocaleDateString();
                
                try {
                    let readme = '';
                    try {
                        readme = await window.aider.readFile(readmePath);
                    } catch (e) {
                        // File doesn't exist
                    }
                    
                    // Create or update version badge section
                    const versionBadge = `**Version:** v${version} | **Score:** ${score}% | **Updated:** ${date}`;
                    
                    if (readme) {
                        // Update existing version info
                        if (readme.includes('**Version:**')) {
                            readme = readme.replace(/\*\*Version:\*\*[^\n]+/, versionBadge);
                        } else {
                            // Add version after first heading
                            const firstHeadingEnd = readme.indexOf('\n');
                            if (firstHeadingEnd > 0) {
                                readme = readme.substring(0, firstHeadingEnd + 1) + 
                                         `\n${versionBadge}\n` + 
                                         readme.substring(firstHeadingEnd + 1);
                            }
                        }
                        
                        // Update or add changelog section
                        const changelogEntry = `\n### v${version} (${date})\n- ${this.cycleState.objective || 'Updates and improvements'}\n`;
                        
                        if (readme.includes('## Changelog') || readme.includes('## Version History')) {
                            // Add to existing changelog
                            readme = readme.replace(
                                /(## Changelog|## Version History)\n/,
                                `$1\n${changelogEntry}`
                            );
                        } else {
                            // Add changelog section at the end
                            readme += `\n\n## Changelog\n${changelogEntry}`;
                        }
                        
                        await window.aider.writeFile(readmePath, readme);
                        this.addMessage('system', `    README.md updated`);
                    } else {
                        // Create a basic README
                        const projectName = this.currentSpaceName || 'Project';
                        const newReadme = `# ${projectName}

${versionBadge}

## Overview

${this.cycleState.objective || 'A project created with GSX Create.'}

## Getting Started

1. Open the main HTML file in your browser
2. Or run a local server in this directory

## Files

${this.projectFiles.slice(0, 10).map(f => `- \`${f.name}\` - ${f.type || 'file'}`).join('\n')}

## Changelog

### v${version} (${date})
- Initial release
- ${this.cycleState.objective || 'Project setup complete'}

---

*Generated by GSX Create Meta Learning Cycle*
`;
                        await window.aider.writeFile(readmePath, newReadme);
                        this.addMessage('system', `    README.md created`);
                    }
                } catch (error) {
                    console.error('[Cycle] Documentation update error:', error);
                    this.addMessage('system', `    Could not update documentation`);
                }
            },
            
            // ========== END CYCLE FILE MANAGEMENT ==========
            
            // Research Phase - Define objective and analyze requirements
            async phaseResearch() {
                // Update progress
                this.cycleState.currentScore = 25;
                this.updateCycleUI();
                
                // Check required files for this phase
                var filesReady = await this.checkPhaseRequiredFiles('research');
                if (!filesReady) {
                    await this.waitForFileApproval();
                }
                
                // Try to auto-extract objective from Journey Map if not set
                if (!this.cycleState.objective) {
                    if (this.evaluatedJourneyMap) {
                        this.addMessage('system', ' Extracting objective from Journey Map...');
                        const extractedObjective = await this.extractObjectiveFromJourneyMap();
                        if (extractedObjective) {
                            this.cycleState.objective = extractedObjective;
                            this.addMessage('system', `    Objective extracted`);
                        }
                    }
                }
                
                // If still no objective, ask user
                if (!this.cycleState.objective) {
                    this.addMessage('system', ' Waiting for objective...');
                    this.addMessage('system', '   Type your goal and press Send');
                    this.cycleState.paused = true;
                    this.cycleState.waitingForObjective = true;
                    await this.logCycleEvent('Waiting for Objective', {});
                    this.updateCycleUI();
                    return;
                }
                
                // Display the objective
                this.addMessage('system', ` Objective: "${this.cycleState.objective}"`);
                await this.logCycleEvent('Objective Set', { objective: this.cycleState.objective });
                await this.delay(300);
                
                // Step 1: Load pending feedback from user-feedback.md
                this.addMessage('system', ` Loading pending feedback...`);
                const feedbackContent = await this.loadCycleFile('userFeedback', false);
                const pendingFeedback = this.parsePendingFeedback(feedbackContent);
                
                if (pendingFeedback.length > 0) {
                    this.addMessage('system', `    ${pendingFeedback.length} pending items found`);
                    this.cycleState.pendingFeedback = pendingFeedback;
                } else {
                    this.addMessage('system', `    No pending feedback`);
                    this.cycleState.pendingFeedback = [];
                }
                await this.delay(300);
                
                // Step 2: Analyze current state
                if (this.currentPreviewFile) {
                    const fileName = this.currentPreviewFile.split('/').pop();
                    this.addMessage('system', ` Analyzing ${fileName}...`);
                    
                    try {
                        const result = await window.testAgent.runInteractiveTest(this.currentPreviewFile);
                        if (result.success && result.aiAnalysis) {
                            this.lastVisualAnalysis = result.aiAnalysis;
                            this.addMessage('system', `    AI analysis complete`);
                        }
                    } catch (e) {
                        this.addMessage('system', `    Analysis skipped`);
                    }
                }
                await this.delay(300);
                
                // Step 3: Generate research notes
                this.addMessage('system', ` Creating research notes...`);
                const researchContent = await this.generateResearchNotes();
                await this.saveCycleFile('researchNotes', researchContent, true);
                this.addMessage('system', `    research-notes-v${this.cycleState.currentVersion}.md created`);
                await this.delay(300);
                
                // Ensure persistent files exist
                await this.ensurePersistentFiles();
                
                await this.runPhase('plan');
            },
            
            // Parse pending feedback items from feedback file
            parsePendingFeedback(content) {
                if (!content) return [];
                const pending = [];
                const lines = content.split('\n');
                let currentBucket = '';
                
                for (const line of lines) {
                    if (line.includes('## End User')) currentBucket = 'endUser';
                    else if (line.includes('## Advocate')) currentBucket = 'advocate';
                    else if (line.includes('## Generated')) currentBucket = 'generated';
                    
                    // Match unchecked items: - [ ] text
                    const match = line.match(/^[\s]*-\s*\[ \]\s*(.+)$/);
                    if (match && currentBucket) {
                        const text = match[1].trim();
                        if (text && !text.includes('No ') && !text.includes('Waiting for')) {
                            pending.push({ text, bucket: currentBucket });
                        }
                    }
                }
                
                return pending;
            },
            
            // Generate research notes with AI
            async generateResearchNotes() {
                const version = this.cycleState.currentVersion;
                const objective = this.cycleState.objective;
                const feedback = this.cycleState.pendingFeedback || [];
                const analysis = this.lastVisualAnalysis || '';
                
                // Create base template
                let notes = `# Research Notes - v${version}
*Date: ${new Date().toLocaleDateString()}*
*Objective: ${objective}*

## Pending Feedback to Address
${feedback.length > 0 
    ? feedback.map(f => `- [${f.bucket}] ${f.text}`).join('\n')
    : '- No pending feedback'}

## Current State Analysis
${analysis ? analysis.substring(0, 500) + '...' : 'No visual analysis available'}

## Research Findings
*To be populated by AI research...*

## Proposed Approach
Based on the objective and feedback, the recommended approach is:
1. Address pending feedback items first
2. Implement the main objective
3. Validate changes against evaluation criteria

## Files to Modify
- ${this.currentPreviewFile ? this.currentPreviewFile.split('/').pop() : 'TBD'}

---
*Auto-generated by Research phase*
`;
                
                return notes;
            },
            
            // Ensure persistent files exist (style guide, journey map, feedback)
            async ensurePersistentFiles() {
                // Check style guide
                const styleGuide = await this.loadCycleFile('styleGuide', false);
                if (!styleGuide) {
                    this.addMessage('system', ` Creating style-guide.md...`);
                    await this.saveCycleFile('styleGuide', this.generateStyleGuideTemplate(), false);
                }
                
                // Check journey map
                const journeyMap = await this.loadCycleFile('journeyMap', false);
                if (!journeyMap) {
                    this.addMessage('system', ` Creating journey-map.md...`);
                    await this.saveCycleFile('journeyMap', this.generateJourneyMapTemplate(), false);
                }
                
                // Check feedback file
                const feedback = await this.loadCycleFile('userFeedback', false);
                if (!feedback) {
                    this.addMessage('system', ` Creating user-feedback.md...`);
                    await this.saveCycleFile('userFeedback', this.generateFeedbackTemplate(), false);
                }
            },
            
            // Helper for delays
            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            },
            
            // Find main HTML file in project
            async findMainHtmlFile() {
                // If main file is already set, use it
                if (this.mainFile) {
                    console.log('[Cycle] Using configured main file:', this.mainFile);
                    return this.mainFile;
                }
                
                // Refresh project files first to ensure we have latest
                if (this.repoPath) {
                    try {
                        await this.loadProjectFiles();
                    } catch (e) {
                        console.log('[Cycle] Could not refresh project files:', e);
                    }
                }
                
                // Get files array - handle both array and object formats
                var files = [];
                if (Array.isArray(this.projectFiles)) {
                    files = this.projectFiles.filter(f => !f.isDirectory).map(f => f.path);
                } else if (this.projectFiles && this.projectFiles.files) {
                    files = this.projectFiles.files;
                }
                
                if (files.length === 0) {
                    console.log('[Cycle] No project files available');
                    return null;
                }
                
                console.log('[Cycle] Looking for HTML file in:', files);
                
                // Priority order for main files
                const priorities = ['index.html', 'main.html', 'app.html', 'home.html', 'calendar.html'];
                
                // First, check for priority files
                for (const priority of priorities) {
                    const found = files.find(f => {
                        const fileName = (f.path || f).split('/').pop().toLowerCase();
                        return fileName === priority;
                    });
                    if (found) {
                        const filePath = found.path || found;
                        console.log('[Cycle] Found priority HTML file:', filePath);
                        this.mainFile = filePath; // Save for future use
                        return filePath;
                    }
                }
                
                // Then, find any HTML file
                const htmlFile = files.find(f => {
                    const path = f.path || f;
                    return path.toLowerCase().endsWith('.html') || path.toLowerCase().endsWith('.htm');
                });
                if (htmlFile) {
                    const filePath = htmlFile.path || htmlFile;
                    console.log('[Cycle] Found HTML file:', filePath);
                    this.mainFile = filePath; // Save for future use
                    return filePath;
                }
                
                console.log('[Cycle] No HTML file found');
                return null;
            },
            
            // Plan Phase - Generate tasks and show checkboxes for user approval
            async phasePlan() {
                // Check required files for this phase
                var filesReady = await this.checkPhaseRequiredFiles('plan');
                if (!filesReady) {
                    await this.waitForFileApproval();
                }
                
                if (!this.cycleState.objective) {
                    this.addMessage('error', 'No objective set. Cannot create plan.');
                    await this.logCycleEvent('Plan Skipped - No Objective', {});
                    await this.runPhase('execute');
                    return;
                }
                
                this.addMessage('system', ` Generating task breakdown...`);
                
                // Generate tasks using AI
                const tasks = await this.generateTaskBreakdown();
                
                if (tasks.length === 0) {
                    // Fallback to single task
                    tasks.push({ task: this.cycleState.objective, approved: true });
                }
                
                // Store tasks
                this.cycleState.proposedTasks = tasks;
                await this.logCycleEvent('Tasks Generated', { taskCount: tasks.length, tasks: tasks.map(t => t.task) });
                
                // Show tasks with checkboxes
                this.showTaskApprovalUI(tasks);
                
                // Pause and wait for user to approve
                this.cycleState.paused = true;
                this.cycleState.waitingForApproval = true;
                await this.logCycleEvent('Waiting for Task Approval', { taskCount: tasks.length });
                this.updateCycleUI();
            },
            
            // Generate task breakdown from objective
            async generateTaskBreakdown() {
                const objective = this.cycleState.objective;
                
                
                const tasks = [];
                
                // Guard: ensure objective is a string
                if (!objective || typeof objective !== 'string') {
                    console.warn('[Cycle] generateTaskBreakdown called without valid objective');
                    return [{ task: 'Implement the requested feature', approved: true }];
                }
                
                // Simple breakdown - split by common patterns or use AI
                // For now, create logical subtasks based on objective
                const keywords = objective.toLowerCase();
                    
                    if (keywords.includes(' and ')) {
                    // Split by "and"
                        const parts = objective.split(/ and /i);
                        parts.forEach(p => tasks.push({ task: p.trim(), approved: true }));
                    } else if (keywords.includes(',')) {
                    // Split by comma
                        const parts = objective.split(',');
                        parts.forEach(p => tasks.push({ task: p.trim(), approved: true }));
                    } else {
                    // Single task with common subtasks
                    tasks.push({ task: `Analyze current code for: ${objective}`, approved: true });
                        tasks.push({ task: `Implement: ${objective}`, approved: true });
                        tasks.push({ task: `Add error handling and edge cases`, approved: true });
                    tasks.push({ task: `Update styles if needed`, approved: false });
                    tasks.push({ task: `Add comments and documentation`, approved: false });
                }
                
                return tasks;
            },
            
            // Show task approval UI with checkboxes
            showTaskApprovalUI(tasks) {
                const taskListHtml = tasks.map((t, i) => `
                    <div style="display: flex; align-items: center; gap: 8px; padding: 8px; background: var(--bg-tertiary); border-radius: 6px; margin: 4px 0;">
                        <input type="checkbox" id="task-${i}" ${t.approved ? 'checked' : ''} 
                               onchange="GSXCreate.toggleTaskApproval(${i})"
                               style="width: 16px; height: 16px; cursor: pointer;">
                        <label for="task-${i}" style="flex: 1; cursor: pointer; font-size: 12px;">${t.task}</label>
                    </div>
                `).join('');
                
                const approvalHtml = `
                    <div style="margin: 12px 0;">
                        <div style="font-size: 11px; color: var(--text-muted); margin-bottom: 8px;">
                            Select tasks to execute:
                        </div>
                        ${taskListHtml}
                        <div style="display: flex; gap: 8px; margin-top: 12px;">
                            <button onclick="GSXCreate.approveSelectedTasks()" 
                                    style="flex: 1; padding: 8px; background: var(--success); color: #000; border: none; border-radius: 6px; cursor: pointer; font-size: 12px;">
                                 Approve & Execute
                            </button>
                            <button onclick="GSXCreate.selectAllTasks(true)" 
                                    style="padding: 8px 12px; background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border); border-radius: 6px; cursor: pointer; font-size: 11px;">
                                All
                            </button>
                            <button onclick="GSXCreate.selectAllTasks(false)" 
                                    style="padding: 8px 12px; background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border); border-radius: 6px; cursor: pointer; font-size: 11px;">
                                None
                            </button>
                        </div>
                    </div>
                `;
                
                this.addMessage('system', approvalHtml, null, true);
            },
            
            // Toggle task approval
            toggleTaskApproval(index) {
                if (this.cycleState.proposedTasks && this.cycleState.proposedTasks[index]) {
                    this.cycleState.proposedTasks[index].approved = !this.cycleState.proposedTasks[index].approved;
                }
            },
            
            // Select/deselect all tasks
            selectAllTasks(select) {
                if (this.cycleState.proposedTasks) {
                    this.cycleState.proposedTasks.forEach((t, i) => {
                        t.approved = select;
                        const checkbox = document.getElementById(`task-${i}`);
                        if (checkbox) checkbox.checked = select;
                    });
                }
            },
            
            // Approve selected tasks and continue
            approveSelectedTasks() {
                const approvedTasks = this.cycleState.proposedTasks.filter(t => t.approved);
                
                if (approvedTasks.length === 0) {
                    this.addMessage('error', 'Please select at least one task');
                    return;
                }
                
                // Convert to todos
                this.cycleState.todos = approvedTasks.map(t => ({
                    task: t.task,
                    status: 'pending',
                    created: new Date().toISOString()
                }));
                
                // Sync to Episodic Memory Plan tab
                this.syncCycleTodosToEpisodicMemory();
                
                this.addMessage('system', ` ${approvedTasks.length} task(s) approved`);
                
                // Resume cycle
                this.cycleState.paused = false;
                this.cycleState.waitingForApproval = false;
                this.updateCycleUI();
                
                // Continue to execute
                this.runPhase('execute');
            },
            
            // Sync cycle todos to Episodic Memory Plan tab
            syncCycleTodosToEpisodicMemory() {
                // Add cycle tasks to the sidebar todo list
                const cycleTasks = this.cycleState.todos || [];
                
                // Merge with existing todos (avoid duplicates)
                cycleTasks.forEach(ct => {
                    const exists = this.todos.some(t => t.text === ct.task);
                    if (!exists) {
                        this.todos.unshift({
                            id: Date.now() + Math.random(),
                            text: ct.task,
                            done: ct.status === 'completed',
                            created: ct.created,
                            fromCycle: true // Mark as from meta learning cycle
                        });
                    }
                });
                
                this.saveTodos();
                this.renderTodos();
                
                // Switch to Plan tab to show the new tasks
                this.switchEpisodicTab('plan');
            },
            
            // Placeholder for future AI-based todo generation
            async generateTodosLegacy() {
                // This was causing issues because Aider executes code when given prompts
                // For now, we use the objective directly as a single task
                return [{
                    task: this.cycleState.objective,
                    status: 'pending',
                    created: new Date().toISOString()
                }];
            },
            
            // Save todos to a file in the space
            async saveTodoFile(todos) {
                if (!this.repoPath) return;
                
                const version = this.cycleState.currentVersion;
                const timestamp = new Date().toISOString().split('T')[0];
                const fileName = `TODO-v${version}.md`;
                const filePath = `${this.repoPath}/${fileName}`;
                
                // Format as markdown
                let content = `# Todo List - v${version}\n`;
                content += `**Objective:** ${this.cycleState.objective}\n`;
                content += `**Created:** ${timestamp}\n\n`;
                content += `## Tasks\n\n`;
                
                todos.forEach((t, i) => {
                    const checkbox = t.status === 'completed' ? '[x]' : '[ ]';
                    content += `${i + 1}. ${checkbox} ${t.task}\n`;
                });
                
                content += '\n---\n*Generated by GSX Create Meta Learning*\n';
                
                try {
                    // Use Aider to create the file
                    const todoFilePrompt = `Create a new file called ${fileName} with this exact content:\n\n${content}`;
                    const todoResult = await window.aider.runPrompt(todoFilePrompt);
                    await this.trackTaskCost(todoFilePrompt, todoResult?.response || '', 'save_todo');
                    this.addMessage('system', ` Saved: ${fileName}`);
                } catch (e) {
                    console.log('[Cycle] Save todo file error:', e);
                }
            },
            
            // Execute Phase - Work through todos one by one (fully automatic)
            async phaseExecute() {
                // Check required files for this phase
                var filesReady = await this.checkPhaseRequiredFiles('execute');
                if (!filesReady) {
                    await this.waitForFileApproval();
                }
                
                const todos = this.cycleState.todos || [];
                const pendingTodos = todos.filter(t => t.status === 'pending');
                
                if (pendingTodos.length === 0) {
                    // Check for fixes from previous test
                    if (this.fixQueue && this.fixQueue.length > 0) {
                        const fix = this.fixQueue.shift();
                        this.addMessage('system', ` Fixing: ${fix.description.substring(0, 50)}...`);
                        await this.logCycleEvent('Applying Fix', { fix: fix.description.substring(0, 100) });
                        await this.executeTask(`Fix this issue: ${fix.description}`);
                    } else {
                        this.addMessage('system', ' All tasks completed');
                        await this.logCycleEvent('All Tasks Completed', { totalTasks: todos.length });
                    }
                    await this.runPhase('test');
                    return;
                }
                
                // Get next pending todo
                const currentTodo = pendingTodos[0];
                const todoIndex = todos.indexOf(currentTodo);
                const taskNum = todos.length - pendingTodos.length + 1;
                await this.logCycleEvent('Executing Task', { taskNum, totalTasks: todos.length, task: currentTodo.task });
                
                this.addMessage('system', ` Task ${taskNum}/${todos.length}: ${currentTodo.task}`);
                
                // Execute the todo using AI (automatic - no user input needed)
                try {
                    // Step 1: Summarize Constitutional Memory for this specific task
                    this.addMessage('system', `    Loading constitutional context...`);
                    await this.summarizeConstitutionalMemory(currentTodo.task);
                    const constitutionalContext = this.getConstitutionalContext();
                    
                    // Log the dynamic system prompt
                    await this.logDynamicSystemPrompt(currentTodo.task, constitutionalContext);
                    
                    // Check if task involves data persistence
                    const needsApi = this.detectApiNeed(currentTodo.task);
                    
                    // Build prompt with Constitutional Memory context
                    var prompt = '';
                    
                    // Add Constitutional Memory summary first (guiding principles)
                    if (constitutionalContext) {
                        prompt += constitutionalContext;
                    }
                    
                    // Add Debug Mode instructions if enabled
                    const debugInstructions = this.getDebugModeInstructions();
                    if (debugInstructions) {
                        prompt += debugInstructions;
                    }
                    
                    prompt += 'Complete this task: ' + currentTodo.task + '\n\n' +
                        'Context:\n' +
                        '- Objective: ' + this.cycleState.objective + '\n' +
                        '- File: ' + (this.currentPreviewFile ? this.currentPreviewFile.split('/').pop() : 'current project') + '\n\n';
                    
                    if (needsApi) {
                        prompt += 'IMPORTANT - Data Persistence:\n' +
                            'This task involves saving/loading data. Follow these rules:\n' +
                            '1. Create API calls using a stub pattern: AppAPI.methodName(data)\n' +
                            '2. Use localStorage as temporary storage until backend is ready\n' +
                            '3. Structure data with: id, createdAt, updatedAt fields\n' +
                            '4. Handle loading states and errors gracefully\n' +
                            '5. DO NOT hardcode data - always use the API pattern\n\n';
                    }
                    
                    prompt += 'Follow the project guidelines above. Implement the changes needed to complete this specific task.';

                    // If this task is from user feedback, mark as in_progress
                    if (currentTodo.feedbackId) {
                        this.updateFeedbackStatus(currentTodo.feedbackId, 'in_progress');
                    }
                    
                    await this.executeTask(prompt);
                    
                    // After task, check if we need to generate API requirements
                    if (needsApi) {
                        await this.generateApiRequirements(currentTodo.task);
                    }
                    
                    // Mark todo as completed
                    todos[todoIndex].status = 'completed';
                    await this.updateTodoFile();
                    
                    // If this task was from user feedback, mark it as completed
                    if (currentTodo.feedbackId) {
                        this.updateFeedbackStatus(currentTodo.feedbackId, 'completed');
                    }
                    
                    // Sync to Episodic Memory
                    this.markCycleTaskComplete(currentTodo.task);
                    
                    // Brief pause then continue with next todo
                    await new Promise(function(r) { setTimeout(r, 500); });
                    
                    // Continue with next todo or move to test
                    var stillPending = todos.filter(function(t) { return t.status === 'pending'; });
                    if (stillPending.length > 0) {
                        await this.phaseExecute();
                    } else {
                        this.addMessage('system', ' All tasks completed');
                        // Generate consolidated API requirements if any were detected
                        await this.finalizeApiRequirements();
                        await this.runPhase('test');
                    }
                } catch (e) {
                    console.log('[Cycle] Execute error:', e);
                    this.addMessage('error', 'Task failed: ' + e.message);
                    // Mark as failed but continue
                    todos[todoIndex].status = 'failed';
                    await this.updateTodoFile();
                    
                    var stillPending = todos.filter(function(t) { return t.status === 'pending'; });
                    if (stillPending.length > 0) {
                        await this.phaseExecute();
                    } else {
                        await this.runPhase('test');
                    }
                }
            },
            
            // Detect if a task needs API/persistence
            detectApiNeed(taskDescription) {
                var keywords = [
                    'save', 'store', 'persist', 'database', 'storage',
                    'create', 'update', 'delete', 'remove', 'add',
                    'user', 'account', 'login', 'register', 'auth',
                    'submit', 'form', 'data', 'record',
                    'order', 'cart', 'checkout', 'payment',
                    'booking', 'reservation', 'appointment', 'event',
                    'message', 'comment', 'post', 'upload',
                    'settings', 'preferences', 'profile'
                ];
                var lowerTask = taskDescription.toLowerCase();
                for (var i = 0; i < keywords.length; i++) {
                    if (lowerTask.indexOf(keywords[i]) !== -1) {
                        return true;
                    }
                }
                return false;
            },
            
            // Track detected API endpoints during execution
            detectedApiEndpoints: [],
            
            // API docs folder name
            apiDocsFolder: 'api-specs',
            
            // Generate API requirements for a task
            async generateApiRequirements(taskDescription) {
                this.addMessage('system', ' Detecting API requirements...');
                
                // Ask AI to identify the data model and endpoints needed
                var prompt = 'Based on this task: "' + taskDescription + '"\n\n' +
                    'Identify the API requirements. Respond in this exact JSON format:\n' +
                    '{\n' +
                    '  "resourceName": "the main resource (e.g., Event, User, Order)",\n' +
                    '  "resourceDescription": "what this resource represents",\n' +
                    '  "fields": [\n' +
                    '    {"name": "fieldName", "type": "string|number|boolean|date|array|object", "required": true/false, "description": "what this field is for"}\n' +
                    '  ],\n' +
                    '  "operations": [\n' +
                    '    {"name": "operationName", "type": "create|read|update|delete|list|search|custom", "description": "what this operation does", "inputFields": ["field1"], "outputFields": ["field1", "field2"]}\n' +
                    '  ],\n' +
                    '  "businessRules": ["rule 1", "rule 2"],\n' +
                    '  "relatedResources": ["OtherResource"]\n' +
                    '}\n\n' +
                    'Only output the JSON, no other text.';
                
                try {
                    var response = await this.executeTaskSilent(prompt);
                    
                    // Parse the JSON from response
                    var jsonMatch = response.match(/\{[\s\S]*\}/);
                    if (jsonMatch) {
                        var apiSpec = JSON.parse(jsonMatch[0]);
                        apiSpec.appVersion = this.cycleState.currentVersion;
                        apiSpec.detectedAt = new Date().toISOString();
                        apiSpec.sourceTask = taskDescription;
                        
                        // Check if this resource already exists
                        var existingIndex = -1;
                        for (var i = 0; i < this.detectedApiEndpoints.length; i++) {
                            if (this.detectedApiEndpoints[i].resourceName === apiSpec.resourceName) {
                                existingIndex = i;
                                break;
                            }
                        }
                        
                        if (existingIndex >= 0) {
                            // Merge with existing - add new operations
                            var existing = this.detectedApiEndpoints[existingIndex];
                            if (apiSpec.operations) {
                                existing.operations = existing.operations || [];
                                for (var j = 0; j < apiSpec.operations.length; j++) {
                                    var op = apiSpec.operations[j];
                                    var opExists = existing.operations.some(function(e) { return e.name === op.name; });
                                    if (!opExists) {
                                        existing.operations.push(op);
                                    }
                                }
                            }
                            if (apiSpec.fields) {
                                existing.fields = existing.fields || [];
                                for (var j = 0; j < apiSpec.fields.length; j++) {
                                    var field = apiSpec.fields[j];
                                    var fieldExists = existing.fields.some(function(f) { return f.name === field.name; });
                                    if (!fieldExists) {
                                        existing.fields.push(field);
                                    }
                                }
                            }
                            existing.appVersion = apiSpec.appVersion;
                            this.addMessage('system', '   Updated: ' + apiSpec.resourceName + ' API');
                        } else {
                            this.detectedApiEndpoints.push(apiSpec);
                            this.addMessage('system', '   Found: ' + apiSpec.resourceName + ' (' + (apiSpec.operations ? apiSpec.operations.length : 0) + ' operations)');
                        }
                    }
                } catch (e) {
                    console.log('[Execute] API detection error:', e);
                }
            },
            
            // Execute task without UI streaming (for internal queries)
            async executeTaskSilent(prompt) {
                var response = '';
                var self = this;
                try {
                    await window.aider.runPromptStreaming(prompt, function(chunk) {
                        response += chunk;
                    });
                    
                    // Track API cost silently
                    await self.trackTaskCost(prompt, response, 'silent_task');
                    
                    return response;
                } catch (e) {
                    throw e;
                }
            },
            
            // Generate individual API requirement documents
            async finalizeApiRequirements() {
                if (this.detectedApiEndpoints.length === 0) {
                    return;
                }
                
                this.addMessage('system', ' Generating API Requirement Documents...');
                
                // Ensure api-specs folder exists
                var specsFolderPath = this.repoPath + '/' + this.apiDocsFolder;
                try {
                    await window.aider.createDirectory(specsFolderPath);
                } catch (e) {
                    // Folder may already exist
                }
                
                // Generate individual doc for each resource
                for (var i = 0; i < this.detectedApiEndpoints.length; i++) {
                    var spec = this.detectedApiEndpoints[i];
                    await this.saveApiSpecDoc(spec);
                }
                
                // Generate index/manifest file
                await this.saveApiManifest();
                
                // Generate the stub client
                await this.generateApiStubClient();
                
                // Check for sync issues
                await this.checkApiSync();
                
                // Generate test harness for APIs
                await this.generateApiTestHarness();
                
                // Update test plan
                await this.updateTestPlan();
                
                // Log API changes
                await this.logApiChanges();
                
                // Clear for next cycle
                this.detectedApiEndpoints = [];
            },
            
            // API change log
            apiChangeLog: [],
            
            // Log API changes for tracking
            async logApiChanges() {
                if (this.detectedApiEndpoints.length === 0) return;
                
                var version = this.cycleState.currentVersion;
                var timestamp = new Date().toISOString();
                
                for (var i = 0; i < this.detectedApiEndpoints.length; i++) {
                    var spec = this.detectedApiEndpoints[i];
                    var changeEntry = {
                        resource: spec.resourceName,
                        version: version,
                        timestamp: timestamp,
                        operations: spec.operations ? spec.operations.map(function(o) { return o.type; }) : [],
                        fields: spec.fields ? spec.fields.length : 0,
                        action: spec.isUpdate ? 'updated' : 'created'
                    };
                    this.apiChangeLog.push(changeEntry);
                    
                    // Also log to event database
                    try {
                        await window.aider.txdbLogEvent({
                            type: 'api_change',
                            summary: 'API ' + changeEntry.action + ': ' + spec.resourceName + ' (v' + version + ')',
                            message: spec.resourceName + ' API ' + changeEntry.action,
                            context: JSON.stringify(changeEntry),
                            timestamp: timestamp
                        });
                    } catch (e) {
                        console.log('[Execute] Log API change error:', e);
                    }
                }
            },
            
            // Generate test harness for all detected APIs
            async generateApiTestHarness() {
                if (this.detectedApiEndpoints.length === 0) return;
                
                this.addMessage('system', ' Generating Playwright API test harness...');
                
                var version = this.cycleState.currentVersion;
                var appName = (this.currentSpaceName || 'App').replace(/[^a-zA-Z0-9]/g, '');
                
                // Ensure test folder exists
                var testFolderPath = this.repoPath + '/tests';
                try {
                    await window.aider.createDirectory(testFolderPath);
                } catch (e) { /* may exist */ }
                
                // Generate Playwright config
                await this.generatePlaywrightConfig(version, appName);
                
                // Generate Playwright test file for each API
                for (var i = 0; i < this.detectedApiEndpoints.length; i++) {
                    var spec = this.detectedApiEndpoints[i];
                    await this.generatePlaywrightApiTests(spec, version, appName);
                }
                
                // Generate combined test runner
                await this.generatePlaywrightTestRunner(version, appName);
                
                // Also generate browser-based tests for stub mode
                for (var i = 0; i < this.detectedApiEndpoints.length; i++) {
                    var spec = this.detectedApiEndpoints[i];
                    await this.generateApiTests(spec, version, appName);
                }
                await this.generateTestRunner(version, appName);
            },
            
            // Generate Playwright config for API testing
            async generatePlaywrightConfig(version, appName) {
                var filePath = this.repoPath + '/playwright.config.js';
                
                var code = '// Playwright Configuration for ' + appName + '\n';
                code += '// Version: ' + version + '\n';
                code += '// Generated by GSX Create Meta Learning\n\n';
                
                code += 'const { defineConfig } = require("@playwright/test");\n\n';
                
                code += 'module.exports = defineConfig({\n';
                code += '    testDir: "./tests",\n';
                code += '    timeout: 30000,\n';
                code += '    retries: 1,\n';
                code += '    use: {\n';
                code += '        // Base URL for API tests (set when backend ready)\n';
                code += '        baseURL: process.env.API_BASE_URL || "http://localhost:3000",\n';
                code += '        extraHTTPHeaders: {\n';
                code += '            "Accept": "application/json",\n';
                code += '            "Content-Type": "application/json"\n';
                code += '        }\n';
                code += '    },\n';
                code += '    reporter: [\n';
                code += '        ["list"],\n';
                code += '        ["json", { outputFile: "test-results.json" }]\n';
                code += '    ],\n';
                code += '    projects: [\n';
                code += '        {\n';
                code += '            name: "api",\n';
                code += '            testMatch: "**/*.api.spec.js"\n';
                code += '        },\n';
                code += '        {\n';
                code += '            name: "ui",\n';
                code += '            testMatch: "**/*.ui.spec.js",\n';
                code += '            use: { browserName: "chromium" }\n';
                code += '        }\n';
                code += '    ]\n';
                code += '});\n';
                
                try {
                    await window.aider.writeFile(filePath, code);
                    this.addMessage('system', '   playwright.config.js');
                } catch (e) {
                    console.log('[Execute] Save playwright config error:', e);
                }
            },
            
            // Generate Playwright API tests for a resource
            async generatePlaywrightApiTests(spec, version, appName) {
                var resource = spec.resourceName;
                var resourceLower = resource.toLowerCase();
                var fileName = resourceLower + '.api.spec.js';
                var filePath = this.repoPath + '/tests/' + fileName;
                
                var code = '// @ts-check\n';
                code += 'const { test, expect } = require("@playwright/test");\n\n';
                
                code += '/**\n';
                code += ' * ' + resource + ' API Tests\n';
                code += ' * Version: ' + version + '\n';
                code += ' * Spec: api-specs/' + resourceLower + '-api.md\n';
                code += ' * \n';
                code += ' * Run: npx playwright test ' + fileName + '\n';
                code += ' */\n\n';
                
                code += 'test.describe("' + resource + ' API", () => {\n';
                code += '    const endpoint = "/' + resourceLower + 's";\n';
                code += '    let createdId;\n\n';
                
                // Test data
                code += '    const testData = ' + JSON.stringify(this.generateTestData(spec), null, 8).replace(/\n/g, '\n    ') + ';\n\n';
                
                // Create test
                code += '    test("POST ' + endpoint + ' - create ' + resourceLower + '", async ({ request }) => {\n';
                code += '        const response = await request.post(endpoint, {\n';
                code += '            data: testData\n';
                code += '        });\n';
                code += '        \n';
                code += '        expect(response.ok()).toBeTruthy();\n';
                code += '        \n';
                code += '        const body = await response.json();\n';
                code += '        expect(body.id).toBeDefined();\n';
                code += '        expect(body.createdAt).toBeDefined();\n';
                
                // Assert required fields
                if (spec.fields) {
                    for (var j = 0; j < spec.fields.length; j++) {
                        var f = spec.fields[j];
                        if (f.required) {
                            code += '        expect(body.' + f.name + ').toBeDefined();\n';
                        }
                    }
                }
                
                code += '        \n';
                code += '        createdId = body.id;\n';
                code += '    });\n\n';
                
                // Read test
                code += '    test("GET ' + endpoint + '/:id - get ' + resourceLower + '", async ({ request }) => {\n';
                code += '        test.skip(!createdId, "No id from create test");\n';
                code += '        \n';
                code += '        const response = await request.get(`${endpoint}/${createdId}`);\n';
                code += '        \n';
                code += '        expect(response.ok()).toBeTruthy();\n';
                code += '        \n';
                code += '        const body = await response.json();\n';
                code += '        expect(body.id).toBe(createdId);\n';
                code += '    });\n\n';
                
                // List test
                code += '    test("GET ' + endpoint + ' - list ' + resourceLower + 's", async ({ request }) => {\n';
                code += '        const response = await request.get(endpoint);\n';
                code += '        \n';
                code += '        expect(response.ok()).toBeTruthy();\n';
                code += '        \n';
                code += '        const body = await response.json();\n';
                code += '        expect(Array.isArray(body.items) || Array.isArray(body)).toBeTruthy();\n';
                code += '    });\n\n';
                
                // Update test
                code += '    test("PUT ' + endpoint + '/:id - update ' + resourceLower + '", async ({ request }) => {\n';
                code += '        test.skip(!createdId, "No id from create test");\n';
                code += '        \n';
                code += '        const updateData = { updatedField: "test_update_" + Date.now() };\n';
                code += '        const response = await request.put(`${endpoint}/${createdId}`, {\n';
                code += '            data: updateData\n';
                code += '        });\n';
                code += '        \n';
                code += '        expect(response.ok()).toBeTruthy();\n';
                code += '        \n';
                code += '        const body = await response.json();\n';
                code += '        expect(body.updatedAt).toBeDefined();\n';
                code += '    });\n\n';
                
                // Delete test
                code += '    test("DELETE ' + endpoint + '/:id - delete ' + resourceLower + '", async ({ request }) => {\n';
                code += '        test.skip(!createdId, "No id from create test");\n';
                code += '        \n';
                code += '        const response = await request.delete(`${endpoint}/${createdId}`);\n';
                code += '        \n';
                code += '        expect(response.ok()).toBeTruthy();\n';
                code += '        \n';
                code += '        // Verify deleted\n';
                code += '        const getResponse = await request.get(`${endpoint}/${createdId}`);\n';
                code += '        expect(getResponse.status()).toBe(404);\n';
                code += '    });\n\n';
                
                // Error handling tests
                code += '    test("GET ' + endpoint + '/:id - 404 for non-existent", async ({ request }) => {\n';
                code += '        const response = await request.get(`${endpoint}/nonexistent123`);\n';
                code += '        \n';
                code += '        expect(response.status()).toBe(404);\n';
                code += '    });\n\n';
                
                code += '    test("POST ' + endpoint + ' - 400 for invalid data", async ({ request }) => {\n';
                code += '        const response = await request.post(endpoint, {\n';
                code += '            data: {} // Empty/invalid data\n';
                code += '        });\n';
                code += '        \n';
                code += '        // Should return 400 for validation error\n';
                code += '        expect([400, 422].includes(response.status())).toBeTruthy();\n';
                code += '    });\n';
                
                code += '});\n';
                
                try {
                    await window.aider.writeFile(filePath, code);
                    this.addMessage('system', '   tests/' + fileName);
                } catch (e) {
                    console.log('[Execute] Save Playwright API tests error:', e);
                }
            },
            
            // Generate Playwright test runner script
            async generatePlaywrightTestRunner(version, appName) {
                var filePath = this.repoPath + '/tests/run-api-tests.js';
                
                var code = '#!/usr/bin/env node\n';
                code += '/**\n';
                code += ' * ' + appName + ' API Test Runner\n';
                code += ' * Version: ' + version + '\n';
                code += ' * \n';
                code += ' * Usage:\n';
                code += ' *   node tests/run-api-tests.js [baseUrl]\n';
                code += ' *   npx playwright test --project=api\n';
                code += ' * \n';
                code += ' * Generated by GSX Create Meta Learning\n';
                code += ' */\n\n';
                
                code += 'const { exec } = require("child_process");\n\n';
                
                code += 'const baseUrl = process.argv[2] || process.env.API_BASE_URL || "http://localhost:3000";\n\n';
                
                code += 'console.log("\\n========================================");\n';
                code += 'console.log("  ' + appName + ' API Tests (v' + version + ')");\n';
                code += 'console.log("  Base URL:", baseUrl);\n';
                code += 'console.log("========================================\\n");\n\n';
                
                code += 'const cmd = `API_BASE_URL=${baseUrl} npx playwright test --project=api`;\n\n';
                
                code += 'exec(cmd, (error, stdout, stderr) => {\n';
                code += '    console.log(stdout);\n';
                code += '    if (stderr) console.error(stderr);\n';
                code += '    if (error) {\n';
                code += '        console.error("Tests failed:", error.message);\n';
                code += '        process.exit(1);\n';
                code += '    }\n';
                code += '});\n';
                
                try {
                    await window.aider.writeFile(filePath, code);
                    this.addMessage('system', '   tests/run-api-tests.js');
                } catch (e) {
                    console.log('[Execute] Save Playwright runner error:', e);
                }
            },
            
            // Generate tests for a single API
            async generateApiTests(spec, version, appName) {
                var resource = spec.resourceName;
                var resourceLower = resource.toLowerCase();
                var fileName = resourceLower + '-api.test.js';
                var filePath = this.repoPath + '/tests/' + fileName;
                
                var code = '/**\n';
                code += ' * ' + resource + ' API Tests\n';
                code += ' * Version: ' + version + '\n';
                code += ' * Generated by GSX Create Meta Learning\n';
                code += ' * \n';
                code += ' * These tests validate the ' + resource + ' API operations.\n';
                code += ' * Run with: TestRunner.run' + resource + 'Tests()\n';
                code += ' */\n\n';
                
                code += 'var ' + resource + 'Tests = {\n';
                code += '    name: "' + resource + ' API",\n';
                code += '    version: ' + version + ',\n';
                code += '    results: [],\n\n';
                
                code += '    // Test utilities\n';
                code += '    assert: function(condition, message) {\n';
                code += '        if (!condition) throw new Error(message);\n';
                code += '    },\n\n';
                
                code += '    log: function(status, test, message) {\n';
                code += '        this.results.push({ status: status, test: test, message: message, timestamp: new Date().toISOString() });\n';
                code += '        console.log("[" + status + "] " + test + ": " + message);\n';
                code += '    },\n\n';
                
                code += '    // Run all tests\n';
                code += '    runAll: async function() {\n';
                code += '        this.results = [];\n';
                code += '        console.log("\\n=== ' + resource + ' API Tests (v' + version + ') ===\\n");\n';
                code += '        \n';
                code += '        await this.testCreate();\n';
                code += '        await this.testRead();\n';
                code += '        await this.testUpdate();\n';
                code += '        await this.testDelete();\n';
                code += '        await this.testList();\n';
                
                // Add custom operation tests
                if (spec.operations) {
                    for (var j = 0; j < spec.operations.length; j++) {
                        var op = spec.operations[j];
                        if (['create', 'read', 'update', 'delete', 'list'].indexOf(op.type) === -1) {
                            code += '        await this.test' + this.capitalize(op.name || op.type) + '();\n';
                        }
                    }
                }
                
                code += '        \n';
                code += '        return this.getSummary();\n';
                code += '    },\n\n';
                
                // Create test
                code += '    testCreate: async function() {\n';
                code += '        try {\n';
                code += '            var testData = ' + JSON.stringify(this.generateTestData(spec)) + ';\n';
                code += '            var result = await ' + appName + 'API.create' + resource + '(testData);\n';
                code += '            \n';
                code += '            this.assert(result.id, "Should return id");\n';
                code += '            this.assert(result.createdAt, "Should have createdAt");\n';
                
                // Assert required fields
                if (spec.fields) {
                    for (var j = 0; j < spec.fields.length; j++) {
                        var f = spec.fields[j];
                        if (f.required) {
                            code += '            this.assert(result.' + f.name + ' !== undefined, "Should have ' + f.name + '");\n';
                        }
                    }
                }
                
                code += '            \n';
                code += '            this._createdId = result.id; // Save for other tests\n';
                code += '            this.log("PASS", "Create ' + resource + '", "Created with id: " + result.id);\n';
                code += '        } catch (e) {\n';
                code += '            this.log("FAIL", "Create ' + resource + '", e.message);\n';
                code += '        }\n';
                code += '    },\n\n';
                
                // Read test
                code += '    testRead: async function() {\n';
                code += '        try {\n';
                code += '            if (!this._createdId) throw new Error("No id from create test");\n';
                code += '            \n';
                code += '            var result = await ' + appName + 'API.get' + resource + '(this._createdId);\n';
                code += '            \n';
                code += '            this.assert(result.id === this._createdId, "Should return correct item");\n';
                code += '            this.log("PASS", "Read ' + resource + '", "Retrieved successfully");\n';
                code += '        } catch (e) {\n';
                code += '            this.log("FAIL", "Read ' + resource + '", e.message);\n';
                code += '        }\n';
                code += '    },\n\n';
                
                // Update test
                code += '    testUpdate: async function() {\n';
                code += '        try {\n';
                code += '            if (!this._createdId) throw new Error("No id from create test");\n';
                code += '            \n';
                code += '            var updateData = { updatedField: "test_update_" + Date.now() };\n';
                code += '            var result = await ' + appName + 'API.update' + resource + '(this._createdId, updateData);\n';
                code += '            \n';
                code += '            this.assert(result.updatedAt, "Should have updatedAt");\n';
                code += '            this.log("PASS", "Update ' + resource + '", "Updated successfully");\n';
                code += '        } catch (e) {\n';
                code += '            this.log("FAIL", "Update ' + resource + '", e.message);\n';
                code += '        }\n';
                code += '    },\n\n';
                
                // List test
                code += '    testList: async function() {\n';
                code += '        try {\n';
                code += '            var result = await ' + appName + 'API.list' + resource + 's();\n';
                code += '            \n';
                code += '            this.assert(Array.isArray(result.items), "Should return items array");\n';
                code += '            this.assert(typeof result.total === "number", "Should return total count");\n';
                code += '            this.log("PASS", "List ' + resource + 's", "Found " + result.total + " items");\n';
                code += '        } catch (e) {\n';
                code += '            this.log("FAIL", "List ' + resource + 's", e.message);\n';
                code += '        }\n';
                code += '    },\n\n';
                
                // Delete test
                code += '    testDelete: async function() {\n';
                code += '        try {\n';
                code += '            if (!this._createdId) throw new Error("No id from create test");\n';
                code += '            \n';
                code += '            var result = await ' + appName + 'API.delete' + resource + '(this._createdId);\n';
                code += '            \n';
                code += '            this.assert(result.success, "Should return success");\n';
                code += '            \n';
                code += '            // Verify deleted\n';
                code += '            try {\n';
                code += '                await ' + appName + 'API.get' + resource + '(this._createdId);\n';
                code += '                this.log("FAIL", "Delete ' + resource + '", "Item still exists after delete");\n';
                code += '            } catch (e) {\n';
                code += '                this.log("PASS", "Delete ' + resource + '", "Deleted successfully");\n';
                code += '            }\n';
                code += '        } catch (e) {\n';
                code += '            this.log("FAIL", "Delete ' + resource + '", e.message);\n';
                code += '        }\n';
                code += '    },\n\n';
                
                // Summary
                code += '    getSummary: function() {\n';
                code += '        var passed = this.results.filter(function(r) { return r.status === "PASS"; }).length;\n';
                code += '        var failed = this.results.filter(function(r) { return r.status === "FAIL"; }).length;\n';
                code += '        return {\n';
                code += '            name: this.name,\n';
                code += '            version: this.version,\n';
                code += '            passed: passed,\n';
                code += '            failed: failed,\n';
                code += '            total: this.results.length,\n';
                code += '            results: this.results\n';
                code += '        };\n';
                code += '    }\n';
                code += '};\n';
                
                try {
                    await window.aider.writeFile(filePath, code);
                    this.addMessage('system', '   tests/' + fileName);
                } catch (e) {
                    console.log('[Execute] Save API tests error:', e);
                }
            },
            
            // Generate test data based on spec
            generateTestData(spec) {
                var data = {};
                if (spec.fields) {
                    for (var i = 0; i < spec.fields.length; i++) {
                        var f = spec.fields[i];
                        data[f.name] = this.getExampleValue(f.type, f.name);
                    }
                }
                return data;
            },
            
            // Capitalize first letter
            capitalize(str) {
                return str.charAt(0).toUpperCase() + str.slice(1);
            },
            
            // Generate test runner that runs all API tests
            async generateTestRunner(version, appName) {
                var filePath = this.repoPath + '/tests/test-runner.js';
                
                var code = '/**\n';
                code += ' * ' + appName + ' Test Runner\n';
                code += ' * Version: ' + version + '\n';
                code += ' * Generated by GSX Create Meta Learning\n';
                code += ' */\n\n';
                
                code += 'var TestRunner = {\n';
                code += '    version: ' + version + ',\n';
                code += '    results: [],\n\n';
                
                code += '    // Run all API tests\n';
                code += '    runAllApiTests: async function() {\n';
                code += '        console.log("\\n========================================");\n';
                code += '        console.log("  ' + appName + ' API Test Suite (v' + version + ')");\n';
                code += '        console.log("========================================\\n");\n';
                code += '        \n';
                code += '        this.results = [];\n';
                code += '        var testSuites = [\n';
                
                for (var i = 0; i < this.detectedApiEndpoints.length; i++) {
                    var spec = this.detectedApiEndpoints[i];
                    code += '            ' + spec.resourceName + 'Tests,\n';
                }
                
                code += '        ];\n';
                code += '        \n';
                code += '        for (var i = 0; i < testSuites.length; i++) {\n';
                code += '            try {\n';
                code += '                var result = await testSuites[i].runAll();\n';
                code += '                this.results.push(result);\n';
                code += '            } catch (e) {\n';
                code += '                console.error("Test suite error:", e);\n';
                code += '            }\n';
                code += '        }\n';
                code += '        \n';
                code += '        return this.getSummary();\n';
                code += '    },\n\n';
                
                code += '    // Get overall summary\n';
                code += '    getSummary: function() {\n';
                code += '        var totalPassed = 0;\n';
                code += '        var totalFailed = 0;\n';
                code += '        \n';
                code += '        for (var i = 0; i < this.results.length; i++) {\n';
                code += '            totalPassed += this.results[i].passed;\n';
                code += '            totalFailed += this.results[i].failed;\n';
                code += '        }\n';
                code += '        \n';
                code += '        console.log("\\n========================================");\n';
                code += '        console.log("  SUMMARY: " + totalPassed + " passed, " + totalFailed + " failed");\n';
                code += '        console.log("========================================\\n");\n';
                code += '        \n';
                code += '        return {\n';
                code += '            version: this.version,\n';
                code += '            passed: totalPassed,\n';
                code += '            failed: totalFailed,\n';
                code += '            total: totalPassed + totalFailed,\n';
                code += '            suites: this.results,\n';
                code += '            success: totalFailed === 0\n';
                code += '        };\n';
                code += '    }\n';
                code += '};\n';
                
                try {
                    await window.aider.writeFile(filePath, code);
                    this.addMessage('system', '   tests/test-runner.js');
                } catch (e) {
                    console.log('[Execute] Save test runner error:', e);
                }
            },
            
            // Update or create test plan document
            async updateTestPlan() {
                this.addMessage('system', ' Updating test plan...');
                
                var version = this.cycleState.currentVersion;
                var filePath = this.repoPath + '/TEST-PLAN.md';
                
                // Try to load existing test plan
                var existingPlan = null;
                try {
                    existingPlan = await window.aider.readFile(filePath);
                } catch (e) { /* doesn't exist */ }
                
                var doc = '# Test Plan\n\n';
                doc += '| Property | Value |\n';
                doc += '|----------|-------|\n';
                doc += '| App | ' + (this.currentSpaceName || 'App') + ' |\n';
                doc += '| Version | v' + version + ' |\n';
                doc += '| Last Updated | ' + new Date().toISOString().split('T')[0] + ' |\n\n';
                
                doc += '---\n\n';
                doc += '## Test Categories\n\n';
                
                // API Tests
                doc += '### 1. API Tests\n\n';
                doc += 'Automated tests for all API operations.\n\n';
                doc += '| Resource | Tests | Status | File |\n';
                doc += '|----------|-------|--------|------|\n';
                
                for (var i = 0; i < this.detectedApiEndpoints.length; i++) {
                    var spec = this.detectedApiEndpoints[i];
                    var testCount = 5; // CRUD + list
                    if (spec.operations) {
                        testCount = spec.operations.length;
                    }
                    doc += '| ' + spec.resourceName + ' | ' + testCount + ' |  Pending | `tests/' + spec.resourceName.toLowerCase() + '-api.test.js` |\n';
                }
                
                doc += '\n**Run:** `TestRunner.runAllApiTests()`\n\n';
                
                // UI Tests
                doc += '### 2. UI Tests\n\n';
                doc += 'Visual and interaction tests.\n\n';
                doc += '| Test | Description | Status |\n';
                doc += '|------|-------------|--------|\n';
                doc += '| Page Load | Page loads without errors |  Pending |\n';
                doc += '| Responsive | Works on mobile/tablet/desktop |  Pending |\n';
                doc += '| Accessibility | Meets WCAG guidelines |  Pending |\n';
                doc += '| Forms | All forms submit correctly |  Pending |\n';
                doc += '| Navigation | All links/buttons work |  Pending |\n\n';
                
                // Integration Tests
                doc += '### 3. Integration Tests\n\n';
                doc += 'End-to-end user flow tests.\n\n';
                doc += '| Flow | Steps | Status |\n';
                doc += '|------|-------|--------|\n';
                
                // Generate flows based on detected resources
                for (var i = 0; i < this.detectedApiEndpoints.length; i++) {
                    var spec = this.detectedApiEndpoints[i];
                    doc += '| Create ' + spec.resourceName + ' | Open form  Fill data  Submit  Verify |  Pending |\n';
                }
                
                doc += '\n';
                
                // Error Handling
                doc += '### 4. Error Handling Tests\n\n';
                doc += '| Scenario | Expected | Status |\n';
                doc += '|----------|----------|--------|\n';
                doc += '| Invalid input | Show validation error |  Pending |\n';
                doc += '| Network failure | Show retry option |  Pending |\n';
                doc += '| Not found | Show 404 message |  Pending |\n';
                doc += '| Server error | Show error + log |  Pending |\n\n';
                
                // Test History
                doc += '---\n\n';
                doc += '## Test History\n\n';
                doc += '| Version | Date | Passed | Failed | Notes |\n';
                doc += '|---------|------|--------|--------|-------|\n';
                doc += '| v' + version + ' | ' + new Date().toISOString().split('T')[0] + ' | - | - | Tests generated |\n';
                
                // Parse existing history if available
                if (existingPlan) {
                    var historyMatch = existingPlan.match(/## Test History[\s\S]*?\n\n([\s\S]*?)(?=\n---|\n##|$)/);
                    if (historyMatch) {
                        var lines = historyMatch[1].split('\n').filter(function(l) { 
                            return l.startsWith('|') && !l.includes('Version') && !l.includes('---'); 
                        });
                        for (var i = 0; i < lines.length; i++) {
                            if (lines[i].indexOf('v' + version) === -1) {
                                doc += lines[i] + '\n';
                            }
                        }
                    }
                }
                
                doc += '\n---\n\n';
                doc += '## Running Tests\n\n';
                doc += '### In Browser Console\n';
                doc += '```javascript\n';
                doc += '// Run all API tests\n';
                doc += 'TestRunner.runAllApiTests().then(console.log);\n';
                doc += '\n';
                doc += '// Run specific resource tests\n';
                for (var i = 0; i < this.detectedApiEndpoints.length; i++) {
                    var spec = this.detectedApiEndpoints[i];
                    doc += spec.resourceName + 'Tests.runAll().then(console.log);\n';
                }
                doc += '```\n\n';
                
                doc += '### In Meta Learning Cycle\n';
                doc += 'Tests run automatically during the **Test** phase.\n\n';
                
                doc += '---\n\n';
                doc += '*Generated by GSX Create Meta Learning*\n';
                
                try {
                    await window.aider.writeFile(filePath, doc);
                    this.addMessage('system', '   TEST-PLAN.md');
                } catch (e) {
                    console.log('[Execute] Save test plan error:', e);
                }
            },
            
            // Save individual API spec document
            async saveApiSpecDoc(spec) {
                var version = this.cycleState.currentVersion;
                var resourceName = spec.resourceName;
                var fileName = resourceName.toLowerCase() + '-api.md';
                var filePath = this.repoPath + '/' + this.apiDocsFolder + '/' + fileName;
                
                var doc = '# ' + resourceName + ' API\n\n';
                doc += '| Property | Value |\n';
                doc += '|----------|-------|\n';
                doc += '| App Version | v' + version + ' |\n';
                doc += '| Last Updated | ' + new Date().toISOString().split('T')[0] + ' |\n';
                doc += '| Status | Active |\n\n';
                
                doc += '---\n\n';
                doc += '## Overview\n\n';
                doc += spec.resourceDescription + '\n\n';
                
                // Data Model
                doc += '---\n\n';
                doc += '## Data Model\n\n';
                doc += '### ' + resourceName + '\n\n';
                doc += '| Field | Type | Required | Description |\n';
                doc += '|-------|------|----------|-------------|\n';
                doc += '| id | string | Yes | Unique identifier (auto-generated) |\n';
                
                if (spec.fields) {
                    for (var j = 0; j < spec.fields.length; j++) {
                        var f = spec.fields[j];
                        doc += '| ' + f.name + ' | ' + f.type + ' | ' + (f.required ? 'Yes' : 'No') + ' | ' + f.description + ' |\n';
                    }
                }
                
                doc += '| createdAt | datetime | Yes | Creation timestamp (auto-generated) |\n';
                doc += '| updatedAt | datetime | Yes | Last update timestamp (auto-generated) |\n\n';
                
                // Example JSON
                doc += '### Example\n\n';
                doc += '```json\n';
                var example = { id: 'abc123' };
                if (spec.fields) {
                    for (var j = 0; j < spec.fields.length; j++) {
                        var f = spec.fields[j];
                        example[f.name] = this.getExampleValue(f.type, f.name);
                    }
                }
                example.createdAt = '2024-01-15T10:30:00Z';
                example.updatedAt = '2024-01-15T10:30:00Z';
                doc += JSON.stringify(example, null, 2) + '\n';
                doc += '```\n\n';
                
                // Operations
                doc += '---\n\n';
                doc += '## Operations\n\n';
                
                if (spec.operations) {
                    for (var j = 0; j < spec.operations.length; j++) {
                        var op = spec.operations[j];
                        doc += '### ' + this.formatOperationName(op.name, op.type, resourceName) + '\n\n';
                        doc += '**Purpose:** ' + op.description + '\n\n';
                        doc += '**Type:** ' + op.type.toUpperCase() + '\n\n';
                        
                        if (op.inputFields && op.inputFields.length > 0) {
                            doc += '**Input Fields:** ' + op.inputFields.join(', ') + '\n\n';
                        }
                        
                        if (op.outputFields && op.outputFields.length > 0) {
                            doc += '**Output Fields:** ' + op.outputFields.join(', ') + '\n\n';
                        }
                        
                        // Standard behavior based on type
                        doc += '**Expected Behavior:**\n';
                        switch (op.type) {
                            case 'create':
                                doc += '- Validate all required fields\n';
                                doc += '- Generate unique id\n';
                                doc += '- Set createdAt and updatedAt timestamps\n';
                                doc += '- Return created object\n';
                                break;
                            case 'read':
                                doc += '- Accept id parameter\n';
                                doc += '- Return single object or 404 if not found\n';
                                break;
                            case 'update':
                                doc += '- Accept id and partial object\n';
                                doc += '- Update only provided fields\n';
                                doc += '- Update updatedAt timestamp\n';
                                doc += '- Return updated object or 404\n';
                                break;
                            case 'delete':
                                doc += '- Accept id parameter\n';
                                doc += '- Remove object from storage\n';
                                doc += '- Return success or 404\n';
                                break;
                            case 'list':
                                doc += '- Support pagination (limit, offset)\n';
                                doc += '- Support sorting (sortBy, order)\n';
                                doc += '- Return array with total count\n';
                                break;
                            case 'search':
                                doc += '- Accept search query parameters\n';
                                doc += '- Return matching objects with relevance\n';
                                break;
                            default:
                                doc += '- Implement custom logic as described\n';
                        }
                        doc += '\n';
                    }
                }
                
                // Business Rules
                if (spec.businessRules && spec.businessRules.length > 0) {
                    doc += '---\n\n';
                    doc += '## Business Rules\n\n';
                    for (var j = 0; j < spec.businessRules.length; j++) {
                        doc += (j + 1) + '. ' + spec.businessRules[j] + '\n';
                    }
                    doc += '\n';
                }
                
                // Related Resources
                if (spec.relatedResources && spec.relatedResources.length > 0) {
                    doc += '---\n\n';
                    doc += '## Related APIs\n\n';
                    for (var j = 0; j < spec.relatedResources.length; j++) {
                        var related = spec.relatedResources[j];
                        doc += '- [' + related + ' API](./' + related.toLowerCase() + '-api.md)\n';
                    }
                    doc += '\n';
                }
                
                // Footer
                doc += '---\n\n';
                doc += '*This specification is for GSX Studio API Builder Agent.*\n';
                doc += '*Do not include implementation code - focus on requirements.*\n\n';
                doc += '**Sync Check:** This document matches app version v' + version + '\n';
                
                try {
                    await window.aider.writeFile(filePath, doc);
                    this.addMessage('system', '   ' + fileName + ' (v' + version + ')');
                } catch (e) {
                    console.log('[Execute] Save API spec error:', e);
                }
            },
            
            // Format operation name for display
            formatOperationName(name, type, resource) {
                if (name) return name;
                switch (type) {
                    case 'create': return 'Create ' + resource;
                    case 'read': return 'Get ' + resource;
                    case 'update': return 'Update ' + resource;
                    case 'delete': return 'Delete ' + resource;
                    case 'list': return 'List ' + resource + 's';
                    case 'search': return 'Search ' + resource + 's';
                    default: return type + ' ' + resource;
                }
            },
            
            // Get example value for a field type
            getExampleValue(type, name) {
                switch (type.toLowerCase()) {
                    case 'string': 
                        if (name.toLowerCase().includes('email')) return 'user@example.com';
                        if (name.toLowerCase().includes('name')) return 'Example Name';
                        if (name.toLowerCase().includes('title')) return 'Example Title';
                        if (name.toLowerCase().includes('description')) return 'A brief description';
                        if (name.toLowerCase().includes('url')) return 'https://example.com';
                        return 'example string';
                    case 'number': return 42;
                    case 'boolean': return true;
                    case 'date': 
                    case 'datetime': return '2024-01-15T10:30:00Z';
                    case 'array': return [];
                    case 'object': return {};
                    default: return null;
                }
            },
            
            // Save API manifest (index of all APIs)
            async saveApiManifest() {
                var version = this.cycleState.currentVersion;
                var filePath = this.repoPath + '/' + this.apiDocsFolder + '/API-MANIFEST.md';
                
                var doc = '# API Manifest\n\n';
                doc += '| Property | Value |\n';
                doc += '|----------|-------|\n';
                doc += '| App | ' + (this.currentSpaceName || 'App') + ' |\n';
                doc += '| Version | v' + version + ' |\n';
                doc += '| Generated | ' + new Date().toISOString() + ' |\n';
                doc += '| Total APIs | ' + this.detectedApiEndpoints.length + ' |\n\n';
                
                doc += '---\n\n';
                doc += '## API Index\n\n';
                doc += '| Resource | Operations | Status | Doc |\n';
                doc += '|----------|------------|--------|-----|\n';
                
                for (var i = 0; i < this.detectedApiEndpoints.length; i++) {
                    var spec = this.detectedApiEndpoints[i];
                    var opCount = spec.operations ? spec.operations.length : 0;
                    var docLink = './' + spec.resourceName.toLowerCase() + '-api.md';
                    doc += '| ' + spec.resourceName + ' | ' + opCount + ' |  Synced | [View](' + docLink + ') |\n';
                }
                
                doc += '\n---\n\n';
                doc += '## Version History\n\n';
                doc += '| Version | Date | Changes |\n';
                doc += '|---------|------|----------|\n';
                doc += '| v' + version + ' | ' + new Date().toISOString().split('T')[0] + ' | Current version |\n';
                
                doc += '\n---\n\n';
                doc += '## Sync Status\n\n';
                doc += 'All API specifications are in sync with app version v' + version + '.\n\n';
                doc += 'To check for drift:\n';
                doc += '1. Run the Meta Learning Cycle\n';
                doc += '2. Compare manifest version with app version\n';
                doc += '3. Review any  warnings in the index\n';
                
                try {
                    await window.aider.writeFile(filePath, doc);
                    this.addMessage('system', '   API-MANIFEST.md (index)');
                } catch (e) {
                    console.log('[Execute] Save manifest error:', e);
                }
            },
            
            // Check if API docs are in sync with app version
            async checkApiSync() {
                var currentVersion = this.cycleState.currentVersion;
                var outOfSync = [];
                
                // Read existing API docs and check versions
                try {
                    var specsFolderPath = this.repoPath + '/' + this.apiDocsFolder;
                    var files = await window.aider.listFiles(specsFolderPath);
                    
                    if (files && files.length > 0) {
                        for (var i = 0; i < files.length; i++) {
                            var file = files[i];
                            if (file.endsWith('-api.md') && file !== 'API-MANIFEST.md') {
                                var content = await window.aider.readFile(specsFolderPath + '/' + file);
                                if (content) {
                                    // Check for version in content
                                    var versionMatch = content.match(/App Version \| v(\d+)/);
                                    if (versionMatch) {
                                        var docVersion = parseInt(versionMatch[1]);
                                        if (docVersion < currentVersion) {
                                            outOfSync.push({
                                                file: file,
                                                docVersion: docVersion,
                                                appVersion: currentVersion
                                            });
                                        }
                                    }
                                }
                            }
                        }
                    }
                } catch (e) {
                    console.log('[Execute] Sync check error:', e);
                }
                
                if (outOfSync.length > 0) {
                    this.addMessage('warning', ' API Docs Out of Sync:');
                    for (var i = 0; i < outOfSync.length; i++) {
                        var item = outOfSync[i];
                        this.addMessage('warning', '   ' + item.file + ' (v' + item.docVersion + '  v' + item.appVersion + ')');
                    }
                    this.addMessage('system', '   Run another cycle to update these docs');
                }
            },
            
            // Generate API stub client for frontend
            async generateApiStubClient() {
                if (this.detectedApiEndpoints.length === 0) return;
                
                var appName = (this.currentSpaceName || 'App').replace(/[^a-zA-Z0-9]/g, '');
                var version = this.cycleState.currentVersion;
                var fileName = appName.toLowerCase() + '-api.js';
                var filePath = this.repoPath + '/' + fileName;
                
                var code = '/**\n';
                code += ' * ' + appName + ' API Client\n';
                code += ' * Version: ' + version + '\n';
                code += ' * \n';
                code += ' * Stub implementation using localStorage.\n';
                code += ' * Replace baseUrl when backend API is ready.\n';
                code += ' * \n';
                code += ' * Generated by GSX Create Meta Learning\n';
                code += ' * Sync with: api-specs/API-MANIFEST.md\n';
                code += ' */\n\n';
                
                code += 'var ' + appName + 'API = {\n';
                code += '    version: ' + version + ',\n';
                code += '    baseUrl: null, // Set when backend ready\n';
                code += '    storagePrefix: "' + appName.toLowerCase() + '_",\n\n';
                
                code += '    // Check if using stub mode\n';
                code += '    isStubMode: function() { return !this.baseUrl; },\n\n';
                
                code += '    // Generate unique ID\n';
                code += '    generateId: function() {\n';
                code += '        return Date.now().toString(36) + Math.random().toString(36).substr(2);\n';
                code += '    },\n\n';
                
                code += '    // Storage helpers\n';
                code += '    getStorage: function(key) {\n';
                code += '        try {\n';
                code += '            var data = localStorage.getItem(this.storagePrefix + key);\n';
                code += '            return data ? JSON.parse(data) : null;\n';
                code += '        } catch(e) { return null; }\n';
                code += '    },\n\n';
                
                code += '    setStorage: function(key, value) {\n';
                code += '        try {\n';
                code += '            localStorage.setItem(this.storagePrefix + key, JSON.stringify(value));\n';
                code += '            return true;\n';
                code += '        } catch(e) { return false; }\n';
                code += '    },\n\n';
                
                // Generate CRUD methods for each resource
                for (var i = 0; i < this.detectedApiEndpoints.length; i++) {
                    var spec = this.detectedApiEndpoints[i];
                    var resource = spec.resourceName.toLowerCase();
                    var Resource = spec.resourceName;
                    
                    code += '    // === ' + Resource + ' Methods (see: api-specs/' + resource + '-api.md) ===\n\n';
                    
                    // List
                    code += '    list' + Resource + 's: function(options) {\n';
                    code += '        options = options || {};\n';
                    code += '        var items = this.getStorage("' + resource + 's") || [];\n';
                    code += '        var start = options.offset || 0;\n';
                    code += '        var end = start + (options.limit || items.length);\n';
                    code += '        return Promise.resolve({ items: items.slice(start, end), total: items.length });\n';
                    code += '    },\n\n';
                    
                    // Get
                    code += '    get' + Resource + ': function(id) {\n';
                    code += '        var items = this.getStorage("' + resource + 's") || [];\n';
                    code += '        var item = items.find(function(i) { return i.id === id; });\n';
                    code += '        if (!item) return Promise.reject(new Error("' + Resource + ' not found"));\n';
                    code += '        return Promise.resolve(item);\n';
                    code += '    },\n\n';
                    
                    // Create
                    code += '    create' + Resource + ': function(data) {\n';
                    code += '        var items = this.getStorage("' + resource + 's") || [];\n';
                    code += '        var newItem = Object.assign({}, data, {\n';
                    code += '            id: this.generateId(),\n';
                    code += '            createdAt: new Date().toISOString(),\n';
                    code += '            updatedAt: new Date().toISOString()\n';
                    code += '        });\n';
                    code += '        items.push(newItem);\n';
                    code += '        this.setStorage("' + resource + 's", items);\n';
                    code += '        return Promise.resolve(newItem);\n';
                    code += '    },\n\n';
                    
                    // Update
                    code += '    update' + Resource + ': function(id, data) {\n';
                    code += '        var items = this.getStorage("' + resource + 's") || [];\n';
                    code += '        var index = items.findIndex(function(i) { return i.id === id; });\n';
                    code += '        if (index === -1) return Promise.reject(new Error("' + Resource + ' not found"));\n';
                    code += '        items[index] = Object.assign({}, items[index], data, {\n';
                    code += '            updatedAt: new Date().toISOString()\n';
                    code += '        });\n';
                    code += '        this.setStorage("' + resource + 's", items);\n';
                    code += '        return Promise.resolve(items[index]);\n';
                    code += '    },\n\n';
                    
                    // Delete
                    code += '    delete' + Resource + ': function(id) {\n';
                    code += '        var items = this.getStorage("' + resource + 's") || [];\n';
                    code += '        var index = items.findIndex(function(i) { return i.id === id; });\n';
                    code += '        if (index === -1) return Promise.reject(new Error("' + Resource + ' not found"));\n';
                    code += '        items.splice(index, 1);\n';
                    code += '        this.setStorage("' + resource + 's", items);\n';
                    code += '        return Promise.resolve({ success: true });\n';
                    code += '    },\n\n';
                }
                
                code += '};\n';
                
                try {
                    await window.aider.writeFile(filePath, code);
                    this.addMessage('system', '   ' + fileName + ' (v' + version + ')');
                } catch (e) {
                    console.log('[Execute] Save API stub error:', e);
                }
            },
            
            // Execute a single task automatically (no UI interaction)
            async executeTask(prompt) {
                // Create streaming message for output
                const msgId = 'task-' + Date.now();
                this.addStreamingMessage(msgId);
                
                let response = '';
                try {
                    await window.aider.runPromptStreaming(prompt, (chunk) => {
                        response += chunk;
                        this.appendToStreamingMessage(msgId, chunk);
                    });
                    
                    this.finalizeStreamingMessage(msgId);
                    
                    // Track API cost for this task
                    await this.trackTaskCost(prompt, response, 'executeTask');
                    
                    // Refresh preview after changes
                    if (this.currentPreviewFile) {
                        setTimeout(() => this.refreshPreview(), 500);
                    }
                    
                    return response;
                } catch (e) {
                    this.finalizeStreamingMessage(msgId);
                    
                    // Handle rate limit errors gracefully
                    const errorMsg = e?.message || String(e);
                    if (errorMsg.includes('rate limit') || errorMsg.includes('Rate limit')) {
                        this.addMessage('warning', ' Rate limited - waiting 10 seconds...');
                        await new Promise(r => setTimeout(r, 10000));
                        // Retry once
                        return await this.executeTask(prompt);
                    }
                    
                    throw e;
                }
            },
            
            // Update the todo file with current status
            async updateTodoFile() {
                if (!this.repoPath || !this.cycleState.todos) return;
                
                const todos = this.cycleState.todos;
                const version = this.cycleState.currentVersion;
                const fileName = `TODO-v${version}.md`;
                
                let content = `# Todo List - v${version}\n`;
                content += `**Objective:** ${this.cycleState.objective}\n`;
                content += `**Updated:** ${new Date().toISOString()}\n\n`;
                content += `## Tasks\n\n`;
                
                todos.forEach((t, i) => {
                    const checkbox = t.status === 'completed' ? '[x]' : '[ ]';
                    content += `${i + 1}. ${checkbox} ${t.task}\n`;
                });
                
                const completed = todos.filter(t => t.status === 'completed').length;
                content += `\n**Progress:** ${completed}/${todos.length} completed\n`;
                content += '\n---\n*Updated by GSX Create Meta Learning*\n';
                
                try {
                    const updateTodoPrompt = `Update the file ${fileName} with this content:\n\n${content}`;
                    const updateResult = await window.aider.runPrompt(updateTodoPrompt);
                    await this.trackTaskCost(updateTodoPrompt, updateResult?.response || '', 'update_todo');
                } catch (e) {
                    console.log('[Cycle] Update todo file error:', e);
                }
            },
            
            // Test Phase - Run tests and evaluate
            async phaseTest() {
                // Check required files for this phase
                var filesReady = await this.checkPhaseRequiredFiles('test');
                if (!filesReady) {
                    await this.waitForFileApproval();
                }
                
                const testResults = {
                    total: 0,
                    passed: 0,
                    failed: 0,
                    score: 0,
                    consoleErrors: [],
                    failedTests: [],
                    apiTestResults: null,
                    aiAnalysis: ''
                };
                
                if (!this.currentPreviewFile) {
                    this.addMessage('system', ' No file selected for testing - skipping');
                    return testResults;
                }
                
                // Run basic tests
                this.addMessage('system', ' Running tests...');
                return testResults;
            },
            
            // Improve Phase - Apply improvements based on test results and feedback
            async phaseImprove() {
                
                this.addMessage('system', ' Improve phase - analyzing feedback and applying improvements...');
                
                try {
                    // Check if we have any pending fixes or improvements
                    if (this.fixQueue && this.fixQueue.length > 0) {
                        this.addMessage('system', `    ${this.fixQueue.length} improvements pending`);
                        
                        // Process first pending fix
                    const fix = this.fixQueue.shift();
                        if (fix && fix.description) {
                            this.addMessage('system', `    Applying: ${fix.description.substring(0, 50)}...`);
                            
                            try {
                                const result = await window.aider.runPrompt(fix.description);
                                const response = result?.response;
                                // Safe string handling - avoid .trim() on non-strings
                                const responseText = (response && typeof response === 'string') ? response.trim() : '';
                                if (responseText) {
                                    this.addMessage('system', `    Improvement applied`);
                                }
                    } catch (e) {
                                console.warn('[Cycle] Improvement failed:', e.message);
                                this.addMessage('system', `    Could not apply improvement: ${e.message}`);
                    }
                }
                    } else {
                        this.addMessage('system', '    No pending improvements');
                }
                
                    // Move to finalize phase
                await this.runPhase('finalize');
                    
                } catch (error) {
                    console.error('[Cycle] Improve phase error:', error);
                    this.addMessage('system', `    Improve phase error: ${error.message}`);
                }
            },
            
            // Finalize Phase - Update documentation and complete the cycle
            async phaseFinalize() {
                
                this.addMessage('system', ' Finalize phase - completing cycle...');
                
                try {
                    const version = this.cycleState.currentVersion || 1;
                    const score = this.cycleState.currentScore || 0;
                    const evaluation = this.cycleState.evaluation || null;
                    
                    // Calculate cost for this version
                    const costAtStart = this.cycleState.costAtCycleStart || 0;
                    const currentCost = this.costSummary.totalCost || 0;
                    const versionCost = currentCost - costAtStart;
                    
                    // Record version with cost
                    const entry = this.ensureVersionEntry(version);
                    entry.timestamp = entry.timestamp || new Date().toISOString();
                    entry.objective = this.cycleState.objective || entry.objective || null;
                    entry.costDelta = versionCost;
                    entry.testsSummary = entry.testsSummary || this.buildTestsSummaryFromEvaluation(evaluation);
                    entry.phaseSummary = entry.phaseSummary || 'Cycle finalized';

                    // Score delta relative to previous version (best-effort)
                    const prev = this.ensureVersionEntry(Math.max(version - 1, 1));
                    const prevScore = typeof prev.score === 'number' ? prev.score : null;
                    entry.score = score;
                    entry.scoreDelta = prevScore === null ? null : (score - prevScore);

                    // Keep legacy cost fields if present/used elsewhere
                    entry.cost = versionCost;
                    entry.costAtStart = costAtStart;
                    entry.costAtEnd = currentCost;

                    // Generate / refresh release notes based on accumulated facts
                    entry.releaseNotes = await this.generateReleaseNotesForVersion(entry);
                    this.saveCycleState();
                    
                    // === CREATE VERSION BACKUP ===
                    this.addMessage('system', `    Creating backup of v${version}...`);
                    const backupResult = await window.aider.backupVersion(this.repoPath, version, {
                        score: score,
                        objective: this.cycleState.objective,
                        model: this.selectedModel,
                        cost: versionCost
                    });
                    
                    if (backupResult.success) {
                        if (backupResult.alreadyExists) {
                            this.addMessage('system', `    Backup already exists for v${version}`);
                        } else {
                            this.addMessage('system', `    Backup created: ${backupResult.files?.length || 0} files saved`);
                        }
                        entry.backedUp = true;
                    } else {
                        this.addMessage('system', `    Backup failed: ${backupResult.error}`);
                    }
                    
                    // Update version documentation with safe string handling
                    await this.updateVersionDocumentation(version, score);
                    
                    // Finalize the cycle files
                    await this.finalizeCycle();
                    
                    this.addMessage('system', `    Cycle v${version} finalized (Score: ${score}%, Cost: $${versionCost.toFixed(4)})`);
                    
                    // Refresh backups list
                    await this.loadVersionBackups();
                    
                } catch (error) {
                    console.error('[Cycle] Finalize phase error:', error);
                    this.addMessage('system', `    Finalize error: ${error.message}`);
                }
            },
            
            // Generate README.md using AI
            async generateReadme() {
                if (!this.repoPath) return;
                
                try {
                    const readmePath = `${this.repoPath}/README.md`;
                    
                    // Get context from evaluated assets
                    const journeyContext = this.evaluatedJourneyMap?.content || '';
                    const styleContext = this.evaluatedStyleGuide?.content || '';
                    
                    const systemPrompt = `You are a technical writer. Generate a comprehensive README.md file for this project.`;
                    const userPrompt = `Generate a README.md with:
1. **Project Name & Description** - What this app does
2. **Features** - Key capabilities
3. **Getting Started** - How to run it
4. **How to Use** - User guide
5. **Technical Details** - Architecture notes
6. **Version History** - Current version: ${this.cycleState.currentVersion}

Context from Journey Map:
${journeyContext.substring(0, 1000)}

Context from Style Guide:
${styleContext.substring(0, 500)}

Make it professional but friendly.`;

                    const readme = await this.callEvaluationAPI(systemPrompt, userPrompt);
                    await window.aider.writeFile(readmePath, readme);
                    this.addMessage('system', `    README.md generated`);
                } catch (error) {
                    console.error('[Cycle] README generation error:', error);
                }
            },
            
            // Generate HELP.md for in-app help
            async generateHelpDocs() {
                if (!this.repoPath) return;
                
                try {
                    const helpPath = `${this.repoPath}/HELP.md`;
                    
                    const systemPrompt = `You are a UX writer. Generate helpful in-app documentation.`;
                    const userPrompt = `Generate a HELP.md with:
1. **Welcome** - Friendly introduction
2. **Quick Start** - Get started in 30 seconds
3. **Controls** - How to interact
4. **Tips & Tricks** - Power user features
5. **Troubleshooting** - Common issues
6. **Keyboard Shortcuts** - If applicable

Keep it concise and user-friendly. Use emojis sparingly.`;

                    const help = await this.callEvaluationAPI(systemPrompt, userPrompt);
                    await window.aider.writeFile(helpPath, help);
                    this.addMessage('system', `    HELP.md generated`);
                } catch (error) {
                    console.error('[Cycle] HELP generation error:', error);
                }
            },
            
            // Inject help button into generated HTML
            async injectHelpButton() {
                if (!this.repoPath || !this.currentPreviewFile) return;
                
                try {
                    const filePath = this.currentPreviewFile;
                    let content = await window.aider.readFile(filePath);
                    
                    if (!content || content.includes('gsx-help-btn')) return; // Already has help
                    
                    // Help button and modal HTML/CSS
                    // NOTE: Script tags are split to prevent HTML parser from breaking
                    const helpCode = `
<!-- GSX Help Button -->
<style>
.gsx-help-btn { position: fixed; bottom: 20px; right: 20px; width: 50px; height: 50px; border-radius: 50%; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; font-size: 24px; cursor: pointer; box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4); z-index: 9999; transition: transform 0.2s; }
.gsx-help-btn:hover { transform: scale(1.1); }
.gsx-help-modal { display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); z-index: 10000; justify-content: center; align-items: center; }
.gsx-help-modal.active { display: flex; }
.gsx-help-content { background: white; border-radius: 12px; max-width: 600px; max-height: 80vh; overflow-y: auto; padding: 30px; margin: 20px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); }
.gsx-help-close { position: absolute; top: 10px; right: 15px; font-size: 28px; cursor: pointer; color: #666; }
</style>
<button class="gsx-help-btn" onclick="document.getElementById('gsxHelpModal').classList.add('active')" title="Help">?</button>
<div id="gsxHelpModal" class="gsx-help-modal" onclick="if(event.target===this)this.classList.remove('active')">
  <div class="gsx-help-content">
    <span class="gsx-help-close" onclick="document.getElementById('gsxHelpModal').classList.remove('active')">&times;</span>
    <div id="gsxHelpText">Loading help...</div>
  </div>
</div>
` + '<scr' + 'ipt>' + `
(function(){
  fetch('HELP.md').then(r=>r.text()).then(md=>{
    document.getElementById('gsxHelpText').innerHTML = md.replace(/^### (.*$)/gm,'<h3>$1</h3>').replace(/^## (.*$)/gm,'<h2>$1</h2>').replace(/^# (.*$)/gm,'<h1>$1</h1>').replace(/\\*\\*(.*?)\\*\\*/g,'<strong>$1</strong>').replace(/\\n/g,'<br>');
  }).catch(()=>{document.getElementById('gsxHelpText').innerHTML='<p>Help not available.</p>';});
})();
` + '</scr' + 'ipt>';
                    
                    // Inject before closing body tag
                    if (content.includes('</body>')) {
                        content = content.replace('</body>', helpCode + '\n</body>');
                    } else {
                        content += helpCode;
                    }
                    
                    await window.aider.writeFile(filePath, content);
                    this.addMessage('system', `    Help button added`);
                } catch (error) {
                    console.error('[Cycle] Help button injection error:', error);
                }
            },
            
            // Inject test harness for external browser testing
            async injectTestHarness() {
                if (!this.repoPath || !this.currentPreviewFile) return;
                
                try {
                    const filePath = this.currentPreviewFile;
                    let content = await window.aider.readFile(filePath);
                    
                    if (!content || content.includes('gsx-test-harness')) return; // Already has harness
                    
                    // NOTE: Script tags are split to prevent HTML parser from breaking
                    const testHarnessCode = `
<!-- GSX Test Harness -->
` + '<scr' + 'ipt id="gsx-test-harness">' + `
(function(){
  var params = new URLSearchParams(window.location.search);
  var testMode = params.get('gsx-test') === '1' || params.get('testMode') === 'true' || params.get('dev') === '1';
  if (!testMode) return;
  
  var refreshInterval = parseInt(params.get('refresh')) || 5000;
  var paused = false;
  var countdown = refreshInterval / 1000;
  var lastRefresh = new Date().toLocaleTimeString();
  
  // Create overlay
  var overlay = document.createElement('div');
  overlay.id = 'gsx-test-overlay';
  overlay.innerHTML = '<div style="position:fixed;top:10px;right:10px;background:rgba(0,0,0,0.85);color:#0f0;font-family:monospace;padding:12px 16px;border-radius:8px;z-index:99999;font-size:12px;min-width:180px;box-shadow:0 4px 20px rgba(0,0,0,0.4);">' +
    '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;"><span style="color:#0f0;font-weight:bold;"> TEST MODE</span><span id="gsx-minimize" style="cursor:pointer;opacity:0.7;">_</span></div>' +
    '<div id="gsx-test-status">Auto-refresh: ON</div>' +
    '<div id="gsx-test-countdown">Next: <span id="gsx-cd">' + countdown + '</span>s</div>' +
    '<div style="margin-top:6px;opacity:0.7;">File: ' + location.pathname.split("/").pop() + '</div>' +
    '<div id="gsx-last-refresh" style="opacity:0.7;">Last: ' + lastRefresh + '</div>' +
    '<div style="margin-top:8px;display:flex;gap:6px;">' +
    '<button id="gsx-pause" style="flex:1;padding:4px;background:#333;color:#0f0;border:1px solid #0f0;border-radius:4px;cursor:pointer;"> Pause</button>' +
    '<button id="gsx-refresh-now" style="flex:1;padding:4px;background:#333;color:#0f0;border:1px solid #0f0;border-radius:4px;cursor:pointer;"> Now</button>' +
    '</div></div>';
  document.body.appendChild(overlay);
  
  document.getElementById('gsx-pause').onclick = function() {
    paused = !paused;
    this.textContent = paused ? ' Resume' : ' Pause';
    document.getElementById('gsx-test-status').textContent = 'Auto-refresh: ' + (paused ? 'PAUSED' : 'ON');
  };
  document.getElementById('gsx-refresh-now').onclick = function() { location.reload(); };
  document.getElementById('gsx-minimize').onclick = function() {
    var content = overlay.querySelector('div');
    content.style.display = content.style.display === 'none' ? 'block' : 'none';
  };
  
  setInterval(function() {
    if (paused) return;
    countdown--;
    document.getElementById('gsx-cd').textContent = countdown;
    if (countdown <= 0) {
      location.reload();
    }
  }, 1000);
})();
` + '</scr' + 'ipt>';
                    
                    // Inject before closing body tag
                    if (content.includes('</body>')) {
                        content = content.replace('</body>', testHarnessCode + '\n</body>');
                    } else {
                        content += testHarnessCode;
                    }
                    
                    await window.aider.writeFile(filePath, content);
                    this.addMessage('system', `    Test harness injected (use ?gsx-test=1 in browser)`);
                } catch (error) {
                    console.error('[Cycle] Test harness injection error:', error);
                }
            },
            
            // Generate criteria from evaluated assets
            async generateCriteriaFromAssets() {
                if (!this.evaluatedJourneyMap && !this.evaluatedStyleGuide) {
                    return null;
                }
                
                try {
                    const journeyContent = this.evaluatedJourneyMap?.content || '';
                    const styleContent = this.evaluatedStyleGuide?.content || '';
                    
                    const systemPrompt = `You are a QA expert. Generate specific, measurable evaluation criteria.`;
                    const userPrompt = `Based on these assets, generate 5-8 specific evaluation criteria:

Journey Map:
${journeyContent.substring(0, 1500)}

Style Guide:
${styleContent.substring(0, 1000)}

Format each criterion as:
- [Category] Criterion description

Categories: UX, Visual, Functionality, Accessibility, Performance`;

                    const response = await this.callEvaluationAPI(systemPrompt, userPrompt);
                    
                    // Parse response into criteria array
                    const lines = response.split('\n').filter(l => l.trim().startsWith('-'));
                    const criteria = lines.map(l => l.replace(/^-\s*/, '').trim());
                    
                    // Create evaluation-criteria.md
                    if (this.repoPath && criteria.length > 0) {
                        const content = `# Evaluation Criteria\n\n${criteria.map(c => `- ${c}`).join('\n')}\n\n---\n*Auto-generated from Journey Map and Style Guide*\n`;
                        await window.aider.writeFile(`${this.repoPath}/evaluation-criteria.md`, content);
                        this.addMessage('system', `    Generated ${criteria.length} evaluation criteria`);
                    }
                    
                    return criteria;
                } catch (error) {
                    console.error('[Cycle] Criteria generation error:', error);
                    return null;
                }
            },
            
            // Extract objective from Journey Map
            async extractObjectiveFromJourneyMap(journeyMapContent) {
                
                // Use passed content or fall back to evaluatedJourneyMap
                const content = journeyMapContent || this.evaluatedJourneyMap?.content;
                if (!content) return null;
                
                try {
                    const systemPrompt = `You are a product manager. Extract the main objective.`;
                    const userPrompt = `From this Journey Map, extract the main user objective or goal in 1-2 sentences:

${typeof content === 'string' ? content.substring(0, 2000) : JSON.stringify(content).substring(0, 2000)}

Respond with ONLY the objective, no other text.`;

                    const objective = await this.callEvaluationAPI(systemPrompt, userPrompt);
                    
                    
                    return typeof objective === 'string' ? objective.trim() : null;
                } catch (error) {
                    console.error('[Cycle] Objective extraction error:', error);
                    return null;
                }
            },
            
            // Update version documentation with safe response handling
            async updateVersionDocumentation(version, score) {
                
                if (!this.repoPath) {
                    console.log('[Cycle] No repo path set, skipping version documentation');
                    return;
                }
                
                const date = new Date().toLocaleDateString();
                
                try {
                    // Try to update or create a VERSION.md file
                    const versionPath = `${this.repoPath}/VERSION.md`;
                    let versionContent = '';
                    
                    try {
                        const existingContent = await window.aider.readFile(versionPath);
                        // Safe string handling - ensure we have a string before calling trim()
                        versionContent = (existingContent && typeof existingContent === 'string') 
                            ? existingContent.trim() 
                            : '';
                } catch (e) {
                        // File doesn't exist, that's OK
                    }
                    
                    // Create or update version info
                    const versionInfo = `# Version ${version}\n\n**Score:** ${score}%\n**Updated:** ${date}\n\n---\n`;
                    
                    if (versionContent) {
                        // Prepend new version info
                        versionContent = versionInfo + '\n' + versionContent;
            } else {
                        versionContent = versionInfo;
                    }
                    
                    await window.aider.writeFile(versionPath, versionContent);
                    this.addMessage('system', `    VERSION.md updated`);
                    
                    // Generate additional documentation
                    await this.generateReadme();
                    await this.generateHelpDocs();
                    await this.injectHelpButton();
                    await this.injectTestHarness();
                    
                    
                } catch (error) {
                    console.error('[Cycle] Version documentation error:', error);
                    this.addMessage('system', `    Could not update version documentation`);
                    
                }
            }
        };
        
        // Initialize on load - handle case where DOMContentLoaded already fired
        
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                GSXCreate.init();
            });
        } else {
            // DOM already loaded, call init immediately
            GSXCreate.init();
        }
        
        // ========== BEFOREUNLOAD FALLBACK ==========
        // Save state when window is about to close
        window.addEventListener('beforeunload', (event) => {
            console.log('[GSX Create] beforeunload triggered - saving state');
            
            // Save all state synchronously
            try {
                GSXCreate.saveAllStateForShutdown();
            } catch (error) {
                console.error('[GSX Create] Error in beforeunload save:', error);
            }
            
            // Don't block the close - just let it happen after saving
            // The state is saved, so no data is lost
        });
    </script>
    
    <!-- Floating Voice Panel (doesn't block app view) -->
    <div class="voice-panel" id="voicePanel">
        <div class="voice-panel-header">
            <div class="voice-panel-title">
                <span></span>
                <span>Voice Mode</span>
            </div>
            <button class="voice-panel-close" onclick="GSXCreate.exitVoiceMode()" title="Close (Escape)"></button>
        </div>
        <div class="voice-panel-body">
            <canvas class="voice-orb-small" id="voiceOrb" width="80" height="80"></canvas>
            <div class="voice-status" id="voiceStatus">Click to start speaking</div>
            <div class="voice-transcript" id="voiceTranscript"></div>
            <div class="voice-prompt-preview" id="voicePromptPreview"></div>
            <div class="voice-hints">
                <kbd>go</kbd> execute  <kbd>change</kbd> refine  <kbd>Esc</kbd> close
            </div>
        </div>
    </div>
    
    <!-- Evaluation HUD Components -->
    <script src="js/evaluation-hud.js"></script>
    <script src="js/outcome-feedback-ui.js"></script>
    <script>
        // Initialize Evaluation HUD and Outcome Feedback UI
        (function() {
            'use strict';
            
            // Wait for GSXCreate to be available
            const initEvalComponents = () => {
                if (typeof EvaluationHUD === 'undefined' || typeof OutcomeFeedbackUI === 'undefined') {
                    console.log('[Eval HUD] Components not loaded, skipping initialization');
                    return;
                }
                
                // Create Evaluation HUD instance
                window.evalHUD = new EvaluationHUD({
                    position: { bottom: 20, right: 340 }
                });
                
                // Create Outcome Feedback UI instance
                window.outcomeFeedback = new OutcomeFeedbackUI({
                    onSubmit: async (outcome) => {
                        console.log('[Outcome Feedback] Submitting:', outcome);
                        try {
                            if (window.electronAPI?.invoke) {
                                await window.electronAPI.invoke('meta:record-outcome', outcome);
                            }
                        } catch (error) {
                            console.error('[Outcome Feedback] Failed to record:', error);
                        }
                    }
                });
                
                // Listen for evaluation results
                document.addEventListener('eval:display', (e) => {
                    if (e.detail && window.evalHUD) {
                        window.evalHUD.displayEvaluation(e.detail);
                    }
                });
                
                // Listen for apply suggestion events
                document.addEventListener('eval:apply-suggestion', async (e) => {
                    const suggestion = e.detail?.suggestion;
                    if (suggestion && typeof GSXCreate !== 'undefined' && GSXCreate.addTask) {
                        await GSXCreate.addTask({
                            type: 'improvement',
                            description: suggestion,
                            source: 'evaluation',
                            priority: 4
                        });
                        console.log('[Eval HUD] Suggestion added to task queue:', suggestion);
                    }
                });
                
                // Listen for weighting mode changes
                document.addEventListener('eval:weighting-change', (e) => {
                    console.log('[Eval HUD] Weighting mode changed to:', e.detail?.mode);
                });

                // Listen for run evaluation requests from HUD
                document.addEventListener('eval:run', async (e) => {
                    const weightingMode = e.detail?.weightingMode || 
                                          window.evalHUD?.getWeightingMode?.() || 
                                          'contextual';
                    
                    // Get current preview file content if available
                    if (typeof GSXCreate !== 'undefined' && GSXCreate.currentPreviewFile) {
                        try {
                            const content = await window.electronAPI.invoke('read-file', GSXCreate.currentPreviewFile);
                            if (content) {
                                await GSXCreate.runEvaluation(content, {
                                    filePath: GSXCreate.currentPreviewFile,
                                    weightingMode
                                });
                            }
                        } catch (error) {
                            console.error('[Eval] Failed to read file for evaluation:', error);
                        }
                    }
                });

                // Listen for view dashboard requests
                document.addEventListener('eval:view-dashboard', () => {
                    console.log('[Eval HUD] View dashboard requested');
                    // Could open a separate dashboard window or modal in the future
                    if (typeof GSXCreate !== 'undefined' && GSXCreate.addMessage) {
                        GSXCreate.addMessage('system', 'Learning dashboard coming soon!');
                    }
                });

                // Add method to GSXCreate for triggering evaluations
                if (typeof GSXCreate !== 'undefined') {
                    GSXCreate.runEvaluation = async function(content, options = {}) {
                        try {
                            if (!window.electronAPI?.invoke) {
                                console.warn('[Eval] electronAPI not available');
                                return;
                            }

                            // Get weighting mode from HUD if not specified
                            const weightingMode = options.weightingMode || 
                                                  window.evalHUD?.getWeightingMode?.() || 
                                                  localStorage.getItem('eval.weightingMode') ||
                                                  'contextual';

                            // Show loading state in HUD
                            if (window.evalHUD) {
                                window.evalHUD.displayLoading({ agentCount: 'multiple' });
                            }
                            
                            // Generate agents
                            const agentConfigs = await window.electronAPI.invoke('eval:generate-agents', {
                                content,
                                filePath: options.filePath || 'unknown',
                                userOverrideTypes: options.documentTypes,
                                weightingMode
                            });
                            
                            if (agentConfigs.error) {
                                console.error('[Eval] Error generating agents:', agentConfigs.error);
                                if (window.evalHUD) {
                                    window.evalHUD.displayError({ message: agentConfigs.error });
                                }
                                return;
                            }
                            
                            // Run evaluations
                            const evaluations = await window.electronAPI.invoke('eval:run-evaluation', {
                                agentConfigs,
                                content,
                                context: { weightingMode, ...options.context }
                            });
                            
                            if (evaluations.error) {
                                console.error('[Eval] Error running evaluations:', evaluations.error);
                                if (window.evalHUD) {
                                    window.evalHUD.displayError({ message: evaluations.error });
                                }
                                return;
                            }
                            
                            // Get consolidated result with weighting mode
                            const consolidated = await window.electronAPI.invoke('eval:get-consolidated', {
                                evaluations,
                                weightingStrategy: weightingMode,
                                context: { weightingMode }
                            });
                            
                            if (consolidated.error) {
                                console.error('[Eval] Error consolidating:', consolidated.error);
                                if (window.evalHUD) {
                                    window.evalHUD.displayError({ message: consolidated.error });
                                }
                                return;
                            }
                            
                            // Display in HUD
                            document.dispatchEvent(new CustomEvent('eval:display', { detail: consolidated }));
                            
                            return consolidated;
                        } catch (error) {
                            console.error('[Eval] Evaluation failed:', error);
                            if (window.evalHUD) {
                                window.evalHUD.displayError({ message: error.message });
                            }
                        }
                    };
                    
                    GSXCreate.showOutcomeFeedback = function(evaluation) {
                        if (window.outcomeFeedback) {
                            window.outcomeFeedback.show(evaluation);
                        }
                    };
                    
                    GSXCreate.toggleEvalHUD = function() {
                        if (window.evalHUD) {
                            if (window.evalHUD.isVisible) {
                                window.evalHUD.hide();
                            } else {
                                window.evalHUD.show();
                            }
                        }
                    };
                }
                
                console.log('[Eval HUD] Evaluation components initialized - HUD v' + (window.evalHUD?.version || 'unknown') + ', Feedback v' + (window.outcomeFeedback?.version || 'unknown'));
            };
            
            // Initialize when DOM is ready
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initEvalComponents);
            } else {
                setTimeout(initEvalComponents, 100);
            }
        })();
    </script>
</body>
</html>
