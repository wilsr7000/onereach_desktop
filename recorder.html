<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta
      http-equiv="Content-Security-Policy"
      content="default-src 'self'; script-src 'self' 'unsafe-inline' 'wasm-unsafe-eval'; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com; media-src 'self' blob: mediastream:; img-src 'self' blob: data:; connect-src 'self' blob: https://*.onereach.ai wss://*.onereach.ai https://*.livekit.cloud wss://*.livekit.cloud; worker-src 'self' blob:;"
    />
    <title>WISER Meeting</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --bg-base: #08080e;
        --bg-surface: #101018;
        --bg-panel: #161622;
        --bg-elevated: #1e1e30;
        --bg-hover: #282842;
        --bg-active: #2e2e50;
        --accent-red: #ff3b4e;
        --accent-red-dim: #cc2f3e;
        --accent-red-glow: rgba(255, 59, 78, 0.35);
        --accent-blue: #4d7cff;
        --accent-blue-dim: rgba(77, 124, 255, 0.15);
        --accent-green: #00d68f;
        --accent-green-dim: rgba(0, 214, 143, 0.15);
        --accent-purple: #8b5cf6;
        --text-primary: #e8e8f0;
        --text-secondary: #8585a0;
        --text-muted: #4e4e68;
        --border-color: rgba(255, 255, 255, 0.06);
        --border-light: rgba(255, 255, 255, 0.1);
        --border-focus: rgba(77, 124, 255, 0.5);
        --glass-bg: rgba(16, 16, 26, 0.75);
        --glass-border: rgba(255, 255, 255, 0.08);
        --glass-blur: 20px;
        --radius-sm: 8px;
        --radius-md: 12px;
        --radius-lg: 16px;
        --radius-xl: 20px;
        --transition-fast: 0.15s cubic-bezier(0.4, 0, 0.2, 1);
        --transition-smooth: 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        --transition-spring: 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family:
          'Inter',
          -apple-system,
          BlinkMacSystemFont,
          sans-serif;
        background: var(--bg-base);
        color: var(--text-primary);
        height: 100vh;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        user-select: none;
      }

      /* Scrollbar */
      ::-webkit-scrollbar {
        width: 6px;
      }
      ::-webkit-scrollbar-track {
        background: transparent;
      }
      ::-webkit-scrollbar-thumb {
        background: var(--text-muted);
        border-radius: 3px;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: var(--text-secondary);
      }

      /* ============================================
       HEADER
       ============================================ */
      .header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0 16px 0 80px; /* 80px left padding clears macOS traffic light buttons */
        height: 44px;
        background: linear-gradient(180deg, rgba(20, 20, 35, 0.9) 0%, rgba(10, 10, 18, 0.95) 100%);
        border-bottom: 1px solid var(--border-color);
        -webkit-app-region: drag;
        flex-shrink: 0;
        position: relative;
        z-index: 10;
      }

      .header-title {
        font-size: 13px;
        font-weight: 600;
        color: var(--text-primary);
        display: flex;
        align-items: center;
        gap: 8px;
        letter-spacing: 0.3px;
      }

      .header-title .title-icon {
        width: 18px;
        height: 18px;
        color: var(--accent-red);
        flex-shrink: 0;
      }

      .header-actions {
        display: flex;
        gap: 2px;
        -webkit-app-region: no-drag;
      }

      .header-btn {
        background: transparent;
        border: none;
        color: var(--text-muted);
        cursor: pointer;
        padding: 6px 8px;
        border-radius: var(--radius-sm);
        transition: all var(--transition-fast);
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .header-btn:hover {
        background: var(--bg-hover);
        color: var(--text-primary);
      }

      .header-btn:active {
        transform: scale(0.95);
      }

      .header-btn.close-btn:hover {
        background: var(--accent-red);
        color: white;
      }

      /* ============================================
       MAIN LAYOUT
       ============================================ */
      .main-layout {
        flex: 1;
        display: flex;
        flex-direction: column;
        min-height: 0;
        position: relative;
      }

      /* ============================================
       PREVIEW AREA
       ============================================ */
      .preview-wrapper {
        flex: 1;
        position: relative;
        min-height: 0;
        display: flex;
        align-items: stretch;
      }

      .preview-container {
        flex: 1;
        background: #000;
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
        transition: box-shadow var(--transition-smooth);
      }

      .preview-container.recording-active {
        box-shadow:
          inset 0 0 80px var(--accent-red-glow),
          inset 0 0 2px var(--accent-red);
      }

      .preview-container video {
        width: 100%;
        height: 100%;
        object-fit: contain;
        background: #000;
      }

      /* PiP Camera Overlay */
      .pip-camera {
        position: absolute;
        bottom: 80px;
        right: 20px;
        width: 200px;
        height: 150px;
        border-radius: var(--radius-md);
        overflow: hidden;
        border: 2px solid rgba(255, 255, 255, 0.2);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        z-index: 10;
        display: none;
        cursor: move;
        transition: border-color var(--transition-fast);
      }

      .pip-camera.active {
        display: block;
      }
      .pip-camera:hover {
        border-color: rgba(255, 255, 255, 0.4);
      }

      .pip-camera video {
        width: 100%;
        height: 100%;
        object-fit: cover;
        transform: scaleX(-1);
      }

      .pip-camera .pip-label {
        position: absolute;
        top: 6px;
        left: 6px;
        background: rgba(0, 0, 0, 0.6);
        backdrop-filter: blur(8px);
        padding: 3px 8px;
        border-radius: 4px;
        font-size: 10px;
        color: white;
        font-weight: 500;
      }

      #combinedCanvas {
        display: none;
      }

      /* Preview Placeholder */
      .preview-placeholder {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 16px;
        color: var(--text-muted);
        position: absolute;
        inset: 0;
        justify-content: center;
        z-index: 2;
      }

      .placeholder-icon {
        width: 72px;
        height: 72px;
        border-radius: 50%;
        background: var(--bg-elevated);
        display: flex;
        align-items: center;
        justify-content: center;
        border: 1px solid var(--border-color);
      }

      .placeholder-icon svg {
        width: 32px;
        height: 32px;
        opacity: 0.4;
      }

      .preview-placeholder span {
        font-size: 14px;
        font-weight: 400;
        letter-spacing: 0.2px;
      }

      .preview-placeholder .shortcut-hint {
        font-size: 11px;
        color: var(--text-muted);
        margin-top: -8px;
      }

      .shortcut-hint kbd {
        display: inline-block;
        background: var(--bg-elevated);
        border: 1px solid var(--border-light);
        border-radius: 4px;
        padding: 1px 6px;
        font-family: inherit;
        font-size: 10px;
        font-weight: 500;
        color: var(--text-secondary);
      }

      /* Recording Indicator */
      .recording-indicator {
        position: absolute;
        top: 16px;
        left: 16px;
        display: flex;
        align-items: center;
        gap: 8px;
        background: rgba(10, 10, 18, 0.55);
        backdrop-filter: blur(24px) saturate(1.3);
        -webkit-backdrop-filter: blur(24px) saturate(1.3);
        padding: 8px 14px;
        border-radius: 20px;
        font-size: 11px;
        font-weight: 600;
        letter-spacing: 1.5px;
        text-transform: uppercase;
        opacity: 0;
        transform: translateY(-8px);
        transition: all var(--transition-smooth);
        z-index: 20;
        border: 1px solid rgba(255, 59, 78, 0.3);
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
      }

      .recording-indicator.active {
        opacity: 1;
        transform: translateY(0);
      }

      .recording-dot {
        width: 8px;
        height: 8px;
        background: var(--accent-red);
        border-radius: 50%;
        animation: rec-pulse 1.2s ease-in-out infinite;
        box-shadow: 0 0 8px var(--accent-red-glow);
      }

      @keyframes rec-pulse {
        0%,
        100% {
          opacity: 1;
          transform: scale(1);
        }
        50% {
          opacity: 0.4;
          transform: scale(0.85);
        }
      }

      /* Duration Display */
      .duration-display {
        position: absolute;
        top: 16px;
        right: 16px;
        background: rgba(10, 10, 18, 0.55);
        backdrop-filter: blur(24px) saturate(1.3);
        -webkit-backdrop-filter: blur(24px) saturate(1.3);
        padding: 8px 16px;
        border-radius: 20px;
        font-family: 'Inter', monospace;
        font-size: 16px;
        font-weight: 600;
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(255, 255, 255, 0.08);
        font-variant-numeric: tabular-nums;
        z-index: 20;
        border: 1px solid var(--border-color);
        opacity: 0;
        transform: translateY(-8px);
        transition: all var(--transition-smooth);
      }

      .duration-display.visible {
        opacity: 1;
        transform: translateY(0);
      }

      .duration-display .target {
        color: var(--text-muted);
        font-size: 11px;
        margin-left: 8px;
        font-weight: 400;
      }

      /* Countdown Overlay */
      .countdown-overlay {
        position: absolute;
        inset: 0;
        background: rgba(0, 0, 0, 0.7);
        backdrop-filter: blur(8px);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 50;
        opacity: 0;
        visibility: hidden;
        transition: all 0.2s;
      }

      .countdown-overlay.active {
        opacity: 1;
        visibility: visible;
      }

      .countdown-number {
        font-size: 120px;
        font-weight: 700;
        color: white;
        text-shadow: 0 0 60px var(--accent-red-glow);
        animation: countdown-pop 0.8s ease-out;
        line-height: 1;
      }

      @keyframes countdown-pop {
        0% {
          transform: scale(2);
          opacity: 0;
        }
        30% {
          transform: scale(0.9);
          opacity: 1;
        }
        50% {
          transform: scale(1.05);
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }

      /* Permission Overlay */
      .permission-overlay {
        position: absolute;
        inset: 0;
        background: rgba(0, 0, 0, 0.85);
        backdrop-filter: blur(12px);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 16px;
        z-index: 30;
      }

      .permission-overlay.hidden {
        display: none;
      }

      .permission-overlay svg {
        width: 48px;
        height: 48px;
        color: var(--text-muted);
      }

      .permission-overlay p {
        font-size: 14px;
        color: var(--text-secondary);
      }

      .permission-btn {
        padding: 12px 28px;
        background: var(--accent-blue);
        color: white;
        border: none;
        border-radius: var(--radius-sm);
        font-size: 13px;
        font-weight: 600;
        cursor: pointer;
        transition: all var(--transition-fast);
      }

      .permission-btn:hover {
        filter: brightness(1.15);
        transform: translateY(-1px);
      }

      .permission-btn:active {
        transform: translateY(0);
      }

      /* Audio Level Meter */
      .audio-meter {
        position: absolute;
        bottom: 16px;
        left: 16px;
        display: flex;
        align-items: flex-end;
        gap: 2px;
        height: 32px;
        z-index: 20;
        opacity: 0;
        transition: opacity var(--transition-smooth);
      }

      .audio-meter.visible {
        opacity: 1;
      }

      .audio-meter-bar {
        width: 3px;
        background: var(--accent-green);
        border-radius: 2px;
        transition: height 0.05s ease-out;
        min-height: 3px;
      }

      .audio-meter-bar.peak {
        background: var(--accent-red);
      }

      /* ============================================
       BOTTOM PANEL
       ============================================ */
      .bottom-panel {
        flex-shrink: 0;
        background: linear-gradient(180deg, var(--bg-surface) 0%, var(--bg-base) 100%);
        border-top: 1px solid var(--border-color);
        display: flex;
        flex-direction: column;
      }

      /* Mode Tabs */
      .mode-tabs {
        display: flex;
        gap: 2px;
        padding: 10px 16px 0;
        border-bottom: 1px solid var(--border-color);
      }

      .mode-tab {
        flex: 1;
        padding: 10px 12px;
        background: transparent;
        border: none;
        border-bottom: 2px solid transparent;
        color: var(--text-muted);
        font-size: 12px;
        font-weight: 500;
        cursor: pointer;
        transition: all var(--transition-fast);
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 6px;
        white-space: nowrap;
      }

      .mode-tab svg {
        width: 15px;
        height: 15px;
        flex-shrink: 0;
      }

      .mode-tab:hover {
        color: var(--text-secondary);
        background: var(--bg-elevated);
      }

      .mode-tab.active {
        color: var(--text-primary);
        border-bottom-color: var(--accent-blue);
      }

      /* Space Selector Bar */
      .space-selector-bar {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 10px 16px;
        background: var(--bg-panel);
        border-bottom: 1px solid var(--border-color);
      }

      .space-selector-label {
        font-size: 11px;
        font-weight: 600;
        color: var(--text-muted);
        text-transform: uppercase;
        letter-spacing: 0.5px;
        white-space: nowrap;
        display: flex;
        align-items: center;
        gap: 5px;
      }

      .space-selector-label svg {
        width: 14px;
        height: 14px;
      }

      .space-selector-bar .source-select {
        flex: 1;
      }

      .space-selector-bar .source-select.unset {
        border-color: rgba(255, 59, 78, 0.3);
        animation: pulse-border 2s infinite;
      }

      @keyframes pulse-border {
        0%,
        100% {
          border-color: rgba(255, 59, 78, 0.3);
        }
        50% {
          border-color: rgba(255, 59, 78, 0.6);
        }
      }

      /* Controls Bar */
      .controls-bar {
        display: flex;
        align-items: center;
        padding: 12px 16px;
        gap: 12px;
      }

      /* Audio Source (compact) */
      .source-compact {
        flex: 1;
        display: flex;
        gap: 8px;
        min-width: 0;
      }

      .source-compact-item {
        flex: 1;
        min-width: 0;
      }

      .source-compact-label {
        font-size: 10px;
        font-weight: 600;
        color: var(--text-muted);
        text-transform: uppercase;
        letter-spacing: 0.5px;
        margin-bottom: 4px;
        display: flex;
        align-items: center;
        gap: 4px;
      }

      .source-compact-label svg {
        width: 12px;
        height: 12px;
      }

      .source-select {
        width: 100%;
        padding: 8px 28px 8px 10px;
        background: var(--bg-panel);
        border: 1px solid var(--border-color);
        border-radius: var(--radius-sm);
        color: var(--text-primary);
        font-size: 12px;
        font-family: inherit;
        cursor: pointer;
        appearance: none;
        -webkit-appearance: none;
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='10' viewBox='0 0 24 24' fill='none' stroke='%234e4e68' stroke-width='2.5'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
        background-repeat: no-repeat;
        background-position: right 8px center;
        transition: all var(--transition-fast);
        text-overflow: ellipsis;
        white-space: nowrap;
        overflow: hidden;
      }

      .source-select:hover {
        border-color: var(--border-light);
        background-color: var(--bg-elevated);
      }

      .source-select:focus {
        outline: none;
        border-color: var(--border-focus);
      }

      /* Record Button */
      .record-wrapper {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 4px;
        flex-shrink: 0;
      }

      .record-btn {
        width: 56px;
        height: 56px;
        border-radius: 50%;
        border: 3px solid var(--text-muted);
        background: transparent;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all var(--transition-smooth);
        position: relative;
      }

      .record-btn::before {
        content: '';
        position: absolute;
        inset: -6px;
        border-radius: 50%;
        border: 2px solid transparent;
        transition: all var(--transition-smooth);
      }

      .record-btn:hover {
        border-color: var(--accent-red);
        transform: scale(1.06);
      }

      .record-btn:hover::before {
        border-color: rgba(255, 59, 78, 0.2);
      }

      .record-btn:active {
        transform: scale(0.98);
      }

      .record-btn-inner {
        width: 36px;
        height: 36px;
        background: var(--accent-red);
        border-radius: 50%;
        transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
        box-shadow: 0 0 0 0 transparent;
      }

      .record-btn.recording {
        border-color: var(--accent-red);
      }

      .record-btn.recording::before {
        border-color: var(--accent-red-glow);
        animation: record-ring-pulse 1.8s ease-in-out infinite;
      }

      .record-btn.recording .record-btn-inner {
        width: 22px;
        height: 22px;
        border-radius: 5px;
        box-shadow: 0 0 20px var(--accent-red-glow);
      }

      @keyframes record-ring-pulse {
        0%,
        100% {
          opacity: 1;
          transform: scale(1);
        }
        50% {
          opacity: 0.3;
          transform: scale(1.1);
        }
      }

      .record-label {
        font-size: 9px;
        font-weight: 700;
        letter-spacing: 1.5px;
        text-transform: uppercase;
        color: var(--text-muted);
        transition: color var(--transition-fast);
      }

      .record-btn.recording + .record-label {
        color: var(--accent-red);
      }

      /* Pause Button */
      .pause-btn {
        width: 36px;
        height: 36px;
        border-radius: 50%;
        background: var(--bg-panel);
        border: 1px solid var(--border-color);
        color: var(--text-secondary);
        cursor: pointer;
        display: none;
        align-items: center;
        justify-content: center;
        transition: all var(--transition-fast);
        position: absolute;
        right: -48px;
        top: 50%;
        transform: translateY(-50%);
      }

      .pause-btn:hover {
        background: var(--bg-elevated);
        border-color: var(--border-light);
        color: var(--text-primary);
      }

      .pause-btn svg {
        width: 16px;
        height: 16px;
      }

      .pause-btn.visible {
        display: flex;
      }

      .pause-btn.paused {
        background: var(--accent-blue-dim);
        border-color: var(--accent-blue);
        color: var(--accent-blue);
      }

      .pause-btn.paused:hover {
        background: rgba(77, 124, 255, 0.25);
      }

      /* Paused Overlay */
      .paused-overlay {
        position: absolute;
        inset: 0;
        background: rgba(10, 10, 18, 0.65);
        backdrop-filter: blur(24px) saturate(1.2);
        -webkit-backdrop-filter: blur(24px) saturate(1.2);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 12px;
        z-index: 5;
        opacity: 0;
        pointer-events: none;
        transition: opacity var(--transition-smooth);
        border-radius: var(--radius-lg);
      }

      .paused-overlay.active {
        opacity: 1;
        pointer-events: auto;
      }

      .paused-overlay-icon {
        width: 48px;
        height: 48px;
        color: var(--accent-blue);
        opacity: 0.9;
      }

      .paused-overlay-text {
        font-size: 14px;
        font-weight: 600;
        color: var(--text-primary);
        letter-spacing: 2px;
        text-transform: uppercase;
      }

      .paused-overlay-hint {
        font-size: 11px;
        color: var(--text-secondary);
        margin-top: 4px;
      }

      /* Control Buttons (adjacent to record) */
      .ctrl-btn {
        width: 36px;
        height: 36px;
        border-radius: var(--radius-sm);
        background: var(--bg-panel);
        border: 1px solid var(--border-color);
        color: var(--text-secondary);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all var(--transition-fast);
      }

      .ctrl-btn svg {
        width: 16px;
        height: 16px;
      }

      .ctrl-btn:hover {
        background: var(--bg-elevated);
        color: var(--text-primary);
        border-color: var(--border-light);
      }

      .ctrl-btn:active {
        transform: scale(0.95);
      }

      .ctrl-btn.active {
        background: var(--accent-blue-dim);
        color: var(--accent-blue);
        border-color: rgba(77, 124, 255, 0.3);
      }

      /* Review Controls */
      .review-bar {
        display: none;
        align-items: center;
        justify-content: center;
        padding: 14px 16px;
        gap: 10px;
      }

      .review-bar.visible {
        display: flex;
      }

      .review-btn {
        padding: 10px 20px;
        border: none;
        border-radius: var(--radius-sm);
        font-size: 13px;
        font-weight: 600;
        font-family: inherit;
        cursor: pointer;
        transition: all var(--transition-fast);
        display: flex;
        align-items: center;
        gap: 7px;
      }

      .review-btn svg {
        width: 15px;
        height: 15px;
      }

      .review-btn:active {
        transform: scale(0.97);
      }

      .review-btn.danger {
        background: rgba(255, 59, 78, 0.12);
        color: var(--accent-red);
        border: 1px solid rgba(255, 59, 78, 0.2);
      }

      .review-btn.danger:hover {
        background: rgba(255, 59, 78, 0.2);
      }

      .review-btn.secondary {
        background: var(--bg-elevated);
        color: var(--text-primary);
        border: 1px solid var(--border-color);
      }

      .review-btn.secondary:hover {
        background: var(--bg-hover);
        border-color: var(--border-light);
      }

      .review-btn.primary {
        background: var(--accent-green);
        color: #000;
        border: 1px solid transparent;
      }

      .review-btn.primary:hover {
        filter: brightness(1.1);
        box-shadow: 0 4px 16px rgba(0, 214, 143, 0.25);
      }

      .review-btn:disabled {
        opacity: 0.4;
        cursor: not-allowed;
        pointer-events: none;
      }

      /* ============================================
       SETTINGS PANEL (expandable)
       ============================================ */
      .settings-panel {
        max-height: 0;
        overflow: hidden;
        transition: max-height 0.35s cubic-bezier(0.4, 0, 0.2, 1);
        border-top: 1px solid transparent;
      }

      .settings-panel.open {
        max-height: 500px;
        border-top-color: var(--border-color);
      }

      .settings-inner {
        padding: 14px 16px;
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      /* Source Selection */
      .setting-row {
        display: flex;
        gap: 12px;
      }

      .setting-group {
        flex: 1;
        min-width: 0;
      }

      .setting-label {
        font-size: 10px;
        font-weight: 600;
        color: var(--text-muted);
        text-transform: uppercase;
        letter-spacing: 0.5px;
        margin-bottom: 6px;
        display: flex;
        align-items: center;
        gap: 5px;
      }

      .setting-label svg {
        width: 13px;
        height: 13px;
      }

      /* Audio Mixing Panel */
      .audio-mix-panel {
        display: none;
      }

      .audio-mix-panel.visible {
        display: block;
      }

      .mix-title {
        font-size: 11px;
        font-weight: 600;
        color: var(--text-secondary);
        text-transform: uppercase;
        letter-spacing: 0.5px;
        margin-bottom: 10px;
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .mix-title svg {
        width: 14px;
        height: 14px;
      }

      .volume-sliders {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
        gap: 10px;
      }

      .volume-slider-group {
        background: var(--bg-panel);
        padding: 10px 12px;
        border-radius: var(--radius-sm);
        border: 1px solid var(--border-color);
      }

      .volume-label {
        display: flex;
        align-items: center;
        gap: 6px;
        font-size: 11px;
        color: var(--text-secondary);
        margin-bottom: 8px;
      }

      .volume-label svg {
        width: 14px;
        height: 14px;
        flex-shrink: 0;
      }

      .volume-value {
        margin-left: auto;
        font-weight: 600;
        font-size: 11px;
        color: var(--text-primary);
        min-width: 35px;
        text-align: right;
        font-variant-numeric: tabular-nums;
      }

      .volume-slider {
        width: 100%;
        height: 4px;
        -webkit-appearance: none;
        appearance: none;
        background: var(--bg-hover);
        border-radius: 2px;
        outline: none;
        cursor: pointer;
      }

      .volume-slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 14px;
        height: 14px;
        background: var(--accent-blue);
        border-radius: 50%;
        cursor: pointer;
        transition:
          transform 0.1s,
          box-shadow 0.1s;
        box-shadow: 0 0 0 0 transparent;
      }

      .volume-slider::-webkit-slider-thumb:hover {
        transform: scale(1.2);
        box-shadow: 0 0 8px rgba(77, 124, 255, 0.4);
      }

      .volume-slider::-moz-range-thumb {
        width: 14px;
        height: 14px;
        background: var(--accent-blue);
        border-radius: 50%;
        cursor: pointer;
        border: none;
      }

      .volume-source-select {
        width: 100%;
        padding: 5px 24px 5px 8px;
        margin-bottom: 8px;
        background: var(--bg-elevated);
        border: 1px solid var(--border-color);
        border-radius: 5px;
        color: var(--text-primary);
        font-size: 11px;
        font-family: inherit;
        cursor: pointer;
        appearance: none;
        -webkit-appearance: none;
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='10' viewBox='0 0 24 24' fill='none' stroke='%234e4e68' stroke-width='2.5'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
        background-repeat: no-repeat;
        background-position: right 6px center;
      }

      .volume-source-select:hover {
        border-color: var(--border-light);
      }
      .volume-source-select:focus {
        outline: none;
        border-color: var(--border-focus);
      }

      /* System audio status badge */
      .audio-status-badge {
        display: inline-block;
        font-size: 9px;
        font-weight: 600;
        letter-spacing: 0.3px;
        text-transform: uppercase;
        padding: 1px 5px;
        border-radius: 3px;
        margin-left: auto;
        background: rgba(78, 78, 104, 0.2);
        color: var(--text-muted);
        cursor: help;
        transition: var(--transition-fast);
      }

      .audio-status-badge.active {
        background: var(--accent-green-dim);
        color: var(--accent-green);
      }

      /* Live Caption Overlay */
      .caption-overlay {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        z-index: 6;
        padding: 12px 20px 16px;
        background: linear-gradient(0deg, rgba(10, 10, 18, 0.7) 0%, rgba(10, 10, 18, 0.35) 60%, transparent 100%);
        backdrop-filter: blur(16px) saturate(1.2);
        -webkit-backdrop-filter: blur(16px) saturate(1.2);
        display: none;
        flex-direction: column;
        align-items: center;
        justify-content: flex-end;
        pointer-events: none;
        min-height: 64px;
        transition: opacity var(--transition-smooth);
      }

      .caption-overlay.visible {
        display: flex;
      }

      .caption-text {
        font-size: 15px;
        font-weight: 500;
        color: #fff;
        text-align: center;
        line-height: 1.5;
        max-width: 90%;
        text-shadow:
          0 1px 6px rgba(0, 0, 0, 0.8),
          0 0 2px rgba(0, 0, 0, 0.5);
        word-wrap: break-word;
        max-height: 80px;
        overflow-y: hidden;
        background: rgba(10, 10, 18, 0.45);
        padding: 6px 16px;
        border-radius: 8px;
        backdrop-filter: blur(20px);
        -webkit-backdrop-filter: blur(20px);
      }

      .caption-text.interim {
        color: rgba(200, 200, 220, 0.85);
        font-style: italic;
        font-weight: 400;
      }

      .caption-text:empty {
        display: none;
      }

      /* Caption toggle button */
      .caption-toggle {
        width: 36px;
        height: 36px;
        border-radius: var(--radius-sm);
        background: var(--bg-panel);
        border: 1px solid var(--border-color);
        color: var(--text-muted);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all var(--transition-fast);
      }

      .caption-toggle:hover {
        background: var(--bg-elevated);
        border-color: var(--border-light);
        color: var(--text-secondary);
      }

      .caption-toggle.active {
        background: var(--accent-blue-dim);
        border-color: var(--accent-blue);
        color: var(--accent-blue);
      }

      .caption-toggle svg {
        width: 18px;
        height: 18px;
      }

      /* Transcription status indicator */
      .transcription-status {
        display: none;
        align-items: center;
        gap: 6px;
        font-size: 11px;
        color: var(--text-muted);
        padding: 6px 10px;
        background: rgba(10, 10, 18, 0.5);
        backdrop-filter: blur(20px) saturate(1.3);
        -webkit-backdrop-filter: blur(20px) saturate(1.3);
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: var(--radius-sm);
        position: absolute;
        top: 12px;
        right: 12px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        z-index: 7;
      }

      .transcription-status.visible {
        display: flex;
      }

      .transcription-status.active {
        color: var(--accent-green);
        border-color: rgba(0, 214, 143, 0.3);
      }

      .transcription-status .status-dot {
        width: 6px;
        height: 6px;
        border-radius: 50%;
        background: var(--text-muted);
      }

      .transcription-status.active .status-dot {
        background: var(--accent-green);
        animation: status-pulse 2s ease-in-out infinite;
      }

      @keyframes status-pulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.4;
        }
      }

      /* Monitor Alert Toast */
      .monitor-alert-container {
        position: absolute;
        top: 12px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 50;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
        pointer-events: none;
        width: 90%;
        max-width: 480px;
      }

      .monitor-alert {
        display: flex;
        align-items: flex-start;
        gap: 10px;
        padding: 10px 14px;
        background: rgba(14, 14, 22, 0.7);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: var(--radius-md);
        backdrop-filter: blur(24px) saturate(1.4);
        -webkit-backdrop-filter: blur(24px) saturate(1.4);
        pointer-events: auto;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        opacity: 0;
        transform: translateY(-12px);
        animation: alert-slide-in 0.3s ease-out forwards;
        width: 100%;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
      }

      .monitor-alert.warning {
        border-color: rgba(255, 180, 50, 0.4);
      }

      .monitor-alert.info {
        border-color: rgba(100, 160, 255, 0.3);
      }

      .monitor-alert.dismissing {
        animation: alert-slide-out 0.3s ease-in forwards;
      }

      @keyframes alert-slide-in {
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      @keyframes alert-slide-out {
        from {
          opacity: 1;
          transform: translateY(0);
        }
        to {
          opacity: 0;
          transform: translateY(-12px);
        }
      }

      .monitor-alert-icon {
        flex-shrink: 0;
        width: 18px;
        height: 18px;
        margin-top: 1px;
      }

      .monitor-alert.warning .monitor-alert-icon {
        color: #ffb432;
      }

      .monitor-alert.info .monitor-alert-icon {
        color: #64a0ff;
      }

      .monitor-alert-body {
        flex: 1;
        min-width: 0;
      }

      .monitor-alert-message {
        font-size: 12px;
        font-weight: 500;
        color: var(--text-primary);
        line-height: 1.4;
      }

      .monitor-alert-suggestion {
        font-size: 11px;
        color: var(--text-muted);
        margin-top: 3px;
        line-height: 1.3;
      }

      .monitor-alert-dismiss {
        flex-shrink: 0;
        width: 20px;
        height: 20px;
        border: none;
        background: none;
        color: var(--text-muted);
        cursor: pointer;
        padding: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        transition: color var(--transition-fast);
      }

      .monitor-alert-dismiss:hover {
        color: var(--text-primary);
      }

      .monitor-alert-dismiss svg {
        width: 14px;
        height: 14px;
      }

      /* Instructions Panel */
      .instructions-panel {
        background: var(--bg-panel);
        border: 1px solid var(--border-color);
        border-radius: var(--radius-sm);
        overflow: hidden;
      }

      .instructions-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 10px 12px;
        border-bottom: 1px solid var(--border-color);
      }

      .instructions-title {
        font-size: 10px;
        font-weight: 600;
        color: var(--text-muted);
        text-transform: uppercase;
        letter-spacing: 0.5px;
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .instructions-title svg {
        width: 13px;
        height: 13px;
      }

      .instructions-content {
        font-size: 13px;
        line-height: 1.6;
        color: var(--text-primary);
        padding: 10px 12px;
        min-height: 40px;
        max-height: 80px;
        overflow-y: auto;
      }

      .instructions-content.empty {
        color: var(--text-muted);
        font-style: italic;
      }

      /* ============================================
       SAVE DIALOG
       ============================================ */
      .save-dialog {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.75);
        backdrop-filter: blur(8px);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 100;
        opacity: 0;
        visibility: hidden;
        transition: all 0.25s;
      }

      .save-dialog.active {
        opacity: 1;
        visibility: visible;
      }

      .save-dialog-content {
        background: var(--bg-panel);
        border: 1px solid var(--border-light);
        border-radius: var(--radius-lg);
        padding: 24px;
        width: 400px;
        max-width: 90%;
        box-shadow: 0 24px 80px rgba(0, 0, 0, 0.6);
        transform: scale(0.95) translateY(10px);
        transition: transform 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .save-dialog.active .save-dialog-content {
        transform: scale(1) translateY(0);
      }

      .save-dialog-title {
        font-size: 16px;
        font-weight: 600;
        margin-bottom: 20px;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .save-dialog-title svg {
        width: 18px;
        height: 18px;
        color: var(--accent-green);
      }

      .save-form-group {
        margin-bottom: 14px;
      }

      .save-form-label {
        display: block;
        font-size: 11px;
        font-weight: 600;
        color: var(--text-muted);
        text-transform: uppercase;
        letter-spacing: 0.3px;
        margin-bottom: 6px;
      }

      .save-form-input {
        width: 100%;
        padding: 10px 12px;
        background: var(--bg-elevated);
        border: 1px solid var(--border-color);
        border-radius: var(--radius-sm);
        color: var(--text-primary);
        font-size: 13px;
        font-family: inherit;
        transition: all var(--transition-fast);
      }

      .save-form-input:focus {
        outline: none;
        border-color: var(--border-focus);
        box-shadow: 0 0 0 3px rgba(77, 124, 255, 0.1);
      }

      .save-dialog-actions {
        display: flex;
        gap: 10px;
        margin-top: 22px;
      }

      .save-dialog-actions .review-btn {
        flex: 1;
        justify-content: center;
      }

      /* ============================================
       TRACK TRANSFER OVERLAY (Phase 2)
       ============================================ */
      .transfer-overlay {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.85);
        backdrop-filter: blur(12px);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 200;
        opacity: 0;
        visibility: hidden;
        transition: all 0.3s;
      }

      .transfer-overlay.active {
        opacity: 1;
        visibility: visible;
      }

      .transfer-content {
        text-align: center;
        max-width: 400px;
      }

      .transfer-icon {
        width: 48px;
        height: 48px;
        margin: 0 auto 16px;
        color: var(--accent-blue);
        animation: transferBounce 1.5s ease-in-out infinite;
      }

      .transfer-icon svg {
        width: 100%;
        height: 100%;
      }

      @keyframes transferBounce {
        0%,
        100% {
          transform: translateY(0);
        }
        50% {
          transform: translateY(-8px);
        }
      }

      .transfer-title {
        font-size: 16px;
        font-weight: 600;
        margin-bottom: 20px;
      }

      .transfer-progress-bar {
        width: 100%;
        height: 6px;
        background: var(--bg-elevated);
        border-radius: 3px;
        overflow: hidden;
        margin-bottom: 12px;
      }

      .transfer-progress-fill {
        height: 100%;
        background: linear-gradient(90deg, var(--accent-blue), var(--accent-green));
        border-radius: 3px;
        transition: width 0.2s;
      }

      .transfer-status {
        font-size: 12px;
        color: var(--text-muted);
      }

      /* ============================================
       MERGE DIALOG (Phase 3)
       ============================================ */
      .merge-dialog {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.75);
        backdrop-filter: blur(8px);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 150;
        opacity: 0;
        visibility: hidden;
        transition: all 0.25s;
      }

      .merge-dialog.active {
        opacity: 1;
        visibility: visible;
      }

      .merge-dialog-content {
        background: var(--bg-panel);
        border: 1px solid var(--border-light);
        border-radius: var(--radius-lg);
        padding: 24px;
        width: 480px;
        max-width: 90%;
        box-shadow: 0 24px 80px rgba(0, 0, 0, 0.6);
        transform: scale(0.95) translateY(10px);
        transition: transform 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .merge-dialog.active .merge-dialog-content {
        transform: scale(1) translateY(0);
      }

      .merge-dialog-title {
        font-size: 16px;
        font-weight: 600;
        margin-bottom: 4px;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .merge-dialog-title svg {
        width: 18px;
        height: 18px;
        color: var(--accent-blue);
      }

      .merge-subtitle {
        font-size: 12px;
        color: var(--text-muted);
        margin-bottom: 20px;
      }

      .merge-layout-options {
        display: flex;
        gap: 10px;
        margin-bottom: 20px;
      }

      .merge-layout-option {
        flex: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
        padding: 12px 8px;
        border-radius: var(--radius-sm);
        border: 1px solid var(--border-color);
        background: var(--bg-elevated);
        cursor: pointer;
        transition: all var(--transition-fast);
      }

      .merge-layout-option:hover {
        border-color: var(--border-light);
      }

      .merge-layout-option.selected {
        border-color: var(--accent-blue);
        background: rgba(77, 124, 255, 0.08);
      }

      .merge-layout-option input[type='radio'] {
        display: none;
      }

      .merge-layout-option span {
        font-size: 11px;
        color: var(--text-secondary);
      }

      .merge-layout-preview {
        width: 80px;
        height: 48px;
        position: relative;
        border-radius: 4px;
        overflow: hidden;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .layout-box {
        position: absolute;
        background: rgba(77, 124, 255, 0.3);
        border: 1px solid rgba(77, 124, 255, 0.5);
        border-radius: 2px;
      }

      .layout-box.left {
        top: 2px;
        left: 2px;
        bottom: 2px;
        width: calc(50% - 3px);
      }

      .layout-box.right {
        top: 2px;
        right: 2px;
        bottom: 2px;
        width: calc(50% - 3px);
        background: rgba(0, 200, 120, 0.3);
        border-color: rgba(0, 200, 120, 0.5);
      }

      .layout-box.full {
        inset: 2px;
      }

      .layout-box.full.guest {
        background: rgba(0, 200, 120, 0.3);
        border-color: rgba(0, 200, 120, 0.5);
      }

      .layout-box.pip {
        width: 24px;
        height: 16px;
      }

      .layout-box.pip.bottom-right {
        bottom: 5px;
        right: 5px;
        background: rgba(0, 200, 120, 0.5);
        border-color: rgba(0, 200, 120, 0.7);
      }

      .layout-box.pip.bottom-right.host {
        background: rgba(77, 124, 255, 0.5);
        border-color: rgba(77, 124, 255, 0.7);
      }

      .merge-tracks-info {
        background: var(--bg-elevated);
        border-radius: var(--radius-sm);
        padding: 12px;
        margin-bottom: 16px;
      }

      .merge-track-item {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 4px 0;
        font-size: 12px;
      }

      .merge-track-item + .merge-track-item {
        margin-top: 6px;
        padding-top: 6px;
        border-top: 1px solid var(--border-color);
      }

      .merge-track-role {
        font-size: 10px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.3px;
        padding: 2px 6px;
        border-radius: 3px;
        background: rgba(77, 124, 255, 0.15);
        color: var(--accent-blue);
        min-width: 40px;
        text-align: center;
      }

      .merge-track-role.guest {
        background: rgba(0, 200, 120, 0.15);
        color: var(--accent-green);
      }

      .merge-track-name {
        color: var(--text-secondary);
        flex: 1;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      .merge-progress {
        margin-bottom: 16px;
      }

      .merge-progress-text {
        font-size: 11px;
        color: var(--text-muted);
        margin-top: 6px;
        text-align: center;
      }

      .merge-dialog-actions {
        display: flex;
        gap: 10px;
      }

      .merge-dialog-actions .review-btn {
        flex: 1;
        justify-content: center;
      }

      /* ============================================
       SCREEN PICKER
       ============================================ */
      .screen-picker {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.8);
        backdrop-filter: blur(8px);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 100;
        opacity: 0;
        visibility: hidden;
        transition: all 0.25s;
      }

      .screen-picker.active {
        opacity: 1;
        visibility: visible;
      }

      .screen-picker-content {
        background: var(--bg-panel);
        border: 1px solid var(--border-light);
        border-radius: var(--radius-lg);
        padding: 24px;
        width: 600px;
        max-width: 90%;
        max-height: 80vh;
        overflow-y: auto;
        box-shadow: 0 24px 80px rgba(0, 0, 0, 0.6);
        transform: scale(0.95) translateY(10px);
        transition: transform 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .screen-picker.active .screen-picker-content {
        transform: scale(1) translateY(0);
      }

      .screen-picker-title {
        font-size: 16px;
        font-weight: 600;
        margin-bottom: 4px;
      }

      .screen-picker-subtitle {
        font-size: 12px;
        color: var(--text-muted);
        margin-bottom: 20px;
      }

      .screen-picker-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
        gap: 10px;
        margin-bottom: 20px;
      }

      .screen-source-item {
        background: var(--bg-elevated);
        border: 2px solid var(--border-color);
        border-radius: var(--radius-sm);
        padding: 8px;
        cursor: pointer;
        transition: all var(--transition-fast);
      }

      .screen-source-item:hover {
        border-color: var(--accent-blue);
        background: var(--bg-hover);
        transform: translateY(-2px);
      }

      .screen-source-item.selected {
        border-color: var(--accent-blue);
        background: var(--accent-blue-dim);
        box-shadow: 0 0 0 1px var(--accent-blue);
      }

      .screen-source-thumbnail {
        width: 100%;
        aspect-ratio: 16/9;
        object-fit: contain;
        background: #000;
        border-radius: 4px;
        margin-bottom: 8px;
      }

      .screen-source-name {
        font-size: 11px;
        color: var(--text-secondary);
        text-align: center;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .screen-picker-actions {
        display: flex;
        gap: 10px;
        justify-content: flex-end;
      }

      /* ============================================
       STATUS MESSAGE
       ============================================ */
      .status-message {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%) translateY(20px);
        background: rgba(16, 16, 24, 0.6);
        backdrop-filter: blur(24px) saturate(1.4);
        -webkit-backdrop-filter: blur(24px) saturate(1.4);
        border: 1px solid rgba(255, 255, 255, 0.12);
        padding: 10px 20px;
        border-radius: var(--radius-xl);
        font-size: 13px;
        font-weight: 500;
        opacity: 0;
        visibility: hidden;
        transition: all var(--transition-smooth);
        z-index: 200;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .status-message.active {
        opacity: 1;
        visibility: visible;
        transform: translateX(-50%) translateY(0);
      }

      .status-message.success {
        border-color: rgba(0, 214, 143, 0.3);
        color: var(--accent-green);
      }

      .status-message.error {
        border-color: rgba(255, 59, 78, 0.3);
        color: var(--accent-red);
      }

      .status-dot {
        width: 6px;
        height: 6px;
        border-radius: 50%;
        background: currentColor;
        flex-shrink: 0;
      }

      /* ============================================
       KEYBOARD SHORTCUTS BAR
       ============================================ */
      .shortcuts-bar {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 16px;
        padding: 6px 16px;
        border-top: 1px solid var(--border-color);
        background: var(--bg-base);
      }

      .shortcut-item {
        display: flex;
        align-items: center;
        gap: 5px;
        font-size: 10px;
        color: var(--text-muted);
      }

      .shortcut-item kbd {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        min-width: 18px;
        height: 18px;
        background: var(--bg-elevated);
        border: 1px solid var(--border-light);
        border-radius: 4px;
        padding: 0 4px;
        font-family: inherit;
        font-size: 9px;
        font-weight: 600;
        color: var(--text-secondary);
      }

      /* ============================================
       SESSION MODE  Multi-Participant Layout
       ============================================ */

      /* Container: relative for absolute-positioned children */
      .preview-container.session-active {
        position: relative;
        overflow: hidden;
      }

      /* ---- Participant tile (base) ---- */
      .session-participant {
        position: absolute;
        border-radius: var(--radius-md);
        overflow: hidden;
        background: #000;
        display: flex;
        align-items: center;
        justify-content: center;
        /* Smooth animated transitions when layout changes */
        transition:
          top 0.5s cubic-bezier(0.4, 0, 0.2, 1),
          left 0.5s cubic-bezier(0.4, 0, 0.2, 1),
          bottom 0.5s cubic-bezier(0.4, 0, 0.2, 1),
          width 0.5s cubic-bezier(0.4, 0, 0.2, 1),
          height 0.5s cubic-bezier(0.4, 0, 0.2, 1),
          box-shadow 0.3s ease,
          opacity 0.3s ease;
        z-index: 1;
      }

      .session-participant video {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      /* ---- Spotlight participant (3+ mode) ---- */
      .session-participant.in-spotlight {
        z-index: 2;
        border-radius: var(--radius-md) var(--radius-md) 0 0;
      }

      /* ---- Thumbnail participants (3+ mode) ---- */
      .session-participant.in-thumbnails {
        z-index: 1;
      }

      /* ---- Audio-reactive glow for active speaker ---- */
      .session-participant.speaking {
        box-shadow:
          0 0 calc(var(--audio-level, 0) * 25px + 4px) rgba(77, 124, 255, calc(var(--audio-level, 0) * 0.7 + 0.15)),
          inset 0 0 0 2px rgba(77, 124, 255, calc(var(--audio-level, 0) * 0.5 + 0.3));
      }

      /* Subtle idle glow when speaking but audio is low */
      .session-participant.speaking:not(.in-spotlight) {
        box-shadow:
          0 0 8px rgba(77, 124, 255, 0.3),
          inset 0 0 0 2px rgba(77, 124, 255, 0.4);
      }

      /* ---- Participant label ---- */
      .participant-label {
        position: absolute;
        bottom: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.6);
        backdrop-filter: blur(8px);
        padding: 4px 12px;
        border-radius: 12px;
        font-size: 11px;
        font-weight: 600;
        color: white;
        z-index: 5;
      }

      .participant-label.remote {
        border: 1px solid rgba(77, 124, 255, 0.3);
      }

      /* Larger label in spotlight */
      .session-participant.in-spotlight .participant-label {
        font-size: 13px;
        padding: 5px 14px;
      }

      /* Session setup panel (pre-connection) */
      .session-setup {
        display: none;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 24px;
        position: absolute;
        inset: 0;
        background: var(--bg-base);
        z-index: 40;
        padding: 32px;
      }

      .session-setup.visible {
        display: flex;
      }

      .session-setup-title {
        font-size: 18px;
        font-weight: 600;
        color: var(--text-primary);
        text-align: center;
      }

      .session-setup-subtitle {
        font-size: 13px;
        color: var(--text-muted);
        text-align: center;
        margin-top: -16px;
      }

      /* Session space selector (inline in setup panel) */
      .session-space-selector {
        width: 100%;
        max-width: 280px;
        margin: -8px auto 0;
      }

      .session-space-selector label {
        display: block;
        font-size: 11px;
        color: var(--text-muted);
        margin-bottom: 6px;
        text-transform: uppercase;
        letter-spacing: 0.05em;
      }

      .session-space-selector select {
        width: 100%;
        padding: 10px 14px;
        background: var(--bg-elevated, #1a1a2e);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 8px;
        color: #fff;
        font-size: 14px;
        font-family: inherit;
        appearance: none;
        -webkit-appearance: none;
        cursor: pointer;
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%23888' stroke-width='2'%3E%3Cpolyline points='6 9 12 15 18 9'/%3E%3C/svg%3E");
        background-repeat: no-repeat;
        background-position: right 12px center;
        padding-right: 32px;
        transition: border-color 0.2s;
      }

      .session-space-selector select:focus {
        outline: none;
        border-color: var(--accent-blue);
      }

      .session-space-selector select.unset {
        border-color: rgba(255, 59, 78, 0.4);
      }

      .session-actions {
        display: flex;
        gap: 16px;
        width: 100%;
        max-width: 400px;
      }

      .session-action-card {
        flex: 1;
        padding: 24px 16px;
        background: var(--bg-panel);
        border: 1px solid var(--border-color);
        border-radius: var(--radius-lg);
        cursor: pointer;
        transition: all var(--transition-fast);
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 12px;
        text-align: center;
      }

      .session-action-card:hover {
        background: var(--bg-elevated);
        border-color: var(--border-light);
        transform: translateY(-2px);
      }

      .session-action-card svg {
        width: 32px;
        height: 32px;
        color: var(--accent-blue);
      }

      .session-action-card .card-title {
        font-size: 14px;
        font-weight: 600;
        color: var(--text-primary);
      }

      .session-action-card .card-desc {
        font-size: 11px;
        color: var(--text-muted);
      }

      /* Host waiting state */
      .session-host-waiting {
        display: none;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 20px;
        position: absolute;
        inset: 0;
        background: var(--bg-base);
        z-index: 40;
        padding: 32px;
      }

      .session-host-waiting.visible {
        display: flex;
      }

      .session-code-display {
        font-size: 56px;
        font-weight: 700;
        color: var(--text-primary);
        text-transform: uppercase;
        letter-spacing: 4px;
        padding: 16px 32px;
        background: var(--bg-panel);
        border: 2px solid var(--border-light);
        border-radius: var(--radius-lg);
        cursor: pointer;
        transition: all var(--transition-fast);
        position: relative;
      }

      .session-code-display:hover {
        border-color: var(--accent-blue);
        background: var(--bg-elevated);
      }

      .session-code-display .copy-hint {
        position: absolute;
        bottom: -24px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 11px;
        font-weight: 400;
        color: var(--text-muted);
        letter-spacing: 0;
        text-transform: none;
        white-space: nowrap;
      }

      .waiting-text {
        font-size: 14px;
        color: var(--text-secondary);
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .waiting-dot {
        width: 8px;
        height: 8px;
        background: var(--accent-blue);
        border-radius: 50%;
        animation: waiting-pulse 1.5s ease-in-out infinite;
      }

      @keyframes waiting-pulse {
        0%,
        100% {
          opacity: 1;
          transform: scale(1);
        }
        50% {
          opacity: 0.3;
          transform: scale(0.8);
        }
      }

      .guest-activity {
        display: none;
        flex-direction: column;
        align-items: center;
        gap: 6px;
        padding: 10px 16px;
        background: rgba(77, 124, 255, 0.08);
        border: 1px solid rgba(77, 124, 255, 0.15);
        border-radius: var(--radius-md);
        max-width: 360px;
        width: 100%;
        margin-top: 4px;
        animation: fadeIn 0.3s ease;
      }

      .guest-activity.visible {
        display: flex;
      }

      .guest-activity.error {
        background: rgba(255, 59, 78, 0.08);
        border-color: rgba(255, 59, 78, 0.2);
      }

      .guest-activity-title {
        font-size: 12px;
        font-weight: 600;
        color: var(--accent-blue);
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .guest-activity.error .guest-activity-title {
        color: var(--accent-red);
      }

      .guest-activity-detail {
        font-size: 11px;
        color: var(--text-muted);
        text-align: center;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(4px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      /* Join session panel */
      .session-join-panel {
        display: none;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 20px;
        position: absolute;
        inset: 0;
        background: var(--bg-base);
        z-index: 40;
        padding: 32px;
      }

      .session-join-panel.visible {
        display: flex;
      }

      .join-input-row {
        display: flex;
        gap: 8px;
        width: 100%;
        max-width: 360px;
      }

      .join-code-input {
        flex: 1;
        padding: 14px 16px;
        background: var(--bg-panel);
        border: 2px solid var(--border-color);
        border-radius: var(--radius-md);
        color: var(--text-primary);
        font-size: 20px;
        font-weight: 600;
        font-family: inherit;
        text-align: center;
        text-transform: lowercase;
        letter-spacing: 2px;
        transition: all var(--transition-fast);
      }

      .join-code-input::placeholder {
        color: var(--text-muted);
        font-weight: 400;
        font-size: 14px;
        letter-spacing: 0;
        text-transform: none;
      }

      .join-code-input:focus {
        outline: none;
        border-color: var(--accent-blue);
        box-shadow: 0 0 0 3px rgba(77, 124, 255, 0.15);
      }

      .join-connect-btn {
        padding: 14px 24px;
        background: var(--accent-blue);
        color: white;
        border: none;
        border-radius: var(--radius-md);
        font-size: 14px;
        font-weight: 600;
        font-family: inherit;
        cursor: pointer;
        transition: all var(--transition-fast);
        white-space: nowrap;
      }

      .join-connect-btn:hover {
        filter: brightness(1.15);
      }

      .join-connect-btn:disabled {
        opacity: 0.4;
        cursor: not-allowed;
      }

      /* Session connected indicator */
      .session-connected-badge {
        display: none;
        align-items: center;
        gap: 6px;
        position: absolute;
        top: 16px;
        right: 16px;
        background: rgba(0, 214, 143, 0.15);
        border: 1px solid rgba(0, 214, 143, 0.3);
        padding: 6px 12px;
        border-radius: 20px;
        font-size: 11px;
        font-weight: 600;
        color: var(--accent-green);
        z-index: 20;
      }

      .session-connected-badge.visible {
        display: flex;
      }

      .session-connected-dot {
        width: 6px;
        height: 6px;
        background: var(--accent-green);
        border-radius: 50%;
      }

      /* End session button */
      .end-session-btn {
        padding: 8px 16px;
        background: rgba(255, 59, 78, 0.12);
        border: 1px solid rgba(255, 59, 78, 0.2);
        border-radius: var(--radius-sm);
        color: var(--accent-red);
        font-size: 12px;
        font-weight: 600;
        font-family: inherit;
        cursor: pointer;
        transition: all var(--transition-fast);
        display: none;
        align-items: center;
        gap: 6px;
      }

      .end-session-btn.visible {
        display: flex;
      }

      .end-session-btn:hover {
        background: rgba(255, 59, 78, 0.2);
      }

      .end-session-btn svg {
        width: 14px;
        height: 14px;
      }

      /* Session media controls (mute mic, camera off) */
      .session-media-controls {
        display: none;
        align-items: center;
        gap: 6px;
      }

      .session-media-controls.visible {
        display: flex;
      }

      .session-media-btn {
        width: 36px;
        height: 36px;
        border-radius: var(--radius-sm);
        background: var(--bg-panel);
        border: 1px solid var(--border-color);
        color: var(--text-secondary);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all var(--transition-fast);
        position: relative;
      }

      .session-media-btn svg {
        width: 18px;
        height: 18px;
      }

      .session-media-btn:hover {
        background: var(--bg-elevated);
        color: var(--text-primary);
        border-color: var(--border-light);
      }

      .session-media-btn:active {
        transform: scale(0.95);
      }

      .session-media-btn.off {
        background: rgba(255, 59, 78, 0.12);
        border-color: rgba(255, 59, 78, 0.25);
        color: var(--accent-red);
      }

      .session-media-btn.off:hover {
        background: rgba(255, 59, 78, 0.2);
      }

      .session-media-btn.active-bg {
        background: rgba(77, 124, 255, 0.12);
        border-color: rgba(77, 124, 255, 0.25);
        color: var(--accent-blue, #4d7cff);
      }

      /* Background effect popover */
      .bg-popover {
        display: none;
        position: absolute;
        bottom: calc(100% + 8px);
        left: 50%;
        transform: translateX(-50%);
        background: var(--bg-panel);
        border: 1px solid var(--border-color);
        border-radius: var(--radius-md);
        padding: 10px;
        min-width: 200px;
        z-index: 50;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
      }

      .bg-popover.visible {
        display: block;
      }

      .bg-popover-title {
        font-size: 11px;
        font-weight: 600;
        color: var(--text-secondary);
        text-transform: uppercase;
        letter-spacing: 0.5px;
        margin-bottom: 8px;
      }

      .bg-option {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 7px 8px;
        border-radius: var(--radius-sm);
        cursor: pointer;
        font-size: 13px;
        color: var(--text-primary);
        transition: background 0.15s;
      }

      .bg-option:hover {
        background: var(--bg-elevated);
      }

      .bg-option.selected {
        background: rgba(77, 124, 255, 0.12);
        color: var(--accent-blue, #4d7cff);
      }

      .bg-option svg {
        width: 16px;
        height: 16px;
        flex-shrink: 0;
      }

      .bg-slider-row {
        display: none;
        align-items: center;
        gap: 8px;
        padding: 6px 8px 2px 8px;
      }

      .bg-slider-row.visible {
        display: flex;
      }

      .bg-slider-row label {
        font-size: 11px;
        color: var(--text-secondary);
        min-width: 36px;
      }

      .bg-slider-row input[type='range'] {
        flex: 1;
        height: 4px;
        -webkit-appearance: none;
        appearance: none;
        background: var(--border-color);
        border-radius: 2px;
        outline: none;
      }

      .bg-slider-row input[type='range']::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 14px;
        height: 14px;
        border-radius: 50%;
        background: var(--accent-blue, #4d7cff);
        cursor: pointer;
      }

      .bg-image-row {
        display: none;
        padding: 6px 8px 2px 8px;
      }

      .bg-image-row.visible {
        display: block;
      }

      .bg-image-btn {
        width: 100%;
        padding: 6px 10px;
        font-size: 12px;
        font-family: inherit;
        background: var(--bg-elevated);
        border: 1px solid var(--border-color);
        border-radius: var(--radius-sm);
        color: var(--text-primary);
        cursor: pointer;
        transition: background 0.15s;
      }

      .bg-image-btn:hover {
        background: var(--border-color);
      }

      /* Session status text */
      .session-status {
        font-size: 13px;
        color: var(--text-secondary);
        text-align: center;
      }

      .session-status.error {
        color: var(--accent-red);
      }

      .session-back-btn {
        padding: 8px 16px;
        background: var(--bg-elevated);
        border: 1px solid var(--border-color);
        border-radius: var(--radius-sm);
        color: var(--text-secondary);
        font-size: 12px;
        font-weight: 500;
        font-family: inherit;
        cursor: pointer;
        transition: all var(--transition-fast);
      }

      .session-back-btn:hover {
        background: var(--bg-hover);
        color: var(--text-primary);
      }

      /* ==================== MEETING HUD OVERLAY ==================== */
      .meeting-hud {
        position: absolute;
        top: 8px;
        right: 8px;
        bottom: 8px;
        width: 280px;
        background: rgba(14, 14, 22, 0.6);
        backdrop-filter: blur(32px) saturate(1.5);
        -webkit-backdrop-filter: blur(32px) saturate(1.5);
        border: 1px solid rgba(255, 255, 255, 0.14);
        border-radius: 14px;
        display: flex;
        flex-direction: column;
        z-index: 20;
        overflow: hidden;
        transition:
          opacity 0.25s,
          transform 0.25s;
        box-shadow:
          0 8px 40px rgba(0, 0, 0, 0.35),
          inset 0 1px 0 rgba(255, 255, 255, 0.05);
      }
      .meeting-hud.hidden {
        opacity: 0;
        pointer-events: none;
        transform: translateX(20px);
      }
      .meeting-hud-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 10px 14px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        font-size: 12px;
        font-weight: 600;
        color: rgba(255, 255, 255, 0.85);
        letter-spacing: 0.5px;
        text-transform: uppercase;
      }
      .meeting-hud-header .hud-count {
        font-size: 11px;
        font-weight: 400;
        color: rgba(255, 255, 255, 0.45);
      }
      .meeting-hud-toggle {
        background: none;
        border: none;
        color: rgba(255, 255, 255, 0.5);
        cursor: pointer;
        padding: 2px;
        font-size: 14px;
        line-height: 1;
      }
      .meeting-hud-toggle:hover {
        color: rgba(255, 255, 255, 0.8);
      }
      .meeting-hud-items {
        flex: 1;
        overflow-y: auto;
        padding: 8px 10px;
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .meeting-hud-items::-webkit-scrollbar {
        width: 4px;
      }
      .meeting-hud-items::-webkit-scrollbar-track {
        background: transparent;
      }
      .meeting-hud-items::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.15);
        border-radius: 2px;
      }
      .meeting-hud-items > .hud-item {
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(8px);
        -webkit-backdrop-filter: blur(8px);
        backdrop-filter: blur(12px) saturate(1.2);
        -webkit-backdrop-filter: blur(12px) saturate(1.2);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 10px;
        padding: 8px 10px;
        display: flex;
        flex-direction: column;
        gap: 4px;
        position: relative;
        box-shadow:
          0 2px 8px rgba(0, 0, 0, 0.15),
          inset 0 1px 0 rgba(255, 255, 255, 0.06);
        transition:
          background 0.15s,
          border-color 0.15s,
          box-shadow 0.15s;
      }
      .meeting-hud-items > .hud-item:hover {
        background: rgba(255, 255, 255, 0.13);
        border-color: rgba(255, 255, 255, 0.18);
        box-shadow:
          0 4px 12px rgba(0, 0, 0, 0.2),
          inset 0 1px 0 rgba(255, 255, 255, 0.08);
      }
      .hud-item-top {
        display: flex;
        align-items: center;
        gap: 6px;
        font-size: 10px;
      }
      .hud-type-badge {
        font-weight: 700;
        font-size: 9px;
        padding: 1px 5px;
        border-radius: 3px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }
      .hud-type-badge.action-item {
        background: rgba(96, 165, 250, 0.25);
        color: #93bbfc;
      }
      .hud-type-badge.decision {
        background: rgba(167, 139, 250, 0.25);
        color: #c4b5fd;
      }
      .hud-type-badge.note {
        background: rgba(156, 163, 175, 0.2);
        color: #9ca3af;
      }
      .hud-type-badge.bookmark {
        background: rgba(251, 191, 36, 0.2);
        color: #fbbf24;
      }
      .hud-item-time {
        font-size: 10px;
        color: rgba(255, 255, 255, 0.3);
        margin-left: auto;
      }
      .hud-item-tags {
        display: flex;
        flex-wrap: wrap;
        gap: 3px;
      }
      .hud-tag-pill {
        font-size: 9px;
        font-weight: 600;
        padding: 1px 6px;
        border-radius: 10px;
        color: rgba(255, 255, 255, 0.85);
      }
      .hud-tag-pill.everyone {
        background: transparent;
        border: 1px solid rgba(255, 255, 255, 0.25);
        color: rgba(255, 255, 255, 0.6);
      }
      .hud-item-text {
        font-size: 12px;
        color: rgba(255, 255, 255, 0.75);
        line-height: 1.4;
      }
      .hud-item-deadline {
        font-size: 10px;
        color: rgba(251, 191, 36, 0.7);
      }
      .hud-item-remove {
        position: absolute;
        top: 6px;
        right: 6px;
        background: none;
        border: none;
        color: rgba(255, 255, 255, 0.2);
        cursor: pointer;
        font-size: 12px;
        padding: 0;
        line-height: 1;
        opacity: 0;
        transition: opacity 0.15s;
      }
      .hud-item:hover .hud-item-remove {
        opacity: 1;
      }
      .hud-item-remove:hover {
        color: rgba(255, 100, 100, 0.7);
      }
      .meeting-hud-input {
        display: flex;
        gap: 4px;
        padding: 8px 10px;
        border-top: 1px solid rgba(255, 255, 255, 0.08);
      }
      .meeting-hud-input input {
        flex: 1;
        background: rgba(255, 255, 255, 0.07);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 6px;
        padding: 6px 10px;
        font-size: 12px;
        color: rgba(255, 255, 255, 0.85);
        outline: none;
        font-family: inherit;
      }
      .meeting-hud-input input::placeholder {
        color: rgba(255, 255, 255, 0.3);
      }
      .meeting-hud-input input:focus {
        border-color: rgba(255, 255, 255, 0.25);
      }
      .meeting-hud-input button {
        background: rgba(96, 165, 250, 0.2);
        border: 1px solid rgba(96, 165, 250, 0.3);
        border-radius: 6px;
        color: #93bbfc;
        font-size: 11px;
        padding: 0 10px;
        cursor: pointer;
        white-space: nowrap;
      }
      .meeting-hud-input button:hover {
        background: rgba(96, 165, 250, 0.35);
      }
      .meeting-hud-agents {
        display: flex;
        flex-wrap: wrap;
        gap: 4px;
        padding: 6px 10px;
        border-top: 1px solid rgba(255, 255, 255, 0.05);
      }
      .hud-agent-toggle {
        font-size: 9px;
        padding: 2px 7px;
        border-radius: 10px;
        cursor: pointer;
        border: 1px solid rgba(255, 255, 255, 0.15);
        background: transparent;
        color: rgba(255, 255, 255, 0.45);
        transition: all 0.15s;
      }
      .hud-agent-toggle.active {
        background: rgba(96, 165, 250, 0.2);
        border-color: rgba(96, 165, 250, 0.4);
        color: #93bbfc;
      }
      .hud-agent-toggle:hover {
        border-color: rgba(255, 255, 255, 0.3);
      }
      .meeting-hud-empty {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        color: rgba(255, 255, 255, 0.25);
        font-size: 12px;
        padding: 20px;
        text-align: center;
        line-height: 1.5;
      }

      /* HUD toggle button on the preview */
      .hud-toggle-btn {
        position: absolute;
        top: 8px;
        right: 8px;
        z-index: 19;
        background: rgba(10, 10, 18, 0.5);
        backdrop-filter: blur(20px) saturate(1.3);
        -webkit-backdrop-filter: blur(20px) saturate(1.3);
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: 8px;
        color: rgba(255, 255, 255, 0.6);
        cursor: pointer;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        padding: 6px 10px;
        font-size: 11px;
        font-family: inherit;
        transition: all 0.15s;
      }
      .hud-toggle-btn:hover {
        background: rgba(20, 20, 30, 0.7);
        color: rgba(255, 255, 255, 0.85);
      }
      .hud-toggle-btn.active {
        background: rgba(96, 165, 250, 0.2);
        border-color: rgba(96, 165, 250, 0.3);
        color: #93bbfc;
      }

      /* Tag color palette (deterministic by name hash) */
      .hud-tag-0 {
        background: rgba(96, 165, 250, 0.3);
      }
      .hud-tag-1 {
        background: rgba(167, 139, 250, 0.3);
      }
      .hud-tag-2 {
        background: rgba(52, 211, 153, 0.3);
      }
      .hud-tag-3 {
        background: rgba(251, 146, 60, 0.3);
      }
      .hud-tag-4 {
        background: rgba(248, 113, 113, 0.3);
      }
      .hud-tag-5 {
        background: rgba(251, 191, 36, 0.3);
      }
      .hud-tag-6 {
        background: rgba(236, 72, 153, 0.3);
      }
      .hud-tag-7 {
        background: rgba(34, 211, 238, 0.3);
      }
      .hud-tag-8 {
        background: rgba(163, 230, 53, 0.3);
      }
      .hud-tag-9 {
        background: rgba(232, 121, 249, 0.3);
      }

      /* =====================================================
       FIGHTER PILOT HUD OVERLAY
       ===================================================== */

      :root {
        --hud-green: #5ac8fa;
        --hud-green-dim: rgba(90, 200, 250, 0.25);
        --hud-amber: #f0a030;
        --hud-amber-dim: rgba(240, 160, 48, 0.25);
        --hud-red: #ff5566;
        --hud-red-dim: rgba(255, 85, 102, 0.25);
        --hud-cyan: #7cc4e8;
        --hud-cyan-dim: rgba(124, 196, 232, 0.15);
        --hud-text: rgba(230, 235, 240, 0.85);
        --hud-text-dim: rgba(180, 190, 200, 0.5);
        --hud-font: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        --hud-font-mono: 'JetBrains Mono', 'SF Mono', 'Fira Code', monospace;
        --hud-border: rgba(200, 210, 220, 0.15);
      }

      /* Hide old controls when HUD is active */
      .hud-active .controls-bar,
      .hud-active .mode-tabs,
      .hud-active .space-selector-bar,
      .hud-active .shortcuts-bar,
      .hud-active .bottom-panel,
      .hud-active .audio-meter,
      .hud-active .hud-toggle-btn {
        display: none !important;
      }

      .hud-active .main-layout {
        grid-template-rows: 1fr;
        height: calc(100vh - 36px);
      }

      .hud-active .preview-wrapper {
        height: 100%;
      }

      .hud-active .preview-container {
        height: 100%;
        border-radius: 0;
      }

      /* HUD Overlay Container */
      .pilot-hud {
        position: absolute;
        inset: 0;
        pointer-events: none;
        z-index: 50;
        font-family: var(--hud-font);
        font-size: 11px;
        font-weight: 400;
        letter-spacing: 0.3px;
        color: var(--hud-text);
        overflow: hidden;
      }

      .pilot-hud * {
        pointer-events: none;
      }

      /* Corner Indicators (subtle) */
      .hud-corner {
        display: none;
      }

      /* Top Bar */
      .hud-top {
        position: absolute;
        top: 12px;
        left: 48px;
        right: 48px;
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
      }

      .hud-top-left,
      .hud-top-right {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      .hud-top-right {
        align-items: flex-end;
      }

      /* Bottom Bar */
      .hud-bottom {
        position: absolute;
        bottom: 12px;
        left: 48px;
        right: 48px;
        display: flex;
        justify-content: space-between;
        align-items: flex-end;
      }

      .hud-bottom-left,
      .hud-bottom-right {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      .hud-bottom-right {
        align-items: flex-end;
      }

      /* Left Edge */
      .hud-left {
        position: absolute;
        top: 50%;
        left: 12px;
        transform: translateY(-50%);
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        gap: 6px;
      }

      /* Right Edge */
      .hud-right {
        position: absolute;
        top: 50%;
        right: 12px;
        transform: translateY(-50%);
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        gap: 6px;
      }

      /* HUD Readout Items */
      .hud-item {
        display: flex;
        align-items: center;
        gap: 6px;
        line-height: 1;
        white-space: nowrap;
        background: rgba(10, 10, 18, 0.45);
        backdrop-filter: blur(16px) saturate(1.2);
        -webkit-backdrop-filter: blur(16px) saturate(1.2);
        padding: 3px 8px;
        border-radius: 6px;
        border: 1px solid rgba(255, 255, 255, 0.06);
      }

      .hud-label {
        color: var(--hud-text-dim);
        font-size: 10px;
        text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
      }
      .hud-value {
        color: var(--hud-text);
        font-weight: 500;
        font-family: var(--hud-font-mono);
        text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
      }

      .hud-value.nominal {
        color: var(--hud-green);
      }
      .hud-value.warning {
        color: var(--hud-amber);
      }
      .hud-value.critical {
        color: var(--hud-red);
      }

      /* Recording Indicator */
      .hud-rec {
        display: none;
        align-items: center;
        gap: 6px;
        font-weight: 600;
        font-size: 13px;
        color: var(--hud-red);
        text-shadow: 0 1px 4px rgba(0, 0, 0, 0.6);
        background: rgba(10, 10, 18, 0.5);
        backdrop-filter: blur(16px);
        -webkit-backdrop-filter: blur(16px);
        padding: 4px 10px;
        border-radius: 8px;
        border: 1px solid rgba(255, 85, 102, 0.2);
      }

      .hud-rec.active {
        display: flex;
      }

      .hud-rec-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: var(--hud-red);
        animation: hud-rec-pulse 1.2s ease-in-out infinite;
      }

      @keyframes hud-rec-pulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.2;
        }
      }

      /* Audio Level Meter (vertical) */
      .hud-audio-meter {
        display: flex;
        flex-direction: column-reverse;
        gap: 2px;
        height: 60px;
        width: 6px;
      }

      .hud-audio-bar {
        flex: 1;
        background: var(--hud-green-dim);
        border-radius: 1px;
        transition: background 0.08s;
      }

      .hud-audio-bar.active {
        background: var(--hud-green);
      }
      .hud-audio-bar.peak {
        background: var(--hud-amber);
      }
      .hud-audio-bar.clip {
        background: var(--hud-red);
      }

      /* Status Dot */
      .hud-dot {
        width: 6px;
        height: 6px;
        border-radius: 50%;
        display: inline-block;
        flex-shrink: 0;
      }

      .hud-dot.green {
        background: var(--hud-green);
      }
      .hud-dot.amber {
        background: var(--hud-amber);
      }
      .hud-dot.red {
        background: var(--hud-red);
      }
      .hud-dot.off {
        background: var(--hud-text-dim);
      }

      /* Warning Banner */
      .hud-warning {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        padding: 8px 20px;
        border: 1px solid var(--hud-amber);
        background: rgba(10, 10, 18, 0.5);
        backdrop-filter: blur(20px) saturate(1.3);
        -webkit-backdrop-filter: blur(20px) saturate(1.3);
        color: var(--hud-amber);
        font-size: 13px;
        font-weight: 500;
        font-family: var(--hud-font);
        letter-spacing: 0.5px;
        border-radius: 6px;
        opacity: 0;
        transition: opacity 0.3s;
        pointer-events: none;
        z-index: 55;
        text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
      }

      .hud-warning.visible {
        opacity: 1;
      }
      .hud-warning.critical {
        border-color: var(--hud-red);
        color: var(--hud-red);
        background: rgba(255, 85, 102, 0.1);
      }

      /* Hidden State (context menu overrides) */
      .hud-hidden {
        display: none !important;
      }

      /* =====================================================
       CONTEXT MENU (HUD STYLE)
       ===================================================== */

      .ctx-overlay {
        position: fixed;
        inset: 0;
        z-index: 200;
        background: rgba(0, 0, 0, 0.5);
        opacity: 0;
        visibility: hidden;
        transition:
          opacity 0.2s,
          visibility 0.2s;
      }

      .ctx-overlay.open {
        opacity: 1;
        visibility: visible;
      }

      .ctx-panel {
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        width: 380px;
        max-width: 100vw;
        background: rgba(20, 22, 28, 0.92);
        backdrop-filter: blur(20px);
        border-left: 1px solid var(--hud-border);
        font-family: var(--hud-font);
        color: var(--hud-text);
        display: flex;
        flex-direction: column;
        transform: translateX(100%);
        transition: transform 0.25s cubic-bezier(0.4, 0, 0.2, 1);
        overflow: hidden;
      }

      .ctx-overlay.open .ctx-panel {
        transform: translateX(0);
      }

      .ctx-header {
        padding: 16px 20px 12px;
        border-bottom: 1px solid var(--hud-border);
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-shrink: 0;
      }

      .ctx-title {
        font-size: 12px;
        font-weight: 600;
        letter-spacing: 0.5px;
        color: var(--hud-text-dim);
      }

      .ctx-close {
        background: none;
        border: 1px solid var(--hud-border);
        border-radius: 4px;
        color: var(--hud-text-dim);
        font-family: var(--hud-font);
        font-size: 10px;
        padding: 4px 10px;
        cursor: pointer;
        letter-spacing: 0.3px;
        transition: all 0.15s;
      }

      .ctx-close:hover {
        color: var(--hud-text);
        border-color: var(--hud-text-dim);
      }

      /* Tabs (Controls / Transcript) */
      .ctx-tabs {
        display: flex;
        border-bottom: 1px solid var(--hud-border);
        flex-shrink: 0;
      }

      .ctx-tab {
        flex: 1;
        padding: 10px;
        background: none;
        border: none;
        color: var(--hud-text-dim);
        font-family: var(--hud-font);
        font-size: 11px;
        letter-spacing: 0.3px;
        cursor: pointer;
        border-bottom: 2px solid transparent;
        transition: all 0.15s;
      }

      .ctx-tab:hover {
        color: var(--hud-text);
      }
      .ctx-tab.active {
        color: var(--hud-green);
        border-bottom-color: var(--hud-green);
      }

      /* Scrollable Content */
      .ctx-body {
        flex: 1;
        overflow-y: auto;
        padding: 12px 0;
      }

      .ctx-body::-webkit-scrollbar {
        width: 4px;
      }
      .ctx-body::-webkit-scrollbar-track {
        background: transparent;
      }
      .ctx-body::-webkit-scrollbar-thumb {
        background: var(--hud-border);
        border-radius: 2px;
      }

      /* Section */
      .ctx-section {
        padding: 0 20px;
        margin-bottom: 16px;
      }

      .ctx-section-label {
        font-size: 10px;
        letter-spacing: 0.3px;
        color: var(--hud-text-dim);
        font-weight: 600;
        margin-bottom: 8px;
        padding-bottom: 4px;
        border-bottom: 1px solid rgba(200, 210, 220, 0.08);
      }

      .ctx-divider {
        padding: 0 20px !important;
        margin: 4px 0 !important;
        border-top: 1px solid rgba(200, 210, 220, 0.1);
        min-height: 0;
      }

      /* Menu Item */
      .ctx-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 10px 12px;
        margin: 2px 0;
        cursor: pointer;
        border: 1px solid transparent;
        transition: all 0.12s;
        font-size: 12px;
        letter-spacing: 0.5px;
        pointer-events: auto;
      }

      .ctx-item:hover {
        background: rgba(200, 210, 220, 0.06);
        border-color: var(--hud-border);
      }

      .ctx-item:active {
        background: rgba(200, 210, 220, 0.1);
      }

      .ctx-item-label {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .ctx-item-state {
        font-size: 10px;
        color: var(--hud-text-dim);
        letter-spacing: 1px;
      }

      .ctx-item-state.on {
        color: var(--hud-green);
      }
      .ctx-item-state.off {
        color: var(--hud-red);
      }
      .ctx-item-state.amber {
        color: var(--hud-amber);
      }

      .ctx-item.danger {
        color: var(--hud-red);
      }
      .ctx-item.danger:hover {
        background: rgba(255, 51, 68, 0.08);
        border-color: rgba(255, 51, 68, 0.2);
      }

      .ctx-item.record-active {
        color: var(--hud-red);
      }

      /* Submenu Arrow */
      .ctx-arrow {
        font-size: 10px;
        color: var(--hud-text-dim);
        margin-left: 8px;
      }

      /* Slider Row */
      .ctx-slider-row {
        padding: 6px 12px;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .ctx-slider-row label {
        font-size: 10px;
        color: var(--hud-text-dim);
        min-width: 50px;
        letter-spacing: 1px;
      }

      .ctx-slider-row input[type='range'] {
        flex: 1;
        height: 3px;
        -webkit-appearance: none;
        background: var(--hud-border);
        border-radius: 2px;
        outline: none;
      }

      .ctx-slider-row input[type='range']::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background: var(--hud-green);
        cursor: pointer;
      }

      .ctx-slider-row .ctx-slider-val {
        font-size: 10px;
        color: var(--hud-text);
        min-width: 32px;
        text-align: right;
      }

      /* Submenu Panel */
      .ctx-submenu {
        display: none;
        flex-direction: column;
      }

      .ctx-submenu.open {
        display: flex;
      }

      .ctx-sub-back {
        padding: 8px 12px;
        cursor: pointer;
        color: var(--hud-cyan);
        font-size: 11px;
        letter-spacing: 0.3px;
        border-bottom: 1px solid var(--hud-border);
        margin-bottom: 8px;
      }

      .ctx-sub-back:hover {
        background: rgba(200, 210, 220, 0.06);
      }

      .ctx-sub-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 8px 12px;
        cursor: pointer;
        font-size: 11px;
        transition: background 0.12s;
      }

      .ctx-sub-item:hover {
        background: rgba(200, 210, 220, 0.06);
      }
      .ctx-sub-item .ctx-check {
        color: var(--hud-green);
        margin-right: 8px;
      }

      /* =====================================================
       TRANSCRIPT PANEL
       ===================================================== */

      .ctx-transcript {
        display: none;
        flex-direction: column;
        flex: 1;
        overflow: hidden;
      }

      .ctx-transcript.active {
        display: flex;
      }

      .ctx-transcript-actions {
        display: flex;
        gap: 8px;
        padding: 8px 20px;
        border-bottom: 1px solid var(--hud-border);
        flex-shrink: 0;
      }

      .ctx-transcript-btn {
        background: none;
        border: 1px solid var(--hud-border);
        color: var(--hud-text-dim);
        font-family: var(--hud-font);
        font-size: 10px;
        padding: 4px 12px;
        cursor: pointer;
        letter-spacing: 0.3px;
        transition: all 0.15s;
        pointer-events: auto;
      }

      .ctx-transcript-btn:hover {
        color: var(--hud-text);
        border-color: var(--hud-text-dim);
      }

      .ctx-transcript-editor {
        flex: 1;
        padding: 12px 20px;
        background: transparent;
        border: none;
        color: var(--hud-text);
        font-family: var(--hud-font-mono);
        font-size: 11px;
        line-height: 1.7;
        resize: none;
        outline: none;
        overflow-y: auto;
        pointer-events: auto;
      }

      .ctx-transcript-editor::placeholder {
        color: var(--hud-text-dim);
        font-style: italic;
      }

      .ctx-transcript-editor::-webkit-scrollbar {
        width: 4px;
      }
      .ctx-transcript-editor::-webkit-scrollbar-track {
        background: transparent;
      }
      .ctx-transcript-editor::-webkit-scrollbar-thumb {
        background: var(--hud-border);
        border-radius: 2px;
      }

      .ctx-transcript-add {
        display: flex;
        gap: 6px;
        padding: 8px 20px;
        border-top: 1px solid var(--hud-border);
        flex-shrink: 0;
      }

      .ctx-transcript-input {
        flex: 1;
        background: rgba(200, 210, 220, 0.06);
        border: 1px solid var(--hud-border);
        color: var(--hud-text);
        font-family: var(--hud-font);
        font-size: 11px;
        padding: 6px 10px;
        outline: none;
        pointer-events: auto;
      }

      .ctx-transcript-input:focus {
        border-color: var(--hud-green-dim);
      }

      .ctx-transcript-input::placeholder {
        color: var(--hud-text-dim);
      }

      /* Mobile adjustments */
      @media (max-width: 600px) {
        .ctx-panel {
          width: 100vw;
        }
        .pilot-hud {
          font-size: 9px;
        }
        .hud-corner {
          width: 20px;
          height: 20px;
        }
      }
    </style>
    <!-- LiveKit Client SDK (SFU for WISER Meeting)  loaded locally for CSP compliance -->
    <script src="./node_modules/livekit-client/dist/livekit-client.umd.js"></script>
    <!-- Import map: resolve bare specifiers used inside @livekit/track-processors ESM -->
    <script type="importmap">
      {
        "imports": {
          "livekit-client": "./node_modules/livekit-client/dist/livekit-client.esm.mjs",
          "@mediapipe/tasks-vision": "./node_modules/@mediapipe/tasks-vision/vision_bundle.mjs"
        }
      }
    </script>
    <!-- Track processors for virtual backgrounds (ESM, loaded async) -->
    <script type="module">
      try {
        const { BackgroundProcessor, supportsBackgroundProcessors } =
          await import('./node_modules/@livekit/track-processors/dist/index.mjs');
        window._BgProcessor = BackgroundProcessor;
        window._supportsBg = supportsBackgroundProcessors;
        console.log('[BG] Track processors loaded, supported:', supportsBackgroundProcessors());
      } catch (err) {
        console.error('[BG] Failed to load track processors:', err);
        window._BgProcessor = null;
        window._supportsBg = () => false;
      }
    </script>
  </head>
  <body>
    <!-- Header -->
    <div class="header">
      <div class="header-title">
        <svg class="title-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
          <circle cx="12" cy="12" r="10" />
          <circle cx="12" cy="12" r="3" fill="currentColor" />
        </svg>
        WISER Meeting
      </div>
      <div class="header-actions">
        <button class="header-btn" onclick="app.minimize()" title="Minimize">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M5 12h14" />
          </svg>
        </button>
        <button class="header-btn close-btn" onclick="app.close()" title="Close">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M18 6L6 18M6 6l12 12" />
          </svg>
        </button>
      </div>
    </div>

    <!-- Main Layout -->
    <div class="main-layout">
      <!-- Preview Area -->
      <div class="preview-wrapper">
        <div class="preview-container" id="previewContainer">
          <video id="previewVideo" autoplay muted playsinline></video>
          <video id="reviewVideo" style="display: none" controls></video>

          <div class="preview-placeholder" id="previewPlaceholder">
            <div class="placeholder-icon">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z" />
                <circle cx="12" cy="13" r="4" />
              </svg>
            </div>
            <span>Select a source to begin</span>
            <div class="shortcut-hint">Press <kbd>Space</kbd> to start recording</div>
          </div>

          <div class="permission-overlay hidden" id="permissionOverlay">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
              <rect x="3" y="11" width="18" height="11" rx="2" ry="2" />
              <path d="M7 11V7a5 5 0 0 1 10 0v4" />
            </svg>
            <p>Camera and microphone access required</p>
            <button class="permission-btn" onclick="app.requestPermissions()">Grant Access</button>
          </div>

          <div class="recording-indicator" id="recordingIndicator">
            <div class="recording-dot"></div>
            <span>REC</span>
          </div>

          <!-- Paused Overlay -->
          <div class="paused-overlay" id="pausedOverlay">
            <svg class="paused-overlay-icon" viewBox="0 0 24 24" fill="currentColor" stroke="none">
              <rect x="6" y="4" width="4" height="16" rx="1" />
              <rect x="14" y="4" width="4" height="16" rx="1" />
            </svg>
            <div class="paused-overlay-text">Paused</div>
            <div class="paused-overlay-hint">Audio muted. Click resume to continue.</div>
          </div>

          <!-- Live Caption Overlay -->
          <div class="caption-overlay" id="captionOverlay">
            <div class="caption-text" id="captionText"></div>
          </div>

          <!-- Monitor Alert Toasts -->
          <div class="monitor-alert-container" id="monitorAlertContainer"></div>

          <!-- Transcription Status -->
          <div class="transcription-status" id="transcriptionStatus">
            <div class="status-dot"></div>
            <span id="transcriptionStatusText">Transcribing...</span>
          </div>

          <div class="duration-display" id="durationDisplay">
            <span id="currentDuration">00:00</span>
            <span class="target" id="targetDuration"></span>
          </div>

          <!-- Countdown Overlay -->
          <div class="countdown-overlay" id="countdownOverlay">
            <div class="countdown-number" id="countdownNumber">3</div>
          </div>

          <!-- FIGHTER PILOT HUD OVERLAY -->
          <div class="pilot-hud" id="pilotHud">
            <!-- Corner Brackets -->
            <div class="hud-corner tl"></div>
            <div class="hud-corner tr"></div>
            <div class="hud-corner bl"></div>
            <div class="hud-corner br"></div>

            <!-- Top Left: Recording + Mode -->
            <div class="hud-top">
              <div class="hud-top-left">
                <div class="hud-rec" id="hudRec">
                  <div class="hud-rec-dot"></div>
                  <span>REC</span>
                  <span id="hudRecTime">00:00:00</span>
                </div>
                <div class="hud-item" id="hudMode">
                  <span class="hud-value">CAMERA</span>
                </div>
              </div>
              <div class="hud-top-right">
                <div class="hud-item">
                  <span class="hud-value" id="hudClock">--:--:--</span>
                </div>
                <div class="hud-item" id="hudRoomName" style="display: none">
                  <span class="hud-label">ROOM</span>
                  <span class="hud-value" id="hudRoomValue">--</span>
                </div>
              </div>
            </div>

            <!-- Left Edge: Audio + Mic Status -->
            <div class="hud-left">
              <div class="hud-audio-meter" id="hudAudioMeter">
                <div class="hud-audio-bar"></div>
                <div class="hud-audio-bar"></div>
                <div class="hud-audio-bar"></div>
                <div class="hud-audio-bar"></div>
                <div class="hud-audio-bar"></div>
                <div class="hud-audio-bar"></div>
                <div class="hud-audio-bar"></div>
                <div class="hud-audio-bar"></div>
              </div>
              <div class="hud-item" id="hudMicStatus">
                <span class="hud-dot green" id="hudMicDot"></span>
                <span class="hud-value nominal" id="hudMicLabel">MIC LIVE</span>
              </div>
              <div class="hud-item" id="hudBgStatus">
                <span class="hud-label">BG</span>
                <span class="hud-value" id="hudBgValue">NONE</span>
              </div>
            </div>

            <!-- Right Edge: Camera + Captions + Net -->
            <div class="hud-right">
              <div class="hud-item" id="hudCamStatus">
                <span class="hud-value nominal" id="hudCamLabel">CAM ACTIVE</span>
                <span class="hud-dot green" id="hudCamDot"></span>
              </div>
              <div class="hud-item" id="hudCcStatus">
                <span class="hud-value" id="hudCcLabel">CC OFF</span>
                <span class="hud-dot off" id="hudCcDot"></span>
              </div>
              <div class="hud-item" id="hudNetStatus" style="display: none">
                <span class="hud-value nominal" id="hudNetLabel">NET STRONG</span>
                <span class="hud-dot green" id="hudNetDot"></span>
              </div>
              <div class="hud-item" id="hudCpuStatus" style="display: none">
                <span class="hud-label">CPU</span>
                <span class="hud-value" id="hudCpuValue">--%</span>
              </div>
            </div>

            <!-- Bottom Left: Participants + Speaker -->
            <div class="hud-bottom">
              <div class="hud-bottom-left">
                <div class="hud-item" id="hudParticipants" style="display: none">
                  <span class="hud-label">PARTICIPANTS</span>
                  <span class="hud-value" id="hudParticipantCount">0</span>
                </div>
                <div class="hud-item" id="hudSpeaker" style="display: none">
                  <span class="hud-label">SPEAKING</span>
                  <span class="hud-value" id="hudSpeakerName">--</span>
                </div>
              </div>
              <div class="hud-bottom-right">
                <div class="hud-item">
                  <span class="hud-label">SPACE</span>
                  <span class="hud-value" id="hudSpaceName">--</span>
                </div>
              </div>
            </div>

            <!-- Center Warning Banner -->
            <div class="hud-warning" id="hudWarning"></div>
          </div>

          <!-- CONTEXT MENU -->
          <div class="ctx-overlay" id="ctxOverlay">
            <div class="ctx-panel" id="ctxPanel">
              <div class="ctx-header">
                <span class="ctx-title">Controls</span>
                <button class="ctx-close" onclick="app.closeContextMenu()">ESC</button>
              </div>

              <div class="ctx-tabs">
                <button class="ctx-tab active" id="ctxTabControls" onclick="app.switchCtxTab('controls')">
                  Controls
                </button>
                <button class="ctx-tab" id="ctxTabTranscript" onclick="app.switchCtxTab('transcript')">
                  Transcript
                </button>
              </div>

              <!-- CONTROLS TAB -->
              <div class="ctx-body" id="ctxControls">
                <!-- ========== COMMON ACTIONS (top) ========== -->

                <!-- Recording -->
                <div class="ctx-section">
                  <div class="ctx-section-label">Recording</div>
                  <div class="ctx-item" id="ctxRecord" onclick="app.ctxAction('toggleRecording')">
                    <span class="ctx-item-label"
                      ><span class="hud-dot red" id="ctxRecDot" style="display: none"></span> Record</span
                    >
                    <span class="ctx-item-state" id="ctxRecState">READY</span>
                  </div>
                  <div class="ctx-item" id="ctxPause" onclick="app.ctxAction('togglePause')" style="display: none">
                    <span class="ctx-item-label">Pause</span>
                    <span class="ctx-item-state" id="ctxPauseState">--</span>
                  </div>
                </div>

                <!-- Quick Toggles: Mic, Camera, Captions -->
                <div class="ctx-section">
                  <div class="ctx-section-label">Quick Toggles</div>
                  <div class="ctx-item" onclick="app.ctxAction('toggleMuteMic')">
                    <span class="ctx-item-label">Microphone</span>
                    <span class="ctx-item-state on" id="ctxMicState">LIVE</span>
                  </div>
                  <div class="ctx-item" onclick="app.ctxAction('toggleCameraOff')">
                    <span class="ctx-item-label">Camera</span>
                    <span class="ctx-item-state on" id="ctxCamState">ACTIVE</span>
                  </div>
                  <div class="ctx-item" onclick="app.ctxAction('toggleCaptions')">
                    <span class="ctx-item-label">Live Captions</span>
                    <span class="ctx-item-state" id="ctxCcState">OFF</span>
                  </div>
                </div>

                <!-- Meeting -->
                <div class="ctx-section">
                  <div class="ctx-section-label">Meeting</div>
                  <div class="ctx-item" id="ctxMeetingToggle" onclick="app.ctxAction('meetingToggle')">
                    <span class="ctx-item-label">Start Meeting</span>
                    <span class="ctx-item-state" id="ctxMeetingState">OFFLINE</span>
                  </div>
                  <div class="ctx-item" id="ctxCopyLink" onclick="app.ctxCopyJoinLink()" style="display: none">
                    <span class="ctx-item-label">Copy Join Link</span>
                    <span class="ctx-item-state" id="ctxCopyState">COPY</span>
                  </div>
                  <div
                    id="ctxJoinLinkPreview"
                    style="
                      display: none;
                      padding: 4px 12px 8px;
                      font-size: 9px;
                      font-family: var(--hud-font, monospace);
                      color: var(--hud-green, #0f0);
                      word-break: break-all;
                      line-height: 1.3;
                      opacity: 0.7;
                      cursor: pointer;
                    "
                    onclick="app.ctxCopyJoinLink()"
                  ></div>
                  <div
                    class="ctx-item"
                    id="ctxParticipantsList"
                    onclick="app.ctxOpenSub('participants')"
                    style="display: none"
                  >
                    <span class="ctx-item-label">Participants</span>
                    <span class="ctx-arrow">&rsaquo;</span>
                  </div>
                </div>

                <!-- Space -->
                <div class="ctx-section">
                  <div class="ctx-section-label">Space</div>
                  <div class="ctx-item" onclick="app.ctxOpenSub('spaces')">
                    <span class="ctx-item-label">Save To</span>
                    <span class="ctx-item-state" id="ctxSpaceState">--</span>
                  </div>
                </div>

                <!-- After Recording -->
                <div class="ctx-section" id="ctxPostSection" style="display: none">
                  <div class="ctx-section-label">Recording Complete</div>
                  <div class="ctx-item" onclick="app.ctxAction('showSaveDialog')">
                    <span class="ctx-item-label">Save Recording</span>
                  </div>
                  <div class="ctx-item" onclick="app.ctxAction('discardRecording')">
                    <span class="ctx-item-label">Discard</span>
                    <span class="ctx-item-state critical">DESTRUCTIVE</span>
                  </div>
                  <div class="ctx-item" onclick="app.ctxAction('recordAgain')">
                    <span class="ctx-item-label">Record Again</span>
                  </div>
                </div>

                <!-- Clear -->
                <div class="ctx-section">
                  <div class="ctx-section-label">Actions</div>
                  <div class="ctx-item" onclick="app.ctxCopyTranscript()">
                    <span class="ctx-item-label">Copy Transcript</span>
                    <span class="ctx-item-state" id="ctxCopyTranscriptState">COPY</span>
                  </div>
                  <div class="ctx-item" onclick="app.ctxAction('clearTranscript')">
                    <span class="ctx-item-label">Clear Transcript</span>
                    <span class="ctx-item-state" id="ctxClearState">CLEAR</span>
                  </div>
                </div>

                <!-- ========== SETUP / SETTINGS (bottom) ========== -->

                <div class="ctx-section ctx-divider"></div>

                <!-- Sources -->
                <div class="ctx-section">
                  <div class="ctx-section-label">Sources</div>
                  <div class="ctx-item" onclick="app.ctxOpenSub('cameraSources')">
                    <span class="ctx-item-label">Camera Source</span>
                    <span class="ctx-arrow">&rsaquo;</span>
                  </div>
                  <div class="ctx-item" onclick="app.ctxOpenSub('micSources')">
                    <span class="ctx-item-label">Microphone Source</span>
                    <span class="ctx-arrow">&rsaquo;</span>
                  </div>
                </div>

                <!-- Audio Mixer -->
                <div class="ctx-section" id="ctxMixerSection">
                  <div class="ctx-section-label">Audio Mixer</div>
                  <div class="ctx-slider-row">
                    <label>MIC</label>
                    <input
                      type="range"
                      min="0"
                      max="150"
                      value="100"
                      id="ctxMicVol"
                      oninput="app.ctxUpdateMicVol(this.value)"
                    />
                    <span class="ctx-slider-val" id="ctxMicVolVal">100%</span>
                  </div>
                  <div class="ctx-slider-row" id="ctxDesktopVolRow" style="display: none">
                    <label>DESKTOP</label>
                    <input
                      type="range"
                      min="0"
                      max="150"
                      value="100"
                      id="ctxDesktopVol"
                      oninput="app.ctxUpdateDesktopVol(this.value)"
                    />
                    <span class="ctx-slider-val" id="ctxDesktopVolVal">100%</span>
                  </div>
                </div>

                <!-- Screen -->
                <div class="ctx-section">
                  <div class="ctx-section-label">Screen</div>
                  <div class="ctx-item" onclick="app.ctxAction('switchMode', 'screen')">
                    <span class="ctx-item-label">Share Screen</span>
                    <span class="ctx-item-state" id="ctxScreenState">OFF</span>
                  </div>
                  <div class="ctx-item" onclick="app.ctxAction('switchMode', 'both')">
                    <span class="ctx-item-label">Screen + Camera</span>
                    <span class="ctx-item-state" id="ctxBothState">OFF</span>
                  </div>
                </div>

                <!-- Background -->
                <div class="ctx-section">
                  <div class="ctx-section-label">Background</div>
                  <div class="ctx-item" onclick="app.ctxSetBg('none')">
                    <span class="ctx-item-label">None</span>
                    <span class="ctx-item-state on" id="ctxBgNone">[X]</span>
                  </div>
                  <div class="ctx-item" onclick="app.ctxSetBg('blur')">
                    <span class="ctx-item-label">Blur</span>
                    <span class="ctx-item-state" id="ctxBgBlur">[ ]</span>
                  </div>
                  <div class="ctx-slider-row" id="ctxBlurRadiusRow" style="display: none">
                    <label>RADIUS</label>
                    <input
                      type="range"
                      min="1"
                      max="20"
                      value="10"
                      id="ctxBlurRadius"
                      oninput="
                        document.getElementById('ctxBlurRadiusVal').textContent = this.value;
                        app.updateBlurRadius(this.value);
                      "
                    />
                    <span class="ctx-slider-val" id="ctxBlurRadiusVal">10</span>
                  </div>
                  <div class="ctx-item" onclick="app.ctxSetBg('image')">
                    <span class="ctx-item-label">Custom Image</span>
                    <span class="ctx-item-state" id="ctxBgImage">[ ]</span>
                  </div>
                </div>

                <!-- Settings -->
                <div class="ctx-section">
                  <div class="ctx-section-label">System</div>
                  <div class="ctx-item" onclick="app.ctxAction('toggleSettings')">
                    <span class="ctx-item-label">Settings</span>
                  </div>
                </div>
              </div>
              <!-- /ctx-body controls -->

              <!-- TRANSCRIPT TAB -->
              <div class="ctx-transcript" id="ctxTranscript">
                <div class="ctx-transcript-actions">
                  <button class="ctx-transcript-btn" onclick="app.ctxCopyTranscript()">COPY</button>
                  <button class="ctx-transcript-btn" onclick="app.ctxDownloadTranscript()">DOWNLOAD</button>
                </div>
                <textarea
                  class="ctx-transcript-editor"
                  id="ctxTranscriptEditor"
                  placeholder="Transcript will appear here when recording starts...&#10;&#10;You can type notes at any time."
                ></textarea>
                <div class="ctx-transcript-add">
                  <input
                    type="text"
                    class="ctx-transcript-input"
                    id="ctxTranscriptNote"
                    placeholder="Add a note..."
                    onkeydown="if (event.key === 'Enter') app.ctxAddNote();"
                  />
                </div>
              </div>

              <!-- SUBMENU PANELS (shared, slide in) -->
              <div class="ctx-submenu" id="ctxSubCameraSources">
                <div class="ctx-sub-back" onclick="app.ctxCloseSub()">&lsaquo; BACK</div>
                <div id="ctxCameraList"></div>
              </div>
              <div class="ctx-submenu" id="ctxSubMicSources">
                <div class="ctx-sub-back" onclick="app.ctxCloseSub()">&lsaquo; BACK</div>
                <div id="ctxMicList"></div>
              </div>
              <div class="ctx-submenu" id="ctxSubParticipants">
                <div class="ctx-sub-back" onclick="app.ctxCloseSub()">&lsaquo; BACK</div>
                <div id="ctxParticipantList"></div>
              </div>
              <div class="ctx-submenu" id="ctxSubSpaces">
                <div class="ctx-sub-back" onclick="app.ctxCloseSub()">&lsaquo; BACK</div>
                <div id="ctxSpaceList"></div>
              </div>
            </div>
            <!-- /ctx-panel -->
          </div>
          <!-- /ctx-overlay -->

          <!-- Audio Level Meter -->
          <div class="audio-meter" id="audioMeter">
            <div class="audio-meter-bar"></div>
            <div class="audio-meter-bar"></div>
            <div class="audio-meter-bar"></div>
            <div class="audio-meter-bar"></div>
            <div class="audio-meter-bar"></div>
            <div class="audio-meter-bar"></div>
            <div class="audio-meter-bar"></div>
            <div class="audio-meter-bar"></div>
            <div class="audio-meter-bar"></div>
            <div class="audio-meter-bar"></div>
            <div class="audio-meter-bar"></div>
            <div class="audio-meter-bar"></div>
          </div>

          <!-- Meeting HUD Toggle Button -->
          <button class="hud-toggle-btn" id="hudToggleBtn" onclick="app.toggleMeetingHUD()" title="Meeting HUD">
            Meeting
          </button>

          <!-- Meeting HUD Overlay (glass panel) -->
          <div class="meeting-hud hidden" id="meetingHUD">
            <div class="meeting-hud-header">
              <span>Meeting</span>
              <span class="hud-count" id="hudItemCount">0 items</span>
              <button class="meeting-hud-toggle" onclick="app.toggleMeetingHUD()" title="Close HUD">&times;</button>
            </div>

            <div class="meeting-hud-items" id="hudItemList">
              <div class="meeting-hud-empty" id="hudEmptyState">
                Type or speak to add action items, decisions, and notes
              </div>
            </div>

            <div class="meeting-hud-input">
              <input
                type="text"
                id="hudInput"
                placeholder="Add item or @mention..."
                autocomplete="off"
                spellcheck="false"
                onkeydown="if (event.key === 'Enter') app.submitHUDItem();"
              />
              <button onclick="app.submitHUDItem()">Add</button>
            </div>

            <div class="meeting-hud-agents" id="hudAgentToggles">
              <!-- Agent toggles populated by JS -->
            </div>
          </div>

          <!-- Session: Setup Panel (Host or Join) -->
          <div class="session-setup" id="sessionSetup">
            <div class="session-setup-title">Start a WISER Meeting</div>
            <div class="session-setup-subtitle">Record with another person -- each side records at full quality</div>
            <div style="margin: 0 auto 16px; max-width: 280px">
              <input
                type="text"
                id="hostNameInput"
                placeholder="Your name"
                autocomplete="name"
                autocapitalize="words"
                spellcheck="false"
                style="
                  width: 100%;
                  padding: 10px 14px;
                  background: var(--bg-elevated, #1a1a2e);
                  border: 1px solid rgba(255, 255, 255, 0.1);
                  border-radius: 8px;
                  color: #fff;
                  font-size: 15px;
                  font-family: inherit;
                  text-align: center;
                "
              />
            </div>
            <div class="session-space-selector">
              <label>Save recording to</label>
              <select id="sessionSpaceSelect" onchange="app.onSessionSpaceChange()">
                <option value="">Select a space...</option>
              </select>
            </div>
            <div class="session-actions">
              <div class="session-action-card" onclick="app.sessionHost()">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                  <polygon points="23 7 16 12 23 17 23 7" />
                  <rect x="1" y="5" width="15" height="14" rx="2" ry="2" />
                </svg>
                <span class="card-title">Host Session</span>
                <span class="card-desc">Create a room and invite someone</span>
              </div>
              <div class="session-action-card" onclick="app.sessionShowJoin()">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                  <path d="M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4" />
                  <polyline points="10 17 15 12 10 7" />
                  <line x1="15" y1="12" x2="3" y2="12" />
                </svg>
                <span class="card-title">Join Session</span>
                <span class="card-desc">Enter a code to connect</span>
              </div>
            </div>
          </div>

          <!-- Session: Host Waiting -->
          <div class="session-host-waiting" id="sessionHostWaiting">
            <div class="session-setup-title">Invite someone to join</div>

            <!-- Code word -- click copies join link (or code+address as fallback) -->
            <div style="text-align: center; width: 100%; max-width: 400px">
              <div
                class="session-code-display"
                id="sessionCodeDisplay"
                onclick="app.copySessionCode()"
                style="cursor: pointer"
              >
                ---
                <span class="copy-hint" id="codeCopyHint">Click to copy invite</span>
              </div>
            </div>

            <!-- Join link shown below code word when available -->
            <div
              id="publicJoinSection"
              style="display: none; width: 100%; max-width: 400px; text-align: center; margin-top: -8px"
            >
              <div
                id="publicJoinUrl"
                style="
                  font-size: 11px;
                  font-family: var(--font-mono, monospace);
                  color: var(--text-muted);
                  word-break: break-all;
                  line-height: 1.4;
                  padding: 0 8px;
                  cursor: pointer;
                "
                onclick="app.copySessionCode()"
                title="Click to copy"
              >
                ---
              </div>
            </div>

            <!-- LAN address (small, secondary) -->
            <div
              class="session-host-address"
              id="sessionHostAddress"
              style="
                font-size: 12px;
                color: var(--text-muted);
                font-family: var(--font-mono, monospace);
                letter-spacing: 0.5px;
                cursor: pointer;
                margin-top: 4px;
              "
              onclick="app.copySessionCode()"
              title="Click to copy"
            >
              ---
            </div>

            <div class="waiting-text" id="waitingText">
              <div class="waiting-dot"></div>
              Waiting for guest to join...
            </div>

            <!-- Guest activity (shown when guest starts joining) -->
            <div class="guest-activity" id="guestActivity">
              <div class="guest-activity-title" id="guestActivityTitle">
                <div class="waiting-dot"></div>
                A guest is connecting...
              </div>
              <div class="guest-activity-detail" id="guestActivityDetail"></div>
            </div>

            <div class="session-status" id="hostSessionStatus"></div>
            <button class="session-back-btn" onclick="app.sessionCancel()">Cancel</button>
          </div>

          <!-- Session: Join Panel -->
          <div class="session-join-panel" id="sessionJoinPanel">
            <div class="session-setup-title">Join a Session</div>
            <div class="session-setup-subtitle">Enter the host's address and code word</div>
            <div class="join-input-row" style="flex-direction: column; gap: 8px">
              <input
                type="text"
                class="join-code-input"
                id="joinHostInput"
                placeholder="Host address (e.g. 192.168.1.5:48150)"
                autocomplete="off"
                spellcheck="false"
                style="font-size: 13px; font-family: var(--font-mono, monospace)"
              />
              <div style="display: flex; gap: 8px">
                <input
                  type="text"
                  class="join-code-input"
                  id="joinCodeInput"
                  placeholder="Code word (e.g. falcon)"
                  autocomplete="off"
                  spellcheck="false"
                  style="flex: 1"
                />
                <button class="join-connect-btn" id="joinConnectBtn" onclick="app.sessionJoin()">Connect</button>
              </div>
            </div>
            <div class="session-status" id="joinSessionStatus"></div>
            <button class="session-back-btn" onclick="app.sessionShowSetup()">Back</button>
          </div>

          <!-- Session: Connected Badge -->
          <div class="session-connected-badge" id="sessionConnectedBadge">
            <div class="session-connected-dot"></div>
            Connected
          </div>

          <!-- Session: Remote Video (used in split-view) -->
          <video id="remoteVideo" style="display: none" autoplay playsinline></video>
        </div>
      </div>

      <!-- Bottom Panel -->
      <div class="bottom-panel">
        <!-- Mode Tabs -->
        <div class="mode-tabs">
          <button class="mode-tab active" data-mode="camera" onclick="app.switchMode('camera')">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
              <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z" />
              <circle cx="12" cy="13" r="4" />
            </svg>
            Camera
          </button>
          <button class="mode-tab" data-mode="screen" onclick="app.switchMode('screen')">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
              <rect x="2" y="3" width="20" height="14" rx="2" ry="2" />
              <line x1="8" y1="21" x2="16" y2="21" />
              <line x1="12" y1="17" x2="12" y2="21" />
            </svg>
            Screen
          </button>
          <button class="mode-tab" data-mode="both" onclick="app.switchMode('both')">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
              <rect x="2" y="3" width="20" height="14" rx="2" ry="2" />
              <line x1="8" y1="21" x2="16" y2="21" />
              <line x1="12" y1="17" x2="12" y2="21" />
              <circle cx="18" cy="14" r="4" fill="none" />
            </svg>
            Screen + Camera
          </button>
          <button class="mode-tab" data-mode="session" onclick="app.switchMode('session')">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
              <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2" />
              <circle cx="9" cy="7" r="4" />
              <path d="M23 21v-2a4 4 0 0 0-3-3.87" />
              <path d="M16 3.13a4 4 0 0 1 0 7.75" />
            </svg>
            Session
          </button>
        </div>

        <!-- Space Selector (always visible) -->
        <div class="space-selector-bar">
          <div class="space-selector-label">
            <svg
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="1.5"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <circle cx="12" cy="12" r="8" />
            </svg>
            Save to
          </div>
          <select class="source-select" id="targetSpace" onchange="app.onTargetSpaceChange()">
            <option value="">Select a space...</option>
          </select>
        </div>

        <!-- Controls Bar -->
        <div class="controls-bar" id="controlsBar">
          <div class="source-compact">
            <div class="source-compact-item" id="cameraSourceWrapper">
              <div class="source-compact-label">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                  <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z" />
                  <circle cx="12" cy="13" r="4" />
                </svg>
                Camera
              </div>
              <select class="source-select" id="videoSource" onchange="app.changeVideoSource()">
                <option value="">Select camera...</option>
              </select>
            </div>
            <div class="source-compact-item">
              <div class="source-compact-label">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                  <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z" />
                  <path d="M19 10v2a7 7 0 0 1-14 0v-2" />
                  <line x1="12" y1="19" x2="12" y2="23" />
                  <line x1="8" y1="23" x2="16" y2="23" />
                </svg>
                Mic
              </div>
              <select class="source-select" id="audioSource" onchange="app.changeAudioSource()">
                <option value="">No microphone</option>
              </select>
            </div>
          </div>

          <div class="record-wrapper" style="position: relative">
            <button class="record-btn" id="recordBtn" onclick="app.toggleRecording()">
              <div class="record-btn-inner"></div>
            </button>
            <button class="pause-btn" id="pauseBtn" onclick="app.togglePause()" title="Pause recording">
              <svg viewBox="0 0 24 24" fill="currentColor" stroke="none" id="pauseIcon">
                <rect x="6" y="4" width="4" height="16" rx="1" />
                <rect x="14" y="4" width="4" height="16" rx="1" />
              </svg>
            </button>
            <span class="record-label" id="recordLabel">REC</span>
          </div>

          <!-- Session media controls (mute mic, camera off)  visible during active session -->
          <div class="session-media-controls" id="sessionMediaControls">
            <button class="session-media-btn" id="muteMicBtn" onclick="app.toggleMuteMic()" title="Mute microphone">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" id="micIcon">
                <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z" />
                <path d="M19 10v2a7 7 0 0 1-14 0v-2" />
                <line x1="12" y1="19" x2="12" y2="23" />
                <line x1="8" y1="23" x2="16" y2="23" />
              </svg>
            </button>
            <button class="session-media-btn" id="camOffBtn" onclick="app.toggleCameraOff()" title="Turn off camera">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" id="camIcon">
                <path d="M23 7l-7 5 7 5V7z" />
                <rect x="1" y="5" width="15" height="14" rx="2" ry="2" />
              </svg>
            </button>
            <button
              class="session-media-btn"
              id="bgEffectBtn"
              onclick="app.toggleBgPopover()"
              title="Background effects"
            >
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2" />
                <circle cx="12" cy="7" r="4" />
              </svg>
              <div class="bg-popover" id="bgPopover">
                <div class="bg-popover-title">Background</div>
                <div class="bg-option selected" data-bg="none" onclick="app.setBgEffect('none', event)">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                    <circle cx="12" cy="12" r="10" />
                    <line x1="4.93" y1="4.93" x2="19.07" y2="19.07" />
                  </svg>
                  None
                </div>
                <div class="bg-option" data-bg="blur" onclick="app.setBgEffect('blur', event)">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                    <circle cx="12" cy="12" r="10" />
                    <circle cx="12" cy="12" r="4" opacity="0.4" />
                    <circle cx="12" cy="12" r="7" opacity="0.2" />
                  </svg>
                  Blur
                </div>
                <div class="bg-slider-row" id="bgBlurSlider">
                  <label>Radius</label>
                  <input
                    type="range"
                    min="1"
                    max="20"
                    value="10"
                    id="bgBlurRadius"
                    oninput="app.updateBlurRadius(this.value)"
                  />
                </div>
                <div class="bg-option" data-bg="image" onclick="app.setBgEffect('image', event)">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                    <rect x="3" y="3" width="18" height="18" rx="2" />
                    <circle cx="8.5" cy="8.5" r="1.5" />
                    <polyline points="21 15 16 10 5 21" />
                  </svg>
                  Image
                </div>
                <div class="bg-image-row" id="bgImageRow">
                  <input
                    type="file"
                    id="bgImageFile"
                    accept="image/*"
                    style="display: none"
                    onchange="app.handleBgImageFile(this)"
                  />
                  <button class="bg-image-btn" onclick="document.getElementById('bgImageFile').click()">
                    Choose image...
                  </button>
                </div>
              </div>
            </button>
          </div>

          <button
            class="caption-toggle"
            id="captionToggle"
            onclick="app.toggleCaptions()"
            title="Toggle live captions (C)"
          >
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
              <rect x="2" y="4" width="20" height="16" rx="2" />
              <text
                x="12"
                y="15"
                text-anchor="middle"
                font-size="8"
                font-weight="700"
                fill="currentColor"
                stroke="none"
              >
                CC
              </text>
            </svg>
          </button>

          <button class="ctrl-btn" id="settingsToggle" onclick="app.toggleSettings()" title="Settings">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
              <circle cx="12" cy="12" r="3" />
              <path
                d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06A1.65 1.65 0 0 0 4.68 15a1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06A1.65 1.65 0 0 0 9 4.68a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06A1.65 1.65 0 0 0 19.4 9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"
              />
            </svg>
          </button>

          <button class="end-session-btn" id="endSessionBtn" onclick="app.sessionEnd()">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
              <path d="M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4" />
              <polyline points="10 17 15 12 10 7" />
              <line x1="15" y1="12" x2="3" y2="12" />
            </svg>
            End Session
          </button>
        </div>

        <!-- Review Controls -->
        <div class="review-bar" id="reviewControls">
          <button class="review-btn danger" onclick="app.discardRecording()">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
              <path d="M3 6h18M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" />
            </svg>
            Discard
          </button>
          <button class="review-btn secondary" onclick="app.recordAgain()">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
              <path d="M1 4v6h6" />
              <path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10" />
            </svg>
            Record Again
          </button>
          <button class="review-btn primary" onclick="app.showSaveDialog()">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
              <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" />
              <polyline points="17 21 17 13 7 13 7 21" />
              <polyline points="7 3 7 8 15 8" />
            </svg>
            Save to Space
          </button>
        </div>

        <!-- Settings Panel (expandable) -->
        <div class="settings-panel" id="settingsPanel">
          <div class="settings-inner">
            <!-- Hidden video source (used by mode switching) -->
            <div class="setting-row" id="videoSourceRow" style="display: none">
              <div class="setting-group">
                <div class="setting-label">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                    <polygon points="23 7 16 12 23 17 23 7" />
                    <rect x="1" y="5" width="15" height="14" rx="2" ry="2" />
                  </svg>
                  Video Source
                </div>
                <select class="source-select" id="videoSourceHidden">
                  <option value="">Select source...</option>
                </select>
              </div>
            </div>

            <!-- Audio Mixing Panel -->
            <div class="audio-mix-panel" id="audioMixControls">
              <div class="mix-title">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                  <line x1="4" y1="21" x2="4" y2="14" />
                  <line x1="4" y1="10" x2="4" y2="3" />
                  <line x1="12" y1="21" x2="12" y2="12" />
                  <line x1="12" y1="8" x2="12" y2="3" />
                  <line x1="20" y1="21" x2="20" y2="16" />
                  <line x1="20" y1="12" x2="20" y2="3" />
                  <line x1="1" y1="14" x2="7" y2="14" />
                  <line x1="9" y1="8" x2="15" y2="8" />
                  <line x1="17" y1="16" x2="23" y2="16" />
                </svg>
                Audio Mixer
              </div>
              <div class="volume-sliders">
                <div class="volume-slider-group">
                  <label class="volume-label">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                      <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z" />
                      <path d="M19 10v2a7 7 0 0 1-14 0v-2" />
                      <line x1="12" y1="19" x2="12" y2="23" />
                      <line x1="8" y1="23" x2="16" y2="23" />
                    </svg>
                    Mic
                    <span class="volume-value" id="micVolumeValue">100%</span>
                  </label>
                  <input
                    type="range"
                    class="volume-slider"
                    id="micVolume"
                    min="0"
                    max="150"
                    value="100"
                    oninput="app.updateMicVolume(this.value)"
                  />
                </div>
                <div class="volume-slider-group">
                  <label class="volume-label">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                      <rect x="2" y="3" width="20" height="14" rx="2" ry="2" />
                      <line x1="8" y1="21" x2="16" y2="21" />
                      <line x1="12" y1="17" x2="12" y2="21" />
                    </svg>
                    Desktop
                    <span
                      class="audio-status-badge"
                      id="desktopAudioStatus"
                      title="System audio capture not available on this platform"
                      >Unavailable</span
                    >
                    <span class="volume-value" id="desktopVolumeValue">100%</span>
                  </label>
                  <input
                    type="range"
                    class="volume-slider"
                    id="desktopVolume"
                    min="0"
                    max="150"
                    value="100"
                    oninput="app.updateDesktopVolume(this.value)"
                  />
                </div>
                <div class="volume-slider-group">
                  <label class="volume-label">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                      <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z" />
                      <path d="M19 10v2a7 7 0 0 1-14 0v-2" />
                    </svg>
                    External 1
                    <span class="volume-value" id="externalMicVolumeValue">100%</span>
                  </label>
                  <select class="volume-source-select" id="externalMicSource" onchange="app.updateExternalMicSource(1)">
                    <option value="">None (disabled)</option>
                  </select>
                  <input
                    type="range"
                    class="volume-slider"
                    id="externalMicVolume"
                    min="0"
                    max="150"
                    value="100"
                    oninput="app.updateExternalMicVolume(1, this.value)"
                  />
                </div>
                <div class="volume-slider-group">
                  <label class="volume-label">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                      <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z" />
                      <path d="M19 10v2a7 7 0 0 1-14 0v-2" />
                    </svg>
                    External 2
                    <span class="volume-value" id="externalMic2VolumeValue">100%</span>
                  </label>
                  <select
                    class="volume-source-select"
                    id="externalMic2Source"
                    onchange="app.updateExternalMicSource(2)"
                  >
                    <option value="">None (disabled)</option>
                  </select>
                  <input
                    type="range"
                    class="volume-slider"
                    id="externalMic2Volume"
                    min="0"
                    max="150"
                    value="100"
                    oninput="app.updateExternalMicVolume(2, this.value)"
                  />
                </div>
              </div>
            </div>

            <!-- Instructions Panel -->
            <div class="instructions-panel" id="instructionsPanel">
              <div class="instructions-header">
                <span class="instructions-title">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" />
                    <polyline points="14 2 14 8 20 8" />
                    <line x1="16" y1="13" x2="8" y2="13" />
                    <line x1="16" y1="17" x2="8" y2="17" />
                    <polyline points="10 9 9 9 8 9" />
                  </svg>
                  Recording Instructions
                </span>
              </div>
              <div class="instructions-content" id="instructionsContent">No specific instructions. Record freely.</div>
            </div>
          </div>
        </div>

        <!-- Keyboard Shortcuts Bar -->
        <div class="shortcuts-bar">
          <div class="shortcut-item"><kbd>Space</kbd> Record</div>
          <div class="shortcut-item"><kbd>Esc</kbd> Stop</div>
          <div class="shortcut-item"><kbd>S</kbd> Save</div>
          <div class="shortcut-item"><kbd>,</kbd> Settings</div>
        </div>
      </div>
    </div>

    <!-- Save Dialog -->
    <div class="save-dialog" id="saveDialog">
      <div class="save-dialog-content">
        <div class="save-dialog-title">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
            <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" />
            <polyline points="17 21 17 13 7 13 7 21" />
            <polyline points="7 3 7 8 15 8" />
          </svg>
          Save Recording
        </div>

        <div class="save-form-group">
          <label class="save-form-label">Filename</label>
          <input type="text" class="save-form-input" id="saveFilename" placeholder="recording.webm" />
        </div>

        <div class="save-form-group">
          <label class="save-form-label">Save to Space</label>
          <select class="save-form-input" id="saveSpace">
            <option value="">Select a space...</option>
          </select>
        </div>

        <div class="save-form-group">
          <label class="save-form-label">Project (optional)</label>
          <select class="save-form-input" id="saveProject">
            <option value="">No project - save to space root</option>
          </select>
        </div>

        <div class="save-dialog-actions">
          <button class="review-btn secondary" onclick="app.hideSaveDialog()">Cancel</button>
          <button class="review-btn primary" onclick="app.saveRecording()">Save</button>
        </div>
      </div>
    </div>

    <!-- Screen Source Picker -->
    <div class="screen-picker" id="screenPicker">
      <div class="screen-picker-content">
        <div class="screen-picker-title">Select Screen or Window</div>
        <div class="screen-picker-subtitle">Choose what you want to capture</div>
        <div class="screen-picker-grid" id="screenSourcesGrid"></div>
        <div class="screen-picker-actions">
          <button class="review-btn secondary" onclick="app.hideScreenPicker()">Cancel</button>
          <button class="review-btn primary" onclick="app.selectScreenSource()">Select</button>
        </div>
      </div>
    </div>

    <!-- Track Transfer Overlay (Phase 2) -->
    <div class="transfer-overlay" id="transferOverlay">
      <div class="transfer-content">
        <div class="transfer-icon">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
            <path d="M12 5v14M19 12l-7 7-7-7" />
          </svg>
        </div>
        <div class="transfer-title" id="transferTitle">Transferring Guest Recording</div>
        <div class="transfer-progress-bar">
          <div class="transfer-progress-fill" id="transferProgressFill" style="width: 0%"></div>
        </div>
        <div class="transfer-status" id="transferStatus">Preparing...</div>
      </div>
    </div>

    <!-- Merge Dialog (Phase 3) -->
    <div class="merge-dialog" id="mergeDialog">
      <div class="merge-dialog-content">
        <div class="merge-dialog-title">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
            <rect x="2" y="3" width="8" height="6" rx="1" />
            <rect x="14" y="3" width="8" height="6" rx="1" />
            <rect x="5" y="15" width="14" height="6" rx="1" />
            <path d="M6 9v2a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2V9" />
            <path d="M12 13v2" />
          </svg>
          Merge Tracks
        </div>
        <div class="merge-subtitle">Combine host and guest recordings into one video</div>

        <div class="merge-layout-options">
          <label class="merge-layout-option selected" data-layout="side-by-side">
            <input type="radio" name="mergeLayout" value="side-by-side" checked />
            <div class="merge-layout-preview">
              <div class="layout-box left"></div>
              <div class="layout-box right"></div>
            </div>
            <span>Side by Side</span>
          </label>

          <label class="merge-layout-option" data-layout="pip-guest">
            <input type="radio" name="mergeLayout" value="pip-guest" />
            <div class="merge-layout-preview">
              <div class="layout-box full"></div>
              <div class="layout-box pip bottom-right"></div>
            </div>
            <span>Host + Guest PiP</span>
          </label>

          <label class="merge-layout-option" data-layout="pip-host">
            <input type="radio" name="mergeLayout" value="pip-host" />
            <div class="merge-layout-preview">
              <div class="layout-box full guest"></div>
              <div class="layout-box pip bottom-right host"></div>
            </div>
            <span>Guest + Host PiP</span>
          </label>
        </div>

        <div class="merge-tracks-info" id="mergeTracksInfo">
          <div class="merge-track-item">
            <span class="merge-track-role">Host</span>
            <span class="merge-track-name" id="mergeHostName">--</span>
          </div>
          <div class="merge-track-item">
            <span class="merge-track-role guest">Guest</span>
            <span class="merge-track-name" id="mergeGuestName">--</span>
          </div>
        </div>

        <div class="merge-progress" id="mergeProgressSection" style="display: none">
          <div class="transfer-progress-bar">
            <div class="transfer-progress-fill" id="mergeProgressFill" style="width: 0%"></div>
          </div>
          <div class="merge-progress-text" id="mergeProgressText">Starting merge...</div>
        </div>

        <div class="merge-dialog-actions" id="mergeActions">
          <button class="review-btn secondary" onclick="app.hideMergeDialog()">Skip</button>
          <button class="review-btn primary" onclick="app.startMerge()">Merge</button>
        </div>
      </div>
    </div>

    <!-- Status Message -->
    <div class="status-message" id="statusMessage">
      <div class="status-dot"></div>
      <span id="statusText"></span>
    </div>

    <script>
      const app = {
        // State
        stream: null,
        mediaRecorder: null,
        recordedChunks: [],
        recordedBlob: null,
        isRecording: false,
        recordingStartTime: null,
        lastRecordingDuration: null,
        reviewBlobUrl: null,
        durationInterval: null,
        instructions: null,
        screenSources: [],
        selectedScreenSourceId: null,
        currentMode: 'camera', // 'camera' | 'screen' | 'both'
        settingsOpen: false,
        countdownActive: false,
        audioAnalyser: null,
        audioMeterFrame: null,

        // Meeting HUD state
        hudVisible: false,
        hudItems: [], // Array of { id, type, text, tags, deadline, addedBy, timestamp, agentId }
        hudAgentStates: {}, // agentId -> enabled
        hudNameRoster: [], // Auto-built list of known names for @mention

        // DOM Elements
        elements: {},

        // Initialize
        async init() {
          console.log('[Recorder] Initializing...');

          this.cacheElements();
          await this.loadDevices();
          await this.loadSpaces();
          this.setupEventListeners();
          this.setupKeyboardShortcuts();

          // Check for instructions from editor
          if (window.recorder) {
            const instructions = await window.recorder.getInstructions();
            if (instructions) {
              this.setInstructions(instructions);
            }

            window.recorder.onInstructionsReceived((instructions) => {
              this.setInstructions(instructions);
            });

            // Listen for meeting monitor alerts
            if (window.recorder.onMonitorAlert) {
              window.recorder.onMonitorAlert((alert) => {
                this.showMonitorAlert(alert);
              });
            }
          }

          // Initialize Meeting HUD
          this.initMeetingHUD();

          // Restore host name from localStorage
          const savedHostName = localStorage.getItem('wiser-host-name');
          const hostNameInput = document.getElementById('hostNameInput');
          if (savedHostName && hostNameInput) {
            hostNameInput.value = savedHostName;
          }

          // Clean up meeting tokens when window is closed without clicking End Session
          window.addEventListener('beforeunload', () => {
            if (this._meetingRoomName && window.recorder) {
              // Use sendBeacon for reliability during page unload
              const roomName = this._meetingRoomName;
              console.log('[Recorder] Window closing  clearing meeting tokens for:', roomName);
              window.recorder.clearMeetingTokens(roomName).catch(() => {});
            }
            // Disconnect from LiveKit if still connected
            if (this._livekitRoom) {
              try {
                this._livekitRoom.disconnect();
              } catch {}
            }
          });

          console.log('[Recorder] Ready');
        },

        // ==================== MEETING HUD ====================

        TAG_COLORS: 10, // Number of colors in palette

        _hashName(name) {
          let h = 0;
          for (let i = 0; i < name.length; i++) h = ((h << 5) - h + name.charCodeAt(i)) | 0;
          return Math.abs(h) % this.TAG_COLORS;
        },

        async initMeetingHUD() {
          if (!window.agentHUD) {
            console.log('[MeetingHUD] agentHUD API not available');
            return;
          }

          // Load agent toggles for meeting space
          try {
            const agents = await window.agentHUD.getAgentsInSpace('meeting-agents');
            if (agents && agents.length > 0) {
              agents.forEach((a) => {
                this.hudAgentStates[a.id] = a.enabled !== false;
              });
              this._renderAgentToggles(agents);
            }
          } catch (e) {
            console.warn('[MeetingHUD] Could not load agents:', e);
          }

          // Listen for HUD API events
          window.agentHUD.onResult((result) => {
            if (
              result.data &&
              (result.data.type === 'action-item' ||
                result.data.type === 'decision' ||
                result.data.type === 'note' ||
                result.data.type === 'bookmark')
            ) {
              this._addHUDItem({
                type: result.data.type,
                text: result.data.text,
                tags: result.data.tags || [],
                deadline: result.data.deadline || null,
                agentId: result.agentId || null,
              });
            }
          });

          console.log('[MeetingHUD] Initialized');
        },

        toggleMeetingHUD() {
          this.hudVisible = !this.hudVisible;
          this.elements.meetingHUD.classList.toggle('hidden', !this.hudVisible);
          this.elements.hudToggleBtn.classList.toggle('active', this.hudVisible);

          // Move toggle button when HUD is open
          if (this.hudVisible) {
            this.elements.hudToggleBtn.style.right = '296px';
          } else {
            this.elements.hudToggleBtn.style.right = '8px';
          }
        },

        async submitHUDItem() {
          const input = this.elements.hudInput;
          const text = input.value.trim();
          if (!text) return;

          input.value = '';

          if (window.agentHUD) {
            // Submit via centralized HUD API to meeting-agents space
            try {
              await window.agentHUD.submitTask(text, {
                spaceId: 'meeting-agents',
                toolId: 'recorder',
                metadata: { context: 'meeting-hud' },
              });
            } catch (e) {
              console.error('[MeetingHUD] Submit error:', e);
              // Fallback: add as a local note
              this._addHUDItem({ type: 'note', text, tags: ['Me'], deadline: null });
            }
          } else {
            // No agentHUD, add directly
            this._addHUDItem({ type: 'note', text, tags: ['Me'], deadline: null });
          }
        },

        _addHUDItem(item) {
          const fullItem = {
            id: 'hud-' + Date.now() + '-' + Math.random().toString(36).slice(2, 6),
            type: item.type || 'note',
            text: item.text || '',
            tags: item.tags || [],
            deadline: item.deadline || null,
            addedBy: item.addedBy || 'Me',
            timestamp: item.timestamp || Date.now(),
            agentId: item.agentId || null,
          };

          this.hudItems.push(fullItem);

          // Update name roster
          for (const tag of fullItem.tags) {
            if (tag !== 'Me' && tag !== 'Everyone' && !this.hudNameRoster.includes(tag)) {
              this.hudNameRoster.push(tag);
            }
          }

          this._renderHUDItems();

          // If HUD is not visible, open it automatically on first item
          if (!this.hudVisible && this.hudItems.length === 1) {
            this.toggleMeetingHUD();
          }

          // P2P sync: broadcast to peer
          this._syncHUDItemToPeer('add', fullItem);

          // Add to centralized HUD items store
          if (window.agentHUD) {
            window.agentHUD.addItem('recorder', fullItem).catch(() => {});
          }
        },

        _removeHUDItem(itemId) {
          this.hudItems = this.hudItems.filter((i) => i.id !== itemId);
          this._renderHUDItems();
          this._syncHUDItemToPeer('remove', { id: itemId });
          if (window.agentHUD) {
            window.agentHUD.removeItem('recorder', itemId).catch(() => {});
          }
        },

        _renderHUDItems() {
          const list = this.elements.hudItemList;
          const empty = this.elements.hudEmptyState;
          const count = this.elements.hudItemCount;

          // Update count
          count.textContent = `${this.hudItems.length} item${this.hudItems.length !== 1 ? 's' : ''}`;

          // Show/hide empty state
          if (this.hudItems.length === 0) {
            empty.style.display = 'flex';
            // Clear all items except empty state
            Array.from(list.children).forEach((c) => {
              if (c !== empty) c.remove();
            });
            return;
          }
          empty.style.display = 'none';

          // Remove existing item elements (keep empty state)
          Array.from(list.children).forEach((c) => {
            if (c !== empty) c.remove();
          });

          // Render items (newest first)
          const sorted = [...this.hudItems].reverse();
          for (const item of sorted) {
            const el = this._createHUDItemElement(item);
            list.appendChild(el);
          }
        },

        _createHUDItemElement(item) {
          const div = document.createElement('div');
          div.className = 'hud-item';
          div.dataset.id = item.id;

          // Time
          const elapsed = item.timestamp - (this.recordingStartTime || Date.now());
          const mins = Math.floor(Math.abs(elapsed) / 60000);
          const secs = Math.floor((Math.abs(elapsed) % 60000) / 1000);
          const timeStr = `${mins}:${secs.toString().padStart(2, '0')}`;

          // Type badge
          const typeClass = item.type.replace(/\s+/g, '-');
          const typeLabel = { 'action-item': 'AI', decision: 'DC', note: 'NT', bookmark: 'BK' }[item.type] || 'NT';

          // Tags HTML
          const tagsHtml = (item.tags || [])
            .map((tag) => {
              if (tag === 'Everyone') {
                return `<span class="hud-tag-pill everyone">${tag}</span>`;
              }
              const colorIdx = tag === 'Me' ? 0 : this._hashName(tag);
              return `<span class="hud-tag-pill hud-tag-${colorIdx}">${tag}</span>`;
            })
            .join('');

          // Deadline
          const deadlineHtml = item.deadline ? `<div class="hud-item-deadline">By ${item.deadline}</div>` : '';

          div.innerHTML = `
          <div class="hud-item-top">
            <span class="hud-type-badge ${typeClass}">${typeLabel}</span>
            <div class="hud-item-tags">${tagsHtml}</div>
            <span class="hud-item-time">${timeStr}</span>
          </div>
          <div class="hud-item-text">${this._escapeHtml(item.text)}</div>
          ${deadlineHtml}
          <button class="hud-item-remove" onclick="app._removeHUDItem('${item.id}')" title="Remove">&times;</button>
        `;

          return div;
        },

        _escapeHtml(text) {
          const d = document.createElement('div');
          d.textContent = text;
          return d.innerHTML;
        },

        _renderAgentToggles(agents) {
          const container = this.elements.hudAgentToggles;
          container.innerHTML = '';
          for (const agent of agents) {
            const btn = document.createElement('button');
            btn.className = 'hud-agent-toggle' + (this.hudAgentStates[agent.id] !== false ? ' active' : '');
            btn.textContent = agent.id.replace(/-agent$/, '').replace(/-/g, ' ');
            btn.title = agent.name || agent.id;
            btn.onclick = () => {
              const newState = !this.hudAgentStates[agent.id];
              this.hudAgentStates[agent.id] = newState;
              btn.classList.toggle('active', newState);
              if (window.agentHUD) {
                window.agentHUD.setAgentEnabled('meeting-agents', agent.id, newState).catch(() => {});
              }
            };
            container.appendChild(btn);
          }
        },

        // P2P HUD Sync
        _syncHUDItemToPeer(action, data) {
          if (!this.sessionConnected) return;
          try {
            if (action === 'add') {
              this.sendSessionData({ type: 'hud-item-add', item: data });
            } else if (action === 'remove') {
              this.sendSessionData({ type: 'hud-item-remove', id: data.id });
            }
          } catch (e) {
            console.warn('[MeetingHUD] P2P sync error:', e);
          }
        },

        _sendHUDFullSync() {
          if (!this.sessionConnected) return;
          try {
            this.sendSessionData({ type: 'hud-sync-full', items: this.hudItems });
          } catch (e) {
            console.warn('[MeetingHUD] Full sync error:', e);
          }
        },

        _handleHUDSyncMessage(msg) {
          if (msg.type === 'hud-item-add' && msg.item) {
            // Avoid duplicates
            if (!this.hudItems.find((i) => i.id === msg.item.id)) {
              this.hudItems.push(msg.item);
              this._renderHUDItems();
              if (!this.hudVisible && this.hudItems.length === 1) {
                this.toggleMeetingHUD();
              }
            }
          } else if (msg.type === 'hud-item-remove' && msg.id) {
            this.hudItems = this.hudItems.filter((i) => i.id !== msg.id);
            this._renderHUDItems();
          } else if (msg.type === 'hud-sync-full' && Array.isArray(msg.items)) {
            this.hudItems = msg.items;
            this._renderHUDItems();
          }
        },

        cacheElements() {
          this.elements = {
            previewContainer: document.getElementById('previewContainer'),
            previewVideo: document.getElementById('previewVideo'),
            reviewVideo: document.getElementById('reviewVideo'),
            previewPlaceholder: document.getElementById('previewPlaceholder'),
            permissionOverlay: document.getElementById('permissionOverlay'),
            recordingIndicator: document.getElementById('recordingIndicator'),
            durationDisplay: document.getElementById('durationDisplay'),
            currentDuration: document.getElementById('currentDuration'),
            targetDuration: document.getElementById('targetDuration'),
            countdownOverlay: document.getElementById('countdownOverlay'),
            countdownNumber: document.getElementById('countdownNumber'),
            audioMeter: document.getElementById('audioMeter'),
            instructionsContent: document.getElementById('instructionsContent'),
            videoSource: document.getElementById('videoSource'),
            audioSource: document.getElementById('audioSource'),
            audioMixControls: document.getElementById('audioMixControls'),
            micVolume: document.getElementById('micVolume'),
            micVolumeValue: document.getElementById('micVolumeValue'),
            desktopVolume: document.getElementById('desktopVolume'),
            desktopVolumeValue: document.getElementById('desktopVolumeValue'),
            externalMicSource: document.getElementById('externalMicSource'),
            externalMicVolume: document.getElementById('externalMicVolume'),
            externalMicVolumeValue: document.getElementById('externalMicVolumeValue'),
            externalMic2Source: document.getElementById('externalMic2Source'),
            externalMic2Volume: document.getElementById('externalMic2Volume'),
            externalMic2VolumeValue: document.getElementById('externalMic2VolumeValue'),
            controlsBar: document.getElementById('controlsBar'),
            reviewControls: document.getElementById('reviewControls'),
            recordBtn: document.getElementById('recordBtn'),
            recordLabel: document.getElementById('recordLabel'),
            pauseBtn: document.getElementById('pauseBtn'),
            pauseIcon: document.getElementById('pauseIcon'),
            pausedOverlay: document.getElementById('pausedOverlay'),
            captionOverlay: document.getElementById('captionOverlay'),
            captionText: document.getElementById('captionText'),
            captionToggle: document.getElementById('captionToggle'),
            transcriptionStatus: document.getElementById('transcriptionStatus'),
            transcriptionStatusText: document.getElementById('transcriptionStatusText'),
            monitorAlertContainer: document.getElementById('monitorAlertContainer'),
            settingsPanel: document.getElementById('settingsPanel'),
            settingsToggle: document.getElementById('settingsToggle'),
            cameraSourceWrapper: document.getElementById('cameraSourceWrapper'),
            saveDialog: document.getElementById('saveDialog'),
            saveFilename: document.getElementById('saveFilename'),
            saveSpace: document.getElementById('saveSpace'),
            saveProject: document.getElementById('saveProject'),
            statusMessage: document.getElementById('statusMessage'),
            statusText: document.getElementById('statusText'),
            screenPicker: document.getElementById('screenPicker'),
            screenSourcesGrid: document.getElementById('screenSourcesGrid'),
            targetSpace: document.getElementById('targetSpace'),
            // Meeting HUD
            meetingHUD: document.getElementById('meetingHUD'),
            hudToggleBtn: document.getElementById('hudToggleBtn'),
            hudItemList: document.getElementById('hudItemList'),
            hudItemCount: document.getElementById('hudItemCount'),
            hudEmptyState: document.getElementById('hudEmptyState'),
            hudInput: document.getElementById('hudInput'),
            hudAgentToggles: document.getElementById('hudAgentToggles'),
          };
        },

        setupEventListeners() {
          // Save dialog space change -> load projects + sync back to main selector
          this.elements.saveSpace.addEventListener('change', async () => {
            const spaceId = this.elements.saveSpace.value;

            // Sync back to main target selector and session selector
            if (spaceId && this.elements.targetSpace.value !== spaceId) {
              this.elements.targetSpace.value = spaceId;
              this.updateTargetSpaceHighlight();
            }
            const sessionSel = document.getElementById('sessionSpaceSelect');
            if (sessionSel && spaceId) sessionSel.value = spaceId;

            // Load projects for the selected space
            if (spaceId && window.recorder) {
              const result = await window.recorder.getProjectFolder(spaceId);
              this.elements.saveProject.innerHTML = '<option value="">No project - save to space root</option>';
              if (result.success && result.projects) {
                result.projects.forEach((p) => {
                  const option = document.createElement('option');
                  option.value = p.id;
                  option.textContent = p.name;
                  this.elements.saveProject.appendChild(option);
                });
              }
            }
          });
        },

        // Keyboard shortcuts
        setupKeyboardShortcuts() {
          document.addEventListener('keydown', (e) => {
            // Enter key in join code input -> connect
            if (e.code === 'Enter' && e.target.id === 'joinCodeInput') {
              e.preventDefault();
              this.sessionJoin();
              return;
            }

            // Don't trigger shortcuts when typing in inputs
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT')
              return;

            switch (e.code) {
              case 'Space':
                e.preventDefault();
                this.toggleRecording();
                break;
              case 'KeyP':
                if (this.isRecording) {
                  e.preventDefault();
                  this.togglePause();
                }
                break;
              case 'Escape':
                if (this.isRecording) {
                  this.stopRecording();
                } else if (this.elements.saveDialog.classList.contains('active')) {
                  this.hideSaveDialog();
                } else if (this.elements.screenPicker.classList.contains('active')) {
                  this.hideScreenPicker();
                }
                break;
              case 'KeyS':
                if (this.recordedBlob && !this.isRecording) {
                  this.showSaveDialog();
                }
                break;
              case 'KeyC':
                e.preventDefault();
                this.toggleCaptions();
                break;
              case 'Comma':
                this.toggleSettings();
                break;
            }
          });
        },

        // Mode switching
        switchMode(mode) {
          if (mode === this.currentMode) return;

          // If leaving session mode, clean up
          if (this.currentMode === 'session' && mode !== 'session') {
            this.sessionHideAllPanels();
          }

          this.currentMode = mode;

          // Update tabs
          document.querySelectorAll('.mode-tab').forEach((tab) => {
            tab.classList.toggle('active', tab.dataset.mode === mode);
          });

          // Session mode -- special handling
          if (mode === 'session') {
            this.elements.previewPlaceholder.style.display = 'none';
            this.elements.audioMixControls.classList.remove('visible');
            this.sessionShowSetup();
            return;
          }

          // Hide session panels when switching away
          this.sessionHideAllPanels();

          // Update source visibility
          const cameraWrapper = this.elements.cameraSourceWrapper;
          if (mode === 'screen') {
            cameraWrapper.style.display = 'none';
          } else {
            cameraWrapper.style.display = 'block';
          }

          // Stop existing streams
          if (this.stream) {
            this.stream.getTracks().forEach((t) => t.stop());
            this.stream = null;
          }
          this.cleanupPipResources();

          // Handle mode
          if (mode === 'camera') {
            // Re-select camera
            const camId = this.elements.videoSource.value;
            if (camId && !camId.startsWith('screen')) {
              this.changeVideoSource();
            } else {
              this.elements.previewVideo.srcObject = null;
              this.elements.previewPlaceholder.style.display = 'flex';
            }
            this.elements.audioMixControls.classList.remove('visible');
          } else if (mode === 'screen') {
            this.showScreenPicker(false);
          } else if (mode === 'both') {
            this.showScreenPicker(true);
          }
        },

        // Toggle settings panel
        toggleSettings() {
          this.settingsOpen = !this.settingsOpen;
          this.elements.settingsPanel.classList.toggle('open', this.settingsOpen);
          this.elements.settingsToggle.classList.toggle('active', this.settingsOpen);
        },

        // Load available media devices
        async loadDevices() {
          try {
            let hasCamera = false;
            try {
              const tempStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
              tempStream.getTracks().forEach((t) => t.stop());
              hasCamera = true;
            } catch (e) {
              try {
                const audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                audioStream.getTracks().forEach((t) => t.stop());
              } catch (e2) {
                console.warn('[Recorder] No camera or mic available');
              }
            }

            const devices = await navigator.mediaDevices.enumerateDevices();

            // Video devices
            const videoDevices = devices.filter((d) => d.kind === 'videoinput');
            this.elements.videoSource.innerHTML = '<option value="">Select camera...</option>';

            videoDevices.forEach((device, i) => {
              const option = document.createElement('option');
              option.value = device.deviceId;
              option.textContent = device.label || `Camera ${i + 1}`;
              this.elements.videoSource.appendChild(option);
            });

            // Audio devices
            const audioDevices = devices.filter((d) => d.kind === 'audioinput');
            this.elements.audioSource.innerHTML = '<option value="">No microphone</option>';
            audioDevices.forEach((device, i) => {
              const option = document.createElement('option');
              option.value = device.deviceId;
              option.textContent = device.label || `Microphone ${i + 1}`;
              this.elements.audioSource.appendChild(option);
            });

            // Auto-select first devices
            if (videoDevices.length > 0) {
              this.elements.videoSource.value = videoDevices[0].deviceId;
              this.changeVideoSource();
            }
            if (audioDevices.length > 0) {
              this.elements.audioSource.value = audioDevices[0].deviceId;
            }

            this.elements.permissionOverlay.classList.add('hidden');
          } catch (error) {
            console.error('[Recorder] Device enumeration error:', error);
            this.elements.permissionOverlay.classList.remove('hidden');
          }
        },

        // Load spaces into all space selectors (main, save dialog, session setup)
        async loadSpaces() {
          if (!window.recorder) return;

          try {
            const spaces = await window.recorder.getSpaces();

            // All three selectors to populate
            const selectors = [
              this.elements.targetSpace,
              this.elements.saveSpace,
              document.getElementById('sessionSpaceSelect'),
            ].filter(Boolean);

            selectors.forEach((sel) => {
              sel.innerHTML = '<option value="">Select a space...</option>';
            });

            if (spaces && spaces.length > 0) {
              spaces.forEach((space) => {
                selectors.forEach((sel) => {
                  const opt = document.createElement('option');
                  opt.value = space.id;
                  opt.textContent = space.name || space.id;
                  sel.appendChild(opt);
                });
              });
            }

            // Show pulse animation if no space selected yet
            this.updateTargetSpaceHighlight();
          } catch (error) {
            console.error('[Recorder] Failed to load spaces:', error);
          }
        },

        // Handle target space selection change (from bottom panel)
        onTargetSpaceChange() {
          const spaceId = this.elements.targetSpace.value;
          // Sync to save dialog
          this.elements.saveSpace.value = spaceId;
          this.elements.saveSpace.dispatchEvent(new Event('change'));
          // Sync to session space selector
          const sessionSel = document.getElementById('sessionSpaceSelect');
          if (sessionSel) sessionSel.value = spaceId;
          // Update highlight
          this.updateTargetSpaceHighlight();
          if (spaceId) {
            console.log('[Recorder] Target space set:', spaceId);
          }
        },

        // Handle space selection from session setup panel
        onSessionSpaceChange() {
          const sessionSel = document.getElementById('sessionSpaceSelect');
          if (!sessionSel) return;
          const spaceId = sessionSel.value;
          // Sync to main target selector and save dialog
          this.elements.targetSpace.value = spaceId;
          this.elements.saveSpace.value = spaceId;
          this.elements.saveSpace.dispatchEvent(new Event('change'));
          this.updateTargetSpaceHighlight();
          // Clear unset styling on session selector
          sessionSel.classList.toggle('unset', !spaceId);
          if (spaceId) {
            console.log('[Recorder] Session space set:', spaceId);
          }
        },

        // Pulse the space selector when unset to prompt the user
        updateTargetSpaceHighlight() {
          if (this.elements.targetSpace.value) {
            this.elements.targetSpace.classList.remove('unset');
          } else {
            this.elements.targetSpace.classList.add('unset');
          }
        },

        // Request permissions
        async requestPermissions() {
          if (window.recorder) {
            await window.recorder.requestPermissions('camera');
            await window.recorder.requestPermissions('microphone');
          }
          await this.loadDevices();
        },

        // Change video source
        async changeVideoSource() {
          const deviceId = this.elements.videoSource.value;
          if (!deviceId) {
            if (this.stream) {
              this.stream.getTracks().forEach((t) => t.stop());
              this.stream = null;
            }
            this.elements.previewVideo.srcObject = null;
            this.elements.previewPlaceholder.style.display = 'flex';
            this.elements.audioMixControls.classList.remove('visible');
            this.stopAudioMeter();
            return;
          }

          try {
            if (this.stream) {
              this.stream.getTracks().forEach((t) => t.stop());
            }
            this.cleanupPipResources();

            if (deviceId === 'screen') {
              await this.showScreenPicker();
              return;
            } else if (deviceId === 'screen-pip') {
              await this.showScreenPicker(true);
              return;
            } else if (deviceId.startsWith('screen-pip:')) {
              const sourceId = deviceId.replace('screen-pip:', '');
              await this.startScreenPipCapture(sourceId);
            } else if (deviceId.startsWith('screen:')) {
              const sourceId = deviceId.replace('screen:', '');
              await this.startScreenCapture(sourceId);
            } else {
              // Camera
              const videoConstraints = { deviceId: { exact: deviceId } };
              const audioDeviceId = this.elements.audioSource.value;

              this.stream = await navigator.mediaDevices.getUserMedia({
                video: videoConstraints,
                audio: audioDeviceId ? { deviceId: { exact: audioDeviceId } } : true,
              });

              this.elements.previewVideo.srcObject = this.stream;
              this.elements.previewPlaceholder.style.display = 'none';
              this.elements.previewVideo.style.display = 'block';
              this.elements.reviewVideo.style.display = 'none';

              // Start audio metering
              this.startAudioMeter(this.stream);
            }

            this.updateAudioMixControlsVisibility();
          } catch (error) {
            console.error('[Recorder] Failed to get media:', error);
            this.showStatus('Failed to access camera: ' + error.message, 'error');
          }
        },

        // Show screen source picker
        async showScreenPicker(pipMode = false) {
          if (!window.recorder || !window.recorder.getScreenSources) {
            this.showStatus('Screen capture not available', 'error');
            return;
          }

          try {
            this.screenSources = await window.recorder.getScreenSources();
            this.pipModeSelection = pipMode;

            if (this.screenSources.length === 0) {
              this.showStatus('No screen sources found. Check screen recording permissions.', 'error');
              return;
            }

            this.elements.screenSourcesGrid.innerHTML = '';
            this.selectedScreenSourceId = null;

            this.screenSources.forEach((source, index) => {
              const item = document.createElement('div');
              item.className = 'screen-source-item';
              item.dataset.sourceId = source.id;
              item.onclick = () => this.selectScreenSourceItem(source.id);

              if (index === 0) {
                item.classList.add('selected');
                this.selectedScreenSourceId = source.id;
              }

              item.innerHTML = `
              <img class="screen-source-thumbnail" src="${source.thumbnail}" alt="${source.name}">
              <div class="screen-source-name">${source.name}</div>
            `;

              this.elements.screenSourcesGrid.appendChild(item);
            });

            this.elements.screenPicker.classList.add('active');
          } catch (error) {
            console.error('[Recorder] Error loading screen sources:', error);
            this.showStatus('Failed to load screen sources: ' + error.message, 'error');
          }
        },

        selectScreenSourceItem(sourceId) {
          this.selectedScreenSourceId = sourceId;
          this.elements.screenSourcesGrid.querySelectorAll('.screen-source-item').forEach((item) => {
            item.classList.toggle('selected', item.dataset.sourceId === sourceId);
          });
        },

        hideScreenPicker() {
          this.elements.screenPicker.classList.remove('active');
          this.pipModeSelection = false;
          if (!this.stream) {
            this.elements.videoSource.value = '';
          }
        },

        async selectScreenSource() {
          if (!this.selectedScreenSourceId) {
            this.showStatus('Please select a screen or window', 'error');
            return;
          }

          this.elements.screenPicker.classList.remove('active');

          if (this.pipModeSelection) {
            await this.startScreenPipCapture(this.selectedScreenSourceId);
          } else {
            await this.startScreenCapture(this.selectedScreenSourceId);
          }
        },

        // Get system audio loopback stream (macOS 12.3+, Windows, Linux  no drivers needed)
        // Returns an audio-only MediaStream or null if unavailable
        async getLoopbackAudioStream() {
          try {
            // Enable the loopback handler in main process
            await window.recorder.enableLoopbackAudio();

            // getDisplayMedia requires video: true, but we only want audio
            const loopbackStream = await navigator.mediaDevices.getDisplayMedia({
              video: true,
              audio: true,
            });

            // Stop and remove the video tracks we don't need
            const videoTracks = loopbackStream.getVideoTracks();
            videoTracks.forEach((track) => {
              track.stop();
              loopbackStream.removeTrack(track);
            });

            // Restore normal getDisplayMedia behavior
            await window.recorder.disableLoopbackAudio();

            const audioTracks = loopbackStream.getAudioTracks();
            if (audioTracks.length > 0) {
              console.log('[Recorder] System audio loopback captured via ScreenCaptureKit');
              return loopbackStream;
            }

            console.log('[Recorder] Loopback stream had no audio tracks');
            return null;
          } catch (error) {
            console.warn('[Recorder] Loopback audio unavailable:', error.message);
            // Make sure we disable even on error
            try {
              await window.recorder.disableLoopbackAudio();
            } catch (e) {}
            return null;
          }
        },

        // Start screen capture (with full desktop + mic audio mixing)
        async startScreenCapture(sourceId) {
          try {
            const audioDeviceId = this.elements.audioSource.value;

            // 1. Get screen video stream
            const screenStream = await navigator.mediaDevices.getUserMedia({
              audio: false,
              video: {
                mandatory: {
                  chromeMediaSource: 'desktop',
                  chromeMediaSourceId: sourceId,
                },
              },
            });

            // 2. Get system audio via native loopback (no drivers needed)
            //    Falls back to legacy chromeMediaSource approach if unavailable
            let loopbackStream = null;
            let hasSystemAudio = false;

            loopbackStream = await this.getLoopbackAudioStream();
            if (loopbackStream) {
              hasSystemAudio = true;
            } else {
              // Fallback: try legacy chromeMediaSource desktop audio (works on Windows)
              // Desktop audio requires paired video capture, so we request both then discard the video
              try {
                const legacyStream = await navigator.mediaDevices.getUserMedia({
                  audio: {
                    mandatory: {
                      chromeMediaSource: 'desktop',
                      chromeMediaSourceId: sourceId,
                    },
                  },
                  video: {
                    mandatory: {
                      chromeMediaSource: 'desktop',
                      chromeMediaSourceId: sourceId,
                    },
                  },
                });
                if (legacyStream.getAudioTracks().length > 0) {
                  // Keep only the audio tracks, stop the redundant video tracks
                  legacyStream.getVideoTracks().forEach((t) => t.stop());
                  loopbackStream = new MediaStream(legacyStream.getAudioTracks());
                  hasSystemAudio = true;
                  console.log('[Recorder] System audio captured via legacy chromeMediaSource');
                } else {
                  legacyStream.getTracks().forEach((t) => t.stop());
                }
              } catch (legacyError) {
                console.log('[Recorder] Legacy system audio also unavailable:', legacyError.message);
              }
            }

            // Store for cleanup
            this.loopbackStream = loopbackStream;
            this.systemAudioActive = hasSystemAudio;

            // 3. Get mic stream separately
            let micStream = null;
            if (audioDeviceId) {
              try {
                micStream = await navigator.mediaDevices.getUserMedia({
                  audio: { deviceId: { exact: audioDeviceId } },
                  video: false,
                });
              } catch (micError) {
                console.warn('[Recorder] Mic not available:', micError.message);
              }
            }

            // 4. Mix audio via AudioContext (desktop + mic + external mics)
            const systemAudioTracks = loopbackStream ? loopbackStream.getAudioTracks() : [];
            const micAudioTracks = micStream ? micStream.getAudioTracks() : [];
            let mixedAudioTrack = null;

            if (systemAudioTracks.length > 0 || micAudioTracks.length > 0) {
              try {
                const audioContext = new AudioContext();
                const destination = audioContext.createMediaStreamDestination();

                const micVolumeLevel = this.micVolumeLevel !== undefined ? this.micVolumeLevel : 1.0;
                const desktopVolumeLevel = this.desktopVolumeLevel !== undefined ? this.desktopVolumeLevel : 1.0;

                if (micAudioTracks.length > 0) {
                  const micSource = audioContext.createMediaStreamSource(new MediaStream([micAudioTracks[0]]));
                  const micGain = audioContext.createGain();
                  micGain.gain.value = micVolumeLevel;
                  micSource.connect(micGain);
                  micGain.connect(destination);
                  this.pipMicGain = micGain;
                  console.log('[Recorder] Mic added to mix at volume:', micVolumeLevel);
                }

                if (systemAudioTracks.length > 0) {
                  const systemSource = audioContext.createMediaStreamSource(new MediaStream([systemAudioTracks[0]]));
                  const desktopGain = audioContext.createGain();
                  desktopGain.gain.value = desktopVolumeLevel;
                  systemSource.connect(desktopGain);
                  desktopGain.connect(destination);
                  this.pipDesktopGain = desktopGain;
                  console.log('[Recorder] Desktop audio added to mix at volume:', desktopVolumeLevel);
                }

                this.pipAudioContext = audioContext;
                this.pipAudioDestination = destination;

                // External mic 1
                const extMic1Id = this.elements.externalMicSource.value;
                if (extMic1Id) {
                  try {
                    this.externalMicStream = await navigator.mediaDevices.getUserMedia({
                      audio: { deviceId: { exact: extMic1Id } },
                      video: false,
                    });
                    const src = audioContext.createMediaStreamSource(this.externalMicStream);
                    const gain = audioContext.createGain();
                    gain.gain.value = this.externalMicVolumeLevel !== undefined ? this.externalMicVolumeLevel : 1.0;
                    src.connect(gain);
                    gain.connect(destination);
                    this.pipExternalMicGain = gain;
                  } catch (e) {
                    console.error('[Recorder] External mic 1 failed:', e);
                  }
                }

                // External mic 2
                const extMic2Id = this.elements.externalMic2Source.value;
                if (extMic2Id) {
                  try {
                    this.externalMic2Stream = await navigator.mediaDevices.getUserMedia({
                      audio: { deviceId: { exact: extMic2Id } },
                      video: false,
                    });
                    const src = audioContext.createMediaStreamSource(this.externalMic2Stream);
                    const gain = audioContext.createGain();
                    gain.gain.value = this.externalMic2VolumeLevel !== undefined ? this.externalMic2VolumeLevel : 1.0;
                    src.connect(gain);
                    gain.connect(destination);
                    this.pipExternalMic2Gain = gain;
                  } catch (e) {
                    console.error('[Recorder] External mic 2 failed:', e);
                  }
                }

                mixedAudioTrack = destination.stream.getAudioTracks()[0];
              } catch (mixError) {
                console.error('[Recorder] Audio mixing failed, using mic only:', mixError);
                mixedAudioTrack = micAudioTracks[0] || null;
              }
            }

            // 5. Build final stream: screen video + mixed audio
            const videoTrack = screenStream.getVideoTracks()[0];
            if (mixedAudioTrack) {
              this.stream = new MediaStream([videoTrack, mixedAudioTrack]);
              console.log('[Recorder] Screen stream with mixed audio (system audio:', hasSystemAudio, ')');
            } else {
              this.stream = new MediaStream([videoTrack]);
              console.log('[Recorder] Screen stream (no audio)');
            }

            // Store for cleanup
            this.pipScreenStream = screenStream;
            this.screenMicStream = micStream;

            this.elements.previewVideo.srcObject = this.stream;
            this.elements.previewPlaceholder.style.display = 'none';
            this.elements.previewVideo.style.display = 'block';
            this.elements.reviewVideo.style.display = 'none';

            // Start audio metering
            this.startAudioMeter(this.stream);

            // Show audio mix controls and system audio status
            this.updateAudioMixControlsVisibility();
            this.updateSystemAudioStatus(hasSystemAudio);

            console.log('[Recorder] Screen capture started:', sourceId);
          } catch (error) {
            console.error('[Recorder] Screen capture error:', error);
            this.showStatus('Failed to start screen capture: ' + error.message, 'error');
            this.cleanupPipResources();
          }
        },

        // Start screen + camera PiP capture
        async startScreenPipCapture(sourceId) {
          try {
            const audioDeviceId = this.elements.audioSource.value;

            // 1. Get screen video stream (video only)
            const screenStream = await navigator.mediaDevices.getUserMedia({
              audio: false,
              video: {
                mandatory: {
                  chromeMediaSource: 'desktop',
                  chromeMediaSourceId: sourceId,
                },
              },
            });

            // 2. Get system audio via native loopback, with legacy fallback
            let loopbackStream = null;
            let hasSystemAudio = false;

            loopbackStream = await this.getLoopbackAudioStream();
            if (loopbackStream) {
              hasSystemAudio = true;
            } else {
              // Fallback: try legacy chromeMediaSource desktop audio (works on Windows)
              // Desktop audio requires paired video capture, so we request both then discard the video
              try {
                const legacyStream = await navigator.mediaDevices.getUserMedia({
                  audio: {
                    mandatory: {
                      chromeMediaSource: 'desktop',
                      chromeMediaSourceId: sourceId,
                    },
                  },
                  video: {
                    mandatory: {
                      chromeMediaSource: 'desktop',
                      chromeMediaSourceId: sourceId,
                    },
                  },
                });
                if (legacyStream.getAudioTracks().length > 0) {
                  // Keep only the audio tracks, stop the redundant video tracks
                  legacyStream.getVideoTracks().forEach((t) => t.stop());
                  loopbackStream = new MediaStream(legacyStream.getAudioTracks());
                  hasSystemAudio = true;
                  console.log('[Recorder] System audio captured via legacy chromeMediaSource');
                } else {
                  legacyStream.getTracks().forEach((t) => t.stop());
                }
              } catch (legacyError) {
                console.log('[Recorder] Legacy system audio also unavailable:', legacyError.message);
              }
            }

            // Store for cleanup
            this.loopbackStream = loopbackStream;
            this.systemAudioActive = hasSystemAudio;

            // 3. Get camera + mic stream
            const devices = await navigator.mediaDevices.enumerateDevices();
            const videoDevices = devices.filter((d) => d.kind === 'videoinput');

            if (videoDevices.length === 0) {
              this.showStatus('No camera available for picture-in-picture', 'error');
              screenStream.getTracks().forEach((t) => t.stop());
              if (loopbackStream) loopbackStream.getTracks().forEach((t) => t.stop());
              return;
            }

            const cameraStream = await navigator.mediaDevices.getUserMedia({
              video: { deviceId: { exact: videoDevices[0].deviceId }, width: 320, height: 240 },
              audio: audioDeviceId ? { deviceId: { exact: audioDeviceId } } : true,
            });

            // 4. Mix audio (loopback system audio + mic + external mics)
            let mixedAudioTrack = null;
            const micAudioTracks = cameraStream.getAudioTracks();
            const systemAudioTracks = loopbackStream ? loopbackStream.getAudioTracks() : [];

            if (micAudioTracks.length > 0 || systemAudioTracks.length > 0) {
              try {
                const audioContext = new AudioContext();
                const destination = audioContext.createMediaStreamDestination();

                const micVolumeLevel = this.micVolumeLevel !== undefined ? this.micVolumeLevel : 1.0;
                const desktopVolumeLevel = this.desktopVolumeLevel !== undefined ? this.desktopVolumeLevel : 1.0;

                if (micAudioTracks.length > 0) {
                  const micSource = audioContext.createMediaStreamSource(new MediaStream([micAudioTracks[0]]));
                  const micGain = audioContext.createGain();
                  micGain.gain.value = micVolumeLevel;
                  micSource.connect(micGain);
                  micGain.connect(destination);
                  this.pipMicGain = micGain;
                }

                if (systemAudioTracks.length > 0) {
                  const systemSource = audioContext.createMediaStreamSource(new MediaStream([systemAudioTracks[0]]));
                  const desktopGain = audioContext.createGain();
                  desktopGain.gain.value = desktopVolumeLevel;
                  systemSource.connect(desktopGain);
                  desktopGain.connect(destination);
                  this.pipDesktopGain = desktopGain;
                }

                this.pipAudioDestination = destination;
                this.pipAudioContext = audioContext;

                // External mic 1
                const externalMicDeviceId = this.elements.externalMicSource.value;
                if (externalMicDeviceId) {
                  try {
                    this.externalMicStream = await navigator.mediaDevices.getUserMedia({
                      audio: { deviceId: { exact: externalMicDeviceId } },
                      video: false,
                    });
                    const externalMicSource = audioContext.createMediaStreamSource(this.externalMicStream);
                    const externalMicGain = audioContext.createGain();
                    const externalMicVolumeLevel =
                      this.externalMicVolumeLevel !== undefined ? this.externalMicVolumeLevel : 1.0;
                    externalMicGain.gain.value = externalMicVolumeLevel;
                    externalMicSource.connect(externalMicGain);
                    externalMicGain.connect(destination);
                    this.pipExternalMicGain = externalMicGain;
                  } catch (extMicError) {
                    console.error('[Recorder] Failed to add external mic 1:', extMicError);
                  }
                }

                // External mic 2
                const externalMic2DeviceId = this.elements.externalMic2Source.value;
                if (externalMic2DeviceId) {
                  try {
                    this.externalMic2Stream = await navigator.mediaDevices.getUserMedia({
                      audio: { deviceId: { exact: externalMic2DeviceId } },
                      video: false,
                    });
                    const externalMic2Source = audioContext.createMediaStreamSource(this.externalMic2Stream);
                    const externalMic2Gain = audioContext.createGain();
                    const externalMic2VolumeLevel =
                      this.externalMic2VolumeLevel !== undefined ? this.externalMic2VolumeLevel : 1.0;
                    externalMic2Gain.gain.value = externalMic2VolumeLevel;
                    externalMic2Source.connect(externalMic2Gain);
                    externalMic2Gain.connect(destination);
                    this.pipExternalMic2Gain = externalMic2Gain;
                  } catch (extMic2Error) {
                    console.error('[Recorder] Failed to add external mic 2:', extMic2Error);
                  }
                }

                mixedAudioTrack = destination.stream.getAudioTracks()[0];
              } catch (mixError) {
                console.error('[Recorder] Audio mixing failed, using mic only:', mixError);
                mixedAudioTrack = micAudioTracks[0] || null;
              }
            }

            // 5. Canvas compositing
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            const screenTrack = screenStream.getVideoTracks()[0];
            const screenSettings = screenTrack.getSettings();
            canvas.width = screenSettings.width || 1920;
            canvas.height = screenSettings.height || 1080;

            const screenVideo = document.createElement('video');
            screenVideo.srcObject = screenStream;
            screenVideo.muted = true;
            await screenVideo.play();

            const cameraVideo = document.createElement('video');
            cameraVideo.srcObject = cameraStream;
            cameraVideo.muted = true;
            await cameraVideo.play();

            const pipWidth = Math.round(canvas.width * 0.2);
            const pipHeight = Math.round(pipWidth * 0.75);
            const pipMargin = 20;
            const pipX = canvas.width - pipWidth - pipMargin;
            const pipY = canvas.height - pipHeight - pipMargin;

            this.pipScreenStream = screenStream;
            this.pipCameraStream = cameraStream;
            this.pipCanvas = canvas;
            this.pipScreenVideo = screenVideo;
            this.pipCameraVideo = cameraVideo;

            const drawFrame = () => {
              if (!this.pipCanvas) return;
              ctx.drawImage(screenVideo, 0, 0, canvas.width, canvas.height);
              ctx.save();
              ctx.beginPath();
              const radius = 10;
              ctx.moveTo(pipX + radius, pipY);
              ctx.lineTo(pipX + pipWidth - radius, pipY);
              ctx.quadraticCurveTo(pipX + pipWidth, pipY, pipX + pipWidth, pipY + radius);
              ctx.lineTo(pipX + pipWidth, pipY + pipHeight - radius);
              ctx.quadraticCurveTo(pipX + pipWidth, pipY + pipHeight, pipX + pipWidth - radius, pipY + pipHeight);
              ctx.lineTo(pipX + radius, pipY + pipHeight);
              ctx.quadraticCurveTo(pipX, pipY + pipHeight, pipX, pipY + pipHeight - radius);
              ctx.lineTo(pipX, pipY + radius);
              ctx.quadraticCurveTo(pipX, pipY, pipX + radius, pipY);
              ctx.closePath();
              ctx.clip();
              ctx.drawImage(cameraVideo, pipX, pipY, pipWidth, pipHeight);
              ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
              ctx.lineWidth = 2;
              ctx.stroke();
              ctx.restore();
              this.pipAnimationFrame = requestAnimationFrame(drawFrame);
            };

            drawFrame();

            const canvasStream = canvas.captureStream(30);
            if (mixedAudioTrack) {
              canvasStream.addTrack(mixedAudioTrack);
            }

            this.stream = canvasStream;
            this.elements.previewVideo.srcObject = this.stream;
            this.elements.previewPlaceholder.style.display = 'none';
            this.elements.previewVideo.style.display = 'block';
            this.elements.reviewVideo.style.display = 'none';

            // Start audio metering
            this.startAudioMeter(this.stream);

            const source = this.screenSources.find((s) => s.id === sourceId);
            if (source) {
              let option = this.elements.videoSource.querySelector('option[value="screen-pip"]');
              if (option) {
                option.textContent = `${source.name} + Camera`;
                option.value = `screen-pip:${sourceId}`;
                this.elements.videoSource.value = `screen-pip:${sourceId}`;
              }
            }

            this.updateAudioMixControlsVisibility();
            this.updateSystemAudioStatus(hasSystemAudio);
            console.log('[Recorder] Screen + Camera PiP capture started:', sourceId);
          } catch (error) {
            console.error('[Recorder] Screen + Camera PiP capture error:', error);
            this.showStatus('Failed to start screen + camera capture: ' + error.message, 'error');
            this.elements.videoSource.value = '';
            this.cleanupPipResources();
          }
        },

        // Cleanup PiP and screen capture audio resources
        cleanupPipResources() {
          if (this.pipAnimationFrame) {
            cancelAnimationFrame(this.pipAnimationFrame);
            this.pipAnimationFrame = null;
          }
          if (this.pipScreenStream) {
            this.pipScreenStream.getTracks().forEach((t) => t.stop());
            this.pipScreenStream = null;
          }
          if (this.pipCameraStream) {
            this.pipCameraStream.getTracks().forEach((t) => t.stop());
            this.pipCameraStream = null;
          }
          if (this.screenMicStream) {
            this.screenMicStream.getTracks().forEach((t) => t.stop());
            this.screenMicStream = null;
          }
          // Cleanup loopback audio stream
          if (this.loopbackStream) {
            this.loopbackStream.getTracks().forEach((t) => t.stop());
            this.loopbackStream = null;
          }
          this.systemAudioActive = false;
          if (this.pipScreenVideo) {
            this.pipScreenVideo.srcObject = null;
            this.pipScreenVideo = null;
          }
          if (this.pipCameraVideo) {
            this.pipCameraVideo.srcObject = null;
            this.pipCameraVideo = null;
          }
          if (this.pipAudioContext) {
            this.pipAudioContext.close();
            this.pipAudioContext = null;
          }
          if (this.externalMicStream) {
            this.externalMicStream.getTracks().forEach((t) => t.stop());
            this.externalMicStream = null;
          }
          if (this.externalMic2Stream) {
            this.externalMic2Stream.getTracks().forEach((t) => t.stop());
            this.externalMic2Stream = null;
          }
          this.pipMicGain = null;
          this.pipDesktopGain = null;
          this.pipExternalMicGain = null;
          this.pipExternalMic2Gain = null;
          this.pipAudioDestination = null;
          this.pipCanvas = null;
          // Reset system audio status indicator
          this.updateSystemAudioStatus(false);
          // Stop live transcription if still running
          this.stopLiveTranscription();
        },

        // Update the system audio status badge on the Desktop volume control
        updateSystemAudioStatus(active) {
          const badge = document.getElementById('desktopAudioStatus');
          if (!badge) return;
          if (active) {
            badge.textContent = 'Active';
            badge.className = 'audio-status-badge active';
            badge.title = 'System audio is being captured (meeting audio, app sounds, etc.)';
          } else {
            badge.textContent = 'Unavailable';
            badge.className = 'audio-status-badge';
            badge.title = 'System audio capture not available on this platform';
          }
        },

        // ==========================================
        // LIVE TRANSCRIPTION (OpenAI Realtime API)
        // ==========================================

        captionsEnabled: false,
        transcriptionWs: null,
        transcriptionAudioCtx: null,
        transcriptionProcessor: null,
        accumulatedTranscript: [],
        interimText: '',
        transcriptFlushInterval: null,
        transcriptLastFlushedIndex: 0,
        transcriptSessionId: null,
        transcriptRecordingStartedAt: null,

        toggleCaptions() {
          this.captionsEnabled = !this.captionsEnabled;
          this.elements.captionToggle.classList.toggle('active', this.captionsEnabled);
          this.elements.captionOverlay.classList.toggle('visible', this.captionsEnabled);
          if (!this.captionsEnabled) {
            this.elements.captionText.textContent = '';
          }
        },

        showCaption(text, isInterim = false) {
          if (!this.captionsEnabled) return;
          this.elements.captionText.textContent = text;
          this.elements.captionText.classList.toggle('interim', isInterim);
        },

        async startLiveTranscription() {
          // Only start if we have a mixed audio destination to tap
          if (!this.pipAudioDestination) {
            console.log('[Transcription] No audio destination to transcribe');
            return;
          }

          try {
            // Get API key
            const keyResult = await window.recorder.getOpenAIKey();
            if (!keyResult.success || !keyResult.key) {
              console.log('[Transcription] No OpenAI API key available, skipping live captions');
              return;
            }

            const apiKey = keyResult.key;

            // Get realtime model from centralized AI service profiles
            // Direct WebSocket is required here for low-latency audio streaming
            let realtimeModel = 'gpt-4o-realtime-preview';
            try {
              const profiles = await window.ai?.getProfiles?.();
              if (profiles?.realtime?.model) {
                realtimeModel = profiles.realtime.model;
              }
            } catch (e) {
              console.log('[Transcription] Using default realtime model');
            }
            const wsUrl = `wss://api.openai.com/v1/realtime?model=${realtimeModel}`;

            // Connect via WebSocket (browser uses subprotocols for auth)
            this.transcriptionWs = new WebSocket(wsUrl, [
              'realtime',
              `openai-insecure-api-key.${apiKey}`,
              'openai-beta.realtime-v1',
            ]);

            this.transcriptionWs.onopen = () => {
              console.log('[Transcription] WebSocket connected');

              // Configure session for transcription only
              this.transcriptionWs.send(
                JSON.stringify({
                  type: 'session.update',
                  session: {
                    modalities: ['text'],
                    input_audio_format: 'pcm16',
                    input_audio_transcription: {
                      model: 'whisper-1',
                    },
                    turn_detection: {
                      type: 'server_vad',
                      threshold: 0.5,
                      prefix_padding_ms: 400,
                      silence_duration_ms: 1000,
                    },
                  },
                })
              );

              // Show status
              this.elements.transcriptionStatus.classList.add('visible', 'active');
              this.elements.transcriptionStatusText.textContent = 'Live captions';

              // Start the periodic transcript file flush (every 5 seconds)
              this.startTranscriptFileFlush();

              // Start streaming audio
              this.startAudioStreaming();
            };

            this.transcriptionWs.onmessage = (event) => {
              try {
                const data = JSON.parse(event.data);
                this.handleTranscriptionEvent(data);
              } catch (e) {}
            };

            this.transcriptionWs.onerror = (error) => {
              console.error('[Transcription] WebSocket error:', error);
              this._trackError('transcription-ws', error?.message || 'WebSocket error');
            };

            this.transcriptionWs.onclose = (ev) => {
              console.log('[Transcription] WebSocket closed');
            };

            // Log first non-silent audio frame to verify audio is actually flowing
            let _audioCheckCount = 0;
            const _origHandler = this.transcriptionProcessor.onaudioprocess;
            this.transcriptionProcessor.onaudioprocess = (e) => {
              if (_audioCheckCount < 3) {
                const samples = e.inputBuffer.getChannelData(0);
                const maxAmp = Math.max(...Array.from(samples).map(Math.abs));
                _audioCheckCount++;
              }
              _origHandler.call(this, e);
            };

            console.log('[Transcription] Audio streaming started at 24kHz');
          } catch (error) {
            this._trackError('audio-streaming', error.message);
            console.error('[Transcription] Audio streaming failed:', error);
          }
        },

        handleTranscriptionEvent(data) {
          switch (data.type) {
            case 'conversation.item.input_audio_transcription.delta':
              if (data.delta) {
                this.interimText += data.delta;
                // Show interim caption with speaker name if in a meeting
                const speakerPrefix =
                  this.sessionConnected && this._currentSpeakerName ? this._currentSpeakerName + ': ' : '';
                this.showCaption(speakerPrefix + this.interimText, true);
              }
              break;

            case 'conversation.item.input_audio_transcription.completed':
              if (data.transcript) {
                const finalText = data.transcript.trim();
                if (finalText) {
                  // Capture who was speaking when this segment was uttered
                  const speaker = this.sessionConnected && this._currentSpeakerName ? this._currentSpeakerName : null;
                  this.accumulatedTranscript.push({
                    text: finalText,
                    speaker: speaker,
                    timestamp: Date.now(),
                  });
                  const displayText = speaker ? speaker + ': ' + finalText : finalText;
                  this.showCaption(displayText, false);
                  // Clear after display
                  setTimeout(() => {
                    if (this.elements.captionText.textContent === displayText) {
                      this.elements.captionText.classList.add('interim');
                    }
                  }, 4000);
                }
              }
              this.interimText = '';
              break;

            case 'input_audio_buffer.speech_started':
              this.interimText = '';
              // Snapshot who started speaking for this utterance
              if (this.sessionConnected && this._livekitRoom) {
                // _currentSpeakerName is already updated by ActiveSpeakersChanged
              }
              break;

            case 'error':
              console.error('[Transcription] API error:', data.error?.message || data);
              break;
          }
        },

        stopLiveTranscription() {
          if (this.transcriptionProcessor) {
            this.transcriptionProcessor.disconnect();
            this.transcriptionProcessor = null;
          }
          if (this.transcriptionAudioCtx) {
            this.transcriptionAudioCtx.close();
            this.transcriptionAudioCtx = null;
          }
          if (this.transcriptionWs) {
            if (this.transcriptionWs.readyState === WebSocket.OPEN) {
              this.transcriptionWs.close();
            }
            this.transcriptionWs = null;
          }
          this.interimText = '';
          this.elements.transcriptionStatus.classList.remove('visible', 'active');

          // Final flush and stop the interval
          this.stopTranscriptFileFlush(true);
        },

        // ==========================================
        // LIVE TRANSCRIPT FILE (Agent-readable .md)
        // ==========================================

        startTranscriptFileFlush() {
          // Create a unique session ID for this recording
          this.transcriptSessionId = `rec_${Date.now()}`;
          this.transcriptRecordingStartedAt = new Date().toISOString();
          this.transcriptLastFlushedIndex = 0;

          // Flush every 5 seconds
          this.transcriptFlushInterval = setInterval(() => {
            this.flushTranscriptToFile();
          }, 5000);

          // Do an initial write to create the file
          this.flushTranscriptToFile();
          console.log('[Transcription] Live transcript file flush started');
        },

        stopTranscriptFileFlush(doFinalFlush = false) {
          if (this.transcriptFlushInterval) {
            clearInterval(this.transcriptFlushInterval);
            this.transcriptFlushInterval = null;
          }
          if (doFinalFlush && this.transcriptSessionId) {
            this.flushTranscriptToFile(true);
          }
        },

        // Collect real-time health metrics from audio/video state + system diagnostics
        async collectHealthMetrics() {
          const health = {
            timestamp: Date.now(),
            recording: this.isRecording,
            paused: this.isPaused,
            videoActive: !!(this.stream && this.stream.getVideoTracks().some((t) => t.readyState === 'live')),
            audioTracks: {
              mic: !!(
                this.screenMicStream && this.screenMicStream.getAudioTracks().some((t) => t.readyState === 'live')
              ),
              desktop: this.systemAudioActive || false,
              externalMic: !!(
                this.externalMicStream && this.externalMicStream.getAudioTracks().some((t) => t.readyState === 'live')
              ),
            },
            volumes: {
              mic: this.micVolumeLevel || 0,
              desktop: this.desktopVolumeLevel || 0,
              externalMic: this.externalMicVolumeLevel || 0,
            },
            captionsConnected: !!(this.transcriptionWs && this.transcriptionWs.readyState === WebSocket.OPEN),
            captionsEnabled: this.captionsEnabled,
            transcriptLineCount: this.accumulatedTranscript.length,
            errors: this._recentErrors || [],
            system: null,
          };

          // Sample audio level from the mixer (RMS of recent buffer)
          if (this._lastAudioRMS !== undefined) {
            health.audioLevel = this._lastAudioRMS;
            health.audioSilent = this._lastAudioRMS < 0.005;
          }

          // Fetch system diagnostics (CPU, memory, battery) from main process
          try {
            if (window.recorder?.getSystemDiagnostics) {
              const diag = await window.recorder.getSystemDiagnostics();
              if (diag.success) {
                health.system = diag;
              }
            }
          } catch (e) {
            // Non-critical, skip if unavailable
          }

          return health;
        },

        // Track recent errors for health reporting
        _recentErrors: [],
        _trackError(source, message) {
          this._recentErrors.push({ source, message, at: Date.now() });
          // Keep only last 10, within last 60 seconds
          const cutoff = Date.now() - 60000;
          this._recentErrors = this._recentErrors.filter((e) => e.at > cutoff).slice(-10);
        },

        // Display a monitor alert toast in the recorder
        showMonitorAlert(alert) {
          const container = this.elements.monitorAlertContainer;
          if (!container) return;

          const el = document.createElement('div');
          el.className = `monitor-alert ${alert.severity || 'info'}`;
          el.innerHTML = `
          <svg class="monitor-alert-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
            ${
              alert.severity === 'warning'
                ? '<path d="M10.29 3.86L1.82 18a2 2 0 001.71 3h16.94a2 2 0 001.71-3L13.71 3.86a2 2 0 00-3.42 0z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/>'
                : '<circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/>'
            }
          </svg>
          <div class="monitor-alert-body">
            <div class="monitor-alert-message">${alert.message}</div>
            ${alert.suggestion ? `<div class="monitor-alert-suggestion">${alert.suggestion}</div>` : ''}
          </div>
          <button class="monitor-alert-dismiss" onclick="app.dismissMonitorAlert(this.closest('.monitor-alert'))">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/>
            </svg>
          </button>
        `;

          container.appendChild(el);

          // Auto-dismiss after 12 seconds
          setTimeout(() => {
            this.dismissMonitorAlert(el);
          }, 12000);
        },

        dismissMonitorAlert(el) {
          if (!el || !el.parentNode) return;
          el.classList.add('dismissing');
          setTimeout(() => {
            if (el.parentNode) el.parentNode.removeChild(el);
          }, 300);
        },

        async flushTranscriptToFile(isFinal = false) {
          if (!window.recorder?.writeLiveTranscript) return;

          const spaceId = this.elements.targetSpace?.value || 'gsx-agent';
          const filename = 'live-transcript.md';

          // Collect health metrics (async for system diagnostics)
          const health = await this.collectHealthMetrics();

          // Build markdown content
          const now = new Date();
          const elapsed = this.recordingStartTime
            ? Math.floor((Date.now() - this.recordingStartTime - (this.totalPausedMs || 0)) / 1000)
            : 0;
          const elapsedStr = this.formatDuration ? this.formatDuration(elapsed) : `${elapsed}s`;

          let md = `# Live Transcript\n\n`;
          md += `## Session\n\n`;
          md += `- **Status:** ${isFinal ? 'Recording ended' : this.isPaused ? 'Paused' : 'Recording'}\n`;
          md += `- **Session:** ${this.transcriptSessionId || 'unknown'}\n`;
          md += `- **Started:** ${this.transcriptRecordingStartedAt || 'unknown'}\n`;
          md += `- **Elapsed:** ${elapsedStr}\n`;
          md += `- **Updated:** ${now.toISOString()}\n`;
          md += `- **Lines:** ${this.accumulatedTranscript.length}\n\n`;

          // Health section -- structured for agent parsing
          md += `## Health\n\n`;
          md += `| Metric | Value |\n|--------|-------|\n`;
          md += `| Video active | ${health.videoActive ? 'Yes' : 'NO'} |\n`;
          md += `| Mic active | ${health.audioTracks.mic ? 'Yes' : 'NO'} |\n`;
          md += `| Desktop audio | ${health.audioTracks.desktop ? 'Yes' : 'NO'} |\n`;
          md += `| Audio level | ${health.audioLevel !== undefined ? health.audioLevel.toFixed(4) : 'N/A'} |\n`;
          md += `| Audio silent | ${health.audioSilent ? 'YES -- possible issue' : 'No'} |\n`;
          md += `| Captions connected | ${health.captionsConnected ? 'Yes' : 'No'} |\n`;
          md += `| Mic volume | ${Math.round((health.volumes.mic || 0) * 100)}% |\n`;
          md += `| Desktop volume | ${Math.round((health.volumes.desktop || 0) * 100)}% |\n`;

          // System diagnostics
          if (health.system) {
            const sys = health.system;
            const cpuStr = sys.cpu?.percent != null ? `${sys.cpu.percent}%` : 'N/A';
            const cpuHigh = sys.cpu?.percent > 80;
            md += `| CPU (app) | ${cpuStr}${cpuHigh ? ' -- HIGH' : ''} |\n`;
            md += `| CPU load avg | ${sys.cpu?.loadAvg?.toFixed(1) || 'N/A'} / ${sys.cpu?.cores || '?'} cores |\n`;
            const memPct = sys.memory?.percentUsed || 0;
            const memHigh = memPct > 85;
            md += `| Memory (system) | ${memPct}% used${memHigh ? ' -- HIGH' : ''} (${sys.memory?.systemFreeMB || '?'} MB free) |\n`;
            md += `| Memory (app) | ${sys.memory?.appMB || '?'} MB |\n`;
            md += `| Battery | ${sys.battery?.onBattery ? 'ON BATTERY' : 'AC power'} |\n`;
            if (sys.throttled > 0) {
              md += `| Throttled windows | ${sys.throttled} -- performance may be degraded |\n`;
            }
          }

          if (health.errors.length > 0) {
            md += `\n### Recent Errors\n\n`;
            for (const err of health.errors) {
              md += `- **${err.source}:** ${err.message} (${new Date(err.at).toISOString()})\n`;
            }
          }

          md += `\n---\n\n`;
          md += `## Transcript\n\n`;

          // Append all transcript lines with relative timestamps and speaker names
          if (this.accumulatedTranscript.length === 0) {
            md += `*Waiting for speech...*\n`;
          } else {
            let lastSpeaker = null;
            for (const entry of this.accumulatedTranscript) {
              const relMs = this.recordingStartTime ? entry.timestamp - this.recordingStartTime : 0;
              const relSec = Math.max(0, Math.floor(relMs / 1000));
              const mm = String(Math.floor(relSec / 60)).padStart(2, '0');
              const ss = String(relSec % 60).padStart(2, '0');
              // Show speaker name when it changes (or always if in a meeting)
              if (entry.speaker && entry.speaker !== lastSpeaker) {
                md += `**${entry.speaker}**\n\n`;
                lastSpeaker = entry.speaker;
              }
              md += `**[${mm}:${ss}]** ${entry.text}\n\n`;
            }
          }

          if (isFinal) {
            md += `---\n\n*Recording ended at ${now.toISOString()}*\n`;
          }

          try {
            const flushResult = await window.recorder.writeLiveTranscript({
              spaceId,
              content: md,
              filename,
            });
          } catch (err) {
            console.warn('[Transcription] Flush to file failed:', err.message);
          }
        },

        // ==========================================
        // POST-SAVE DIARIZED TRANSCRIPTION
        // ==========================================

        async triggerPostSaveTranscription(itemId) {
          try {
            // Show transcription in-progress status
            this.elements.transcriptionStatus.classList.add('visible');
            this.elements.transcriptionStatus.classList.remove('active');
            this.elements.transcriptionStatusText.textContent = 'Transcribing...';

            console.log(`[Recorder] Triggering post-save transcription for ${itemId}`);
            const result = await window.recorder.transcribeItem(itemId);

            if (result.success) {
              this.elements.transcriptionStatus.classList.add('active');
              const speakerInfo = result.speakerCount ? ` (${result.speakerCount} speakers)` : '';
              this.elements.transcriptionStatusText.textContent = `Transcript saved${speakerInfo}`;
              this.showStatus(`Transcript saved${speakerInfo}`, 'success');
              console.log(
                `[Recorder] Post-save transcription complete: ${result.wordCount} words, ${result.speakerCount} speakers`
              );

              // Fade out status after a few seconds
              setTimeout(() => {
                this.elements.transcriptionStatus.classList.remove('visible', 'active');
              }, 6000);
            } else {
              this.elements.transcriptionStatusText.textContent = 'Transcription failed';
              console.warn('[Recorder] Post-save transcription failed:', result.error);
              // Show briefly then hide
              setTimeout(() => {
                this.elements.transcriptionStatus.classList.remove('visible');
              }, 4000);
            }
          } catch (error) {
            console.error('[Recorder] Post-save transcription error:', error);
            this.elements.transcriptionStatus.classList.remove('visible', 'active');
          }
        },

        // Change audio source
        async changeAudioSource() {
          if (this.elements.videoSource.value && this.elements.videoSource.value !== 'screen') {
            await this.changeVideoSource();
          }
        },

        // Volume controls
        updateMicVolume(value) {
          const percent = parseInt(value);
          this.elements.micVolumeValue.textContent = `${percent}%`;
          this.micVolumeLevel = percent / 100;
          if (this.pipMicGain) {
            this.pipMicGain.gain.value = this.micVolumeLevel;
          }
        },

        updateDesktopVolume(value) {
          const percent = parseInt(value);
          this.elements.desktopVolumeValue.textContent = `${percent}%`;
          this.desktopVolumeLevel = percent / 100;
          if (this.pipDesktopGain) {
            this.pipDesktopGain.gain.value = this.desktopVolumeLevel;
          }
        },

        updateExternalMicVolume(micNum, value) {
          const percent = parseInt(value);
          if (micNum === 1) {
            this.elements.externalMicVolumeValue.textContent = `${percent}%`;
            this.externalMicVolumeLevel = percent / 100;
            if (this.pipExternalMicGain) {
              this.pipExternalMicGain.gain.value = this.externalMicVolumeLevel;
            }
          } else if (micNum === 2) {
            this.elements.externalMic2VolumeValue.textContent = `${percent}%`;
            this.externalMic2VolumeLevel = percent / 100;
            if (this.pipExternalMic2Gain) {
              this.pipExternalMic2Gain.gain.value = this.externalMic2VolumeLevel;
            }
          }
        },

        async updateExternalMicSource(micNum) {
          const sourceElement = micNum === 1 ? this.elements.externalMicSource : this.elements.externalMic2Source;
          const deviceId = sourceElement.value;
          const streamKey = micNum === 1 ? 'externalMicStream' : 'externalMic2Stream';
          const gainKey = micNum === 1 ? 'pipExternalMicGain' : 'pipExternalMic2Gain';
          const volumeKey = micNum === 1 ? 'externalMicVolumeLevel' : 'externalMic2VolumeLevel';

          if (this[streamKey]) {
            this[streamKey].getTracks().forEach((t) => t.stop());
            this[streamKey] = null;
          }

          if (!deviceId) {
            if (this[gainKey] && this.pipAudioContext) {
              this[gainKey].disconnect();
              this[gainKey] = null;
            }
            return;
          }

          try {
            this[streamKey] = await navigator.mediaDevices.getUserMedia({
              audio: { deviceId: { exact: deviceId } },
              video: false,
            });

            if (this.pipAudioContext && this.pipAudioDestination) {
              const micSource = this.pipAudioContext.createMediaStreamSource(this[streamKey]);
              const micGain = this.pipAudioContext.createGain();
              micGain.gain.value = this[volumeKey] !== undefined ? this[volumeKey] : 1.0;
              micSource.connect(micGain);
              micGain.connect(this.pipAudioDestination);
              this[gainKey] = micGain;
            }
          } catch (error) {
            console.error(`[Recorder] Failed to get external mic ${micNum}:`, error);
            this.showStatus(`Failed to access external mic ${micNum}: ` + error.message, 'error');
            sourceElement.value = '';
          }
        },

        populateExternalMicDropdown() {
          navigator.mediaDevices.enumerateDevices().then((devices) => {
            const audioDevices = devices.filter((d) => d.kind === 'audioinput');
            const primaryMicId = this.elements.audioSource.value;
            const extMic1Id = this.elements.externalMicSource.value;
            const extMic2Id = this.elements.externalMic2Source.value;

            this.elements.externalMicSource.innerHTML = '<option value="">None (disabled)</option>';
            audioDevices.forEach((device, i) => {
              if (device.deviceId === primaryMicId) return;
              if (device.deviceId === extMic2Id) return;
              const option = document.createElement('option');
              option.value = device.deviceId;
              option.textContent = device.label || `Microphone ${i + 1}`;
              if (device.deviceId === extMic1Id) option.selected = true;
              this.elements.externalMicSource.appendChild(option);
            });

            this.elements.externalMic2Source.innerHTML = '<option value="">None (disabled)</option>';
            audioDevices.forEach((device, i) => {
              if (device.deviceId === primaryMicId) return;
              if (device.deviceId === extMic1Id) return;
              const option = document.createElement('option');
              option.value = device.deviceId;
              option.textContent = device.label || `Microphone ${i + 1}`;
              if (device.deviceId === extMic2Id) option.selected = true;
              this.elements.externalMic2Source.appendChild(option);
            });
          });
        },

        updateAudioMixControlsVisibility() {
          const isScreenMode = this.currentMode === 'screen' || this.currentMode === 'both';
          this.elements.audioMixControls.classList.toggle('visible', isScreenMode);

          if (isScreenMode) {
            this.populateExternalMicDropdown();
          }
        },

        // Instructions
        setInstructions(data) {
          this.instructions = data;

          if (data.instructions) {
            this.elements.instructionsContent.textContent = data.instructions;
            this.elements.instructionsContent.classList.remove('empty');
          }

          if (data.targetDuration) {
            this.elements.targetDuration.textContent = `/ ~${this.formatDuration(data.targetDuration)}`;
          }

          // Pre-select target space from instructions
          if (data.spaceId) {
            if (this.elements.targetSpace) {
              this.elements.targetSpace.value = data.spaceId;
              this.updateTargetSpaceHighlight();
            }
            if (this.elements.saveSpace) {
              this.elements.saveSpace.value = data.spaceId;
              this.elements.saveSpace.dispatchEvent(new Event('change'));
            }
          }

          // Auto-open settings if instructions present
          if (data.instructions && !this.settingsOpen) {
            this.toggleSettings();
          }
        },

        // ==========================================
        // AUDIO LEVEL METERING
        // ==========================================
        startAudioMeter(stream) {
          this.stopAudioMeter();

          const audioTracks = stream.getAudioTracks();
          if (audioTracks.length === 0) return;

          try {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const analyser = audioContext.createAnalyser();
            analyser.fftSize = 64;
            analyser.smoothingTimeConstant = 0.8;

            const source = audioContext.createMediaStreamSource(stream);
            source.connect(analyser);

            this.audioAnalyser = analyser;
            this.audioMeterContext = audioContext;
            this.elements.audioMeter.classList.add('visible');

            const bars = this.elements.audioMeter.querySelectorAll('.audio-meter-bar');
            const dataArray = new Uint8Array(analyser.frequencyBinCount);

            const updateMeter = () => {
              analyser.getByteFrequencyData(dataArray);

              const numBars = bars.length;
              for (let i = 0; i < numBars; i++) {
                const dataIndex = Math.floor((i * dataArray.length) / numBars);
                const value = dataArray[dataIndex] / 255;
                const height = Math.max(3, value * 32);
                bars[i].style.height = height + 'px';
                bars[i].classList.toggle('peak', value > 0.85);
              }

              this.audioMeterFrame = requestAnimationFrame(updateMeter);
            };

            updateMeter();
          } catch (error) {
            console.warn('[Recorder] Audio metering not available:', error);
          }
        },

        stopAudioMeter() {
          if (this.audioMeterFrame) {
            cancelAnimationFrame(this.audioMeterFrame);
            this.audioMeterFrame = null;
          }
          if (this.audioMeterContext) {
            this.audioMeterContext.close();
            this.audioMeterContext = null;
          }
          this.audioAnalyser = null;
          this.elements.audioMeter && this.elements.audioMeter.classList.remove('visible');
        },

        // ==========================================
        // RECORDING WITH COUNTDOWN
        // ==========================================
        toggleRecording() {
          if (this.countdownActive) return;

          if (this.isRecording) {
            this.stopRecording();
          } else {
            this.startCountdown();
          }
        },

        // 3-2-1 countdown
        async startCountdown() {
          if (!this.stream) {
            this.showStatus('No media stream available. Select a source first.', 'error');
            return;
          }

          this.countdownActive = true;
          const overlay = this.elements.countdownOverlay;
          const number = this.elements.countdownNumber;

          for (let i = 3; i >= 1; i--) {
            number.textContent = i;
            number.style.animation = 'none';
            // Force reflow
            number.offsetHeight;
            number.style.animation = 'countdown-pop 0.8s ease-out';
            overlay.classList.add('active');
            await new Promise((r) => setTimeout(r, 800));
          }

          overlay.classList.remove('active');
          this.countdownActive = false;
          this.startRecording();
        },

        startRecording() {
          if (!this.stream) {
            this.showStatus('No media stream available', 'error');
            return;
          }

          this.recordedChunks = [];
          this.isPaused = false;
          this.totalPausedMs = 0;
          this.pauseStartTime = null;

          const options = { mimeType: 'video/webm;codecs=vp9,opus' };
          try {
            this.mediaRecorder = new MediaRecorder(this.stream, options);
          } catch (e) {
            this.mediaRecorder = new MediaRecorder(this.stream);
          }

          this.mediaRecorder.ondataavailable = (event) => {
            if (event.data.size > 0) {
              this.recordedChunks.push(event.data);
            }
          };

          this.mediaRecorder.onstop = () => {
            this.recordedBlob = new Blob(this.recordedChunks, { type: 'video/webm' });
            this.autoSaveRecording();
          };

          this.mediaRecorder.start(1000);
          this.isRecording = true;
          this.recordingStartTime = Date.now();

          // In session mode, notify the other side to start recording too
          if (this.sessionConnected) {
            this.sendSessionData({
              type: 'recording-start',
              timestamp: this.recordingStartTime,
            });
          }

          // Update UI
          this.elements.recordBtn.classList.add('recording');
          this.elements.recordingIndicator.classList.add('active');
          this.elements.durationDisplay.classList.add('visible');
          this.elements.previewContainer.classList.add('recording-active');
          this.elements.recordLabel.textContent = 'STOP';
          this.elements.pauseBtn.classList.add('visible');

          // Duration counter (excludes paused time)
          this.durationInterval = setInterval(() => {
            if (!this.isPaused) {
              const elapsed = (Date.now() - this.recordingStartTime - this.totalPausedMs) / 1000;
              this.elements.currentDuration.textContent = this.formatDuration(elapsed);
            }
          }, 100);

          // Start live transcription (async, non-blocking)
          this.startLiveTranscription();

          // Start meeting monitor agent
          const monitorSpaceId = this.elements.targetSpace?.value || 'gsx-agent';
          if (window.recorder?.startMonitor) {
            window.recorder.startMonitor(monitorSpaceId).catch(() => {});
          }

          console.log('[Recorder] Recording started');
        },

        togglePause() {
          if (!this.isRecording || !this.mediaRecorder) return;

          if (this.isPaused) {
            // Resume
            this.mediaRecorder.resume();
            this.isPaused = false;

            // Track paused duration
            if (this.pauseStartTime) {
              this.totalPausedMs += Date.now() - this.pauseStartTime;
              this.pauseStartTime = null;
            }

            // Restore audio gain levels
            if (this.pipMicGain) this.pipMicGain.gain.value = this.savedMicGain || 1.0;
            if (this.pipDesktopGain) this.pipDesktopGain.gain.value = this.savedDesktopGain || 1.0;
            if (this.pipExternalMicGain) this.pipExternalMicGain.gain.value = this.savedExtMic1Gain || 1.0;
            if (this.pipExternalMic2Gain) this.pipExternalMic2Gain.gain.value = this.savedExtMic2Gain || 1.0;

            // Update UI
            this.elements.pauseBtn.classList.remove('paused');
            this.elements.pauseBtn.title = 'Pause recording';
            this.elements.pausedOverlay.classList.remove('active');
            this.elements.recordingIndicator.querySelector('span').textContent = 'REC';
            // Restore pause icon (two bars)
            this.elements.pauseIcon.innerHTML =
              '<rect x="6" y="4" width="4" height="16" rx="1"/><rect x="14" y="4" width="4" height="16" rx="1"/>';

            console.log('[Recorder] Recording resumed');
          } else {
            // Pause
            this.mediaRecorder.pause();
            this.isPaused = true;
            this.pauseStartTime = Date.now();

            // Save current gain levels then mute all audio
            this.savedMicGain = this.pipMicGain ? this.pipMicGain.gain.value : 1.0;
            this.savedDesktopGain = this.pipDesktopGain ? this.pipDesktopGain.gain.value : 1.0;
            this.savedExtMic1Gain = this.pipExternalMicGain ? this.pipExternalMicGain.gain.value : 1.0;
            this.savedExtMic2Gain = this.pipExternalMic2Gain ? this.pipExternalMic2Gain.gain.value : 1.0;

            if (this.pipMicGain) this.pipMicGain.gain.value = 0;
            if (this.pipDesktopGain) this.pipDesktopGain.gain.value = 0;
            if (this.pipExternalMicGain) this.pipExternalMicGain.gain.value = 0;
            if (this.pipExternalMic2Gain) this.pipExternalMic2Gain.gain.value = 0;

            // Update UI
            this.elements.pauseBtn.classList.add('paused');
            this.elements.pauseBtn.title = 'Resume recording';
            this.elements.pausedOverlay.classList.add('active');
            this.elements.recordingIndicator.querySelector('span').textContent = 'PAUSED';
            // Switch to play/resume icon (triangle)
            this.elements.pauseIcon.innerHTML = '<polygon points="6,4 20,12 6,20"/>';

            console.log('[Recorder] Recording paused');
          }
        },

        stopRecording() {
          // In session mode, notify the other side to stop recording too
          if (this.sessionConnected) {
            this.sendSessionData({
              type: 'recording-stop',
              timestamp: Date.now(),
            });
          }

          // If paused, account for final pause duration
          if (this.isPaused && this.pauseStartTime) {
            this.totalPausedMs += Date.now() - this.pauseStartTime;
          }

          if (this.mediaRecorder && this.mediaRecorder.state !== 'inactive') {
            // Resume if paused before stopping (MediaRecorder requires active state to stop cleanly)
            if (this.mediaRecorder.state === 'paused') {
              this.mediaRecorder.resume();
            }
            this.mediaRecorder.stop();
          }

          this.isRecording = false;
          this.isPaused = false;
          clearInterval(this.durationInterval);

          // Update UI
          this.elements.recordBtn.classList.remove('recording');
          this.elements.recordingIndicator.classList.remove('active');
          this.elements.recordingIndicator.querySelector('span').textContent = 'REC';
          this.elements.previewContainer.classList.remove('recording-active');
          this.elements.recordLabel.textContent = 'REC';
          this.elements.pauseBtn.classList.remove('visible', 'paused');
          this.elements.pausedOverlay.classList.remove('active');
          // Reset pause icon
          this.elements.pauseIcon.innerHTML =
            '<rect x="6" y="4" width="4" height="16" rx="1"/><rect x="14" y="4" width="4" height="16" rx="1"/>';

          // Stop live transcription
          this.stopLiveTranscription();
          this.elements.captionOverlay.classList.remove('visible');

          // Stop meeting monitor agent
          if (window.recorder?.stopMonitor) {
            window.recorder.stopMonitor().catch(() => {});
          }

          console.log('[Recorder] Recording stopped');
        },

        // Review mode
        showReview() {
          this.lastRecordingDuration = (Date.now() - this.recordingStartTime - (this.totalPausedMs || 0)) / 1000;

          if (this.reviewBlobUrl) {
            URL.revokeObjectURL(this.reviewBlobUrl);
          }

          this.elements.previewVideo.style.display = 'none';
          this.elements.reviewVideo.style.display = 'block';
          this.reviewBlobUrl = URL.createObjectURL(this.recordedBlob);
          this.elements.reviewVideo.src = this.reviewBlobUrl;

          // Switch controls
          this.elements.controlsBar.style.display = 'none';
          this.elements.reviewControls.classList.add('visible');
          this.elements.durationDisplay.classList.remove('visible');

          // Set filename
          const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
          this.elements.saveFilename.value = `recording_${timestamp}.webm`;
        },

        recordAgain() {
          if (this.reviewBlobUrl) {
            URL.revokeObjectURL(this.reviewBlobUrl);
            this.reviewBlobUrl = null;
          }

          this.elements.previewVideo.style.display = 'block';
          this.elements.reviewVideo.style.display = 'none';
          this.elements.reviewVideo.src = '';

          this.elements.controlsBar.style.display = 'flex';
          this.elements.reviewControls.classList.remove('visible');

          this.elements.currentDuration.textContent = '00:00';
          this.elements.durationDisplay.classList.remove('visible');
          this.recordedBlob = null;
          this.recordedChunks = [];
          this.lastRecordingDuration = null;

          // Reset live transcription state
          this.accumulatedTranscript = [];
          this.interimText = '';
          this.transcriptLastFlushedIndex = 0;
          this.transcriptSessionId = null;
          this.transcriptRecordingStartedAt = null;
          this.elements.captionText.textContent = '';
          this.elements.transcriptionStatus.classList.remove('visible', 'active');
        },

        discardRecording() {
          this.recordAgain();
          this.showStatus('Recording discarded', 'error');
        },

        // Save dialog
        showSaveDialog() {
          // Sync target space into save dialog
          const targetSpaceId = this.elements.targetSpace.value;
          if (targetSpaceId && !this.elements.saveSpace.value) {
            this.elements.saveSpace.value = targetSpaceId;
            this.elements.saveSpace.dispatchEvent(new Event('change'));
          }
          this.elements.saveDialog.classList.add('active');
        },

        hideSaveDialog() {
          this.elements.saveDialog.classList.remove('active');
        },

        async saveRecording() {
          if (!this.recordedBlob) {
            this.showStatus('No recording to save', 'error');
            return;
          }

          const filename = this.elements.saveFilename.value || 'recording.webm';
          const spaceId = this.elements.saveSpace.value;

          // Require a space to be selected
          if (!spaceId) {
            this.showStatus('Please select a space to save to', 'error');
            this.elements.saveSpace.focus();
            return;
          }

          try {
            // Show saving state
            this.showStatus('Saving recording...', 'info');

            // Convert blob to base64
            const reader = new FileReader();
            const base64Promise = new Promise((resolve, reject) => {
              reader.onload = () => {
                const base64 = reader.result.split(',')[1];
                resolve(base64);
              };
              reader.onerror = reject;
            });
            reader.readAsDataURL(this.recordedBlob);
            const base64Data = await base64Promise;

            // Save via IPC (goes through clipboard storage for proper Spaces indexing)
            if (window.recorder) {
              const result = await window.recorder.saveToSpace({
                blob: base64Data,
                filename,
                spaceId,
                metadata: {
                  duration: this.lastRecordingDuration || 0,
                  instructions: this.instructions?.instructions || null,
                  recordedAt: new Date().toISOString(),
                },
              });

              if (result.success) {
                const spaceName = result.spaceName || 'space';
                this.showStatus(`Saved to ${spaceName}`, 'success');
                this.hideSaveDialog();

                // Auto-trigger diarized transcription in the background
                if (result.itemId && window.recorder.transcribeItem) {
                  this.triggerPostSaveTranscription(result.itemId);
                }

                // === P2P SESSION: Track transfer logic ===
                if (this.sessionConnected) {
                  if (this.sessionRole === 'host') {
                    // Host saved -- remember the item ID for merge later
                    this.hostTrackItemId = result.itemId;
                    this.showStatus(`Host track saved to ${spaceName}. Waiting for guest track...`, 'success');

                    // If guest track was already received (race: guest saved first), offer merge
                    if (this.guestTrackItemId) {
                      setTimeout(() => this.showMergeDialog(), 500);
                    }
                    return; // Don't recordAgain -- session is still active
                  } else if (this.sessionRole === 'guest') {
                    // Guest saved locally -- now transfer to the host via data channel
                    this.showStatus('Sending recording to host...', 'info');
                    await this.sendRecordingToHost();
                    return;
                  }
                }

                setTimeout(() => {
                  this.recordAgain();
                }, 2000);
              } else {
                throw new Error(result.error || 'Save failed');
              }
            }
          } catch (error) {
            console.error('[Recorder] Save error:', error);
            this.showStatus('Failed to save: ' + error.message, 'error');
          }
        },

        // ==========================================
        // AUTO-SAVE (recording + transcript saved automatically on stop)
        // ==========================================

        async autoSaveRecording() {
          if (!this.recordedBlob) {
            console.warn('[Recorder] Auto-save: no recorded blob');
            this.showReview(); // fall back to manual review
            return;
          }

          this.lastRecordingDuration = (Date.now() - this.recordingStartTime - (this.totalPausedMs || 0)) / 1000;

          // Use the selected space, fall back to 'unclassified' so nothing is ever lost
          const spaceId = this.elements.targetSpace?.value || 'unclassified';
          const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
          const filename = `recording_${timestamp}.webm`;

          try {
            this.showStatus('Saving recording...', 'info');

            // Convert blob to base64
            const reader = new FileReader();
            const base64Data = await new Promise((resolve, reject) => {
              reader.onload = () => resolve(reader.result.split(',')[1]);
              reader.onerror = reject;
              reader.readAsDataURL(this.recordedBlob);
            });

            if (!window.recorder?.saveToSpace) {
              throw new Error('Save API not available');
            }

            const result = await window.recorder.saveToSpace({
              blob: base64Data,
              filename,
              spaceId,
              metadata: {
                duration: this.lastRecordingDuration || 0,
                instructions: this.instructions?.instructions || null,
                recordedAt: new Date().toISOString(),
              },
            });

            if (!result.success) {
              throw new Error(result.error || 'Save failed');
            }

            const spaceName = result.spaceName || 'space';

            // Save accumulated transcript as a separate indexed item
            if (this.accumulatedTranscript && this.accumulatedTranscript.length > 0) {
              await this.saveTranscriptAsItem(spaceId, timestamp);
              this.showStatus(`Recording + transcript saved to ${spaceName}`, 'success');
            } else {
              this.showStatus(`Recording saved to ${spaceName}`, 'success');
            }

            // Auto-trigger diarized transcription in the background
            if (result.itemId && window.recorder?.transcribeItem) {
              this.triggerPostSaveTranscription(result.itemId);
            }

            // === P2P SESSION: Track transfer logic ===
            if (this.sessionConnected) {
              if (this.sessionRole === 'host') {
                this.hostTrackItemId = result.itemId;
                this.showStatus(`Host track saved to ${spaceName}. Waiting for guest track...`, 'success');
                if (this.guestTrackItemId) {
                  setTimeout(() => this.showMergeDialog(), 500);
                }
                return;
              } else if (this.sessionRole === 'guest') {
                this.showStatus('Sending recording to host...', 'info');
                await this.sendRecordingToHost();
                return;
              }
            }

            console.log('[Recorder] Auto-save complete:', { filename, spaceId: spaceName, itemId: result.itemId });

            // Reset for next recording after a short delay
            setTimeout(() => this.recordAgain(), 2500);
          } catch (error) {
            console.error('[Recorder] Auto-save failed:', error);
            this.showStatus('Auto-save failed: ' + error.message + ' -- use manual save', 'error');
            // Fall back to manual review/save so the recording isn't lost
            this.showReview();
          }
        },

        async saveTranscriptAsItem(spaceId, timestamp) {
          try {
            if (!window.recorder?.saveTranscriptToSpace) {
              console.warn('[Recorder] saveTranscriptToSpace API not available');
              return;
            }

            // Build readable transcript markdown
            let md = `# Meeting Transcript\n\n`;
            md += `**Recorded:** ${new Date(this.recordingStartTime).toLocaleString()}\n`;
            md += `**Duration:** ${this.formatDuration(this.lastRecordingDuration || 0)}\n`;
            md += `**Lines:** ${this.accumulatedTranscript.length}\n\n---\n\n`;

            let lastSpeaker = null;
            for (const entry of this.accumulatedTranscript) {
              const relMs = this.recordingStartTime ? entry.timestamp - this.recordingStartTime : 0;
              const relSec = Math.max(0, Math.floor(relMs / 1000));
              const mm = String(Math.floor(relSec / 60)).padStart(2, '0');
              const ss = String(relSec % 60).padStart(2, '0');
              if (entry.speaker && entry.speaker !== lastSpeaker) {
                md += `\n**${entry.speaker}**\n\n`;
                lastSpeaker = entry.speaker;
              }
              md += `**[${mm}:${ss}]** ${entry.text}\n\n`;
            }

            const filename = `transcript_${timestamp}.md`;
            const result = await window.recorder.saveTranscriptToSpace({
              content: md,
              filename,
              spaceId,
              metadata: {
                duration: this.lastRecordingDuration || 0,
                recordedAt: new Date().toISOString(),
                lineCount: this.accumulatedTranscript.length,
              },
            });

            if (result?.success) {
              console.log('[Recorder] Transcript saved as indexed item:', result.itemId);
            }
          } catch (err) {
            console.warn('[Recorder] Failed to save transcript item:', err.message);
          }
        },

        // Utilities
        formatDuration(seconds) {
          const mins = Math.floor(seconds / 60);
          const secs = Math.floor(seconds % 60);
          return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        },

        showStatus(message, type = 'info') {
          this.elements.statusText.textContent = message;
          this.elements.statusMessage.className = 'status-message active ' + type;

          setTimeout(() => {
            this.elements.statusMessage.classList.remove('active');
          }, 3000);
        },

        // Window controls
        minimize() {
          if (window.recorder) {
            window.recorder.minimize();
          }
        },

        // ==========================================
        // P2P SESSION (Riverside-style dual recording)
        // ==========================================

        // Session state
        peerConnection: null,
        dataChannel: null,
        remoteStream: null,
        sessionCode: null,
        sessionRole: null, // 'host' | 'guest'
        sessionConnected: false,
        micMuted: false,
        cameraOff: false,
        _hostDisplayName: '', // Host's display name
        _currentSpeakerName: null, // Name of current speaker (for transcription)

        // Multi-participant layout state
        _participants: new Map(), // sid -> { container, identity, isSpeaking }
        _currentSpotlightSid: null, // sid of the participant currently in spotlight
        _speakerDebounceTimer: null, // debounce timer for speaker changes
        _audioGlowFrame: null, // requestAnimationFrame id for audio-reactive glow
        _localParticipantSid: 'local', // key used for the host's own tile

        // Session state for host address
        hostAddress: null,
        publicJoinUrl: null,

        // Session elements (cached on first use)
        getSessionElements() {
          if (!this._sessionEls) {
            this._sessionEls = {
              setup: document.getElementById('sessionSetup'),
              hostWaiting: document.getElementById('sessionHostWaiting'),
              codeDisplay: document.getElementById('sessionCodeDisplay'),
              hostAddressDisplay: document.getElementById('sessionHostAddress'),
              hostStatus: document.getElementById('hostSessionStatus'),
              publicJoinSection: document.getElementById('publicJoinSection'),
              publicJoinUrl: document.getElementById('publicJoinUrl'),
              joinPanel: document.getElementById('sessionJoinPanel'),
              joinHostInput: document.getElementById('joinHostInput'),
              joinInput: document.getElementById('joinCodeInput'),
              joinBtn: document.getElementById('joinConnectBtn'),
              joinStatus: document.getElementById('joinSessionStatus'),
              connectedBadge: document.getElementById('sessionConnectedBadge'),
              endSessionBtn: document.getElementById('endSessionBtn'),
              remoteVideo: document.getElementById('remoteVideo'),
            };
          }
          return this._sessionEls;
        },

        // Show setup (choose host or join)
        sessionShowSetup() {
          const els = this.getSessionElements();
          els.setup.classList.add('visible');
          els.hostWaiting.classList.remove('visible');
          els.joinPanel.classList.remove('visible');
          // Reset guest activity indicator
          const guestActivity = document.getElementById('guestActivity');
          if (guestActivity) guestActivity.classList.remove('visible', 'error');
          const waitingText = document.getElementById('waitingText');
          if (waitingText) waitingText.style.display = '';
          // Sync session space selector with main target space
          const sessionSel = document.getElementById('sessionSpaceSelect');
          if (sessionSel && this.elements.targetSpace) {
            sessionSel.value = this.elements.targetSpace.value || '';
            sessionSel.classList.toggle('unset', !sessionSel.value);
          }
        },

        // Show join panel
        sessionShowJoin() {
          const els = this.getSessionElements();
          els.setup.classList.remove('visible');
          els.joinPanel.classList.add('visible');
          els.joinStatus.textContent = '';
          els.joinInput.value = '';
          els.joinInput.focus();
        },

        // Hide all session panels
        sessionHideAllPanels() {
          const els = this.getSessionElements();
          els.setup.classList.remove('visible');
          els.hostWaiting.classList.remove('visible');
          els.joinPanel.classList.remove('visible');
        },

        // HOST: Start hosting a session via LiveKit
        async sessionHost() {
          // Require host name
          const hostNameInput = document.getElementById('hostNameInput');
          const hostName = (hostNameInput?.value || '').trim();
          if (!hostName) {
            hostNameInput?.focus();
            this.showStatus('Please enter your name before starting a meeting', 'error');
            return;
          }
          // Save for future sessions
          try {
            localStorage.setItem('wiser-host-name', hostName);
          } catch {}
          this._hostDisplayName = hostName;

          // Require a space to be selected  the space name becomes the room name
          const spaceSelect = this.elements.targetSpace;
          if (!spaceSelect || !spaceSelect.value) {
            // Highlight the session panel's space selector (visible to the user)
            const sessionSel = document.getElementById('sessionSpaceSelect');
            if (sessionSel) {
              sessionSel.classList.add('unset');
              sessionSel.focus();
            }
            this.showStatus('Please select a space before starting a meeting', 'error');
            return;
          }

          const els = this.getSessionElements();
          els.setup.classList.remove('visible');
          els.hostWaiting.classList.add('visible');
          els.hostStatus.textContent = 'Setting up...';
          this.sessionRole = 'host';

          try {
            // 1. Derive room name from space name
            const spaceName = spaceSelect.options[spaceSelect.selectedIndex]?.textContent || '';
            const roomName =
              spaceName
                .toLowerCase()
                .replace(/[^a-z0-9]+/g, '-')
                .replace(/^-+|-+$/g, '') || 'wiser-meeting';

            // 2. Create LiveKit room and get tokens
            els.hostStatus.textContent = 'Creating meeting room...';
            const result = await window.recorder.createRoom(roomName);
            if (!result.success) {
              throw new Error(result.error || 'Failed to create room');
            }

            this.sessionCode = result.roomName;
            this._livekitUrl = result.livekitUrl;
            els.codeDisplay.childNodes[0].textContent = result.roomName;

            // 3. Connect to LiveKit room as host
            els.hostStatus.textContent = 'Connecting to meeting...';
            const { Room, RoomEvent, DataPacket_Kind } = LivekitClient;
            this._livekitRoom = new Room({
              adaptiveStream: true,
              dynacast: true,
            });

            // Track subscriptions  per-participant container management
            this._livekitRoom.on(RoomEvent.TrackSubscribed, (track, publication, participant) => {
              const pName = participant.name || participant.identity;
              console.log('[LiveKit] Track subscribed:', track.kind, 'from', pName);
              const container = this._ensureParticipantContainer(participant.sid, pName);
              const element = track.attach();
              if (track.kind === 'video') {
                element.style.width = '100%';
                element.style.height = '100%';
                element.style.objectFit = 'cover';
                element.dataset.trackSid = track.sid;
                container.appendChild(element);
              } else if (track.kind === 'audio') {
                element.dataset.trackSid = track.sid;
                element.style.display = 'none';
                container.appendChild(element);
                // Explicitly play to overcome autoplay policy
                const playPromise = element.play();
                if (playPromise) {
                  playPromise
                    .then(() => {})
                    .catch(() => {});
                }
              }
              this._updateLayout();
            });

            this._livekitRoom.on(RoomEvent.TrackUnsubscribed, (track, publication, participant) => {
              track.detach().forEach((el) => el.remove());
            });

            // Guest presence awareness
            this._livekitRoom.on(RoomEvent.ParticipantConnected, (participant) => {
              const pName = participant.name || participant.identity;
              console.log('[LiveKit] Participant connected:', pName);
              const activity = document.getElementById('guestActivity');
              const waitingText = document.getElementById('waitingText');
              if (activity) {
                activity.classList.remove('visible');
                if (waitingText) waitingText.style.display = 'none';
              }
              // Enter session mode on first remote participant
              if (!this.sessionConnected) {
                this._enterSessionMode();
              }
              this._ensureParticipantContainer(participant.sid, pName);
              this._updateLayout();
              this.showStatus(pName + ' joined the meeting', 'success');

              // Late-joiner sync: if recording is active, tell the new guest to start recording
              if (this.isRecording) {
                console.log('[LiveKit] Syncing recording state to late-joiner:', participant.identity);
                this.sendSessionData(
                  {
                    type: 'recording-start',
                    timestamp: this.recordingStartTime,
                  },
                  [participant.identity]
                );
              }
            });

            // Update display name when a participant sets their name after connecting
            this._livekitRoom.on(RoomEvent.ParticipantNameChanged, (name, participant) => {
              const entry = this._participants.get(participant.sid);
              if (entry) {
                entry.identity = name || participant.identity;
                const label = entry.container.querySelector('.participant-label');
                if (label) label.textContent = entry.identity;
                console.log('[LiveKit] Participant renamed:', entry.identity);
              }
            });

            this._livekitRoom.on(RoomEvent.ParticipantDisconnected, (participant) => {
              const pName = participant.name || participant.identity;
              console.log('[LiveKit] Participant disconnected:', pName);
              this._removeParticipantContainer(participant.sid);
              this._updateLayout();
              const remoteCount = this._participants.size - 1; // exclude local
              if (remoteCount <= 0) {
                this.showStatus('All guests disconnected. Click End Session when ready.', 'error');
              } else {
                this.showStatus(`${participant.identity} left the meeting.`, 'info');
              }
            });

            // Active speaker detection with debounce
            this._livekitRoom.on(RoomEvent.ActiveSpeakersChanged, (speakers) => {
              this._handleActiveSpeakersChanged(speakers);
            });

            // Data messages (recording sync + track transfer)
            this._livekitRoom.on(RoomEvent.DataReceived, (data, participant) => {
              try {
                const senderId = participant?.identity || 'unknown';
                // Binary data = track transfer chunk from the active sender
                if (data instanceof Uint8Array && this.transferInProgress && this._transferSenderId === senderId) {
                  this.handleTrackTransferChunk(data.buffer);
                  return;
                }
                // Text data = JSON message
                const msg = JSON.parse(new TextDecoder().decode(data));
                if (msg.type === 'recording-start') {
                  console.log('[Session] Guest started recording:', senderId);
                } else if (msg.type === 'recording-stop') {
                  console.log('[Session] Guest stopped recording:', senderId);
                } else if (msg.type === 'track-transfer-start') {
                  this.handleTrackTransferStart(msg, senderId);
                } else if (msg.type === 'track-transfer-complete') {
                  this.handleTrackTransferComplete(senderId);
                }
              } catch {}
            });

            this._livekitRoom.on(RoomEvent.Disconnected, () => {
              console.log('[LiveKit] Disconnected from room');
              this.showStatus('Disconnected from meeting server.', 'error');
            });

            // Connect
            await this._livekitRoom.connect(result.livekitUrl, result.hostToken);
            console.log('[LiveKit] Host connected to room:', result.roomName);

            // Set host display name so guests and transcription can identify us
            if (this._hostDisplayName) {
              try {
                this._livekitRoom.localParticipant.setName(this._hostDisplayName);
                this._livekitRoom.localParticipant.setMetadata(JSON.stringify({ displayName: this._hostDisplayName }));
              } catch (e) {
                console.warn('[LiveKit] Could not set host name:', e);
              }
            }

            // Start audio-reactive glow animation loop
            this._startAudioGlow();

            // 4. Publish local camera/mic (LiveKit handles tracks internally)
            await this._livekitRoom.localParticipant.enableCameraAndMicrophone();
            els.hostStatus.textContent = '';

            // Attach local video to preview element
            const localCamPub = this._livekitRoom.localParticipant.getTrackPublication(
              LivekitClient.Track.Source.Camera
            );
            if (localCamPub && localCamPub.track) {
              const el = localCamPub.track.attach();
              el.style.width = '100%';
              el.style.height = '100%';
              el.style.objectFit = 'cover';
              el.muted = true; // Don't play own audio
              this.elements.previewVideo.style.display = 'none';
              this.elements.previewVideo.parentElement?.insertBefore(el, this.elements.previewVideo);
              el.id = 'lk-local-video';
              this.elements.previewPlaceholder.style.display = 'none';
            }

            // Attach local mic for audio metering
            const localMicPub = this._livekitRoom.localParticipant.getTrackPublication(
              LivekitClient.Track.Source.Microphone
            );
            if (localMicPub && localMicPub.track) {
              // Create a MediaStream from the LiveKit mic track for the audio meter
              const mediaTrack = localMicPub.track.mediaStreamTrack;
              if (mediaTrack) {
                this.stream = new MediaStream([mediaTrack]);
                // Also add video track for recording
                if (localCamPub && localCamPub.track && localCamPub.track.mediaStreamTrack) {
                  this.stream.addTrack(localCamPub.track.mediaStreamTrack);
                }
                this.startAudioMeter(this.stream);
              }
            }

            // 5. Publish guest page and build join link
            els.publicJoinSection.style.display = 'block';
            els.publicJoinUrl.textContent = 'Creating join link...';

            try {
              await this.setupPublicJoin(result.guestTokens, result.livekitUrl, result.roomName, els);
            } catch (err) {
              console.error('[Session] Guest page publish failed:', err);
              els.publicJoinUrl.textContent =
                'Guest page unavailable  share room name "' + result.roomName + '" manually';
            }

            // Hide LAN address (not needed with LiveKit)
            els.hostAddressDisplay.style.display = 'none';
          } catch (error) {
            console.error('[Session] Host error:', error);
            els.hostStatus.textContent = 'Error: ' + error.message;
            els.hostStatus.classList.add('error');
          }
        },

        // Copy public join URL (delegates to unified copy)
        copyPublicJoinUrl() {
          this.copySessionCode();
        },

        // Store meeting tokens in KV and ensure permanent guest page exists
        async setupPublicJoin(guestTokens, livekitUrl, roomName, els) {
          console.log('[Session] Storing', (guestTokens || []).length, 'tokens for room:', roomName);
          els.hostStatus.textContent = 'Preparing meeting room...';

          // 1. Store tokens in GSX KeyValue (guests fetch from here at join time)
          const kvResult = await window.recorder.storeMeetingTokens({
            roomName: roomName,
            guestTokens: guestTokens || [],
            livekitUrl: livekitUrl || '',
          });
          if (!kvResult.success) {
            throw new Error('Failed to store meeting tokens: ' + (kvResult.error || 'unknown'));
          }
          console.log('[Session] Tokens stored in KV for room:', roomName);

          // 2. Ensure the permanent guest page is published (only once ever)
          let guestPageUrl = '';
          const stored = await window.recorder.getGuestPageUrl();
          if (stored.success && stored.url) {
            guestPageUrl = stored.url;
            console.log('[Session] Guest page already published:', guestPageUrl);
          } else {
            els.hostStatus.textContent = 'Publishing guest page...';
            const pub = await window.recorder.publishGuestPage();
            console.log('[Session] Publish result:', pub);
            if (pub.success && pub.url) {
              guestPageUrl = pub.url;
            } else {
              throw new Error(pub.error || 'Guest page publish failed');
            }
          }
          els.hostStatus.textContent = '';

          if (!guestPageUrl) throw new Error('No guest page URL available');

          // 3. Build the join link with ?room= param so guests land directly in this room
          const joinUrl = guestPageUrl + '?room=' + encodeURIComponent(roomName);
          this.publicJoinUrl = joinUrl;
          this._meetingRoomName = roomName; // Save for cleanup on session end

          els.publicJoinUrl.textContent = joinUrl;
          const hint = document.getElementById('codeCopyHint');
          if (hint) hint.textContent = 'Click to copy join link (room: ' + roomName + ')';
        },

        // GUEST: Join is no longer done from the Electron app UI (guests use the web page).
        // Keeping a stub for the join panel in case of future in-app guest support.
        async sessionJoin() {
          this.showStatus('Guests join via the shared link on any device', 'info');
        },

        // Ensure we have a local camera stream
        async ensureLocalStream() {
          try {
            this.stream = await navigator.mediaDevices.getUserMedia({
              video: true,
              audio: true,
            });
            this.elements.previewVideo.srcObject = this.stream;
            this.elements.previewPlaceholder.style.display = 'none';
            this.elements.previewVideo.style.display = 'block';
            this.startAudioMeter(this.stream);
          } catch (err) {
            console.error('[Session] Could not get local media:', err);
            throw new Error('Camera/mic access required for sessions');
          }
        },

        // Enter session mode  creates host tile, shows controls
        _enterSessionMode() {
          console.log('[Session] Entering multi-participant session mode');
          this.sessionConnected = true;
          const els = this.getSessionElements();

          // Hide setup panels
          this.sessionHideAllPanels();

          // Activate session layout
          this.elements.previewContainer.classList.add('session-active');

          // Create host's own participant container
          const hostContainer = document.createElement('div');
          hostContainer.className = 'session-participant';
          hostContainer.dataset.sid = this._localParticipantSid;

          // Move existing local video (LiveKit-attached or preview) into host container
          const lkVideo = document.getElementById('lk-local-video');
          if (lkVideo) {
            hostContainer.appendChild(lkVideo);
          } else {
            this.elements.previewVideo.style.display = 'block';
            hostContainer.appendChild(this.elements.previewVideo);
          }

          // Label with host's display name
          const label = document.createElement('div');
          label.className = 'participant-label';
          label.textContent = this._hostDisplayName ? this._hostDisplayName + ' (You)' : 'You';
          hostContainer.appendChild(label);

          // Move audio meter into host container
          if (this.elements.audioMeter) {
            hostContainer.appendChild(this.elements.audioMeter);
          }

          this.elements.previewContainer.appendChild(hostContainer);
          this._participants.set(this._localParticipantSid, {
            container: hostContainer,
            identity: 'host',
            isSpeaking: false,
          });

          // Hide old single-remote video (replaced by per-participant containers)
          els.remoteVideo.style.display = 'none';

          // Show connected badge and session controls
          els.connectedBadge.classList.add('visible');
          els.endSessionBtn.classList.add('visible');
          document.getElementById('sessionMediaControls').classList.add('visible');

          this.showStatus('Session connected - ready to record', 'success');
        },

        // Create or get a participant container
        _ensureParticipantContainer(sid, identity) {
          if (this._participants.has(sid)) {
            return this._participants.get(sid).container;
          }

          const container = document.createElement('div');
          container.className = 'session-participant';
          container.dataset.sid = sid;
          container.style.opacity = '0';

          const label = document.createElement('div');
          label.className = 'participant-label remote';
          label.textContent = identity || 'Guest';
          container.appendChild(label);

          this.elements.previewContainer.appendChild(container);

          // Fade in
          requestAnimationFrame(() => {
            container.style.opacity = '1';
          });

          this._participants.set(sid, {
            container,
            identity: identity || 'Guest',
            isSpeaking: false,
          });

          return container;
        },

        // Remove a participant container
        _removeParticipantContainer(sid) {
          const entry = this._participants.get(sid);
          if (!entry) return;

          // Fade out then remove
          entry.container.style.opacity = '0';
          setTimeout(() => {
            entry.container.remove();
          }, 300);

          this._participants.delete(sid);

          // If removed participant was in spotlight, pick new one
          if (this._currentSpotlightSid === sid) {
            this._currentSpotlightSid = null;
            this._pickNewSpotlight();
          }
        },

        // Update layout based on participant count
        _updateLayout() {
          const container = this.elements.previewContainer;
          const count = this._participants.size;

          // Remove existing layout classes
          container.classList.remove('layout-side-by-side', 'layout-speaker-view');

          if (count <= 1) {
            // Solo  full size
            this._participants.forEach((entry) => {
              entry.container.classList.remove('in-spotlight', 'in-thumbnails');
              Object.assign(entry.container.style, {
                top: '0',
                left: '0',
                width: '100%',
                height: '100%',
              });
            });
            return;
          }

          if (count === 2) {
            // Side-by-side  position explicitly with JS
            container.classList.add('layout-side-by-side');
            let idx = 0;
            this._participants.forEach((entry) => {
              entry.container.classList.remove('in-spotlight', 'in-thumbnails');
              Object.assign(entry.container.style, {
                top: '0',
                height: '100%',
                width: 'calc(50% - 2px)',
                left: idx === 0 ? '0' : 'calc(50% + 2px)',
              });
              idx++;
            });
          } else {
            // 3+ participants  speaker view
            container.classList.add('layout-speaker-view');

            // If no spotlight yet, pick the first remote participant
            if (!this._currentSpotlightSid || !this._participants.has(this._currentSpotlightSid)) {
              this._pickNewSpotlight();
            } else {
              this._applySpotlightLayout();
            }
          }
        },

        // Pick a new spotlight participant (prefer remote over local)
        _pickNewSpotlight() {
          let firstRemoteSid = null;
          for (const [sid] of this._participants) {
            if (sid !== this._localParticipantSid) {
              firstRemoteSid = sid;
              break;
            }
          }
          this._currentSpotlightSid = firstRemoteSid || this._localParticipantSid;
          this._applySpotlightLayout();
        },

        // Apply spotlight + thumbnail positioning via inline styles
        _applySpotlightLayout() {
          let thumbIndex = 0;
          const thumbWidth = 160;
          const thumbHeight = 130;
          const thumbGap = 8;

          this._participants.forEach((entry, sid) => {
            if (sid === this._currentSpotlightSid) {
              entry.container.classList.add('in-spotlight');
              entry.container.classList.remove('in-thumbnails');
              Object.assign(entry.container.style, {
                top: '0',
                left: '0',
                width: '100%',
                height: `calc(100% - ${thumbHeight + 10}px)`,
              });
            } else {
              entry.container.classList.remove('in-spotlight');
              entry.container.classList.add('in-thumbnails');
              const leftPos = thumbGap + thumbIndex * (thumbWidth + thumbGap);
              Object.assign(entry.container.style, {
                top: 'auto',
                bottom: '0',
                left: `${leftPos}px`,
                width: `${thumbWidth}px`,
                height: `${thumbHeight}px`,
              });
              thumbIndex++;
            }
          });
        },

        // Promote a participant to spotlight with animation
        _promoteToSpotlight(sid) {
          if (sid === this._currentSpotlightSid) return;
          if (!this._participants.has(sid)) return;

          this._currentSpotlightSid = sid;
          this._applySpotlightLayout();
        },

        // Handle ActiveSpeakersChanged with debounce
        _handleActiveSpeakersChanged(speakers) {
          // Update speaking state for all participants
          this._participants.forEach((entry, sid) => {
            const wasSpeaking = entry.isSpeaking;
            entry.isSpeaking = false;
            if (!wasSpeaking) {
              entry.container.classList.remove('speaking');
            }
          });

          // Track current speaker name for transcription attribution
          if (speakers.length > 0) {
            const topSpeakerP = speakers[0];
            const isLocalSpeaker =
              this._livekitRoom &&
              this._livekitRoom.localParticipant &&
              topSpeakerP.sid === this._livekitRoom.localParticipant.sid;
            if (isLocalSpeaker) {
              this._currentSpeakerName = this._hostDisplayName || 'Host';
            } else {
              // Look up display name from participant or our map
              const key = topSpeakerP.sid || topSpeakerP.identity;
              const entry = this._participants.get(key);
              this._currentSpeakerName =
                topSpeakerP.name || (entry && entry.identity) || topSpeakerP.identity || 'Guest';
            }
          }

          for (const participant of speakers) {
            const sid = participant.sid || participant.identity;
            // Check if this is the local participant
            const isLocal =
              this._livekitRoom &&
              this._livekitRoom.localParticipant &&
              participant.sid === this._livekitRoom.localParticipant.sid;
            const key = isLocal ? this._localParticipantSid : sid;

            const entry = this._participants.get(key);
            if (entry) {
              entry.isSpeaking = true;
              entry.container.classList.add('speaking');
            }
          }

          // Debounced spotlight promotion (only in 3+ mode)
          if (this._participants.size >= 3 && speakers.length > 0) {
            const topSpeaker = speakers[0];
            const isLocal =
              this._livekitRoom &&
              this._livekitRoom.localParticipant &&
              topSpeaker.sid === this._livekitRoom.localParticipant.sid;
            const topSid = isLocal ? this._localParticipantSid : topSpeaker.sid;

            if (topSid !== this._currentSpotlightSid) {
              clearTimeout(this._speakerDebounceTimer);
              this._speakerDebounceTimer = setTimeout(() => {
                this._promoteToSpotlight(topSid);
              }, 1200); // 1.2s debounce to avoid thrashing
            }
          }
        },

        // Start audio-reactive glow animation loop
        _startAudioGlow() {
          if (this._audioGlowFrame) return;

          const animate = () => {
            this._audioGlowFrame = requestAnimationFrame(animate);
            if (!this._livekitRoom) return;

            this._participants.forEach((entry, sid) => {
              if (entry.isSpeaking) {
                // Use LiveKit's audio level if available
                let level = 0;
                if (sid === this._localParticipantSid) {
                  const micPub = this._livekitRoom.localParticipant?.getTrackPublication(
                    LivekitClient.Track.Source.Microphone
                  );
                  level = micPub?.track?.currentBitrate ? 0.5 : 0.3;
                } else {
                  const participant = this._livekitRoom.remoteParticipants?.get(sid);
                  if (participant) {
                    const audioPub = participant.getTrackPublication(LivekitClient.Track.Source.Microphone);
                    level = audioPub?.track?.currentBitrate ? 0.5 : 0.3;
                  }
                }
                entry.container.style.setProperty('--audio-level', Math.min(level + 0.2, 1).toString());
              } else {
                entry.container.style.removeProperty('--audio-level');
              }
            });
          };

          animate();
        },

        // Stop audio glow
        _stopAudioGlow() {
          if (this._audioGlowFrame) {
            cancelAnimationFrame(this._audioGlowFrame);
            this._audioGlowFrame = null;
          }
        },

        // Send data to session peers (LiveKit or legacy data channel)
        sendSessionData(data, destinationIdentities) {
          if (this._livekitRoom && this._livekitRoom.localParticipant) {
            const payload =
              data instanceof ArrayBuffer || data instanceof Uint8Array
                ? new Uint8Array(data)
                : new TextEncoder().encode(typeof data === 'string' ? data : JSON.stringify(data));
            const opts = { reliable: true };
            if (destinationIdentities && destinationIdentities.length > 0) {
              opts.destinationIdentities = destinationIdentities;
            }
            this._livekitRoom.localParticipant.publishData(payload, opts);
          } else if (this.dataChannel && this.dataChannel.readyState === 'open') {
            this.dataChannel.send(
              typeof data === 'string' ? data : data instanceof ArrayBuffer ? data : JSON.stringify(data)
            );
          }
        },

        // Toggle microphone mute (uses LiveKit API if in session, else direct track control)
        toggleMuteMic() {
          this.micMuted = !this.micMuted;

          // Use LiveKit API if in a LiveKit session
          if (this._livekitRoom && this._livekitRoom.localParticipant) {
            this._livekitRoom.localParticipant.setMicrophoneEnabled(!this.micMuted);
          } else if (this.stream) {
            this.stream.getAudioTracks().forEach((t) => {
              t.enabled = !this.micMuted;
            });
          }

          const btn = document.getElementById('muteMicBtn');
          btn.classList.toggle('off', this.micMuted);
          btn.title = this.micMuted ? 'Unmute microphone' : 'Mute microphone';

          const icon = document.getElementById('micIcon');
          if (this.micMuted) {
            icon.innerHTML =
              '<line x1="1" y1="1" x2="23" y2="23"/><path d="M9 9v3a3 3 0 0 0 5.12 2.12M15 9.34V4a3 3 0 0 0-5.94-.6"/><path d="M17 16.95A7 7 0 0 1 5 12v-2m14 0v2c0 .76-.13 1.49-.35 2.17"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/>';
          } else {
            icon.innerHTML =
              '<path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/>';
          }

          if (this.elements.audioMeter) {
            this.elements.audioMeter.classList.toggle('visible', !this.micMuted);
          }
        },

        // Toggle camera on/off (uses LiveKit API if in session, else direct track control)
        toggleCameraOff() {
          this.cameraOff = !this.cameraOff;

          if (this._livekitRoom && this._livekitRoom.localParticipant) {
            this._livekitRoom.localParticipant.setCameraEnabled(!this.cameraOff);
          } else if (this.stream) {
            this.stream.getVideoTracks().forEach((t) => {
              t.enabled = !this.cameraOff;
            });
          }

          const btn = document.getElementById('camOffBtn');
          btn.classList.toggle('off', this.cameraOff);
          btn.title = this.cameraOff ? 'Turn on camera' : 'Turn off camera';

          const icon = document.getElementById('camIcon');
          if (this.cameraOff) {
            icon.innerHTML =
              '<line x1="1" y1="1" x2="23" y2="23"/><path d="M21 21H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h3m3-3h6l2 3h4a2 2 0 0 1 2 2v9.34"/><path d="M14.5 10a2.5 2.5 0 0 0-4.77 1"/>';
          } else {
            icon.innerHTML = '<path d="M23 7l-7 5 7 5V7z"/><rect x="1" y="5" width="15" height="14" rx="2" ry="2"/>';
          }
        },

        // ==========================================
        // VIRTUAL BACKGROUND EFFECTS
        // ==========================================

        _bgProcessor: null, // BackgroundProcessor instance
        _bgMode: 'none', // 'none' | 'blur' | 'image'
        _bgImageDataUrl: null, // data URL for custom image

        toggleBgPopover() {
          const pop = document.getElementById('bgPopover');
          pop.classList.toggle('visible');
          // Close on outside click
          if (pop.classList.contains('visible')) {
            const closeOnOutside = (e) => {
              if (!pop.contains(e.target) && e.target.id !== 'bgEffectBtn') {
                pop.classList.remove('visible');
                document.removeEventListener('click', closeOnOutside);
              }
            };
            // Delay to avoid immediate close from the current click
            setTimeout(() => document.addEventListener('click', closeOnOutside), 0);
          }
        },

        async setBgEffect(mode, event) {
          if (event) event.stopPropagation();
          this._bgMode = mode;
          this._bgEffectMode = mode; // Sync for HUD display

          // Update selected state in old popover UI (if present)
          document.querySelectorAll('.bg-option').forEach((opt) => {
            opt.classList.toggle('selected', opt.dataset.bg === mode);
          });
          const blurSlider = document.getElementById('bgBlurSlider');
          if (blurSlider) blurSlider.classList.toggle('visible', mode === 'blur');
          const imgRow = document.getElementById('bgImageRow');
          if (imgRow) imgRow.classList.toggle('visible', mode === 'image');
          const bgBtn = document.getElementById('bgEffectBtn');
          if (bgBtn) bgBtn.classList.toggle('active-bg', mode !== 'none');

          // Apply the processor
          if (!window._BgProcessor) {
            console.warn('[BG] Track processors not loaded yet');
            if (this.showHudWarning) this.showHudWarning('BG PROCESSOR NOT LOADED', true, 2500);
            return;
          }

          try {
            const camTrack = this._getLocalCameraTrack();
            if (!camTrack) {
              console.warn('[BG] No camera track available');
              if (this.showHudWarning) this.showHudWarning('NO CAMERA TRACK', true, 2000);
              return;
            }

            if (mode === 'none') {
              if (this._bgProcessor) {
                await camTrack.stopProcessor();
                this._bgProcessor = null;
              }
            } else if (mode === 'blur') {
              // Read radius from whichever slider is available
              const radius = parseInt(
                document.getElementById('ctxBlurRadius')?.value ||
                  document.getElementById('bgBlurRadius')?.value ||
                  '10'
              );
              if (this._bgProcessor) {
                await this._bgProcessor.switchTo({ mode: 'background-blur', blurRadius: radius });
              } else {
                this._bgProcessor = window._BgProcessor({ mode: 'background-blur', blurRadius: radius });
                await camTrack.setProcessor(this._bgProcessor);
              }
            } else if (mode === 'image') {
              if (this._bgImageDataUrl) {
                if (this._bgProcessor) {
                  await this._bgProcessor.switchTo({ mode: 'virtual-background', imagePath: this._bgImageDataUrl });
                } else {
                  this._bgProcessor = window._BgProcessor({
                    mode: 'virtual-background',
                    imagePath: this._bgImageDataUrl,
                  });
                  await camTrack.setProcessor(this._bgProcessor);
                }
              }
            }
          } catch (err) {
            console.error('[BG] Failed to apply background effect:', err);
            if (this.showHudWarning) this.showHudWarning('BG EFFECT FAILED', true, 3000);
          }
        },

        async updateBlurRadius(value) {
          if (this._bgMode !== 'blur' || !this._bgProcessor) return;
          try {
            await this._bgProcessor.switchTo({ mode: 'background-blur', blurRadius: parseInt(value) || 10 });
          } catch (err) {
            console.error('[BG] Failed to update blur radius:', err);
          }
        },

        handleBgImageFile(input) {
          const file = input.files && input.files[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = () => {
            this._bgImageDataUrl = reader.result;
            this.setBgEffect('image');
          };
          reader.readAsDataURL(file);
        },

        _getLocalCameraTrack() {
          if (!this._livekitRoom || !this._livekitRoom.localParticipant) return null;
          const camPub = this._livekitRoom.localParticipant.getTrackPublication(LivekitClient.Track.Source.Camera);
          return camPub && camPub.track ? camPub.track : null;
        },

        async _cleanupBgProcessor() {
          if (this._bgProcessor) {
            try {
              const camTrack = this._getLocalCameraTrack();
              if (camTrack) await camTrack.stopProcessor();
            } catch {}
            this._bgProcessor = null;
            this._bgMode = 'none';
            this._bgImageDataUrl = null;
          }
          // Reset UI
          const btn = document.getElementById('bgEffectBtn');
          if (btn) btn.classList.remove('active-bg');
          document.querySelectorAll('.bg-option').forEach((opt) => {
            opt.classList.toggle('selected', opt.dataset.bg === 'none');
          });
          const slider = document.getElementById('bgBlurSlider');
          if (slider) slider.classList.remove('visible');
          const imgRow = document.getElementById('bgImageRow');
          if (imgRow) imgRow.classList.remove('visible');
        },

        // Data channel handlers
        setupDataChannelHandlers(channel) {
          // Use binaryType = arraybuffer for efficient chunk transfer
          channel.binaryType = 'arraybuffer';

          channel.onopen = () => {
            console.log('[Session] Data channel open');
            // Send full HUD state to peer on connect (so guest catches up)
            if (this.sessionRole === 'host' && this.hudItems.length > 0) {
              setTimeout(() => this._sendHUDFullSync(), 500);
            }
          };

          channel.onmessage = (event) => {
            // Binary data = track transfer chunk
            if (event.data instanceof ArrayBuffer) {
              if (this.sessionRole === 'host' && this.transferTotalChunks > 0) {
                this.handleTrackTransferChunk(event.data);
              }
              return;
            }

            try {
              const msg = JSON.parse(event.data);

              if (msg.type === 'recording-start') {
                // Remote side started recording -- start ours too
                if (!this.isRecording && this.sessionRole === 'guest') {
                  this.startRecording();
                }
              } else if (msg.type === 'recording-stop') {
                // Remote side stopped -- stop ours too
                if (this.isRecording && this.sessionRole === 'guest') {
                  this.stopRecording();
                }
              } else if (
                msg.type === 'hud-item-add' ||
                msg.type === 'hud-item-remove' ||
                msg.type === 'hud-sync-full'
              ) {
                // Meeting HUD P2P sync
                this._handleHUDSyncMessage(msg);
              } else if (msg.type === 'track-transfer-start') {
                // Guest is starting to send their recording
                this.handleTrackTransferStart(msg, 'guest-p2p');
              } else if (msg.type === 'track-transfer-complete') {
                // Guest finished sending all chunks
                this.handleTrackTransferComplete('guest-p2p');
              }
            } catch (err) {
              console.warn('[Session] Message parse error:', err);
            }
          };

          channel.onclose = () => {
            console.log('[Session] Data channel closed');
          };
        },

        // ==========================================
        // PHASE 2: GUEST TRACK TRANSFER VIA DATA CHANNEL
        // ==========================================

        // Track transfer state
        transferInProgress: false,
        _transferSenderId: null, // Identity of guest currently sending transfer
        transferChunks: [], // Received chunks (host side)
        transferTotalChunks: 0,
        transferMetadata: null, // Metadata sent by guest before transfer
        hostTrackItemId: null, // Saved host track item ID
        guestTrackItemId: null, // Saved guest track item ID

        // Chunk size: 16KB is safe for all WebRTC data channel implementations
        TRANSFER_CHUNK_SIZE: 16384,

        /**
         * Guest sends their recording to the host via the data channel.
         * Called automatically after both sides stop recording (guest-initiated).
         */
        async sendRecordingToHost() {
          if (!this.recordedBlob || !this.sessionConnected) {
            console.warn('[Transfer] Cannot send: no blob or not connected');
            return;
          }

          this.transferInProgress = true;
          this.showTransferOverlay('Sending recording to host...');

          try {
            const arrayBuffer = await this.recordedBlob.arrayBuffer();
            const totalBytes = arrayBuffer.byteLength;
            const totalChunks = Math.ceil(totalBytes / this.TRANSFER_CHUNK_SIZE);

            // 1. Send transfer metadata header
            this.sendSessionData({
              type: 'track-transfer-start',
              totalChunks,
              totalBytes,
              mimeType: this.recordedBlob.type || 'video/webm',
              duration: this.lastRecordingDuration || 0,
              sessionCode: this.sessionCode,
              recordedAt: new Date().toISOString(),
            });

            // 2. Send chunks
            for (let i = 0; i < totalChunks; i++) {
              const start = i * this.TRANSFER_CHUNK_SIZE;
              const end = Math.min(start + this.TRANSFER_CHUNK_SIZE, totalBytes);
              const chunk = arrayBuffer.slice(start, end);

              this.sendSessionData(chunk);

              // Small yield to prevent flooding
              if (i % 10 === 9) {
                await new Promise((r) => setTimeout(r, 10));
              }

              // Update progress
              const percent = Math.round(((i + 1) / totalChunks) * 100);
              this.updateTransferProgress(
                percent,
                `Sending: ${this.formatBytes(end)} / ${this.formatBytes(totalBytes)}`
              );
            }

            // 3. Send completion marker
            this.sendSessionData({ type: 'track-transfer-complete' });

            this.updateTransferProgress(100, 'Transfer complete');
            await new Promise((r) => setTimeout(r, 800));
            this.hideTransferOverlay();
            this.showStatus('Recording sent to host', 'success');
          } catch (err) {
            console.error('[Transfer] Send failed:', err);
            this.hideTransferOverlay();
            this.showStatus('Transfer failed: ' + err.message, 'error');
          } finally {
            this.transferInProgress = false;
          }
        },

        /**
         * Host handles incoming track transfer from guest.
         * Receives chunks, reassembles, and saves to Space.
         */
        handleTrackTransferStart(meta, senderId) {
          console.log('[Transfer] Receiving guest track from:', senderId, meta);
          this.transferInProgress = true;
          this._transferSenderId = senderId || 'unknown';
          this.transferChunks = [];
          this.transferTotalChunks = meta.totalChunks;
          this.transferMetadata = { ...meta, guestIdentity: senderId };
          this.showTransferOverlay('Receiving recording from ' + (senderId || 'guest') + '...');
        },

        handleTrackTransferChunk(data) {
          // data is an ArrayBuffer (binary chunk)
          this.transferChunks.push(data);
          const percent = Math.round((this.transferChunks.length / this.transferTotalChunks) * 100);
          const receivedBytes = this.transferChunks.reduce((sum, c) => sum + c.byteLength, 0);
          this.updateTransferProgress(
            percent,
            `Receiving: ${this.formatBytes(receivedBytes)} / ${this.formatBytes(this.transferMetadata.totalBytes)}`
          );
        },

        async handleTrackTransferComplete(senderId) {
          const guestId = senderId || this._transferSenderId || 'guest';
          console.log('[Transfer] All chunks received from', guestId, '- reassembling...');
          this.updateTransferProgress(100, 'Saving recording from ' + guestId + '...');

          try {
            // Reassemble into a Blob
            const guestBlob = new Blob(this.transferChunks, {
              type: this.transferMetadata?.mimeType || 'video/webm',
            });

            // Convert to base64 for IPC
            const reader = new FileReader();
            const base64Promise = new Promise((resolve, reject) => {
              reader.onload = () => resolve(reader.result.split(',')[1]);
              reader.onerror = reject;
            });
            reader.readAsDataURL(guestBlob);
            const base64Data = await base64Promise;

            // Save via IPC  include guest identity in filename
            const spaceId = this.elements.topSpaceSelect?.value || this.elements.saveSpace?.value;
            const safeName = guestId.replace(/[^a-z0-9_-]/gi, '_');
            const guestFilename = `guest_${safeName}_${this.sessionCode || 'meeting'}_${Date.now()}.webm`;

            const result = await window.recorder.saveGuestTrack({
              blob: base64Data,
              filename: guestFilename,
              spaceId: spaceId,
              metadata: {
                guestIdentity: guestId,
                duration: this.transferMetadata?.duration || 0,
                sessionCode: this.transferMetadata?.sessionCode || this.sessionCode,
                recordedAt: this.transferMetadata?.recordedAt || new Date().toISOString(),
              },
            });

            if (result.success) {
              this.guestTrackItemId = result.itemId;
              this.hideTransferOverlay();
              this.showStatus('Recording from ' + guestId + ' saved', 'success');

              // If host's track was also saved, offer merge
              if (this.hostTrackItemId && this.guestTrackItemId) {
                setTimeout(() => this.showMergeDialog(), 500);
              }
            } else {
              throw new Error(result.error || 'Save failed');
            }
          } catch (err) {
            console.error('[Transfer] Save guest track failed:', err);
            this.hideTransferOverlay();
            this.showStatus('Failed to save guest track: ' + err.message, 'error');
          }

          // Clean up  ready for next guest's transfer
          this.transferChunks = [];
          this.transferTotalChunks = 0;
          this.transferMetadata = null;
          this.transferInProgress = false;
          this._transferSenderId = null;
        },

        // Transfer overlay helpers
        showTransferOverlay(title) {
          document.getElementById('transferTitle').textContent = title || 'Transferring...';
          document.getElementById('transferOverlay').classList.add('active');
        },

        hideTransferOverlay() {
          document.getElementById('transferOverlay').classList.remove('active');
        },

        updateTransferProgress(percent, statusText) {
          document.getElementById('transferProgressFill').style.width = percent + '%';
          if (statusText) document.getElementById('transferStatus').textContent = statusText;
        },

        formatBytes(bytes) {
          if (bytes < 1024) return bytes + ' B';
          if (bytes < 1048576) return (bytes / 1024).toFixed(1) + ' KB';
          return (bytes / 1048576).toFixed(1) + ' MB';
        },

        // ==========================================
        // PHASE 3: POST-PROCESSING MERGE
        // ==========================================

        showMergeDialog() {
          const dialog = document.getElementById('mergeDialog');
          document.getElementById('mergeHostName').textContent = this.hostTrackItemId ? 'Host recording (saved)' : '--';
          document.getElementById('mergeGuestName').textContent = this.guestTrackItemId
            ? 'Guest recording (saved)'
            : '--';

          // Reset progress
          document.getElementById('mergeProgressSection').style.display = 'none';
          document.getElementById('mergeActions').style.display = 'flex';
          document.getElementById('mergeProgressFill').style.width = '0%';

          // Layout option click handlers
          dialog.querySelectorAll('.merge-layout-option').forEach((opt) => {
            opt.onclick = () => {
              dialog.querySelectorAll('.merge-layout-option').forEach((o) => o.classList.remove('selected'));
              opt.classList.add('selected');
              opt.querySelector('input').checked = true;
            };
          });

          dialog.classList.add('active');
        },

        hideMergeDialog() {
          document.getElementById('mergeDialog').classList.remove('active');
        },

        async startMerge() {
          if (!this.hostTrackItemId || !this.guestTrackItemId) {
            this.showStatus('Both host and guest tracks are required for merge', 'error');
            return;
          }

          const layout = document.querySelector('input[name="mergeLayout"]:checked')?.value || 'side-by-side';
          const spaceId = this.elements.topSpaceSelect?.value || this.elements.saveSpace?.value;

          if (!spaceId) {
            this.showStatus('Please select a space first', 'error');
            return;
          }

          // Show progress, hide buttons
          document.getElementById('mergeProgressSection').style.display = 'block';
          document.getElementById('mergeActions').style.display = 'none';

          // Listen for progress updates
          window.recorder.onMergeProgress((progress) => {
            document.getElementById('mergeProgressFill').style.width = progress.percent + '%';
            document.getElementById('mergeProgressText').textContent = progress.stage || '';
          });

          try {
            const result = await window.recorder.mergeTracks({
              hostItemId: this.hostTrackItemId,
              guestItemId: this.guestTrackItemId,
              spaceId: spaceId,
              layout: layout,
              outputFilename: `merged_${layout}_${Date.now()}.mp4`,
            });

            if (result.success) {
              this.showStatus(`Merged video saved (${this.formatBytes(result.size)})`, 'success');
              setTimeout(() => this.hideMergeDialog(), 1500);
            } else {
              throw new Error(result.error || 'Merge failed');
            }
          } catch (err) {
            console.error('[Merge] Error:', err);
            this.showStatus('Merge failed: ' + err.message, 'error');
            // Restore buttons so user can retry
            document.getElementById('mergeProgressSection').style.display = 'none';
            document.getElementById('mergeActions').style.display = 'flex';
          }
        },

        // Copy invite to clipboard -- always copies the most useful thing
        async copySessionCode() {
          let textToCopy = '';
          let feedbackMsg = '';

          if (this.publicJoinUrl) {
            // Public internet link
            textToCopy = this.publicJoinUrl;
            feedbackMsg = 'Join link copied';
          } else if (this.sessionCode && this.hostAddress) {
            // LAN link -- the signaling server serves the guest page at /join
            textToCopy = `http://${this.hostAddress}/join?code=${this.sessionCode}`;
            feedbackMsg = 'LAN join link copied';
          } else if (this.sessionCode) {
            textToCopy = this.sessionCode;
            feedbackMsg = 'Code copied';
          }

          if (!textToCopy) return;

          // Copy via IPC to main process
          try {
            await window.electronClipboard.writeText(textToCopy);
          } catch (e) {
            console.error('[Copy] Clipboard write failed:', e);
            return;
          }

          // Flash the code word to "Copied!" for clear feedback
          const el = document.getElementById('sessionCodeDisplay');
          const hint = document.getElementById('codeCopyHint');
          if (el && el.childNodes[0]) {
            const origCode = el.childNodes[0].textContent;
            const origHint = hint ? hint.textContent : '';
            el.childNodes[0].textContent = 'Copied!';
            el.style.borderColor = 'var(--accent-green, #00c878)';
            el.style.color = 'var(--accent-green, #00c878)';
            if (hint) hint.textContent = feedbackMsg;
            setTimeout(() => {
              el.childNodes[0].textContent = origCode;
              el.style.borderColor = '';
              el.style.color = '';
              if (hint) hint.textContent = origHint;
            }, 1500);
          }
        },

        // Cancel hosting
        async sessionCancel() {
          await this.sessionCleanup();
          this.sessionShowSetup();
        },

        // End an active session
        async sessionEnd() {
          const els = this.getSessionElements();

          // Stop audio glow animation and clean up background processor
          this._stopAudioGlow();
          clearTimeout(this._speakerDebounceTimer);
          await this._cleanupBgProcessor();

          // Restore preview elements from host tile before removing containers
          const hostEntry = this._participants.get(this._localParticipantSid);
          if (hostEntry) {
            // Move audio meter back to preview container
            if (this.elements.audioMeter && hostEntry.container.contains(this.elements.audioMeter)) {
              this.elements.previewContainer.appendChild(this.elements.audioMeter);
            }
            // Move preview video back
            const lkVideo = document.getElementById('lk-local-video');
            if (lkVideo) {
              this.elements.previewContainer.prepend(lkVideo);
            } else {
              this.elements.previewContainer.prepend(this.elements.previewVideo);
            }
          }

          // Remove ALL participant containers
          this._participants.forEach((entry) => {
            entry.container.remove();
          });
          this._participants.clear();
          this._currentSpotlightSid = null;

          // Remove layout classes
          this.elements.previewContainer.classList.remove(
            'session-active',
            'layout-side-by-side',
            'layout-speaker-view'
          );

          // Clean up remote video and session controls
          els.connectedBadge.classList.remove('visible');
          els.endSessionBtn.classList.remove('visible');
          document.getElementById('sessionMediaControls').classList.remove('visible');
          els.remoteVideo.style.display = 'none';
          els.remoteVideo.srcObject = null;

          // Reset mute/camera state (re-enable tracks)
          if (this.micMuted) {
            this.micMuted = false;
            document.getElementById('muteMicBtn').classList.remove('off');
            const micIcon = document.getElementById('micIcon');
            micIcon.innerHTML =
              '<path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/>';
          }
          if (this.cameraOff) {
            this.cameraOff = false;
            document.getElementById('camOffBtn').classList.remove('off');
            const camIcon = document.getElementById('camIcon');
            camIcon.innerHTML = '<path d="M23 7l-7 5 7 5V7z"/><rect x="1" y="5" width="15" height="14" rx="2" ry="2"/>';
          }
          if (this.stream) {
            this.stream.getAudioTracks().forEach((t) => {
              t.enabled = true;
            });
            this.stream.getVideoTracks().forEach((t) => {
              t.enabled = true;
            });
          }

          // Clear meeting tokens from KV so guests can't join after session ends
          if (this._meetingRoomName) {
            try {
              const clearResult = await window.recorder.clearMeetingTokens(this._meetingRoomName);
              console.log('[Session] Meeting tokens cleared for room:', this._meetingRoomName);
            } catch (err) {
              console.warn('[Session] Failed to clear meeting tokens:', err);
            }
            this._meetingRoomName = null;
          }

          // Clean up WebRTC and signaling
          await this.sessionCleanup();

          // Switch back to camera mode
          this.switchMode('camera');
          this.showStatus('Session ended', 'info');
        },

        // Cleanup session resources
        async sessionCleanup() {
          this.sessionConnected = false;
          this.sessionRole = null;
          this._currentSpeakerName = null;

          // Reset track transfer state
          this.transferInProgress = false;
          this._transferSenderId = null;
          this.transferChunks = [];
          this.transferTotalChunks = 0;
          this.transferMetadata = null;
          this.hostTrackItemId = null;
          this.guestTrackItemId = null;

          // Stop audio glow and speaker debounce
          this._stopAudioGlow();
          clearTimeout(this._speakerDebounceTimer);

          // Clear participant tracking
          this._participants.clear();
          this._currentSpotlightSid = null;

          // Disconnect from LiveKit room
          if (this._livekitRoom) {
            try {
              this._livekitRoom.disconnect();
            } catch {}
            this._livekitRoom = null;
          }
          this._livekitUrl = null;

          // Remove any LiveKit-attached media elements
          document.querySelectorAll('[data-track-sid]').forEach((el) => el.remove());

          // Legacy P2P cleanup (in case any old references exist)
          if (this.dataChannel) {
            try {
              this.dataChannel.close();
            } catch {}
            this.dataChannel = null;
          }
          if (this.peerConnection) {
            try {
              this.peerConnection.close();
            } catch {}
            this.peerConnection = null;
          }
          if (this.remoteStream) {
            this.remoteStream.getTracks().forEach((t) => t.stop());
            this.remoteStream = null;
          }

          // Tell main process to resize window
          try {
            await window.recorder.endSession();
          } catch {}

          this.sessionCode = null;
          this.publicJoinUrl = null;
          this.sessionHideAllPanels();
          this.hideTransferOverlay();
          this.hideMergeDialog();

          // Hide public join section
          const pubSection = document.getElementById('publicJoinSection');
          if (pubSection) pubSection.style.display = 'none';
        },

        close() {
          this.stopAudioMeter();
          this.sessionCleanup().catch(() => {});
          if (this.stream) {
            this.stream.getTracks().forEach((t) => t.stop());
          }
          this.cleanupPipResources();
          if (window.recorder) {
            window.recorder.close();
          }
        },
      };

      // ======================================================
      // FIGHTER PILOT HUD + CONTEXT MENU SYSTEM
      // ======================================================

      // --- HUD Update Loop ---
      Object.assign(app, {
        _hudActive: true,
        _hudInterval: null,
        _hudWarningTimer: null,
        _ctxOpen: false,
        _ctxCurrentSub: null,
        _ctxCurrentTab: 'controls',
        _transcriptAutoScroll: true,
        _bgEffectMode: 'none',

        initHUD() {
          // Activate HUD mode  hide old controls
          document.querySelector('.main-layout')?.classList.add('hud-active');

          // Start HUD update loop (every 500ms)
          this._hudInterval = setInterval(() => this.updateHUD(), 500);
          this.updateHUD();

          // Right-click handler
          const preview = document.getElementById('previewContainer');
          if (preview) {
            preview.addEventListener('contextmenu', (e) => {
              e.preventDefault();
              this.openContextMenu();
            });
          }

          // Swipe right detection for mobile
          let touchStartX = 0;
          let touchStartY = 0;
          document.addEventListener(
            'touchstart',
            (e) => {
              touchStartX = e.touches[0].clientX;
              touchStartY = e.touches[0].clientY;
            },
            { passive: true }
          );

          document.addEventListener(
            'touchend',
            (e) => {
              const dx = e.changedTouches[0].clientX - touchStartX;
              const dy = Math.abs(e.changedTouches[0].clientY - touchStartY);
              // Swipe right (>80px, mostly horizontal)
              if (dx > 80 && dy < 60 && !this._ctxOpen) {
                this.openContextMenu();
              }
            },
            { passive: true }
          );

          // Click overlay to close
          const overlay = document.getElementById('ctxOverlay');
          overlay?.addEventListener('click', (e) => {
            if (e.target === overlay) this.closeContextMenu();
          });

          // Escape key to close
          document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && this._ctxOpen) {
              e.preventDefault();
              e.stopPropagation();
              this.closeContextMenu();
            }
            // ? key to open
            if (e.key === '/' && e.shiftKey && !this._ctxOpen) {
              const tag = document.activeElement?.tagName?.toLowerCase();
              if (tag !== 'input' && tag !== 'textarea' && tag !== 'select') {
                e.preventDefault();
                this.openContextMenu();
              }
            }
          });

          // Transcript auto-scroll detection
          const editor = document.getElementById('ctxTranscriptEditor');
          if (editor) {
            editor.addEventListener('scroll', () => {
              const atBottom = editor.scrollHeight - editor.scrollTop - editor.clientHeight < 30;
              this._transcriptAutoScroll = atBottom;
            });
          }

          console.log('[HUD] Fighter pilot HUD initialized');
        },

        updateHUD() {
          // Clock
          const now = new Date();
          const hh = String(now.getHours()).padStart(2, '0');
          const mm = String(now.getMinutes()).padStart(2, '0');
          const ss = String(now.getSeconds()).padStart(2, '0');
          const clockEl = document.getElementById('hudClock');
          if (clockEl) clockEl.textContent = `${hh}:${mm}:${ss}`;

          // Recording state
          const recEl = document.getElementById('hudRec');
          const hudEl = document.getElementById('pilotHud');
          if (recEl) {
            if (this.isRecording) {
              recEl.classList.add('active');
              hudEl?.classList.add('recording');
              const elapsed = (Date.now() - this.recordingStartTime - (this.totalPausedMs || 0)) / 1000;
              const rh = String(Math.floor(elapsed / 3600)).padStart(2, '0');
              const rm = String(Math.floor((elapsed % 3600) / 60)).padStart(2, '0');
              const rs = String(Math.floor(elapsed % 60)).padStart(2, '0');
              document.getElementById('hudRecTime').textContent = `${rh}:${rm}:${rs}`;
            } else {
              recEl.classList.remove('active');
              hudEl?.classList.remove('recording');
            }
          }

          // Mode
          const modeEl = document.getElementById('hudMode');
          if (modeEl) {
            const modes = { camera: 'CAMERA', screen: 'SCREEN', both: 'SCREEN + CAM', session: 'SESSION' };
            modeEl.querySelector('.hud-value').textContent = modes[this.currentMode] || 'CAMERA';
          }

          // Mic status
          const micDot = document.getElementById('hudMicDot');
          const micLabel = document.getElementById('hudMicLabel');
          if (micDot && micLabel) {
            if (this.micMuted) {
              micDot.className = 'hud-dot red';
              micLabel.className = 'hud-value critical';
              micLabel.textContent = 'MIC MUTED';
            } else {
              micDot.className = 'hud-dot green';
              micLabel.className = 'hud-value nominal';
              micLabel.textContent = 'MIC LIVE';
            }
          }

          // Camera status
          const camDot = document.getElementById('hudCamDot');
          const camLabel = document.getElementById('hudCamLabel');
          if (camDot && camLabel) {
            if (this.cameraOff) {
              camDot.className = 'hud-dot red';
              camLabel.className = 'hud-value critical';
              camLabel.textContent = 'CAM OFF';
            } else {
              camDot.className = 'hud-dot green';
              camLabel.className = 'hud-value nominal';
              camLabel.textContent = 'CAM ACTIVE';
            }
          }

          // Captions status
          const ccDot = document.getElementById('hudCcDot');
          const ccLabel = document.getElementById('hudCcLabel');
          if (ccDot && ccLabel) {
            const ccOn = !!(this.transcriptionWs && this.transcriptionWs.readyState === WebSocket.OPEN);
            ccDot.className = ccOn ? 'hud-dot green' : 'hud-dot off';
            ccLabel.textContent = ccOn ? 'CC ON' : 'CC OFF';
          }

          // Background effect
          const bgVal = document.getElementById('hudBgValue');
          if (bgVal) bgVal.textContent = (this._bgEffectMode || 'none').toUpperCase();

          // Session info
          if (this.sessionConnected) {
            const pCount = this._participants ? this._participants.size : 0;
            const pEl = document.getElementById('hudParticipants');
            const pVal = document.getElementById('hudParticipantCount');
            if (pEl) pEl.style.display = '';
            if (pVal) pVal.textContent = String(pCount);

            const spkEl = document.getElementById('hudSpeaker');
            const spkVal = document.getElementById('hudSpeakerName');
            if (this._currentSpeakerName) {
              if (spkEl) spkEl.style.display = '';
              if (spkVal) spkVal.textContent = this._currentSpeakerName.toUpperCase();
            } else {
              if (spkEl) spkEl.style.display = 'none';
            }

            const roomEl = document.getElementById('hudRoomName');
            const roomVal = document.getElementById('hudRoomValue');
            if (roomEl) roomEl.style.display = '';
            if (roomVal) roomVal.textContent = (this._meetingRoomName || '--').toUpperCase();

            const netEl = document.getElementById('hudNetStatus');
            if (netEl) netEl.style.display = '';
          } else {
            document.getElementById('hudParticipants').style.display = 'none';
            document.getElementById('hudSpeaker').style.display = 'none';
            document.getElementById('hudRoomName').style.display = 'none';
            document.getElementById('hudNetStatus').style.display = 'none';
          }

          // Space name
          const spaceEl = document.getElementById('hudSpaceName');
          const spaceSel = this.elements.targetSpace;
          if (spaceEl && spaceSel) {
            const opt = spaceSel.options[spaceSel.selectedIndex];
            spaceEl.textContent = opt && opt.text && opt.value ? opt.text.substring(0, 20).toUpperCase() : '--';
          }

          // Update HUD audio meter from existing audio meter data
          this._updateHudAudioMeter();
        },

        _updateHudAudioMeter() {
          const bars = document.querySelectorAll('#hudAudioMeter .hud-audio-bar');
          if (!bars.length) return;
          // Get current audio level from the existing audio meter
          const level = this._lastAudioRMS || 0;
          const activeBars = Math.round(level * bars.length * 5); // Scale up
          bars.forEach((bar, i) => {
            if (i < activeBars) {
              if (i >= bars.length - 2) bar.className = 'hud-audio-bar clip';
              else if (i >= bars.length - 4) bar.className = 'hud-audio-bar peak';
              else bar.className = 'hud-audio-bar active';
            } else {
              bar.className = 'hud-audio-bar';
            }
          });
        },

        showHudWarning(text, isCritical, duration) {
          const el = document.getElementById('hudWarning');
          if (!el) return;
          el.textContent = text;
          el.className = 'hud-warning visible' + (isCritical ? ' critical' : '');
          clearTimeout(this._hudWarningTimer);
          this._hudWarningTimer = setTimeout(() => {
            el.classList.remove('visible');
          }, duration || 3000);
        },

        // --- Context Menu ---
        openContextMenu() {
          this._ctxOpen = true;
          this._refreshCtxState();
          document.getElementById('ctxOverlay')?.classList.add('open');
        },

        closeContextMenu() {
          this._ctxOpen = false;
          this._ctxCurrentSub = null;
          document.getElementById('ctxOverlay')?.classList.remove('open');
          // Close any open submenus
          document.querySelectorAll('.ctx-submenu.open').forEach((el) => el.classList.remove('open'));
          // Show main body
          document.getElementById('ctxControls').style.display = '';
          document.getElementById('ctxTranscript').classList.remove('active');
          if (this._ctxCurrentTab === 'transcript') {
            document.getElementById('ctxTranscript').classList.add('active');
            document.getElementById('ctxControls').style.display = 'none';
          }
        },

        ctxAction(method, arg) {
          if (method === 'meetingToggle') {
            if (this.sessionConnected || this.publicJoinUrl) {
              // End meeting whether connected or still waiting for guests
              this.sessionEnd();
            } else {
              this.closeContextMenu();
              this.switchMode('session');
              return;
            }
          } else if (method === 'switchMode') {
            this.switchMode(arg);
          } else if (typeof this[method] === 'function') {
            this[method]();
          }
          this._refreshCtxState();
          // Auto-close for most actions (not toggles that need visual feedback)
          if (['showSaveDialog', 'discardRecording', 'recordAgain', 'toggleSettings', 'switchMode'].includes(method)) {
            this.closeContextMenu();
          }
        },

        _refreshCtxState() {
          // Recording
          const recLabel = document.querySelector('#ctxRecord .ctx-item-label');
          const recState = document.getElementById('ctxRecState');
          const recDot = document.getElementById('ctxRecDot');
          if (this.isRecording) {
            recLabel.innerHTML = '<span class="hud-dot red"></span> Stop Recording';
            recState.textContent = 'RECORDING';
            recState.className = 'ctx-item-state off';
            document.getElementById('ctxRecord').classList.add('record-active');
          } else {
            recLabel.innerHTML = 'Record';
            recState.textContent = 'READY';
            recState.className = 'ctx-item-state on';
            document.getElementById('ctxRecord').classList.remove('record-active');
          }

          // Pause
          const pauseEl = document.getElementById('ctxPause');
          if (pauseEl) {
            pauseEl.style.display = this.isRecording ? '' : 'none';
            const pauseState = document.getElementById('ctxPauseState');
            if (pauseState) pauseState.textContent = this.isPaused ? 'PAUSED' : 'RUNNING';
            pauseEl.querySelector('.ctx-item-label').textContent = this.isPaused ? 'Resume' : 'Pause';
          }

          // Camera
          const camState = document.getElementById('ctxCamState');
          if (camState) {
            camState.textContent = this.cameraOff ? 'OFF' : 'ACTIVE';
            camState.className = 'ctx-item-state ' + (this.cameraOff ? 'off' : 'on');
          }

          // Mic
          const micState = document.getElementById('ctxMicState');
          if (micState) {
            micState.textContent = this.micMuted ? 'MUTED' : 'LIVE';
            micState.className = 'ctx-item-state ' + (this.micMuted ? 'off' : 'on');
          }

          // Screen mode
          const screenState = document.getElementById('ctxScreenState');
          const bothState = document.getElementById('ctxBothState');
          if (screenState) screenState.textContent = this.currentMode === 'screen' ? 'ACTIVE' : 'OFF';
          if (bothState) bothState.textContent = this.currentMode === 'both' ? 'ACTIVE' : 'OFF';

          // Background
          const bgMode = this._bgEffectMode || 'none';
          document.getElementById('ctxBgNone').textContent = bgMode === 'none' ? '[X]' : '[ ]';
          document.getElementById('ctxBgBlur').textContent = bgMode === 'blur' ? '[X]' : '[ ]';
          document.getElementById('ctxBgImage').textContent = bgMode === 'image' ? '[X]' : '[ ]';
          document.getElementById('ctxBlurRadiusRow').style.display = bgMode === 'blur' ? '' : 'none';

          // Captions
          const ccState = document.getElementById('ctxCcState');
          const ccOn = !!(this.transcriptionWs && this.transcriptionWs.readyState === WebSocket.OPEN);
          if (ccState) {
            ccState.textContent = ccOn ? 'ON' : 'OFF';
            ccState.className = 'ctx-item-state ' + (ccOn ? 'on' : '');
          }

          // Meeting
          const meetLabel = document.querySelector('#ctxMeetingToggle .ctx-item-label');
          const meetState = document.getElementById('ctxMeetingState');
          const hasJoinLink = !!this.publicJoinUrl;
          if (this.sessionConnected) {
            meetLabel.textContent = 'End Meeting';
            meetState.textContent = 'LIVE';
            meetState.className = 'ctx-item-state on';
            document.getElementById('ctxMeetingToggle').classList.add('danger');
            document.getElementById('ctxCopyLink').style.display = '';
            document.getElementById('ctxParticipantsList').style.display = '';
          } else if (hasJoinLink) {
            // Meeting started, waiting for guests  show link and allow ending
            meetLabel.textContent = 'End Meeting';
            meetState.textContent = 'WAITING';
            meetState.className = 'ctx-item-state amber';
            document.getElementById('ctxMeetingToggle').classList.add('danger');
            document.getElementById('ctxCopyLink').style.display = '';
            document.getElementById('ctxParticipantsList').style.display = 'none';
          } else {
            meetLabel.textContent = 'Start Meeting';
            meetState.textContent = 'OFFLINE';
            meetState.className = 'ctx-item-state';
            document.getElementById('ctxMeetingToggle').classList.remove('danger');
            document.getElementById('ctxCopyLink').style.display = 'none';
            document.getElementById('ctxParticipantsList').style.display = 'none';
          }

          // Join link preview
          const linkPreview = document.getElementById('ctxJoinLinkPreview');
          if (linkPreview) {
            if (hasJoinLink) {
              linkPreview.style.display = '';
              linkPreview.textContent = this.publicJoinUrl;
            } else {
              linkPreview.style.display = 'none';
              linkPreview.textContent = '';
            }
          }

          // Space
          const spaceState = document.getElementById('ctxSpaceState');
          const spaceSel = this.elements.targetSpace;
          if (spaceState && spaceSel) {
            const opt = spaceSel.options[spaceSel.selectedIndex];
            spaceState.textContent = opt && opt.text && opt.value ? opt.text.substring(0, 18).toUpperCase() : '--';
          }

          // Post-recording section
          const postSec = document.getElementById('ctxPostSection');
          if (postSec) {
            postSec.style.display = this.recordedBlob && !this.isRecording ? '' : 'none';
          }

          // Desktop volume row
          const desktopRow = document.getElementById('ctxDesktopVolRow');
          if (desktopRow) {
            desktopRow.style.display = this.currentMode === 'screen' || this.currentMode === 'both' ? '' : 'none';
          }
        },

        // Submenu navigation
        ctxOpenSub(name) {
          this._ctxCurrentSub = name;
          // Hide main body
          document.getElementById('ctxControls').style.display = 'none';
          document.getElementById('ctxTranscript').classList.remove('active');
          // Show submenu
          const subMap = {
            cameraSources: 'ctxSubCameraSources',
            micSources: 'ctxSubMicSources',
            participants: 'ctxSubParticipants',
            spaces: 'ctxSubSpaces',
          };
          const subId = subMap[name];
          if (subId) {
            document.getElementById(subId).classList.add('open');
            this._populateSubmenu(name);
          }
        },

        ctxCloseSub() {
          this._ctxCurrentSub = null;
          document.querySelectorAll('.ctx-submenu.open').forEach((el) => el.classList.remove('open'));
          if (this._ctxCurrentTab === 'controls') {
            document.getElementById('ctxControls').style.display = '';
          } else {
            document.getElementById('ctxTranscript').classList.add('active');
          }
        },

        async _populateSubmenu(name) {
          if (name === 'cameraSources' || name === 'micSources') {
            const kind = name === 'cameraSources' ? 'videoinput' : 'audioinput';
            const listId = name === 'cameraSources' ? 'ctxCameraList' : 'ctxMicList';
            const selId = name === 'cameraSources' ? 'videoSource' : 'audioSource';
            const list = document.getElementById(listId);
            if (!list) return;
            list.innerHTML = '';
            try {
              const devices = await navigator.mediaDevices.enumerateDevices();
              const filtered = devices.filter((d) => d.kind === kind);
              const currentSel = document.getElementById(selId);
              const currentVal = currentSel?.value || '';
              filtered.forEach((dev) => {
                const item = document.createElement('div');
                item.className = 'ctx-sub-item';
                const check =
                  dev.deviceId === currentVal
                    ? '<span class="ctx-check">[X]</span>'
                    : '<span style="opacity:0.3">[ ]</span>';
                item.innerHTML = `${check} ${dev.label || 'Device ' + dev.deviceId.substring(0, 8)}`;
                item.onclick = () => {
                  if (currentSel) {
                    currentSel.value = dev.deviceId;
                    if (name === 'cameraSources') this.changeVideoSource();
                    else this.changeAudioSource();
                  }
                  this.ctxCloseSub();
                };
                list.appendChild(item);
              });
            } catch (e) {
              list.innerHTML = '<div class="ctx-sub-item" style="color:var(--hud-amber)">DEVICE ACCESS DENIED</div>';
            }
          } else if (name === 'participants') {
            const list = document.getElementById('ctxParticipantList');
            if (!list) return;
            list.innerHTML = '';
            if (this._participants) {
              this._participants.forEach((entry, sid) => {
                const item = document.createElement('div');
                item.className = 'ctx-sub-item';
                const speaking = entry.isSpeaking
                  ? '<span class="hud-dot green" style="display:inline-block"></span>'
                  : '<span class="hud-dot off" style="display:inline-block"></span>';
                const name = entry.identity || sid.substring(0, 8);
                item.innerHTML = `${speaking} ${name.toUpperCase()}`;
                list.appendChild(item);
              });
            }
            if (!list.children.length) {
              list.innerHTML = '<div class="ctx-sub-item" style="color:var(--hud-text-dim)">NO PARTICIPANTS</div>';
            }
          } else if (name === 'spaces') {
            const list = document.getElementById('ctxSpaceList');
            if (!list) return;
            list.innerHTML = '';
            const spaceSel = this.elements.targetSpace;
            if (spaceSel) {
              Array.from(spaceSel.options).forEach((opt) => {
                if (!opt.value) return;
                const item = document.createElement('div');
                item.className = 'ctx-sub-item';
                const check = opt.selected
                  ? '<span class="ctx-check">[X]</span>'
                  : '<span style="opacity:0.3">[ ]</span>';
                item.innerHTML = `${check} ${opt.text.toUpperCase()}`;
                item.onclick = () => {
                  spaceSel.value = opt.value;
                  this.onTargetSpaceChange();
                  this.ctxCloseSub();
                };
                list.appendChild(item);
              });
            }
          }
        },

        // Tab switching
        switchCtxTab(tab) {
          this._ctxCurrentTab = tab;
          document.getElementById('ctxTabControls').classList.toggle('active', tab === 'controls');
          document.getElementById('ctxTabTranscript').classList.toggle('active', tab === 'transcript');
          document.getElementById('ctxControls').style.display = tab === 'controls' ? '' : 'none';
          const transcript = document.getElementById('ctxTranscript');
          if (tab === 'transcript') {
            transcript.classList.add('active');
            this._syncTranscriptEditor();
          } else {
            transcript.classList.remove('active');
          }
          // Close any open submenu
          document.querySelectorAll('.ctx-submenu.open').forEach((el) => el.classList.remove('open'));
        },

        // Background effect from context menu
        ctxSetBg(mode) {
          this._bgEffectMode = mode;
          // Sync the old blur radius value from context menu slider if applicable
          if (mode === 'blur') {
            const ctxRadius = document.getElementById('ctxBlurRadius');
            const oldRadius = document.getElementById('bgBlurRadius');
            if (ctxRadius && oldRadius) oldRadius.value = ctxRadius.value;
          }
          // If image, trigger file picker
          if (mode === 'image' && !this._bgImageDataUrl) {
            const filePicker = document.getElementById('bgImageFile');
            if (filePicker) filePicker.click();
            this._refreshCtxState();
            return;
          }
          this.setBgEffect(mode);
          this._refreshCtxState();
        },

        // Audio mixer from context menu
        ctxUpdateMicVol(val) {
          this.updateMicVolume(val);
          document.getElementById('ctxMicVolVal').textContent = val + '%';
        },

        ctxUpdateDesktopVol(val) {
          this.updateDesktopVolume(val);
          document.getElementById('ctxDesktopVolVal').textContent = val + '%';
        },

        // Copy join link
        async ctxCopyJoinLink() {
          if (this.publicJoinUrl) {
            try {
              await window.electronClipboard.writeText(this.publicJoinUrl);
              document.getElementById('ctxCopyState').textContent = 'COPIED';
              setTimeout(() => {
                document.getElementById('ctxCopyState').textContent = 'COPY';
              }, 1500);
            } catch (e) {
              console.error('[Copy] Join link copy failed:', e);
            }
          }
        },

        // --- Transcript Panel ---
        _syncTranscriptEditor() {
          const editor = document.getElementById('ctxTranscriptEditor');
          if (!editor) return;
          // Only sync if user hasn't manually edited (check if content matches auto-generated)
          let md = '';
          if (this.accumulatedTranscript && this.accumulatedTranscript.length > 0) {
            let lastSpeaker = null;
            for (const entry of this.accumulatedTranscript) {
              const relMs = this.recordingStartTime ? entry.timestamp - this.recordingStartTime : 0;
              const relSec = Math.max(0, Math.floor(relMs / 1000));
              const mm = String(Math.floor(relSec / 60)).padStart(2, '0');
              const ss = String(relSec % 60).padStart(2, '0');
              if (entry.speaker && entry.speaker !== lastSpeaker) {
                md += `\n${entry.speaker}\n`;
                lastSpeaker = entry.speaker;
              }
              md += `[${mm}:${ss}] ${entry.text}\n`;
            }
          }

          // Append any user-added notes that aren't part of the transcript
          const existingNotes = editor.dataset.userNotes || '';
          const fullContent = md + (existingNotes ? '\n--- NOTES ---\n' + existingNotes : '');

          // Only update if content changed and auto-scroll is on
          if (this._transcriptAutoScroll || !editor.value) {
            editor.value = fullContent || '';
            if (this._transcriptAutoScroll) {
              editor.scrollTop = editor.scrollHeight;
            }
          }
        },

        ctxAddNote() {
          const input = document.getElementById('ctxTranscriptNote');
          if (!input || !input.value.trim()) return;
          const note = input.value.trim();
          input.value = '';

          // Add to transcript as a note entry
          const now = new Date();
          const hh = String(now.getHours()).padStart(2, '0');
          const mm = String(now.getMinutes()).padStart(2, '0');
          this.accumulatedTranscript.push({
            text: `[NOTE] ${note}`,
            speaker: null,
            timestamp: Date.now(),
          });

          this._syncTranscriptEditor();
        },

        async ctxCopyTranscript() {
          const editor = document.getElementById('ctxTranscriptEditor');
          if (editor) {
            try {
              await window.electronClipboard.writeText(editor.value);
              this.showHudWarning('TRANSCRIPT COPIED', false, 1500);
              // Update state indicator in Controls tab
              const stateEl = document.getElementById('ctxCopyTranscriptState');
              if (stateEl) {
                stateEl.textContent = 'COPIED';
                stateEl.className = 'ctx-item-state on';
                setTimeout(() => {
                  stateEl.textContent = 'COPY';
                  stateEl.className = 'ctx-item-state';
                }, 2000);
              }
            } catch (e) {
              console.error('[Copy] Transcript copy failed:', e);
            }
          }
        },

        clearTranscript() {
          // Clear accumulated live transcript data
          this.accumulatedTranscript = [];
          this.interimText = '';
          this.transcriptLastFlushedIndex = 0;
          // Clear the transcript editor
          const editor = document.getElementById('ctxTranscriptEditor');
          if (editor) editor.value = '';
          // Clear caption overlay
          if (this.elements.captionText) this.elements.captionText.textContent = '';
          // Visual feedback
          const stateEl = document.getElementById('ctxClearState');
          if (stateEl) {
            stateEl.textContent = 'CLEARED';
            stateEl.className = 'ctx-item-state on';
            setTimeout(() => {
              stateEl.textContent = 'CLEAR';
              stateEl.className = 'ctx-item-state';
            }, 2000);
          }
          this.showHudWarning('TRANSCRIPT CLEARED', false, 1500);
          console.log('[Recorder] Transcript cleared');
        },

        ctxDownloadTranscript() {
          const editor = document.getElementById('ctxTranscriptEditor');
          if (!editor) return;
          const blob = new Blob([editor.value], { type: 'text/markdown' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `transcript_${Date.now()}.md`;
          a.click();
          URL.revokeObjectURL(url);
          this.showHudWarning('TRANSCRIPT DOWNLOADED', false, 1500);
        },

        // Periodically sync transcript when recording
        _startTranscriptSync() {
          this._transcriptSyncInterval = setInterval(() => {
            if (this._ctxCurrentTab === 'transcript' && this._ctxOpen) {
              this._syncTranscriptEditor();
            }
          }, 2000);
        },

        _stopTranscriptSync() {
          clearInterval(this._transcriptSyncInterval);
        },
      });

      // Patch init to also start HUD
      const _origInit = app.init.bind(app);
      app.init = async function () {
        await _origInit();
        this.initHUD();
        this._startTranscriptSync();
      };

      document.addEventListener('DOMContentLoaded', () => app.init());
    </script>
  </body>
</html>
