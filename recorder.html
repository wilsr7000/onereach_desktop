<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com; media-src 'self' blob: mediastream:; img-src 'self' blob: data:; connect-src 'self' https://*.onereach.ai wss://*.onereach.ai;">
  <title>GSX Capture</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-base: #08080e;
      --bg-surface: #101018;
      --bg-panel: #161622;
      --bg-elevated: #1e1e30;
      --bg-hover: #282842;
      --bg-active: #2e2e50;
      --accent-red: #ff3b4e;
      --accent-red-dim: #cc2f3e;
      --accent-red-glow: rgba(255, 59, 78, 0.35);
      --accent-blue: #4d7cff;
      --accent-blue-dim: rgba(77, 124, 255, 0.15);
      --accent-green: #00d68f;
      --accent-green-dim: rgba(0, 214, 143, 0.15);
      --accent-purple: #8b5cf6;
      --text-primary: #e8e8f0;
      --text-secondary: #8585a0;
      --text-muted: #4e4e68;
      --border-color: rgba(255, 255, 255, 0.06);
      --border-light: rgba(255, 255, 255, 0.1);
      --border-focus: rgba(77, 124, 255, 0.5);
      --glass-bg: rgba(16, 16, 26, 0.75);
      --glass-border: rgba(255, 255, 255, 0.08);
      --glass-blur: 20px;
      --radius-sm: 8px;
      --radius-md: 12px;
      --radius-lg: 16px;
      --radius-xl: 20px;
      --transition-fast: 0.15s cubic-bezier(0.4, 0, 0.2, 1);
      --transition-smooth: 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      --transition-spring: 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      background: var(--bg-base);
      color: var(--text-primary);
      height: 100vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      user-select: none;
    }

    /* Scrollbar */
    ::-webkit-scrollbar { width: 6px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: var(--text-muted); border-radius: 3px; }
    ::-webkit-scrollbar-thumb:hover { background: var(--text-secondary); }

    /* ============================================
       HEADER
       ============================================ */
    .header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 16px;
      height: 44px;
      background: linear-gradient(180deg, rgba(20, 20, 35, 0.9) 0%, rgba(10, 10, 18, 0.95) 100%);
      border-bottom: 1px solid var(--border-color);
      -webkit-app-region: drag;
      flex-shrink: 0;
      position: relative;
      z-index: 10;
    }

    .header-title {
      font-size: 13px;
      font-weight: 600;
      color: var(--text-primary);
      display: flex;
      align-items: center;
      gap: 8px;
      letter-spacing: 0.3px;
    }

    .header-title .title-icon {
      width: 18px;
      height: 18px;
      color: var(--accent-red);
      flex-shrink: 0;
    }

    .header-actions {
      display: flex;
      gap: 2px;
      -webkit-app-region: no-drag;
    }

    .header-btn {
      background: transparent;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      padding: 6px 8px;
      border-radius: var(--radius-sm);
      transition: all var(--transition-fast);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .header-btn:hover {
      background: var(--bg-hover);
      color: var(--text-primary);
    }

    .header-btn:active {
      transform: scale(0.95);
    }

    .header-btn.close-btn:hover {
      background: var(--accent-red);
      color: white;
    }

    /* ============================================
       MAIN LAYOUT
       ============================================ */
    .main-layout {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
      position: relative;
    }

    /* ============================================
       PREVIEW AREA
       ============================================ */
    .preview-wrapper {
      flex: 1;
      position: relative;
      min-height: 0;
      display: flex;
      align-items: stretch;
    }

    .preview-container {
      flex: 1;
      background: #000;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      transition: box-shadow var(--transition-smooth);
    }

    .preview-container.recording-active {
      box-shadow: inset 0 0 80px var(--accent-red-glow), inset 0 0 2px var(--accent-red);
    }

    .preview-container video {
      width: 100%;
      height: 100%;
      object-fit: contain;
      background: #000;
    }

    /* PiP Camera Overlay */
    .pip-camera {
      position: absolute;
      bottom: 80px;
      right: 20px;
      width: 200px;
      height: 150px;
      border-radius: var(--radius-md);
      overflow: hidden;
      border: 2px solid rgba(255, 255, 255, 0.2);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
      z-index: 10;
      display: none;
      cursor: move;
      transition: border-color var(--transition-fast);
    }

    .pip-camera.active { display: block; }
    .pip-camera:hover { border-color: rgba(255, 255, 255, 0.4); }

    .pip-camera video {
      width: 100%;
      height: 100%;
      object-fit: cover;
      transform: scaleX(-1);
    }

    .pip-camera .pip-label {
      position: absolute;
      top: 6px;
      left: 6px;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(8px);
      padding: 3px 8px;
      border-radius: 4px;
      font-size: 10px;
      color: white;
      font-weight: 500;
    }

    #combinedCanvas { display: none; }

    /* Preview Placeholder */
    .preview-placeholder {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 16px;
      color: var(--text-muted);
      position: absolute;
      inset: 0;
      justify-content: center;
      z-index: 2;
    }

    .placeholder-icon {
      width: 72px;
      height: 72px;
      border-radius: 50%;
      background: var(--bg-elevated);
      display: flex;
      align-items: center;
      justify-content: center;
      border: 1px solid var(--border-color);
    }

    .placeholder-icon svg {
      width: 32px;
      height: 32px;
      opacity: 0.4;
    }

    .preview-placeholder span {
      font-size: 14px;
      font-weight: 400;
      letter-spacing: 0.2px;
    }

    .preview-placeholder .shortcut-hint {
      font-size: 11px;
      color: var(--text-muted);
      margin-top: -8px;
    }

    .shortcut-hint kbd {
      display: inline-block;
      background: var(--bg-elevated);
      border: 1px solid var(--border-light);
      border-radius: 4px;
      padding: 1px 6px;
      font-family: inherit;
      font-size: 10px;
      font-weight: 500;
      color: var(--text-secondary);
    }

    /* Recording Indicator */
    .recording-indicator {
      position: absolute;
      top: 16px;
      left: 16px;
      display: flex;
      align-items: center;
      gap: 8px;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(12px);
      padding: 8px 14px;
      border-radius: 20px;
      font-size: 11px;
      font-weight: 600;
      letter-spacing: 1.5px;
      text-transform: uppercase;
      opacity: 0;
      transform: translateY(-8px);
      transition: all var(--transition-smooth);
      z-index: 20;
      border: 1px solid rgba(255, 59, 78, 0.3);
    }

    .recording-indicator.active {
      opacity: 1;
      transform: translateY(0);
    }

    .recording-dot {
      width: 8px;
      height: 8px;
      background: var(--accent-red);
      border-radius: 50%;
      animation: rec-pulse 1.2s ease-in-out infinite;
      box-shadow: 0 0 8px var(--accent-red-glow);
    }

    @keyframes rec-pulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.4; transform: scale(0.85); }
    }

    /* Duration Display */
    .duration-display {
      position: absolute;
      top: 16px;
      right: 16px;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(12px);
      padding: 8px 16px;
      border-radius: 20px;
      font-family: 'Inter', monospace;
      font-size: 16px;
      font-weight: 600;
      font-variant-numeric: tabular-nums;
      z-index: 20;
      border: 1px solid var(--border-color);
      opacity: 0;
      transform: translateY(-8px);
      transition: all var(--transition-smooth);
    }

    .duration-display.visible {
      opacity: 1;
      transform: translateY(0);
    }

    .duration-display .target {
      color: var(--text-muted);
      font-size: 11px;
      margin-left: 8px;
      font-weight: 400;
    }

    /* Countdown Overlay */
    .countdown-overlay {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(8px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 50;
      opacity: 0;
      visibility: hidden;
      transition: all 0.2s;
    }

    .countdown-overlay.active {
      opacity: 1;
      visibility: visible;
    }

    .countdown-number {
      font-size: 120px;
      font-weight: 700;
      color: white;
      text-shadow: 0 0 60px var(--accent-red-glow);
      animation: countdown-pop 0.8s ease-out;
      line-height: 1;
    }

    @keyframes countdown-pop {
      0% { transform: scale(2); opacity: 0; }
      30% { transform: scale(0.9); opacity: 1; }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); opacity: 1; }
    }

    /* Permission Overlay */
    .permission-overlay {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(12px);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 16px;
      z-index: 30;
    }

    .permission-overlay.hidden { display: none; }

    .permission-overlay svg {
      width: 48px;
      height: 48px;
      color: var(--text-muted);
    }

    .permission-overlay p {
      font-size: 14px;
      color: var(--text-secondary);
    }

    .permission-btn {
      padding: 12px 28px;
      background: var(--accent-blue);
      color: white;
      border: none;
      border-radius: var(--radius-sm);
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      transition: all var(--transition-fast);
    }

    .permission-btn:hover {
      filter: brightness(1.15);
      transform: translateY(-1px);
    }

    .permission-btn:active {
      transform: translateY(0);
    }

    /* Audio Level Meter */
    .audio-meter {
      position: absolute;
      bottom: 16px;
      left: 16px;
      display: flex;
      align-items: flex-end;
      gap: 2px;
      height: 32px;
      z-index: 20;
      opacity: 0;
      transition: opacity var(--transition-smooth);
    }

    .audio-meter.visible { opacity: 1; }

    .audio-meter-bar {
      width: 3px;
      background: var(--accent-green);
      border-radius: 2px;
      transition: height 0.05s ease-out;
      min-height: 3px;
    }

    .audio-meter-bar.peak {
      background: var(--accent-red);
    }

    /* ============================================
       BOTTOM PANEL
       ============================================ */
    .bottom-panel {
      flex-shrink: 0;
      background: linear-gradient(180deg, var(--bg-surface) 0%, var(--bg-base) 100%);
      border-top: 1px solid var(--border-color);
      display: flex;
      flex-direction: column;
    }

    /* Mode Tabs */
    .mode-tabs {
      display: flex;
      gap: 2px;
      padding: 10px 16px 0;
      border-bottom: 1px solid var(--border-color);
    }

    .mode-tab {
      flex: 1;
      padding: 10px 12px;
      background: transparent;
      border: none;
      border-bottom: 2px solid transparent;
      color: var(--text-muted);
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      transition: all var(--transition-fast);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      white-space: nowrap;
    }

    .mode-tab svg {
      width: 15px;
      height: 15px;
      flex-shrink: 0;
    }

    .mode-tab:hover {
      color: var(--text-secondary);
      background: var(--bg-elevated);
    }

    .mode-tab.active {
      color: var(--text-primary);
      border-bottom-color: var(--accent-blue);
    }

    /* Space Selector Bar */
    .space-selector-bar {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 16px;
      background: var(--bg-panel);
      border-bottom: 1px solid var(--border-color);
    }

    .space-selector-label {
      font-size: 11px;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      white-space: nowrap;
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .space-selector-label svg {
      width: 14px;
      height: 14px;
    }

    .space-selector-bar .source-select {
      flex: 1;
    }

    .space-selector-bar .source-select.unset {
      border-color: rgba(255, 59, 78, 0.3);
      animation: pulse-border 2s infinite;
    }

    @keyframes pulse-border {
      0%, 100% { border-color: rgba(255, 59, 78, 0.3); }
      50% { border-color: rgba(255, 59, 78, 0.6); }
    }

    /* Controls Bar */
    .controls-bar {
      display: flex;
      align-items: center;
      padding: 12px 16px;
      gap: 12px;
    }

    /* Audio Source (compact) */
    .source-compact {
      flex: 1;
      display: flex;
      gap: 8px;
      min-width: 0;
    }

    .source-compact-item {
      flex: 1;
      min-width: 0;
    }

    .source-compact-label {
      font-size: 10px;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 4px;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .source-compact-label svg {
      width: 12px;
      height: 12px;
    }

    .source-select {
      width: 100%;
      padding: 8px 28px 8px 10px;
      background: var(--bg-panel);
      border: 1px solid var(--border-color);
      border-radius: var(--radius-sm);
      color: var(--text-primary);
      font-size: 12px;
      font-family: inherit;
      cursor: pointer;
      appearance: none;
      -webkit-appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='10' viewBox='0 0 24 24' fill='none' stroke='%234e4e68' stroke-width='2.5'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 8px center;
      transition: all var(--transition-fast);
      text-overflow: ellipsis;
      white-space: nowrap;
      overflow: hidden;
    }

    .source-select:hover {
      border-color: var(--border-light);
      background-color: var(--bg-elevated);
    }

    .source-select:focus {
      outline: none;
      border-color: var(--border-focus);
    }

    /* Record Button */
    .record-wrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      flex-shrink: 0;
    }

    .record-btn {
      width: 56px;
      height: 56px;
      border-radius: 50%;
      border: 3px solid var(--text-muted);
      background: transparent;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all var(--transition-smooth);
      position: relative;
    }

    .record-btn::before {
      content: '';
      position: absolute;
      inset: -6px;
      border-radius: 50%;
      border: 2px solid transparent;
      transition: all var(--transition-smooth);
    }

    .record-btn:hover {
      border-color: var(--accent-red);
      transform: scale(1.06);
    }

    .record-btn:hover::before {
      border-color: rgba(255, 59, 78, 0.2);
    }

    .record-btn:active {
      transform: scale(0.98);
    }

    .record-btn-inner {
      width: 36px;
      height: 36px;
      background: var(--accent-red);
      border-radius: 50%;
      transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 0 0 0 transparent;
    }

    .record-btn.recording {
      border-color: var(--accent-red);
    }

    .record-btn.recording::before {
      border-color: var(--accent-red-glow);
      animation: record-ring-pulse 1.8s ease-in-out infinite;
    }

    .record-btn.recording .record-btn-inner {
      width: 22px;
      height: 22px;
      border-radius: 5px;
      box-shadow: 0 0 20px var(--accent-red-glow);
    }

    @keyframes record-ring-pulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.3; transform: scale(1.1); }
    }

    .record-label {
      font-size: 9px;
      font-weight: 700;
      letter-spacing: 1.5px;
      text-transform: uppercase;
      color: var(--text-muted);
      transition: color var(--transition-fast);
    }

    .record-btn.recording + .record-label {
      color: var(--accent-red);
    }

    /* Pause Button */
    .pause-btn {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      background: var(--bg-panel);
      border: 1px solid var(--border-color);
      color: var(--text-secondary);
      cursor: pointer;
      display: none;
      align-items: center;
      justify-content: center;
      transition: all var(--transition-fast);
      position: absolute;
      right: -48px;
      top: 50%;
      transform: translateY(-50%);
    }

    .pause-btn:hover {
      background: var(--bg-elevated);
      border-color: var(--border-light);
      color: var(--text-primary);
    }

    .pause-btn svg {
      width: 16px;
      height: 16px;
    }

    .pause-btn.visible {
      display: flex;
    }

    .pause-btn.paused {
      background: var(--accent-blue-dim);
      border-color: var(--accent-blue);
      color: var(--accent-blue);
    }

    .pause-btn.paused:hover {
      background: rgba(77, 124, 255, 0.25);
    }

    /* Paused Overlay */
    .paused-overlay {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 12px;
      z-index: 5;
      opacity: 0;
      pointer-events: none;
      transition: opacity var(--transition-smooth);
      border-radius: var(--radius-lg);
    }

    .paused-overlay.active {
      opacity: 1;
      pointer-events: auto;
    }

    .paused-overlay-icon {
      width: 48px;
      height: 48px;
      color: var(--accent-blue);
      opacity: 0.9;
    }

    .paused-overlay-text {
      font-size: 14px;
      font-weight: 600;
      color: var(--text-primary);
      letter-spacing: 2px;
      text-transform: uppercase;
    }

    .paused-overlay-hint {
      font-size: 11px;
      color: var(--text-secondary);
      margin-top: 4px;
    }

    /* Control Buttons (adjacent to record) */
    .ctrl-btn {
      width: 36px;
      height: 36px;
      border-radius: var(--radius-sm);
      background: var(--bg-panel);
      border: 1px solid var(--border-color);
      color: var(--text-secondary);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all var(--transition-fast);
    }

    .ctrl-btn svg {
      width: 16px;
      height: 16px;
    }

    .ctrl-btn:hover {
      background: var(--bg-elevated);
      color: var(--text-primary);
      border-color: var(--border-light);
    }

    .ctrl-btn:active {
      transform: scale(0.95);
    }

    .ctrl-btn.active {
      background: var(--accent-blue-dim);
      color: var(--accent-blue);
      border-color: rgba(77, 124, 255, 0.3);
    }

    /* Review Controls */
    .review-bar {
      display: none;
      align-items: center;
      justify-content: center;
      padding: 14px 16px;
      gap: 10px;
    }

    .review-bar.visible {
      display: flex;
    }

    .review-btn {
      padding: 10px 20px;
      border: none;
      border-radius: var(--radius-sm);
      font-size: 13px;
      font-weight: 600;
      font-family: inherit;
      cursor: pointer;
      transition: all var(--transition-fast);
      display: flex;
      align-items: center;
      gap: 7px;
    }

    .review-btn svg {
      width: 15px;
      height: 15px;
    }

    .review-btn:active {
      transform: scale(0.97);
    }

    .review-btn.danger {
      background: rgba(255, 59, 78, 0.12);
      color: var(--accent-red);
      border: 1px solid rgba(255, 59, 78, 0.2);
    }

    .review-btn.danger:hover {
      background: rgba(255, 59, 78, 0.2);
    }

    .review-btn.secondary {
      background: var(--bg-elevated);
      color: var(--text-primary);
      border: 1px solid var(--border-color);
    }

    .review-btn.secondary:hover {
      background: var(--bg-hover);
      border-color: var(--border-light);
    }

    .review-btn.primary {
      background: var(--accent-green);
      color: #000;
      border: 1px solid transparent;
    }

    .review-btn.primary:hover {
      filter: brightness(1.1);
      box-shadow: 0 4px 16px rgba(0, 214, 143, 0.25);
    }

    .review-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
      pointer-events: none;
    }

    /* ============================================
       SETTINGS PANEL (expandable)
       ============================================ */
    .settings-panel {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.35s cubic-bezier(0.4, 0, 0.2, 1);
      border-top: 1px solid transparent;
    }

    .settings-panel.open {
      max-height: 500px;
      border-top-color: var(--border-color);
    }

    .settings-inner {
      padding: 14px 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    /* Source Selection */
    .setting-row {
      display: flex;
      gap: 12px;
    }

    .setting-group {
      flex: 1;
      min-width: 0;
    }

    .setting-label {
      font-size: 10px;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 6px;
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .setting-label svg {
      width: 13px;
      height: 13px;
    }

    /* Audio Mixing Panel */
    .audio-mix-panel {
      display: none;
    }

    .audio-mix-panel.visible {
      display: block;
    }

    .mix-title {
      font-size: 11px;
      font-weight: 600;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .mix-title svg {
      width: 14px;
      height: 14px;
    }

    .volume-sliders {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
      gap: 10px;
    }

    .volume-slider-group {
      background: var(--bg-panel);
      padding: 10px 12px;
      border-radius: var(--radius-sm);
      border: 1px solid var(--border-color);
    }

    .volume-label {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 11px;
      color: var(--text-secondary);
      margin-bottom: 8px;
    }

    .volume-label svg {
      width: 14px;
      height: 14px;
      flex-shrink: 0;
    }

    .volume-value {
      margin-left: auto;
      font-weight: 600;
      font-size: 11px;
      color: var(--text-primary);
      min-width: 35px;
      text-align: right;
      font-variant-numeric: tabular-nums;
    }

    .volume-slider {
      width: 100%;
      height: 4px;
      -webkit-appearance: none;
      appearance: none;
      background: var(--bg-hover);
      border-radius: 2px;
      outline: none;
      cursor: pointer;
    }

    .volume-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 14px;
      height: 14px;
      background: var(--accent-blue);
      border-radius: 50%;
      cursor: pointer;
      transition: transform 0.1s, box-shadow 0.1s;
      box-shadow: 0 0 0 0 transparent;
    }

    .volume-slider::-webkit-slider-thumb:hover {
      transform: scale(1.2);
      box-shadow: 0 0 8px rgba(77, 124, 255, 0.4);
    }

    .volume-slider::-moz-range-thumb {
      width: 14px;
      height: 14px;
      background: var(--accent-blue);
      border-radius: 50%;
      cursor: pointer;
      border: none;
    }

    .volume-source-select {
      width: 100%;
      padding: 5px 24px 5px 8px;
      margin-bottom: 8px;
      background: var(--bg-elevated);
      border: 1px solid var(--border-color);
      border-radius: 5px;
      color: var(--text-primary);
      font-size: 11px;
      font-family: inherit;
      cursor: pointer;
      appearance: none;
      -webkit-appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='10' viewBox='0 0 24 24' fill='none' stroke='%234e4e68' stroke-width='2.5'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 6px center;
    }

    .volume-source-select:hover { border-color: var(--border-light); }
    .volume-source-select:focus { outline: none; border-color: var(--border-focus); }

    /* System audio status badge */
    .audio-status-badge {
      display: inline-block;
      font-size: 9px;
      font-weight: 600;
      letter-spacing: 0.3px;
      text-transform: uppercase;
      padding: 1px 5px;
      border-radius: 3px;
      margin-left: auto;
      background: rgba(78, 78, 104, 0.2);
      color: var(--text-muted);
      cursor: help;
      transition: var(--transition-fast);
    }

    .audio-status-badge.active {
      background: var(--accent-green-dim);
      color: var(--accent-green);
    }

    /* Live Caption Overlay */
    .caption-overlay {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      z-index: 6;
      padding: 12px 20px 16px;
      background: linear-gradient(0deg, rgba(0,0,0,0.85) 0%, rgba(0,0,0,0.6) 60%, transparent 100%);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: flex-end;
      pointer-events: none;
      min-height: 64px;
      transition: opacity var(--transition-smooth);
    }

    .caption-overlay.visible {
      display: flex;
    }

    .caption-text {
      font-size: 15px;
      font-weight: 500;
      color: rgba(255, 255, 255, 0.95);
      text-align: center;
      line-height: 1.5;
      max-width: 90%;
      text-shadow: 0 1px 4px rgba(0, 0, 0, 0.7);
      word-wrap: break-word;
      max-height: 80px;
      overflow-y: hidden;
    }

    .caption-text.interim {
      color: rgba(180, 180, 200, 0.8);
      font-style: italic;
      font-weight: 400;
    }

    .caption-text:empty {
      display: none;
    }

    /* Caption toggle button */
    .caption-toggle {
      width: 36px;
      height: 36px;
      border-radius: var(--radius-sm);
      background: var(--bg-panel);
      border: 1px solid var(--border-color);
      color: var(--text-muted);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all var(--transition-fast);
    }

    .caption-toggle:hover {
      background: var(--bg-elevated);
      border-color: var(--border-light);
      color: var(--text-secondary);
    }

    .caption-toggle.active {
      background: var(--accent-blue-dim);
      border-color: var(--accent-blue);
      color: var(--accent-blue);
    }

    .caption-toggle svg {
      width: 18px;
      height: 18px;
    }

    /* Transcription status indicator */
    .transcription-status {
      display: none;
      align-items: center;
      gap: 6px;
      font-size: 11px;
      color: var(--text-muted);
      padding: 6px 10px;
      background: var(--bg-panel);
      border: 1px solid var(--border-color);
      border-radius: var(--radius-sm);
      position: absolute;
      top: 12px;
      right: 12px;
      z-index: 7;
    }

    .transcription-status.visible {
      display: flex;
    }

    .transcription-status.active {
      color: var(--accent-green);
      border-color: rgba(0, 214, 143, 0.3);
    }

    .transcription-status .status-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: var(--text-muted);
    }

    .transcription-status.active .status-dot {
      background: var(--accent-green);
      animation: status-pulse 2s ease-in-out infinite;
    }

    @keyframes status-pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.4; }
    }

    /* Monitor Alert Toast */
    .monitor-alert-container {
      position: absolute;
      top: 12px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 50;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      pointer-events: none;
      width: 90%;
      max-width: 480px;
    }

    .monitor-alert {
      display: flex;
      align-items: flex-start;
      gap: 10px;
      padding: 10px 14px;
      background: rgba(20, 20, 30, 0.95);
      border: 1px solid var(--border-color);
      border-radius: var(--radius-md);
      backdrop-filter: blur(12px);
      pointer-events: auto;
      opacity: 0;
      transform: translateY(-12px);
      animation: alert-slide-in 0.3s ease-out forwards;
      width: 100%;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
    }

    .monitor-alert.warning {
      border-color: rgba(255, 180, 50, 0.4);
    }

    .monitor-alert.info {
      border-color: rgba(100, 160, 255, 0.3);
    }

    .monitor-alert.dismissing {
      animation: alert-slide-out 0.3s ease-in forwards;
    }

    @keyframes alert-slide-in {
      to { opacity: 1; transform: translateY(0); }
    }

    @keyframes alert-slide-out {
      from { opacity: 1; transform: translateY(0); }
      to { opacity: 0; transform: translateY(-12px); }
    }

    .monitor-alert-icon {
      flex-shrink: 0;
      width: 18px;
      height: 18px;
      margin-top: 1px;
    }

    .monitor-alert.warning .monitor-alert-icon {
      color: #ffb432;
    }

    .monitor-alert.info .monitor-alert-icon {
      color: #64a0ff;
    }

    .monitor-alert-body {
      flex: 1;
      min-width: 0;
    }

    .monitor-alert-message {
      font-size: 12px;
      font-weight: 500;
      color: var(--text-primary);
      line-height: 1.4;
    }

    .monitor-alert-suggestion {
      font-size: 11px;
      color: var(--text-muted);
      margin-top: 3px;
      line-height: 1.3;
    }

    .monitor-alert-dismiss {
      flex-shrink: 0;
      width: 20px;
      height: 20px;
      border: none;
      background: none;
      color: var(--text-muted);
      cursor: pointer;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      transition: color var(--transition-fast);
    }

    .monitor-alert-dismiss:hover {
      color: var(--text-primary);
    }

    .monitor-alert-dismiss svg {
      width: 14px;
      height: 14px;
    }

    /* Instructions Panel */
    .instructions-panel {
      background: var(--bg-panel);
      border: 1px solid var(--border-color);
      border-radius: var(--radius-sm);
      overflow: hidden;
    }

    .instructions-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      border-bottom: 1px solid var(--border-color);
    }

    .instructions-title {
      font-size: 10px;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .instructions-title svg {
      width: 13px;
      height: 13px;
    }

    .instructions-content {
      font-size: 13px;
      line-height: 1.6;
      color: var(--text-primary);
      padding: 10px 12px;
      min-height: 40px;
      max-height: 80px;
      overflow-y: auto;
    }

    .instructions-content.empty {
      color: var(--text-muted);
      font-style: italic;
    }

    /* ============================================
       SAVE DIALOG
       ============================================ */
    .save-dialog {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.75);
      backdrop-filter: blur(8px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
      opacity: 0;
      visibility: hidden;
      transition: all 0.25s;
    }

    .save-dialog.active {
      opacity: 1;
      visibility: visible;
    }

    .save-dialog-content {
      background: var(--bg-panel);
      border: 1px solid var(--border-light);
      border-radius: var(--radius-lg);
      padding: 24px;
      width: 400px;
      max-width: 90%;
      box-shadow: 0 24px 80px rgba(0, 0, 0, 0.6);
      transform: scale(0.95) translateY(10px);
      transition: transform 0.25s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .save-dialog.active .save-dialog-content {
      transform: scale(1) translateY(0);
    }

    .save-dialog-title {
      font-size: 16px;
      font-weight: 600;
      margin-bottom: 20px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .save-dialog-title svg {
      width: 18px;
      height: 18px;
      color: var(--accent-green);
    }

    .save-form-group {
      margin-bottom: 14px;
    }

    .save-form-label {
      display: block;
      font-size: 11px;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.3px;
      margin-bottom: 6px;
    }

    .save-form-input {
      width: 100%;
      padding: 10px 12px;
      background: var(--bg-elevated);
      border: 1px solid var(--border-color);
      border-radius: var(--radius-sm);
      color: var(--text-primary);
      font-size: 13px;
      font-family: inherit;
      transition: all var(--transition-fast);
    }

    .save-form-input:focus {
      outline: none;
      border-color: var(--border-focus);
      box-shadow: 0 0 0 3px rgba(77, 124, 255, 0.1);
    }

    .save-dialog-actions {
      display: flex;
      gap: 10px;
      margin-top: 22px;
    }

    .save-dialog-actions .review-btn {
      flex: 1;
      justify-content: center;
    }

    /* ============================================
       SCREEN PICKER
       ============================================ */
    .screen-picker {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(8px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
      opacity: 0;
      visibility: hidden;
      transition: all 0.25s;
    }

    .screen-picker.active {
      opacity: 1;
      visibility: visible;
    }

    .screen-picker-content {
      background: var(--bg-panel);
      border: 1px solid var(--border-light);
      border-radius: var(--radius-lg);
      padding: 24px;
      width: 600px;
      max-width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 24px 80px rgba(0, 0, 0, 0.6);
      transform: scale(0.95) translateY(10px);
      transition: transform 0.25s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .screen-picker.active .screen-picker-content {
      transform: scale(1) translateY(0);
    }

    .screen-picker-title {
      font-size: 16px;
      font-weight: 600;
      margin-bottom: 4px;
    }

    .screen-picker-subtitle {
      font-size: 12px;
      color: var(--text-muted);
      margin-bottom: 20px;
    }

    .screen-picker-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      gap: 10px;
      margin-bottom: 20px;
    }

    .screen-source-item {
      background: var(--bg-elevated);
      border: 2px solid var(--border-color);
      border-radius: var(--radius-sm);
      padding: 8px;
      cursor: pointer;
      transition: all var(--transition-fast);
    }

    .screen-source-item:hover {
      border-color: var(--accent-blue);
      background: var(--bg-hover);
      transform: translateY(-2px);
    }

    .screen-source-item.selected {
      border-color: var(--accent-blue);
      background: var(--accent-blue-dim);
      box-shadow: 0 0 0 1px var(--accent-blue);
    }

    .screen-source-thumbnail {
      width: 100%;
      aspect-ratio: 16/9;
      object-fit: contain;
      background: #000;
      border-radius: 4px;
      margin-bottom: 8px;
    }

    .screen-source-name {
      font-size: 11px;
      color: var(--text-secondary);
      text-align: center;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .screen-picker-actions {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
    }

    /* ============================================
       STATUS MESSAGE
       ============================================ */
    .status-message {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%) translateY(20px);
      background: var(--bg-panel);
      border: 1px solid var(--border-color);
      padding: 10px 20px;
      border-radius: var(--radius-xl);
      font-size: 13px;
      font-weight: 500;
      opacity: 0;
      visibility: hidden;
      transition: all var(--transition-smooth);
      z-index: 200;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .status-message.active {
      opacity: 1;
      visibility: visible;
      transform: translateX(-50%) translateY(0);
    }

    .status-message.success {
      border-color: rgba(0, 214, 143, 0.3);
      color: var(--accent-green);
    }

    .status-message.error {
      border-color: rgba(255, 59, 78, 0.3);
      color: var(--accent-red);
    }

    .status-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: currentColor;
      flex-shrink: 0;
    }

    /* ============================================
       KEYBOARD SHORTCUTS BAR
       ============================================ */
    .shortcuts-bar {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 16px;
      padding: 6px 16px;
      border-top: 1px solid var(--border-color);
      background: var(--bg-base);
    }

    .shortcut-item {
      display: flex;
      align-items: center;
      gap: 5px;
      font-size: 10px;
      color: var(--text-muted);
    }

    .shortcut-item kbd {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 18px;
      height: 18px;
      background: var(--bg-elevated);
      border: 1px solid var(--border-light);
      border-radius: 4px;
      padding: 0 4px;
      font-family: inherit;
      font-size: 9px;
      font-weight: 600;
      color: var(--text-secondary);
    }

    /* ============================================
       P2P SESSION MODE
       ============================================ */

    /* Split-view for session */
    .preview-container.session-active {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 4px;
    }

    .session-participant {
      position: relative;
      border-radius: var(--radius-md);
      overflow: hidden;
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .session-participant video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .participant-label {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(8px);
      padding: 4px 12px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 600;
      color: white;
      z-index: 5;
    }

    .participant-label.remote {
      border: 1px solid rgba(77, 124, 255, 0.3);
    }

    /* Session setup panel (pre-connection) */
    .session-setup {
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 24px;
      position: absolute;
      inset: 0;
      background: var(--bg-base);
      z-index: 40;
      padding: 32px;
    }

    .session-setup.visible {
      display: flex;
    }

    .session-setup-title {
      font-size: 18px;
      font-weight: 600;
      color: var(--text-primary);
      text-align: center;
    }

    .session-setup-subtitle {
      font-size: 13px;
      color: var(--text-muted);
      text-align: center;
      margin-top: -16px;
    }

    .session-actions {
      display: flex;
      gap: 16px;
      width: 100%;
      max-width: 400px;
    }

    .session-action-card {
      flex: 1;
      padding: 24px 16px;
      background: var(--bg-panel);
      border: 1px solid var(--border-color);
      border-radius: var(--radius-lg);
      cursor: pointer;
      transition: all var(--transition-fast);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      text-align: center;
    }

    .session-action-card:hover {
      background: var(--bg-elevated);
      border-color: var(--border-light);
      transform: translateY(-2px);
    }

    .session-action-card svg {
      width: 32px;
      height: 32px;
      color: var(--accent-blue);
    }

    .session-action-card .card-title {
      font-size: 14px;
      font-weight: 600;
      color: var(--text-primary);
    }

    .session-action-card .card-desc {
      font-size: 11px;
      color: var(--text-muted);
    }

    /* Host waiting state */
    .session-host-waiting {
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 20px;
      position: absolute;
      inset: 0;
      background: var(--bg-base);
      z-index: 40;
      padding: 32px;
    }

    .session-host-waiting.visible {
      display: flex;
    }

    .session-code-display {
      font-size: 56px;
      font-weight: 700;
      color: var(--text-primary);
      text-transform: uppercase;
      letter-spacing: 4px;
      padding: 16px 32px;
      background: var(--bg-panel);
      border: 2px solid var(--border-light);
      border-radius: var(--radius-lg);
      cursor: pointer;
      transition: all var(--transition-fast);
      position: relative;
    }

    .session-code-display:hover {
      border-color: var(--accent-blue);
      background: var(--bg-elevated);
    }

    .session-code-display .copy-hint {
      position: absolute;
      bottom: -24px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 11px;
      font-weight: 400;
      color: var(--text-muted);
      letter-spacing: 0;
      text-transform: none;
      white-space: nowrap;
    }

    .waiting-text {
      font-size: 14px;
      color: var(--text-secondary);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .waiting-dot {
      width: 8px;
      height: 8px;
      background: var(--accent-blue);
      border-radius: 50%;
      animation: waiting-pulse 1.5s ease-in-out infinite;
    }

    @keyframes waiting-pulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.3; transform: scale(0.8); }
    }

    /* Join session panel */
    .session-join-panel {
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 20px;
      position: absolute;
      inset: 0;
      background: var(--bg-base);
      z-index: 40;
      padding: 32px;
    }

    .session-join-panel.visible {
      display: flex;
    }

    .join-input-row {
      display: flex;
      gap: 8px;
      width: 100%;
      max-width: 360px;
    }

    .join-code-input {
      flex: 1;
      padding: 14px 16px;
      background: var(--bg-panel);
      border: 2px solid var(--border-color);
      border-radius: var(--radius-md);
      color: var(--text-primary);
      font-size: 20px;
      font-weight: 600;
      font-family: inherit;
      text-align: center;
      text-transform: lowercase;
      letter-spacing: 2px;
      transition: all var(--transition-fast);
    }

    .join-code-input::placeholder {
      color: var(--text-muted);
      font-weight: 400;
      font-size: 14px;
      letter-spacing: 0;
      text-transform: none;
    }

    .join-code-input:focus {
      outline: none;
      border-color: var(--accent-blue);
      box-shadow: 0 0 0 3px rgba(77, 124, 255, 0.15);
    }

    .join-connect-btn {
      padding: 14px 24px;
      background: var(--accent-blue);
      color: white;
      border: none;
      border-radius: var(--radius-md);
      font-size: 14px;
      font-weight: 600;
      font-family: inherit;
      cursor: pointer;
      transition: all var(--transition-fast);
      white-space: nowrap;
    }

    .join-connect-btn:hover {
      filter: brightness(1.15);
    }

    .join-connect-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    /* Session connected indicator */
    .session-connected-badge {
      display: none;
      align-items: center;
      gap: 6px;
      position: absolute;
      top: 16px;
      right: 16px;
      background: rgba(0, 214, 143, 0.15);
      border: 1px solid rgba(0, 214, 143, 0.3);
      padding: 6px 12px;
      border-radius: 20px;
      font-size: 11px;
      font-weight: 600;
      color: var(--accent-green);
      z-index: 20;
    }

    .session-connected-badge.visible {
      display: flex;
    }

    .session-connected-dot {
      width: 6px;
      height: 6px;
      background: var(--accent-green);
      border-radius: 50%;
    }

    /* End session button */
    .end-session-btn {
      padding: 8px 16px;
      background: rgba(255, 59, 78, 0.12);
      border: 1px solid rgba(255, 59, 78, 0.2);
      border-radius: var(--radius-sm);
      color: var(--accent-red);
      font-size: 12px;
      font-weight: 600;
      font-family: inherit;
      cursor: pointer;
      transition: all var(--transition-fast);
      display: none;
      align-items: center;
      gap: 6px;
    }

    .end-session-btn.visible {
      display: flex;
    }

    .end-session-btn:hover {
      background: rgba(255, 59, 78, 0.2);
    }

    .end-session-btn svg {
      width: 14px;
      height: 14px;
    }

    /* Session status text */
    .session-status {
      font-size: 13px;
      color: var(--text-secondary);
      text-align: center;
    }

    .session-status.error {
      color: var(--accent-red);
    }

    .session-back-btn {
      padding: 8px 16px;
      background: var(--bg-elevated);
      border: 1px solid var(--border-color);
      border-radius: var(--radius-sm);
      color: var(--text-secondary);
      font-size: 12px;
      font-weight: 500;
      font-family: inherit;
      cursor: pointer;
      transition: all var(--transition-fast);
    }

    .session-back-btn:hover {
      background: var(--bg-hover);
      color: var(--text-primary);
    }

    /* ==================== MEETING HUD OVERLAY ==================== */
    .meeting-hud {
      position: absolute;
      top: 8px;
      right: 8px;
      bottom: 8px;
      width: 280px;
      background: rgba(20, 20, 30, 0.65);
      backdrop-filter: blur(20px) saturate(1.4);
      -webkit-backdrop-filter: blur(20px) saturate(1.4);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 14px;
      display: flex;
      flex-direction: column;
      z-index: 20;
      overflow: hidden;
      transition: opacity 0.25s, transform 0.25s;
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
    }
    .meeting-hud.hidden {
      opacity: 0;
      pointer-events: none;
      transform: translateX(20px);
    }
    .meeting-hud-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 14px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
      font-size: 12px;
      font-weight: 600;
      color: rgba(255,255,255,0.85);
      letter-spacing: 0.5px;
      text-transform: uppercase;
    }
    .meeting-hud-header .hud-count {
      font-size: 11px;
      font-weight: 400;
      color: rgba(255,255,255,0.45);
    }
    .meeting-hud-toggle {
      background: none;
      border: none;
      color: rgba(255,255,255,0.5);
      cursor: pointer;
      padding: 2px;
      font-size: 14px;
      line-height: 1;
    }
    .meeting-hud-toggle:hover { color: rgba(255,255,255,0.8); }
    .meeting-hud-items {
      flex: 1;
      overflow-y: auto;
      padding: 8px 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .meeting-hud-items::-webkit-scrollbar { width: 4px; }
    .meeting-hud-items::-webkit-scrollbar-track { background: transparent; }
    .meeting-hud-items::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.15); border-radius: 2px; }
    .hud-item {
      background: rgba(255,255,255,0.06);
      border-radius: 8px;
      padding: 8px 10px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      position: relative;
    }
    .hud-item:hover { background: rgba(255,255,255,0.1); }
    .hud-item-top {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 10px;
    }
    .hud-type-badge {
      font-weight: 700;
      font-size: 9px;
      padding: 1px 5px;
      border-radius: 3px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .hud-type-badge.action-item { background: rgba(96,165,250,0.25); color: #93bbfc; }
    .hud-type-badge.decision { background: rgba(167,139,250,0.25); color: #c4b5fd; }
    .hud-type-badge.note { background: rgba(156,163,175,0.2); color: #9ca3af; }
    .hud-type-badge.bookmark { background: rgba(251,191,36,0.2); color: #fbbf24; }
    .hud-item-time {
      font-size: 10px;
      color: rgba(255,255,255,0.3);
      margin-left: auto;
    }
    .hud-item-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 3px;
    }
    .hud-tag-pill {
      font-size: 9px;
      font-weight: 600;
      padding: 1px 6px;
      border-radius: 10px;
      color: rgba(255,255,255,0.85);
    }
    .hud-tag-pill.everyone {
      background: transparent;
      border: 1px solid rgba(255,255,255,0.25);
      color: rgba(255,255,255,0.6);
    }
    .hud-item-text {
      font-size: 12px;
      color: rgba(255,255,255,0.75);
      line-height: 1.4;
    }
    .hud-item-deadline {
      font-size: 10px;
      color: rgba(251,191,36,0.7);
    }
    .hud-item-remove {
      position: absolute;
      top: 6px;
      right: 6px;
      background: none;
      border: none;
      color: rgba(255,255,255,0.2);
      cursor: pointer;
      font-size: 12px;
      padding: 0;
      line-height: 1;
      opacity: 0;
      transition: opacity 0.15s;
    }
    .hud-item:hover .hud-item-remove { opacity: 1; }
    .hud-item-remove:hover { color: rgba(255,100,100,0.7); }
    .meeting-hud-input {
      display: flex;
      gap: 4px;
      padding: 8px 10px;
      border-top: 1px solid rgba(255,255,255,0.08);
    }
    .meeting-hud-input input {
      flex: 1;
      background: rgba(255,255,255,0.07);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 6px;
      padding: 6px 10px;
      font-size: 12px;
      color: rgba(255,255,255,0.85);
      outline: none;
      font-family: inherit;
    }
    .meeting-hud-input input::placeholder { color: rgba(255,255,255,0.3); }
    .meeting-hud-input input:focus { border-color: rgba(255,255,255,0.25); }
    .meeting-hud-input button {
      background: rgba(96,165,250,0.2);
      border: 1px solid rgba(96,165,250,0.3);
      border-radius: 6px;
      color: #93bbfc;
      font-size: 11px;
      padding: 0 10px;
      cursor: pointer;
      white-space: nowrap;
    }
    .meeting-hud-input button:hover { background: rgba(96,165,250,0.35); }
    .meeting-hud-agents {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      padding: 6px 10px;
      border-top: 1px solid rgba(255,255,255,0.05);
    }
    .hud-agent-toggle {
      font-size: 9px;
      padding: 2px 7px;
      border-radius: 10px;
      cursor: pointer;
      border: 1px solid rgba(255,255,255,0.15);
      background: transparent;
      color: rgba(255,255,255,0.45);
      transition: all 0.15s;
    }
    .hud-agent-toggle.active {
      background: rgba(96,165,250,0.2);
      border-color: rgba(96,165,250,0.4);
      color: #93bbfc;
    }
    .hud-agent-toggle:hover { border-color: rgba(255,255,255,0.3); }
    .meeting-hud-empty {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      color: rgba(255,255,255,0.25);
      font-size: 12px;
      padding: 20px;
      text-align: center;
      line-height: 1.5;
    }

    /* HUD toggle button on the preview */
    .hud-toggle-btn {
      position: absolute;
      top: 8px;
      right: 8px;
      z-index: 19;
      background: rgba(20, 20, 30, 0.5);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 8px;
      color: rgba(255,255,255,0.6);
      cursor: pointer;
      padding: 6px 10px;
      font-size: 11px;
      font-family: inherit;
      transition: all 0.15s;
    }
    .hud-toggle-btn:hover {
      background: rgba(20, 20, 30, 0.7);
      color: rgba(255,255,255,0.85);
    }
    .hud-toggle-btn.active {
      background: rgba(96,165,250,0.2);
      border-color: rgba(96,165,250,0.3);
      color: #93bbfc;
    }

    /* Tag color palette (deterministic by name hash) */
    .hud-tag-0 { background: rgba(96,165,250,0.3); }
    .hud-tag-1 { background: rgba(167,139,250,0.3); }
    .hud-tag-2 { background: rgba(52,211,153,0.3); }
    .hud-tag-3 { background: rgba(251,146,60,0.3); }
    .hud-tag-4 { background: rgba(248,113,113,0.3); }
    .hud-tag-5 { background: rgba(251,191,36,0.3); }
    .hud-tag-6 { background: rgba(236,72,153,0.3); }
    .hud-tag-7 { background: rgba(34,211,238,0.3); }
    .hud-tag-8 { background: rgba(163,230,53,0.3); }
    .hud-tag-9 { background: rgba(232,121,249,0.3); }
  </style>
</head>
<body>

  <!-- Header -->
  <div class="header">
    <div class="header-title">
      <svg class="title-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
        <circle cx="12" cy="12" r="10"/>
        <circle cx="12" cy="12" r="3" fill="currentColor"/>
      </svg>
      GSX Capture
    </div>
    <div class="header-actions">
      <button class="header-btn" onclick="app.minimize()" title="Minimize">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M5 12h14"/>
        </svg>
      </button>
      <button class="header-btn close-btn" onclick="app.close()" title="Close">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M18 6L6 18M6 6l12 12"/>
        </svg>
      </button>
    </div>
  </div>

  <!-- Main Layout -->
  <div class="main-layout">

    <!-- Preview Area -->
    <div class="preview-wrapper">
      <div class="preview-container" id="previewContainer">
        <video id="previewVideo" autoplay muted playsinline></video>
        <video id="reviewVideo" style="display: none;" controls></video>

        <div class="preview-placeholder" id="previewPlaceholder">
          <div class="placeholder-icon">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
              <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/>
              <circle cx="12" cy="13" r="4"/>
            </svg>
          </div>
          <span>Select a source to begin</span>
          <div class="shortcut-hint">Press <kbd>Space</kbd> to start recording</div>
        </div>

        <div class="permission-overlay hidden" id="permissionOverlay">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
            <rect x="3" y="11" width="18" height="11" rx="2" ry="2"/>
            <path d="M7 11V7a5 5 0 0 1 10 0v4"/>
          </svg>
          <p>Camera and microphone access required</p>
          <button class="permission-btn" onclick="app.requestPermissions()">
            Grant Access
          </button>
        </div>

        <div class="recording-indicator" id="recordingIndicator">
          <div class="recording-dot"></div>
          <span>REC</span>
        </div>

        <!-- Paused Overlay -->
        <div class="paused-overlay" id="pausedOverlay">
          <svg class="paused-overlay-icon" viewBox="0 0 24 24" fill="currentColor" stroke="none">
            <rect x="6" y="4" width="4" height="16" rx="1"/>
            <rect x="14" y="4" width="4" height="16" rx="1"/>
          </svg>
          <div class="paused-overlay-text">Paused</div>
          <div class="paused-overlay-hint">Audio muted. Click resume to continue.</div>
        </div>

        <!-- Live Caption Overlay -->
        <div class="caption-overlay" id="captionOverlay">
          <div class="caption-text" id="captionText"></div>
        </div>

        <!-- Monitor Alert Toasts -->
        <div class="monitor-alert-container" id="monitorAlertContainer"></div>

        <!-- Transcription Status -->
        <div class="transcription-status" id="transcriptionStatus">
          <div class="status-dot"></div>
          <span id="transcriptionStatusText">Transcribing...</span>
        </div>

        <div class="duration-display" id="durationDisplay">
          <span id="currentDuration">00:00</span>
          <span class="target" id="targetDuration"></span>
        </div>

        <!-- Countdown Overlay -->
        <div class="countdown-overlay" id="countdownOverlay">
          <div class="countdown-number" id="countdownNumber">3</div>
        </div>

        <!-- Audio Level Meter -->
        <div class="audio-meter" id="audioMeter">
          <div class="audio-meter-bar"></div>
          <div class="audio-meter-bar"></div>
          <div class="audio-meter-bar"></div>
          <div class="audio-meter-bar"></div>
          <div class="audio-meter-bar"></div>
          <div class="audio-meter-bar"></div>
          <div class="audio-meter-bar"></div>
          <div class="audio-meter-bar"></div>
          <div class="audio-meter-bar"></div>
          <div class="audio-meter-bar"></div>
          <div class="audio-meter-bar"></div>
          <div class="audio-meter-bar"></div>
        </div>

        <!-- Meeting HUD Toggle Button -->
        <button class="hud-toggle-btn" id="hudToggleBtn" onclick="app.toggleMeetingHUD()" title="Meeting HUD">Meeting</button>

        <!-- Meeting HUD Overlay (glass panel) -->
        <div class="meeting-hud hidden" id="meetingHUD">
          <div class="meeting-hud-header">
            <span>Meeting</span>
            <span class="hud-count" id="hudItemCount">0 items</span>
            <button class="meeting-hud-toggle" onclick="app.toggleMeetingHUD()" title="Close HUD">&times;</button>
          </div>

          <div class="meeting-hud-items" id="hudItemList">
            <div class="meeting-hud-empty" id="hudEmptyState">
              Type or speak to add action items, decisions, and notes
            </div>
          </div>

          <div class="meeting-hud-input">
            <input type="text" id="hudInput" placeholder="Add item or @mention..." autocomplete="off" spellcheck="false"
              onkeydown="if(event.key==='Enter')app.submitHUDItem()">
            <button onclick="app.submitHUDItem()">Add</button>
          </div>

          <div class="meeting-hud-agents" id="hudAgentToggles">
            <!-- Agent toggles populated by JS -->
          </div>
        </div>

        <!-- Session: Setup Panel (Host or Join) -->
        <div class="session-setup" id="sessionSetup">
          <div class="session-setup-title">Start a Dual Recording Session</div>
          <div class="session-setup-subtitle">Record with another person -- each side captures at full quality</div>
          <div class="session-actions">
            <div class="session-action-card" onclick="app.sessionHost()">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                <polygon points="23 7 16 12 23 17 23 7"/>
                <rect x="1" y="5" width="15" height="14" rx="2" ry="2"/>
              </svg>
              <span class="card-title">Host Session</span>
              <span class="card-desc">Create a room and invite someone</span>
            </div>
            <div class="session-action-card" onclick="app.sessionShowJoin()">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                <path d="M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4"/>
                <polyline points="10 17 15 12 10 7"/>
                <line x1="15" y1="12" x2="3" y2="12"/>
              </svg>
              <span class="card-title">Join Session</span>
              <span class="card-desc">Enter a code to connect</span>
            </div>
          </div>
        </div>

        <!-- Session: Host Waiting -->
        <div class="session-host-waiting" id="sessionHostWaiting">
          <div class="session-setup-title">Share this info with the guest</div>
          <div class="session-code-display" id="sessionCodeDisplay" onclick="app.copySessionCode()">
            ---
            <span class="copy-hint">Click to copy</span>
          </div>
          <div class="session-host-address" id="sessionHostAddress" style="font-size: 13px; color: var(--text-secondary); margin-top: -8px; font-family: var(--font-mono, monospace); letter-spacing: 0.5px; cursor: pointer;" onclick="app.copyHostAddress()" title="Click to copy address">---</div>
          <div class="waiting-text">
            <div class="waiting-dot"></div>
            Waiting for guest to join...
          </div>
          <div class="session-status" id="hostSessionStatus"></div>
          <button class="session-back-btn" onclick="app.sessionCancel()">Cancel</button>
        </div>

        <!-- Session: Join Panel -->
        <div class="session-join-panel" id="sessionJoinPanel">
          <div class="session-setup-title">Join a Session</div>
          <div class="session-setup-subtitle">Enter the host's address and code word</div>
          <div class="join-input-row" style="flex-direction: column; gap: 8px;">
            <input type="text" class="join-code-input" id="joinHostInput" placeholder="Host address (e.g. 192.168.1.5:48150)" autocomplete="off" spellcheck="false" style="font-size: 13px; font-family: var(--font-mono, monospace);">
            <div style="display: flex; gap: 8px;">
              <input type="text" class="join-code-input" id="joinCodeInput" placeholder="Code word (e.g. falcon)" autocomplete="off" spellcheck="false" style="flex: 1;">
              <button class="join-connect-btn" id="joinConnectBtn" onclick="app.sessionJoin()">Connect</button>
            </div>
          </div>
          <div class="session-status" id="joinSessionStatus"></div>
          <button class="session-back-btn" onclick="app.sessionShowSetup()">Back</button>
        </div>

        <!-- Session: Connected Badge -->
        <div class="session-connected-badge" id="sessionConnectedBadge">
          <div class="session-connected-dot"></div>
          P2P Connected
        </div>

        <!-- Session: Remote Video (used in split-view) -->
        <video id="remoteVideo" style="display: none;" autoplay playsinline></video>
      </div>
    </div>

    <!-- Bottom Panel -->
    <div class="bottom-panel">

      <!-- Mode Tabs -->
      <div class="mode-tabs">
        <button class="mode-tab active" data-mode="camera" onclick="app.switchMode('camera')">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
            <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/>
            <circle cx="12" cy="13" r="4"/>
          </svg>
          Camera
        </button>
        <button class="mode-tab" data-mode="screen" onclick="app.switchMode('screen')">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
            <rect x="2" y="3" width="20" height="14" rx="2" ry="2"/>
            <line x1="8" y1="21" x2="16" y2="21"/>
            <line x1="12" y1="17" x2="12" y2="21"/>
          </svg>
          Screen
        </button>
        <button class="mode-tab" data-mode="both" onclick="app.switchMode('both')">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
            <rect x="2" y="3" width="20" height="14" rx="2" ry="2"/>
            <line x1="8" y1="21" x2="16" y2="21"/>
            <line x1="12" y1="17" x2="12" y2="21"/>
            <circle cx="18" cy="14" r="4" fill="none"/>
          </svg>
          Screen + Camera
        </button>
        <button class="mode-tab" data-mode="session" onclick="app.switchMode('session')">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
            <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/>
            <circle cx="9" cy="7" r="4"/>
            <path d="M23 21v-2a4 4 0 0 0-3-3.87"/>
            <path d="M16 3.13a4 4 0 0 1 0 7.75"/>
          </svg>
          Session
        </button>
      </div>

      <!-- Space Selector (always visible) -->
      <div class="space-selector-bar">
        <div class="space-selector-label">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="8"/>
          </svg>
          Save to
        </div>
        <select class="source-select" id="targetSpace" onchange="app.onTargetSpaceChange()">
          <option value="">Select a space...</option>
        </select>
      </div>

      <!-- Controls Bar -->
      <div class="controls-bar" id="controlsBar">
        <div class="source-compact">
          <div class="source-compact-item" id="cameraSourceWrapper">
            <div class="source-compact-label">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/>
                <circle cx="12" cy="13" r="4"/>
              </svg>
              Camera
            </div>
            <select class="source-select" id="videoSource" onchange="app.changeVideoSource()">
              <option value="">Select camera...</option>
            </select>
          </div>
          <div class="source-compact-item">
            <div class="source-compact-label">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/>
                <path d="M19 10v2a7 7 0 0 1-14 0v-2"/>
                <line x1="12" y1="19" x2="12" y2="23"/>
                <line x1="8" y1="23" x2="16" y2="23"/>
              </svg>
              Mic
            </div>
            <select class="source-select" id="audioSource" onchange="app.changeAudioSource()">
              <option value="">No microphone</option>
            </select>
          </div>
        </div>

        <div class="record-wrapper" style="position: relative;">
          <button class="record-btn" id="recordBtn" onclick="app.toggleRecording()">
            <div class="record-btn-inner"></div>
          </button>
          <button class="pause-btn" id="pauseBtn" onclick="app.togglePause()" title="Pause recording">
            <svg viewBox="0 0 24 24" fill="currentColor" stroke="none" id="pauseIcon">
              <rect x="6" y="4" width="4" height="16" rx="1"/>
              <rect x="14" y="4" width="4" height="16" rx="1"/>
            </svg>
          </button>
          <span class="record-label" id="recordLabel">REC</span>
        </div>

        <button class="caption-toggle" id="captionToggle" onclick="app.toggleCaptions()" title="Toggle live captions (C)">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
            <rect x="2" y="4" width="20" height="16" rx="2"/>
            <text x="12" y="15" text-anchor="middle" font-size="8" font-weight="700" fill="currentColor" stroke="none">CC</text>
          </svg>
        </button>

        <button class="ctrl-btn" id="settingsToggle" onclick="app.toggleSettings()" title="Settings">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
            <circle cx="12" cy="12" r="3"/>
            <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06A1.65 1.65 0 0 0 4.68 15a1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06A1.65 1.65 0 0 0 9 4.68a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06A1.65 1.65 0 0 0 19.4 9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/>
          </svg>
        </button>

        <button class="end-session-btn" id="endSessionBtn" onclick="app.sessionEnd()">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
            <path d="M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4"/>
            <polyline points="10 17 15 12 10 7"/>
            <line x1="15" y1="12" x2="3" y2="12"/>
          </svg>
          End Session
        </button>
      </div>

      <!-- Review Controls -->
      <div class="review-bar" id="reviewControls">
        <button class="review-btn danger" onclick="app.discardRecording()">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
            <path d="M3 6h18M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
          </svg>
          Discard
        </button>
        <button class="review-btn secondary" onclick="app.recordAgain()">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
            <path d="M1 4v6h6"/>
            <path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"/>
          </svg>
          Record Again
        </button>
        <button class="review-btn primary" onclick="app.showSaveDialog()">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
            <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/>
            <polyline points="17 21 17 13 7 13 7 21"/>
            <polyline points="7 3 7 8 15 8"/>
          </svg>
          Save to Space
        </button>
      </div>

      <!-- Settings Panel (expandable) -->
      <div class="settings-panel" id="settingsPanel">
        <div class="settings-inner">

          <!-- Hidden video source (used by mode switching) -->
          <div class="setting-row" id="videoSourceRow" style="display: none;">
            <div class="setting-group">
              <div class="setting-label">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                  <polygon points="23 7 16 12 23 17 23 7"/>
                  <rect x="1" y="5" width="15" height="14" rx="2" ry="2"/>
                </svg>
                Video Source
              </div>
              <select class="source-select" id="videoSourceHidden">
                <option value="">Select source...</option>
              </select>
            </div>
          </div>

          <!-- Audio Mixing Panel -->
          <div class="audio-mix-panel" id="audioMixControls">
            <div class="mix-title">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                <line x1="4" y1="21" x2="4" y2="14"/>
                <line x1="4" y1="10" x2="4" y2="3"/>
                <line x1="12" y1="21" x2="12" y2="12"/>
                <line x1="12" y1="8" x2="12" y2="3"/>
                <line x1="20" y1="21" x2="20" y2="16"/>
                <line x1="20" y1="12" x2="20" y2="3"/>
                <line x1="1" y1="14" x2="7" y2="14"/>
                <line x1="9" y1="8" x2="15" y2="8"/>
                <line x1="17" y1="16" x2="23" y2="16"/>
              </svg>
              Audio Mixer
            </div>
            <div class="volume-sliders">
              <div class="volume-slider-group">
                <label class="volume-label">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                    <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/>
                    <path d="M19 10v2a7 7 0 0 1-14 0v-2"/>
                    <line x1="12" y1="19" x2="12" y2="23"/>
                    <line x1="8" y1="23" x2="16" y2="23"/>
                  </svg>
                  Mic
                  <span class="volume-value" id="micVolumeValue">100%</span>
                </label>
                <input type="range" class="volume-slider" id="micVolume" min="0" max="150" value="100" oninput="app.updateMicVolume(this.value)">
              </div>
              <div class="volume-slider-group">
                <label class="volume-label">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                    <rect x="2" y="3" width="20" height="14" rx="2" ry="2"/>
                    <line x1="8" y1="21" x2="16" y2="21"/>
                    <line x1="12" y1="17" x2="12" y2="21"/>
                  </svg>
                  Desktop
                  <span class="audio-status-badge" id="desktopAudioStatus" title="System audio capture not available on this platform">Unavailable</span>
                  <span class="volume-value" id="desktopVolumeValue">100%</span>
                </label>
                <input type="range" class="volume-slider" id="desktopVolume" min="0" max="150" value="100" oninput="app.updateDesktopVolume(this.value)">
              </div>
              <div class="volume-slider-group">
                <label class="volume-label">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                    <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/>
                    <path d="M19 10v2a7 7 0 0 1-14 0v-2"/>
                  </svg>
                  External 1
                  <span class="volume-value" id="externalMicVolumeValue">100%</span>
                </label>
                <select class="volume-source-select" id="externalMicSource" onchange="app.updateExternalMicSource(1)">
                  <option value="">None (disabled)</option>
                </select>
                <input type="range" class="volume-slider" id="externalMicVolume" min="0" max="150" value="100" oninput="app.updateExternalMicVolume(1, this.value)">
              </div>
              <div class="volume-slider-group">
                <label class="volume-label">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                    <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/>
                    <path d="M19 10v2a7 7 0 0 1-14 0v-2"/>
                  </svg>
                  External 2
                  <span class="volume-value" id="externalMic2VolumeValue">100%</span>
                </label>
                <select class="volume-source-select" id="externalMic2Source" onchange="app.updateExternalMicSource(2)">
                  <option value="">None (disabled)</option>
                </select>
                <input type="range" class="volume-slider" id="externalMic2Volume" min="0" max="150" value="100" oninput="app.updateExternalMicVolume(2, this.value)">
              </div>
            </div>
          </div>

          <!-- Instructions Panel -->
          <div class="instructions-panel" id="instructionsPanel">
            <div class="instructions-header">
              <span class="instructions-title">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                  <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                  <polyline points="14 2 14 8 20 8"/>
                  <line x1="16" y1="13" x2="8" y2="13"/>
                  <line x1="16" y1="17" x2="8" y2="17"/>
                  <polyline points="10 9 9 9 8 9"/>
                </svg>
                Recording Instructions
              </span>
            </div>
            <div class="instructions-content" id="instructionsContent">
              No specific instructions. Record freely.
            </div>
          </div>

        </div>
      </div>

      <!-- Keyboard Shortcuts Bar -->
      <div class="shortcuts-bar">
        <div class="shortcut-item"><kbd>Space</kbd> Record</div>
        <div class="shortcut-item"><kbd>Esc</kbd> Stop</div>
        <div class="shortcut-item"><kbd>S</kbd> Save</div>
        <div class="shortcut-item"><kbd>,</kbd> Settings</div>
      </div>

    </div>
  </div>

  <!-- Save Dialog -->
  <div class="save-dialog" id="saveDialog">
    <div class="save-dialog-content">
      <div class="save-dialog-title">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
          <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/>
          <polyline points="17 21 17 13 7 13 7 21"/>
          <polyline points="7 3 7 8 15 8"/>
        </svg>
        Save Recording
      </div>

      <div class="save-form-group">
        <label class="save-form-label">Filename</label>
        <input type="text" class="save-form-input" id="saveFilename" placeholder="recording.webm">
      </div>

      <div class="save-form-group">
        <label class="save-form-label">Save to Space</label>
        <select class="save-form-input" id="saveSpace">
          <option value="">Select a space...</option>
        </select>
      </div>

      <div class="save-form-group">
        <label class="save-form-label">Project (optional)</label>
        <select class="save-form-input" id="saveProject">
          <option value="">No project - save to space root</option>
        </select>
      </div>

      <div class="save-dialog-actions">
        <button class="review-btn secondary" onclick="app.hideSaveDialog()">Cancel</button>
        <button class="review-btn primary" onclick="app.saveRecording()">Save</button>
      </div>
    </div>
  </div>

  <!-- Screen Source Picker -->
  <div class="screen-picker" id="screenPicker">
    <div class="screen-picker-content">
      <div class="screen-picker-title">Select Screen or Window</div>
      <div class="screen-picker-subtitle">Choose what you want to capture</div>
      <div class="screen-picker-grid" id="screenSourcesGrid"></div>
      <div class="screen-picker-actions">
        <button class="review-btn secondary" onclick="app.hideScreenPicker()">Cancel</button>
        <button class="review-btn primary" onclick="app.selectScreenSource()">Select</button>
      </div>
    </div>
  </div>

  <!-- Status Message -->
  <div class="status-message" id="statusMessage">
    <div class="status-dot"></div>
    <span id="statusText"></span>
  </div>

  <script>
    const app = {
      // State
      stream: null,
      mediaRecorder: null,
      recordedChunks: [],
      recordedBlob: null,
      isRecording: false,
      recordingStartTime: null,
      lastRecordingDuration: null,
      reviewBlobUrl: null,
      durationInterval: null,
      instructions: null,
      screenSources: [],
      selectedScreenSourceId: null,
      currentMode: 'camera', // 'camera' | 'screen' | 'both'
      settingsOpen: false,
      countdownActive: false,
      audioAnalyser: null,
      audioMeterFrame: null,

      // Meeting HUD state
      hudVisible: false,
      hudItems: [],        // Array of { id, type, text, tags, deadline, addedBy, timestamp, agentId }
      hudAgentStates: {},  // agentId -> enabled
      hudNameRoster: [],   // Auto-built list of known names for @mention

      // DOM Elements
      elements: {},

      // Initialize
      async init() {
        console.log('[Recorder] Initializing...');

        this.cacheElements();
        await this.loadDevices();
        await this.loadSpaces();
        this.setupEventListeners();
        this.setupKeyboardShortcuts();

        // Check for instructions from editor
        if (window.recorder) {
          const instructions = await window.recorder.getInstructions();
          if (instructions) {
            this.setInstructions(instructions);
          }

          window.recorder.onInstructionsReceived((instructions) => {
            this.setInstructions(instructions);
          });

          // Listen for meeting monitor alerts
          if (window.recorder.onMonitorAlert) {
            window.recorder.onMonitorAlert((alert) => {
              this.showMonitorAlert(alert);
            });
          }
        }

        // Initialize Meeting HUD
        this.initMeetingHUD();

        console.log('[Recorder] Ready');
      },

      // ==================== MEETING HUD ====================

      TAG_COLORS: 10, // Number of colors in palette

      _hashName(name) {
        let h = 0;
        for (let i = 0; i < name.length; i++) h = ((h << 5) - h + name.charCodeAt(i)) | 0;
        return Math.abs(h) % this.TAG_COLORS;
      },

      async initMeetingHUD() {
        if (!window.agentHUD) {
          console.log('[MeetingHUD] agentHUD API not available');
          return;
        }

        // Load agent toggles for meeting space
        try {
          const agents = await window.agentHUD.getAgentsInSpace('meeting-agents');
          if (agents && agents.length > 0) {
            agents.forEach(a => { this.hudAgentStates[a.id] = a.enabled !== false; });
            this._renderAgentToggles(agents);
          }
        } catch (e) {
          console.warn('[MeetingHUD] Could not load agents:', e);
        }

        // Listen for HUD API events
        window.agentHUD.onResult((result) => {
          if (result.data && (result.data.type === 'action-item' || result.data.type === 'decision' || result.data.type === 'note' || result.data.type === 'bookmark')) {
            this._addHUDItem({
              type: result.data.type,
              text: result.data.text,
              tags: result.data.tags || [],
              deadline: result.data.deadline || null,
              agentId: result.agentId || null,
            });
          }
        });

        console.log('[MeetingHUD] Initialized');
      },

      toggleMeetingHUD() {
        this.hudVisible = !this.hudVisible;
        this.elements.meetingHUD.classList.toggle('hidden', !this.hudVisible);
        this.elements.hudToggleBtn.classList.toggle('active', this.hudVisible);

        // Move toggle button when HUD is open
        if (this.hudVisible) {
          this.elements.hudToggleBtn.style.right = '296px';
        } else {
          this.elements.hudToggleBtn.style.right = '8px';
        }
      },

      async submitHUDItem() {
        const input = this.elements.hudInput;
        const text = input.value.trim();
        if (!text) return;

        input.value = '';

        if (window.agentHUD) {
          // Submit via centralized HUD API to meeting-agents space
          try {
            await window.agentHUD.submitTask(text, {
              spaceId: 'meeting-agents',
              toolId: 'recorder',
              metadata: { context: 'meeting-hud' },
            });
          } catch (e) {
            console.error('[MeetingHUD] Submit error:', e);
            // Fallback: add as a local note
            this._addHUDItem({ type: 'note', text, tags: ['Me'], deadline: null });
          }
        } else {
          // No agentHUD, add directly
          this._addHUDItem({ type: 'note', text, tags: ['Me'], deadline: null });
        }
      },

      _addHUDItem(item) {
        const fullItem = {
          id: 'hud-' + Date.now() + '-' + Math.random().toString(36).slice(2, 6),
          type: item.type || 'note',
          text: item.text || '',
          tags: item.tags || [],
          deadline: item.deadline || null,
          addedBy: item.addedBy || 'Me',
          timestamp: item.timestamp || Date.now(),
          agentId: item.agentId || null,
        };

        this.hudItems.push(fullItem);

        // Update name roster
        for (const tag of fullItem.tags) {
          if (tag !== 'Me' && tag !== 'Everyone' && !this.hudNameRoster.includes(tag)) {
            this.hudNameRoster.push(tag);
          }
        }

        this._renderHUDItems();

        // If HUD is not visible, open it automatically on first item
        if (!this.hudVisible && this.hudItems.length === 1) {
          this.toggleMeetingHUD();
        }

        // P2P sync: broadcast to peer
        this._syncHUDItemToPeer('add', fullItem);

        // Add to centralized HUD items store
        if (window.agentHUD) {
          window.agentHUD.addItem('recorder', fullItem).catch(() => {});
        }
      },

      _removeHUDItem(itemId) {
        this.hudItems = this.hudItems.filter(i => i.id !== itemId);
        this._renderHUDItems();
        this._syncHUDItemToPeer('remove', { id: itemId });
        if (window.agentHUD) {
          window.agentHUD.removeItem('recorder', itemId).catch(() => {});
        }
      },

      _renderHUDItems() {
        const list = this.elements.hudItemList;
        const empty = this.elements.hudEmptyState;
        const count = this.elements.hudItemCount;

        // Update count
        count.textContent = `${this.hudItems.length} item${this.hudItems.length !== 1 ? 's' : ''}`;

        // Show/hide empty state
        if (this.hudItems.length === 0) {
          empty.style.display = 'flex';
          // Clear all items except empty state
          Array.from(list.children).forEach(c => {
            if (c !== empty) c.remove();
          });
          return;
        }
        empty.style.display = 'none';

        // Remove existing item elements (keep empty state)
        Array.from(list.children).forEach(c => {
          if (c !== empty) c.remove();
        });

        // Render items (newest first)
        const sorted = [...this.hudItems].reverse();
        for (const item of sorted) {
          const el = this._createHUDItemElement(item);
          list.appendChild(el);
        }
      },

      _createHUDItemElement(item) {
        const div = document.createElement('div');
        div.className = 'hud-item';
        div.dataset.id = item.id;

        // Time
        const elapsed = item.timestamp - (this.recordingStartTime || Date.now());
        const mins = Math.floor(Math.abs(elapsed) / 60000);
        const secs = Math.floor((Math.abs(elapsed) % 60000) / 1000);
        const timeStr = `${mins}:${secs.toString().padStart(2, '0')}`;

        // Type badge
        const typeClass = item.type.replace(/\s+/g, '-');
        const typeLabel = { 'action-item': 'AI', 'decision': 'DC', 'note': 'NT', 'bookmark': 'BK' }[item.type] || 'NT';

        // Tags HTML
        const tagsHtml = (item.tags || []).map(tag => {
          if (tag === 'Everyone') {
            return `<span class="hud-tag-pill everyone">${tag}</span>`;
          }
          const colorIdx = tag === 'Me' ? 0 : this._hashName(tag);
          return `<span class="hud-tag-pill hud-tag-${colorIdx}">${tag}</span>`;
        }).join('');

        // Deadline
        const deadlineHtml = item.deadline ? `<div class="hud-item-deadline">By ${item.deadline}</div>` : '';

        div.innerHTML = `
          <div class="hud-item-top">
            <span class="hud-type-badge ${typeClass}">${typeLabel}</span>
            <div class="hud-item-tags">${tagsHtml}</div>
            <span class="hud-item-time">${timeStr}</span>
          </div>
          <div class="hud-item-text">${this._escapeHtml(item.text)}</div>
          ${deadlineHtml}
          <button class="hud-item-remove" onclick="app._removeHUDItem('${item.id}')" title="Remove">&times;</button>
        `;

        return div;
      },

      _escapeHtml(text) {
        const d = document.createElement('div');
        d.textContent = text;
        return d.innerHTML;
      },

      _renderAgentToggles(agents) {
        const container = this.elements.hudAgentToggles;
        container.innerHTML = '';
        for (const agent of agents) {
          const btn = document.createElement('button');
          btn.className = 'hud-agent-toggle' + (this.hudAgentStates[agent.id] !== false ? ' active' : '');
          btn.textContent = agent.id.replace(/-agent$/, '').replace(/-/g, ' ');
          btn.title = agent.name || agent.id;
          btn.onclick = () => {
            const newState = !this.hudAgentStates[agent.id];
            this.hudAgentStates[agent.id] = newState;
            btn.classList.toggle('active', newState);
            if (window.agentHUD) {
              window.agentHUD.setAgentEnabled('meeting-agents', agent.id, newState).catch(() => {});
            }
          };
          container.appendChild(btn);
        }
      },

      // P2P HUD Sync
      _syncHUDItemToPeer(action, data) {
        if (!this.peerConnection || !this.dataChannel || this.dataChannel.readyState !== 'open') return;
        try {
          if (action === 'add') {
            this.dataChannel.send(JSON.stringify({ type: 'hud-item-add', item: data }));
          } else if (action === 'remove') {
            this.dataChannel.send(JSON.stringify({ type: 'hud-item-remove', id: data.id }));
          }
        } catch (e) {
          console.warn('[MeetingHUD] P2P sync error:', e);
        }
      },

      _sendHUDFullSync() {
        if (!this.dataChannel || this.dataChannel.readyState !== 'open') return;
        try {
          this.dataChannel.send(JSON.stringify({ type: 'hud-sync-full', items: this.hudItems }));
        } catch (e) {
          console.warn('[MeetingHUD] Full sync error:', e);
        }
      },

      _handleHUDSyncMessage(msg) {
        if (msg.type === 'hud-item-add' && msg.item) {
          // Avoid duplicates
          if (!this.hudItems.find(i => i.id === msg.item.id)) {
            this.hudItems.push(msg.item);
            this._renderHUDItems();
            if (!this.hudVisible && this.hudItems.length === 1) {
              this.toggleMeetingHUD();
            }
          }
        } else if (msg.type === 'hud-item-remove' && msg.id) {
          this.hudItems = this.hudItems.filter(i => i.id !== msg.id);
          this._renderHUDItems();
        } else if (msg.type === 'hud-sync-full' && Array.isArray(msg.items)) {
          this.hudItems = msg.items;
          this._renderHUDItems();
        }
      },

      cacheElements() {
        this.elements = {
          previewContainer: document.getElementById('previewContainer'),
          previewVideo: document.getElementById('previewVideo'),
          reviewVideo: document.getElementById('reviewVideo'),
          previewPlaceholder: document.getElementById('previewPlaceholder'),
          permissionOverlay: document.getElementById('permissionOverlay'),
          recordingIndicator: document.getElementById('recordingIndicator'),
          durationDisplay: document.getElementById('durationDisplay'),
          currentDuration: document.getElementById('currentDuration'),
          targetDuration: document.getElementById('targetDuration'),
          countdownOverlay: document.getElementById('countdownOverlay'),
          countdownNumber: document.getElementById('countdownNumber'),
          audioMeter: document.getElementById('audioMeter'),
          instructionsContent: document.getElementById('instructionsContent'),
          videoSource: document.getElementById('videoSource'),
          audioSource: document.getElementById('audioSource'),
          audioMixControls: document.getElementById('audioMixControls'),
          micVolume: document.getElementById('micVolume'),
          micVolumeValue: document.getElementById('micVolumeValue'),
          desktopVolume: document.getElementById('desktopVolume'),
          desktopVolumeValue: document.getElementById('desktopVolumeValue'),
          externalMicSource: document.getElementById('externalMicSource'),
          externalMicVolume: document.getElementById('externalMicVolume'),
          externalMicVolumeValue: document.getElementById('externalMicVolumeValue'),
          externalMic2Source: document.getElementById('externalMic2Source'),
          externalMic2Volume: document.getElementById('externalMic2Volume'),
          externalMic2VolumeValue: document.getElementById('externalMic2VolumeValue'),
          controlsBar: document.getElementById('controlsBar'),
          reviewControls: document.getElementById('reviewControls'),
          recordBtn: document.getElementById('recordBtn'),
          recordLabel: document.getElementById('recordLabel'),
          pauseBtn: document.getElementById('pauseBtn'),
          pauseIcon: document.getElementById('pauseIcon'),
          pausedOverlay: document.getElementById('pausedOverlay'),
          captionOverlay: document.getElementById('captionOverlay'),
          captionText: document.getElementById('captionText'),
          captionToggle: document.getElementById('captionToggle'),
          transcriptionStatus: document.getElementById('transcriptionStatus'),
          transcriptionStatusText: document.getElementById('transcriptionStatusText'),
          monitorAlertContainer: document.getElementById('monitorAlertContainer'),
          settingsPanel: document.getElementById('settingsPanel'),
          settingsToggle: document.getElementById('settingsToggle'),
          cameraSourceWrapper: document.getElementById('cameraSourceWrapper'),
          saveDialog: document.getElementById('saveDialog'),
          saveFilename: document.getElementById('saveFilename'),
          saveSpace: document.getElementById('saveSpace'),
          saveProject: document.getElementById('saveProject'),
          statusMessage: document.getElementById('statusMessage'),
          statusText: document.getElementById('statusText'),
          screenPicker: document.getElementById('screenPicker'),
          screenSourcesGrid: document.getElementById('screenSourcesGrid'),
          targetSpace: document.getElementById('targetSpace'),
          // Meeting HUD
          meetingHUD: document.getElementById('meetingHUD'),
          hudToggleBtn: document.getElementById('hudToggleBtn'),
          hudItemList: document.getElementById('hudItemList'),
          hudItemCount: document.getElementById('hudItemCount'),
          hudEmptyState: document.getElementById('hudEmptyState'),
          hudInput: document.getElementById('hudInput'),
          hudAgentToggles: document.getElementById('hudAgentToggles'),
        };
      },

      setupEventListeners() {
        // Save dialog space change -> load projects + sync back to main selector
        this.elements.saveSpace.addEventListener('change', async () => {
          const spaceId = this.elements.saveSpace.value;
          
          // Sync back to main target selector
          if (spaceId && this.elements.targetSpace.value !== spaceId) {
            this.elements.targetSpace.value = spaceId;
            this.updateTargetSpaceHighlight();
          }
          
          // Load projects for the selected space
          if (spaceId && window.recorder) {
            const result = await window.recorder.getProjectFolder(spaceId);
            this.elements.saveProject.innerHTML = '<option value="">No project - save to space root</option>';
            if (result.success && result.projects) {
              result.projects.forEach(p => {
                const option = document.createElement('option');
                option.value = p.id;
                option.textContent = p.name;
                this.elements.saveProject.appendChild(option);
              });
            }
          }
        });
      },

      // Keyboard shortcuts
      setupKeyboardShortcuts() {
        document.addEventListener('keydown', (e) => {
          // Enter key in join code input -> connect
          if (e.code === 'Enter' && e.target.id === 'joinCodeInput') {
            e.preventDefault();
            this.sessionJoin();
            return;
          }

          // Don't trigger shortcuts when typing in inputs
          if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') return;

          switch (e.code) {
            case 'Space':
              e.preventDefault();
              this.toggleRecording();
              break;
            case 'KeyP':
              if (this.isRecording) {
                e.preventDefault();
                this.togglePause();
              }
              break;
            case 'Escape':
              if (this.isRecording) {
                this.stopRecording();
              } else if (this.elements.saveDialog.classList.contains('active')) {
                this.hideSaveDialog();
              } else if (this.elements.screenPicker.classList.contains('active')) {
                this.hideScreenPicker();
              }
              break;
            case 'KeyS':
              if (this.recordedBlob && !this.isRecording) {
                this.showSaveDialog();
              }
              break;
            case 'KeyC':
              e.preventDefault();
              this.toggleCaptions();
              break;
            case 'Comma':
              this.toggleSettings();
              break;
          }
        });
      },

      // Mode switching
      switchMode(mode) {
        if (mode === this.currentMode) return;

        // If leaving session mode, clean up
        if (this.currentMode === 'session' && mode !== 'session') {
          this.sessionHideAllPanels();
        }

        this.currentMode = mode;

        // Update tabs
        document.querySelectorAll('.mode-tab').forEach(tab => {
          tab.classList.toggle('active', tab.dataset.mode === mode);
        });

        // Session mode -- special handling
        if (mode === 'session') {
          this.elements.previewPlaceholder.style.display = 'none';
          this.elements.audioMixControls.classList.remove('visible');
          this.sessionShowSetup();
          return;
        }

        // Hide session panels when switching away
        this.sessionHideAllPanels();

        // Update source visibility
        const cameraWrapper = this.elements.cameraSourceWrapper;
        if (mode === 'screen') {
          cameraWrapper.style.display = 'none';
        } else {
          cameraWrapper.style.display = 'block';
        }

        // Stop existing streams
        if (this.stream) {
          this.stream.getTracks().forEach(t => t.stop());
          this.stream = null;
        }
        this.cleanupPipResources();

        // Handle mode
        if (mode === 'camera') {
          // Re-select camera
          const camId = this.elements.videoSource.value;
          if (camId && !camId.startsWith('screen')) {
            this.changeVideoSource();
          } else {
            this.elements.previewVideo.srcObject = null;
            this.elements.previewPlaceholder.style.display = 'flex';
          }
          this.elements.audioMixControls.classList.remove('visible');
        } else if (mode === 'screen') {
          this.showScreenPicker(false);
        } else if (mode === 'both') {
          this.showScreenPicker(true);
        }
      },

      // Toggle settings panel
      toggleSettings() {
        this.settingsOpen = !this.settingsOpen;
        this.elements.settingsPanel.classList.toggle('open', this.settingsOpen);
        this.elements.settingsToggle.classList.toggle('active', this.settingsOpen);
      },

      // Load available media devices
      async loadDevices() {
        try {
          let hasCamera = false;
          try {
            const tempStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
            tempStream.getTracks().forEach(t => t.stop());
            hasCamera = true;
          } catch (e) {
            try {
              const audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
              audioStream.getTracks().forEach(t => t.stop());
            } catch (e2) {
              console.warn('[Recorder] No camera or mic available');
            }
          }

          const devices = await navigator.mediaDevices.enumerateDevices();

          // Video devices
          const videoDevices = devices.filter(d => d.kind === 'videoinput');
          this.elements.videoSource.innerHTML = '<option value="">Select camera...</option>';

          videoDevices.forEach((device, i) => {
            const option = document.createElement('option');
            option.value = device.deviceId;
            option.textContent = device.label || `Camera ${i + 1}`;
            this.elements.videoSource.appendChild(option);
          });

          // Audio devices
          const audioDevices = devices.filter(d => d.kind === 'audioinput');
          this.elements.audioSource.innerHTML = '<option value="">No microphone</option>';
          audioDevices.forEach((device, i) => {
            const option = document.createElement('option');
            option.value = device.deviceId;
            option.textContent = device.label || `Microphone ${i + 1}`;
            this.elements.audioSource.appendChild(option);
          });

          // Auto-select first devices
          if (videoDevices.length > 0) {
            this.elements.videoSource.value = videoDevices[0].deviceId;
            this.changeVideoSource();
          }
          if (audioDevices.length > 0) {
            this.elements.audioSource.value = audioDevices[0].deviceId;
          }

          this.elements.permissionOverlay.classList.add('hidden');
        } catch (error) {
          console.error('[Recorder] Device enumeration error:', error);
          this.elements.permissionOverlay.classList.remove('hidden');
        }
      },

      // Load spaces into both the main target selector and the save dialog
      async loadSpaces() {
        if (!window.recorder) return;

        try {
          const spaces = await window.recorder.getSpaces();
          
          // Populate main target space selector
          this.elements.targetSpace.innerHTML = '<option value="">Select a space...</option>';
          // Populate save dialog selector
          this.elements.saveSpace.innerHTML = '<option value="">Select a space...</option>';

          if (spaces && spaces.length > 0) {
            spaces.forEach(space => {
              // Main selector
              const opt1 = document.createElement('option');
              opt1.value = space.id;
              opt1.textContent = space.name || space.id;
              this.elements.targetSpace.appendChild(opt1);
              
              // Save dialog selector (mirror)
              const opt2 = document.createElement('option');
              opt2.value = space.id;
              opt2.textContent = space.name || space.id;
              this.elements.saveSpace.appendChild(opt2);
            });
          }

          // Show pulse animation if no space selected yet
          this.updateTargetSpaceHighlight();
        } catch (error) {
          console.error('[Recorder] Failed to load spaces:', error);
        }
      },

      // Handle target space selection change
      onTargetSpaceChange() {
        const spaceId = this.elements.targetSpace.value;
        // Sync to save dialog
        this.elements.saveSpace.value = spaceId;
        this.elements.saveSpace.dispatchEvent(new Event('change'));
        // Update highlight
        this.updateTargetSpaceHighlight();
        if (spaceId) {
          console.log('[Recorder] Target space set:', spaceId);
        }
      },

      // Pulse the space selector when unset to prompt the user
      updateTargetSpaceHighlight() {
        if (this.elements.targetSpace.value) {
          this.elements.targetSpace.classList.remove('unset');
        } else {
          this.elements.targetSpace.classList.add('unset');
        }
      },

      // Request permissions
      async requestPermissions() {
        if (window.recorder) {
          await window.recorder.requestPermissions('camera');
          await window.recorder.requestPermissions('microphone');
        }
        await this.loadDevices();
      },

      // Change video source
      async changeVideoSource() {
        const deviceId = this.elements.videoSource.value;
        if (!deviceId) {
          if (this.stream) {
            this.stream.getTracks().forEach(t => t.stop());
            this.stream = null;
          }
          this.elements.previewVideo.srcObject = null;
          this.elements.previewPlaceholder.style.display = 'flex';
          this.elements.audioMixControls.classList.remove('visible');
          this.stopAudioMeter();
          return;
        }

        try {
          if (this.stream) {
            this.stream.getTracks().forEach(t => t.stop());
          }
          this.cleanupPipResources();

          if (deviceId === 'screen') {
            await this.showScreenPicker();
            return;
          } else if (deviceId === 'screen-pip') {
            await this.showScreenPicker(true);
            return;
          } else if (deviceId.startsWith('screen-pip:')) {
            const sourceId = deviceId.replace('screen-pip:', '');
            await this.startScreenPipCapture(sourceId);
          } else if (deviceId.startsWith('screen:')) {
            const sourceId = deviceId.replace('screen:', '');
            await this.startScreenCapture(sourceId);
          } else {
            // Camera
            const videoConstraints = { deviceId: { exact: deviceId } };
            const audioDeviceId = this.elements.audioSource.value;

            this.stream = await navigator.mediaDevices.getUserMedia({
              video: videoConstraints,
              audio: audioDeviceId ? { deviceId: { exact: audioDeviceId } } : true
            });

            this.elements.previewVideo.srcObject = this.stream;
            this.elements.previewPlaceholder.style.display = 'none';
            this.elements.previewVideo.style.display = 'block';
            this.elements.reviewVideo.style.display = 'none';

            // Start audio metering
            this.startAudioMeter(this.stream);
          }

          this.updateAudioMixControlsVisibility();
        } catch (error) {
          console.error('[Recorder] Failed to get media:', error);
          this.showStatus('Failed to access camera: ' + error.message, 'error');
        }
      },

      // Show screen source picker
      async showScreenPicker(pipMode = false) {
        if (!window.recorder || !window.recorder.getScreenSources) {
          this.showStatus('Screen capture not available', 'error');
          return;
        }

        try {
          this.screenSources = await window.recorder.getScreenSources();
          this.pipModeSelection = pipMode;

          if (this.screenSources.length === 0) {
            this.showStatus('No screen sources found. Check screen recording permissions.', 'error');
            return;
          }

          this.elements.screenSourcesGrid.innerHTML = '';
          this.selectedScreenSourceId = null;

          this.screenSources.forEach((source, index) => {
            const item = document.createElement('div');
            item.className = 'screen-source-item';
            item.dataset.sourceId = source.id;
            item.onclick = () => this.selectScreenSourceItem(source.id);

            if (index === 0) {
              item.classList.add('selected');
              this.selectedScreenSourceId = source.id;
            }

            item.innerHTML = `
              <img class="screen-source-thumbnail" src="${source.thumbnail}" alt="${source.name}">
              <div class="screen-source-name">${source.name}</div>
            `;

            this.elements.screenSourcesGrid.appendChild(item);
          });

          this.elements.screenPicker.classList.add('active');
        } catch (error) {
          console.error('[Recorder] Error loading screen sources:', error);
          this.showStatus('Failed to load screen sources: ' + error.message, 'error');
        }
      },

      selectScreenSourceItem(sourceId) {
        this.selectedScreenSourceId = sourceId;
        this.elements.screenSourcesGrid.querySelectorAll('.screen-source-item').forEach(item => {
          item.classList.toggle('selected', item.dataset.sourceId === sourceId);
        });
      },

      hideScreenPicker() {
        this.elements.screenPicker.classList.remove('active');
        this.pipModeSelection = false;
        if (!this.stream) {
          this.elements.videoSource.value = '';
        }
      },

      async selectScreenSource() {
        if (!this.selectedScreenSourceId) {
          this.showStatus('Please select a screen or window', 'error');
          return;
        }

        this.elements.screenPicker.classList.remove('active');

        if (this.pipModeSelection) {
          await this.startScreenPipCapture(this.selectedScreenSourceId);
        } else {
          await this.startScreenCapture(this.selectedScreenSourceId);
        }
      },

      // Get system audio loopback stream (macOS 12.3+, Windows, Linux  no drivers needed)
      // Returns an audio-only MediaStream or null if unavailable
      async getLoopbackAudioStream() {
        try {
          // Enable the loopback handler in main process
          await window.recorder.enableLoopbackAudio();

          // getDisplayMedia requires video: true, but we only want audio
          const loopbackStream = await navigator.mediaDevices.getDisplayMedia({
            video: true,
            audio: true,
          });

          // Stop and remove the video tracks we don't need
          const videoTracks = loopbackStream.getVideoTracks();
          videoTracks.forEach(track => {
            track.stop();
            loopbackStream.removeTrack(track);
          });

          // Restore normal getDisplayMedia behavior
          await window.recorder.disableLoopbackAudio();

          const audioTracks = loopbackStream.getAudioTracks();
          if (audioTracks.length > 0) {
            console.log('[Recorder] System audio loopback captured via ScreenCaptureKit');
            return loopbackStream;
          }

          console.log('[Recorder] Loopback stream had no audio tracks');
          return null;
        } catch (error) {
          console.warn('[Recorder] Loopback audio unavailable:', error.message);
          // Make sure we disable even on error
          try { await window.recorder.disableLoopbackAudio(); } catch (e) {}
          return null;
        }
      },

      // Start screen capture (with full desktop + mic audio mixing)
      async startScreenCapture(sourceId) {
        try {
          const audioDeviceId = this.elements.audioSource.value;

          // 1. Get screen video stream
          const screenStream = await navigator.mediaDevices.getUserMedia({
            audio: false,
            video: {
              mandatory: {
                chromeMediaSource: 'desktop',
                chromeMediaSourceId: sourceId
              }
            }
          });

          // 2. Get system audio via native loopback (no drivers needed)
          //    Falls back to legacy chromeMediaSource approach if unavailable
          let loopbackStream = null;
          let hasSystemAudio = false;

          loopbackStream = await this.getLoopbackAudioStream();
          if (loopbackStream) {
            hasSystemAudio = true;
          } else {
            // Fallback: try legacy chromeMediaSource desktop audio (works on Windows)
            // Desktop audio requires paired video capture, so we request both then discard the video
            try {
              const legacyStream = await navigator.mediaDevices.getUserMedia({
                audio: {
                  mandatory: {
                    chromeMediaSource: 'desktop',
                    chromeMediaSourceId: sourceId
                  }
                },
                video: {
                  mandatory: {
                    chromeMediaSource: 'desktop',
                    chromeMediaSourceId: sourceId
                  }
                }
              });
              if (legacyStream.getAudioTracks().length > 0) {
                // Keep only the audio tracks, stop the redundant video tracks
                legacyStream.getVideoTracks().forEach(t => t.stop());
                loopbackStream = new MediaStream(legacyStream.getAudioTracks());
                hasSystemAudio = true;
                console.log('[Recorder] System audio captured via legacy chromeMediaSource');
              } else {
                legacyStream.getTracks().forEach(t => t.stop());
              }
            } catch (legacyError) {
              console.log('[Recorder] Legacy system audio also unavailable:', legacyError.message);
            }
          }

          // Store for cleanup
          this.loopbackStream = loopbackStream;
          this.systemAudioActive = hasSystemAudio;

          // 3. Get mic stream separately
          let micStream = null;
          if (audioDeviceId) {
            try {
              micStream = await navigator.mediaDevices.getUserMedia({
                audio: { deviceId: { exact: audioDeviceId } },
                video: false
              });
            } catch (micError) {
              console.warn('[Recorder] Mic not available:', micError.message);
            }
          }

          // 4. Mix audio via AudioContext (desktop + mic + external mics)
          const systemAudioTracks = loopbackStream ? loopbackStream.getAudioTracks() : [];
          const micAudioTracks = micStream ? micStream.getAudioTracks() : [];
          let mixedAudioTrack = null;

          if (systemAudioTracks.length > 0 || micAudioTracks.length > 0) {
            try {
              const audioContext = new AudioContext();
              const destination = audioContext.createMediaStreamDestination();

              const micVolumeLevel = this.micVolumeLevel !== undefined ? this.micVolumeLevel : 1.0;
              const desktopVolumeLevel = this.desktopVolumeLevel !== undefined ? this.desktopVolumeLevel : 1.0;

              if (micAudioTracks.length > 0) {
                const micSource = audioContext.createMediaStreamSource(new MediaStream([micAudioTracks[0]]));
                const micGain = audioContext.createGain();
                micGain.gain.value = micVolumeLevel;
                micSource.connect(micGain);
                micGain.connect(destination);
                this.pipMicGain = micGain;
                console.log('[Recorder] Mic added to mix at volume:', micVolumeLevel);
              }

              if (systemAudioTracks.length > 0) {
                const systemSource = audioContext.createMediaStreamSource(new MediaStream([systemAudioTracks[0]]));
                const desktopGain = audioContext.createGain();
                desktopGain.gain.value = desktopVolumeLevel;
                systemSource.connect(desktopGain);
                desktopGain.connect(destination);
                this.pipDesktopGain = desktopGain;
                console.log('[Recorder] Desktop audio added to mix at volume:', desktopVolumeLevel);
              }

              this.pipAudioContext = audioContext;
              this.pipAudioDestination = destination;

              // External mic 1
              const extMic1Id = this.elements.externalMicSource.value;
              if (extMic1Id) {
                try {
                  this.externalMicStream = await navigator.mediaDevices.getUserMedia({
                    audio: { deviceId: { exact: extMic1Id } }, video: false
                  });
                  const src = audioContext.createMediaStreamSource(this.externalMicStream);
                  const gain = audioContext.createGain();
                  gain.gain.value = this.externalMicVolumeLevel !== undefined ? this.externalMicVolumeLevel : 1.0;
                  src.connect(gain);
                  gain.connect(destination);
                  this.pipExternalMicGain = gain;
                } catch (e) { console.error('[Recorder] External mic 1 failed:', e); }
              }

              // External mic 2
              const extMic2Id = this.elements.externalMic2Source.value;
              if (extMic2Id) {
                try {
                  this.externalMic2Stream = await navigator.mediaDevices.getUserMedia({
                    audio: { deviceId: { exact: extMic2Id } }, video: false
                  });
                  const src = audioContext.createMediaStreamSource(this.externalMic2Stream);
                  const gain = audioContext.createGain();
                  gain.gain.value = this.externalMic2VolumeLevel !== undefined ? this.externalMic2VolumeLevel : 1.0;
                  src.connect(gain);
                  gain.connect(destination);
                  this.pipExternalMic2Gain = gain;
                } catch (e) { console.error('[Recorder] External mic 2 failed:', e); }
              }

              mixedAudioTrack = destination.stream.getAudioTracks()[0];
            } catch (mixError) {
              console.error('[Recorder] Audio mixing failed, using mic only:', mixError);
              mixedAudioTrack = micAudioTracks[0] || null;
            }
          }

          // 5. Build final stream: screen video + mixed audio
          const videoTrack = screenStream.getVideoTracks()[0];
          if (mixedAudioTrack) {
            this.stream = new MediaStream([videoTrack, mixedAudioTrack]);
            console.log('[Recorder] Screen stream with mixed audio (system audio:', hasSystemAudio, ')');
          } else {
            this.stream = new MediaStream([videoTrack]);
            console.log('[Recorder] Screen stream (no audio)');
          }

          // Store for cleanup
          this.pipScreenStream = screenStream;
          this.screenMicStream = micStream;

          this.elements.previewVideo.srcObject = this.stream;
          this.elements.previewPlaceholder.style.display = 'none';
          this.elements.previewVideo.style.display = 'block';
          this.elements.reviewVideo.style.display = 'none';

          // Start audio metering
          this.startAudioMeter(this.stream);

          // Show audio mix controls and system audio status
          this.updateAudioMixControlsVisibility();
          this.updateSystemAudioStatus(hasSystemAudio);

          console.log('[Recorder] Screen capture started:', sourceId);
        } catch (error) {
          console.error('[Recorder] Screen capture error:', error);
          this.showStatus('Failed to start screen capture: ' + error.message, 'error');
          this.cleanupPipResources();
        }
      },

      // Start screen + camera PiP capture
      async startScreenPipCapture(sourceId) {
        try {
          const audioDeviceId = this.elements.audioSource.value;

          // 1. Get screen video stream (video only)
          const screenStream = await navigator.mediaDevices.getUserMedia({
            audio: false,
            video: {
              mandatory: {
                chromeMediaSource: 'desktop',
                chromeMediaSourceId: sourceId
              }
            }
          });

          // 2. Get system audio via native loopback, with legacy fallback
          let loopbackStream = null;
          let hasSystemAudio = false;

          loopbackStream = await this.getLoopbackAudioStream();
          if (loopbackStream) {
            hasSystemAudio = true;
          } else {
            // Fallback: try legacy chromeMediaSource desktop audio (works on Windows)
            // Desktop audio requires paired video capture, so we request both then discard the video
            try {
              const legacyStream = await navigator.mediaDevices.getUserMedia({
                audio: {
                  mandatory: {
                    chromeMediaSource: 'desktop',
                    chromeMediaSourceId: sourceId
                  }
                },
                video: {
                  mandatory: {
                    chromeMediaSource: 'desktop',
                    chromeMediaSourceId: sourceId
                  }
                }
              });
              if (legacyStream.getAudioTracks().length > 0) {
                // Keep only the audio tracks, stop the redundant video tracks
                legacyStream.getVideoTracks().forEach(t => t.stop());
                loopbackStream = new MediaStream(legacyStream.getAudioTracks());
                hasSystemAudio = true;
                console.log('[Recorder] System audio captured via legacy chromeMediaSource');
              } else {
                legacyStream.getTracks().forEach(t => t.stop());
              }
            } catch (legacyError) {
              console.log('[Recorder] Legacy system audio also unavailable:', legacyError.message);
            }
          }

          // Store for cleanup
          this.loopbackStream = loopbackStream;
          this.systemAudioActive = hasSystemAudio;

          // 3. Get camera + mic stream
          const devices = await navigator.mediaDevices.enumerateDevices();
          const videoDevices = devices.filter(d => d.kind === 'videoinput');

          if (videoDevices.length === 0) {
            this.showStatus('No camera available for picture-in-picture', 'error');
            screenStream.getTracks().forEach(t => t.stop());
            if (loopbackStream) loopbackStream.getTracks().forEach(t => t.stop());
            return;
          }

          const cameraStream = await navigator.mediaDevices.getUserMedia({
            video: { deviceId: { exact: videoDevices[0].deviceId }, width: 320, height: 240 },
            audio: audioDeviceId ? { deviceId: { exact: audioDeviceId } } : true
          });

          // 4. Mix audio (loopback system audio + mic + external mics)
          let mixedAudioTrack = null;
          const micAudioTracks = cameraStream.getAudioTracks();
          const systemAudioTracks = loopbackStream ? loopbackStream.getAudioTracks() : [];

          if (micAudioTracks.length > 0 || systemAudioTracks.length > 0) {
            try {
              const audioContext = new AudioContext();
              const destination = audioContext.createMediaStreamDestination();

              const micVolumeLevel = this.micVolumeLevel !== undefined ? this.micVolumeLevel : 1.0;
              const desktopVolumeLevel = this.desktopVolumeLevel !== undefined ? this.desktopVolumeLevel : 1.0;

              if (micAudioTracks.length > 0) {
                const micSource = audioContext.createMediaStreamSource(new MediaStream([micAudioTracks[0]]));
                const micGain = audioContext.createGain();
                micGain.gain.value = micVolumeLevel;
                micSource.connect(micGain);
                micGain.connect(destination);
                this.pipMicGain = micGain;
              }

              if (systemAudioTracks.length > 0) {
                const systemSource = audioContext.createMediaStreamSource(new MediaStream([systemAudioTracks[0]]));
                const desktopGain = audioContext.createGain();
                desktopGain.gain.value = desktopVolumeLevel;
                systemSource.connect(desktopGain);
                desktopGain.connect(destination);
                this.pipDesktopGain = desktopGain;
              }

              this.pipAudioDestination = destination;
              this.pipAudioContext = audioContext;

              // External mic 1
              const externalMicDeviceId = this.elements.externalMicSource.value;
              if (externalMicDeviceId) {
                try {
                  this.externalMicStream = await navigator.mediaDevices.getUserMedia({
                    audio: { deviceId: { exact: externalMicDeviceId } },
                    video: false
                  });
                  const externalMicSource = audioContext.createMediaStreamSource(this.externalMicStream);
                  const externalMicGain = audioContext.createGain();
                  const externalMicVolumeLevel = this.externalMicVolumeLevel !== undefined ? this.externalMicVolumeLevel : 1.0;
                  externalMicGain.gain.value = externalMicVolumeLevel;
                  externalMicSource.connect(externalMicGain);
                  externalMicGain.connect(destination);
                  this.pipExternalMicGain = externalMicGain;
                } catch (extMicError) {
                  console.error('[Recorder] Failed to add external mic 1:', extMicError);
                }
              }

              // External mic 2
              const externalMic2DeviceId = this.elements.externalMic2Source.value;
              if (externalMic2DeviceId) {
                try {
                  this.externalMic2Stream = await navigator.mediaDevices.getUserMedia({
                    audio: { deviceId: { exact: externalMic2DeviceId } },
                    video: false
                  });
                  const externalMic2Source = audioContext.createMediaStreamSource(this.externalMic2Stream);
                  const externalMic2Gain = audioContext.createGain();
                  const externalMic2VolumeLevel = this.externalMic2VolumeLevel !== undefined ? this.externalMic2VolumeLevel : 1.0;
                  externalMic2Gain.gain.value = externalMic2VolumeLevel;
                  externalMic2Source.connect(externalMic2Gain);
                  externalMic2Gain.connect(destination);
                  this.pipExternalMic2Gain = externalMic2Gain;
                } catch (extMic2Error) {
                  console.error('[Recorder] Failed to add external mic 2:', extMic2Error);
                }
              }

              mixedAudioTrack = destination.stream.getAudioTracks()[0];
            } catch (mixError) {
              console.error('[Recorder] Audio mixing failed, using mic only:', mixError);
              mixedAudioTrack = micAudioTracks[0] || null;
            }
          }

          // 5. Canvas compositing
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');

          const screenTrack = screenStream.getVideoTracks()[0];
          const screenSettings = screenTrack.getSettings();
          canvas.width = screenSettings.width || 1920;
          canvas.height = screenSettings.height || 1080;

          const screenVideo = document.createElement('video');
          screenVideo.srcObject = screenStream;
          screenVideo.muted = true;
          await screenVideo.play();

          const cameraVideo = document.createElement('video');
          cameraVideo.srcObject = cameraStream;
          cameraVideo.muted = true;
          await cameraVideo.play();

          const pipWidth = Math.round(canvas.width * 0.2);
          const pipHeight = Math.round(pipWidth * 0.75);
          const pipMargin = 20;
          const pipX = canvas.width - pipWidth - pipMargin;
          const pipY = canvas.height - pipHeight - pipMargin;

          this.pipScreenStream = screenStream;
          this.pipCameraStream = cameraStream;
          this.pipCanvas = canvas;
          this.pipScreenVideo = screenVideo;
          this.pipCameraVideo = cameraVideo;

          const drawFrame = () => {
            if (!this.pipCanvas) return;
            ctx.drawImage(screenVideo, 0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.beginPath();
            const radius = 10;
            ctx.moveTo(pipX + radius, pipY);
            ctx.lineTo(pipX + pipWidth - radius, pipY);
            ctx.quadraticCurveTo(pipX + pipWidth, pipY, pipX + pipWidth, pipY + radius);
            ctx.lineTo(pipX + pipWidth, pipY + pipHeight - radius);
            ctx.quadraticCurveTo(pipX + pipWidth, pipY + pipHeight, pipX + pipWidth - radius, pipY + pipHeight);
            ctx.lineTo(pipX + radius, pipY + pipHeight);
            ctx.quadraticCurveTo(pipX, pipY + pipHeight, pipX, pipY + pipHeight - radius);
            ctx.lineTo(pipX, pipY + radius);
            ctx.quadraticCurveTo(pipX, pipY, pipX + radius, pipY);
            ctx.closePath();
            ctx.clip();
            ctx.drawImage(cameraVideo, pipX, pipY, pipWidth, pipHeight);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.restore();
            this.pipAnimationFrame = requestAnimationFrame(drawFrame);
          };

          drawFrame();

          const canvasStream = canvas.captureStream(30);
          if (mixedAudioTrack) {
            canvasStream.addTrack(mixedAudioTrack);
          }

          this.stream = canvasStream;
          this.elements.previewVideo.srcObject = this.stream;
          this.elements.previewPlaceholder.style.display = 'none';
          this.elements.previewVideo.style.display = 'block';
          this.elements.reviewVideo.style.display = 'none';

          // Start audio metering
          this.startAudioMeter(this.stream);

          const source = this.screenSources.find(s => s.id === sourceId);
          if (source) {
            let option = this.elements.videoSource.querySelector('option[value="screen-pip"]');
            if (option) {
              option.textContent = `${source.name} + Camera`;
              option.value = `screen-pip:${sourceId}`;
              this.elements.videoSource.value = `screen-pip:${sourceId}`;
            }
          }

          this.updateAudioMixControlsVisibility();
          this.updateSystemAudioStatus(hasSystemAudio);
          console.log('[Recorder] Screen + Camera PiP capture started:', sourceId);
        } catch (error) {
          console.error('[Recorder] Screen + Camera PiP capture error:', error);
          this.showStatus('Failed to start screen + camera capture: ' + error.message, 'error');
          this.elements.videoSource.value = '';
          this.cleanupPipResources();
        }
      },

      // Cleanup PiP and screen capture audio resources
      cleanupPipResources() {
        if (this.pipAnimationFrame) {
          cancelAnimationFrame(this.pipAnimationFrame);
          this.pipAnimationFrame = null;
        }
        if (this.pipScreenStream) {
          this.pipScreenStream.getTracks().forEach(t => t.stop());
          this.pipScreenStream = null;
        }
        if (this.pipCameraStream) {
          this.pipCameraStream.getTracks().forEach(t => t.stop());
          this.pipCameraStream = null;
        }
        if (this.screenMicStream) {
          this.screenMicStream.getTracks().forEach(t => t.stop());
          this.screenMicStream = null;
        }
        // Cleanup loopback audio stream
        if (this.loopbackStream) {
          this.loopbackStream.getTracks().forEach(t => t.stop());
          this.loopbackStream = null;
        }
        this.systemAudioActive = false;
        if (this.pipScreenVideo) {
          this.pipScreenVideo.srcObject = null;
          this.pipScreenVideo = null;
        }
        if (this.pipCameraVideo) {
          this.pipCameraVideo.srcObject = null;
          this.pipCameraVideo = null;
        }
        if (this.pipAudioContext) {
          this.pipAudioContext.close();
          this.pipAudioContext = null;
        }
        if (this.externalMicStream) {
          this.externalMicStream.getTracks().forEach(t => t.stop());
          this.externalMicStream = null;
        }
        if (this.externalMic2Stream) {
          this.externalMic2Stream.getTracks().forEach(t => t.stop());
          this.externalMic2Stream = null;
        }
        this.pipMicGain = null;
        this.pipDesktopGain = null;
        this.pipExternalMicGain = null;
        this.pipExternalMic2Gain = null;
        this.pipAudioDestination = null;
        this.pipCanvas = null;
        // Reset system audio status indicator
        this.updateSystemAudioStatus(false);
        // Stop live transcription if still running
        this.stopLiveTranscription();
      },

      // Update the system audio status badge on the Desktop volume control
      updateSystemAudioStatus(active) {
        const badge = document.getElementById('desktopAudioStatus');
        if (!badge) return;
        if (active) {
          badge.textContent = 'Active';
          badge.className = 'audio-status-badge active';
          badge.title = 'System audio is being captured (meeting audio, app sounds, etc.)';
        } else {
          badge.textContent = 'Unavailable';
          badge.className = 'audio-status-badge';
          badge.title = 'System audio capture not available on this platform';
        }
      },

      // ==========================================
      // LIVE TRANSCRIPTION (OpenAI Realtime API)
      // ==========================================

      captionsEnabled: false,
      transcriptionWs: null,
      transcriptionAudioCtx: null,
      transcriptionProcessor: null,
      accumulatedTranscript: [],
      interimText: '',
      transcriptFlushInterval: null,
      transcriptLastFlushedIndex: 0,
      transcriptSessionId: null,
      transcriptRecordingStartedAt: null,

      toggleCaptions() {
        this.captionsEnabled = !this.captionsEnabled;
        this.elements.captionToggle.classList.toggle('active', this.captionsEnabled);
        this.elements.captionOverlay.classList.toggle('visible', this.captionsEnabled);
        if (!this.captionsEnabled) {
          this.elements.captionText.textContent = '';
        }
      },

      showCaption(text, isInterim = false) {
        if (!this.captionsEnabled) return;
        this.elements.captionText.textContent = text;
        this.elements.captionText.classList.toggle('interim', isInterim);
      },

      async startLiveTranscription() {
        // Only start if we have a mixed audio destination to tap
        if (!this.pipAudioDestination) {
          console.log('[Transcription] No audio destination to transcribe');
          return;
        }

        try {
          // Get API key
          const keyResult = await window.recorder.getOpenAIKey();
          if (!keyResult.success || !keyResult.key) {
            console.log('[Transcription] No OpenAI API key available, skipping live captions');
            return;
          }

          const apiKey = keyResult.key;
          
          // Get realtime model from centralized AI service profiles
          // Direct WebSocket is required here for low-latency audio streaming
          let realtimeModel = 'gpt-4o-realtime-preview';
          try {
            const profiles = await window.ai?.getProfiles?.();
            if (profiles?.realtime?.model) {
              realtimeModel = profiles.realtime.model;
            }
          } catch (e) {
            console.log('[Transcription] Using default realtime model');
          }
          const wsUrl = `wss://api.openai.com/v1/realtime?model=${realtimeModel}`;

          // Connect via WebSocket (browser uses subprotocols for auth)
          this.transcriptionWs = new WebSocket(wsUrl, [
            'realtime',
            `openai-insecure-api-key.${apiKey}`,
            'openai-beta.realtime-v1'
          ]);

          this.transcriptionWs.onopen = () => {
            console.log('[Transcription] WebSocket connected');

            // Configure session for transcription only
            this.transcriptionWs.send(JSON.stringify({
              type: 'session.update',
              session: {
                modalities: ['text'],
                input_audio_format: 'pcm16',
                input_audio_transcription: {
                  model: 'whisper-1'
                },
                turn_detection: {
                  type: 'server_vad',
                  threshold: 0.5,
                  prefix_padding_ms: 400,
                  silence_duration_ms: 1000
                }
              }
            }));

            // Show status
            this.elements.transcriptionStatus.classList.add('visible', 'active');
            this.elements.transcriptionStatusText.textContent = 'Live captions';

            // Start the periodic transcript file flush (every 5 seconds)
            this.startTranscriptFileFlush();

            // Start streaming audio
            this.startAudioStreaming();
          };

          this.transcriptionWs.onmessage = (event) => {
            try {
              const data = JSON.parse(event.data);
              this.handleTranscriptionEvent(data);
            } catch (e) {}
          };

          this.transcriptionWs.onerror = (error) => {
            console.error('[Transcription] WebSocket error:', error);
            this._trackError('transcription-ws', error?.message || 'WebSocket error');
          };

          this.transcriptionWs.onclose = (ev) => {
            console.log('[Transcription] WebSocket closed');
          };

          // Log first non-silent audio frame to verify audio is actually flowing
          let _audioCheckCount = 0;
          const _origHandler = this.transcriptionProcessor.onaudioprocess;
          this.transcriptionProcessor.onaudioprocess = (e) => {
            if (_audioCheckCount < 3) {
              const samples = e.inputBuffer.getChannelData(0);
              const maxAmp = Math.max(...Array.from(samples).map(Math.abs));
              _audioCheckCount++;
            }
            _origHandler.call(this, e);
          };

          console.log('[Transcription] Audio streaming started at 24kHz');
        } catch (error) {
          this._trackError('audio-streaming', error.message);
          console.error('[Transcription] Audio streaming failed:', error);
        }
      },

      handleTranscriptionEvent(data) {
        switch (data.type) {
          case 'conversation.item.input_audio_transcription.delta':
            if (data.delta) {
              this.interimText += data.delta;
              this.showCaption(this.interimText, true);
            }
            break;

          case 'conversation.item.input_audio_transcription.completed':
            if (data.transcript) {
              const finalText = data.transcript.trim();
              if (finalText) {
                this.accumulatedTranscript.push({
                  text: finalText,
                  timestamp: Date.now()
                });
                this.showCaption(finalText, false);
                // Clear after display
                setTimeout(() => {
                  if (this.elements.captionText.textContent === finalText) {
                    this.elements.captionText.classList.add('interim');
                  }
                }, 4000);
              }
            }
            this.interimText = '';
            break;

          case 'input_audio_buffer.speech_started':
            this.interimText = '';
            break;

          case 'error':
            console.error('[Transcription] API error:', data.error?.message || data);
            break;
        }
      },

      stopLiveTranscription() {
        if (this.transcriptionProcessor) {
          this.transcriptionProcessor.disconnect();
          this.transcriptionProcessor = null;
        }
        if (this.transcriptionAudioCtx) {
          this.transcriptionAudioCtx.close();
          this.transcriptionAudioCtx = null;
        }
        if (this.transcriptionWs) {
          if (this.transcriptionWs.readyState === WebSocket.OPEN) {
            this.transcriptionWs.close();
          }
          this.transcriptionWs = null;
        }
        this.interimText = '';
        this.elements.transcriptionStatus.classList.remove('visible', 'active');

        // Final flush and stop the interval
        this.stopTranscriptFileFlush(true);
      },

      // ==========================================
      // LIVE TRANSCRIPT FILE (Agent-readable .md)
      // ==========================================

      startTranscriptFileFlush() {
        // Create a unique session ID for this recording
        this.transcriptSessionId = `rec_${Date.now()}`;
        this.transcriptRecordingStartedAt = new Date().toISOString();
        this.transcriptLastFlushedIndex = 0;

        // Flush every 5 seconds
        this.transcriptFlushInterval = setInterval(() => {
          this.flushTranscriptToFile();
        }, 5000);

        // Do an initial write to create the file
        this.flushTranscriptToFile();
        console.log('[Transcription] Live transcript file flush started');
      },

      stopTranscriptFileFlush(doFinalFlush = false) {
        if (this.transcriptFlushInterval) {
          clearInterval(this.transcriptFlushInterval);
          this.transcriptFlushInterval = null;
        }
        if (doFinalFlush && this.transcriptSessionId) {
          this.flushTranscriptToFile(true);
        }
      },

      // Collect real-time health metrics from audio/video state + system diagnostics
      async collectHealthMetrics() {
        const health = {
          timestamp: Date.now(),
          recording: this.isRecording,
          paused: this.isPaused,
          videoActive: !!(this.stream && this.stream.getVideoTracks().some(t => t.readyState === 'live')),
          audioTracks: {
            mic: !!(this.screenMicStream && this.screenMicStream.getAudioTracks().some(t => t.readyState === 'live')),
            desktop: this.systemAudioActive || false,
            externalMic: !!(this.externalMicStream && this.externalMicStream.getAudioTracks().some(t => t.readyState === 'live'))
          },
          volumes: {
            mic: this.micVolumeLevel || 0,
            desktop: this.desktopVolumeLevel || 0,
            externalMic: this.externalMicVolumeLevel || 0
          },
          captionsConnected: !!(this.transcriptionWs && this.transcriptionWs.readyState === WebSocket.OPEN),
          captionsEnabled: this.captionsEnabled,
          transcriptLineCount: this.accumulatedTranscript.length,
          errors: this._recentErrors || [],
          system: null
        };

        // Sample audio level from the mixer (RMS of recent buffer)
        if (this._lastAudioRMS !== undefined) {
          health.audioLevel = this._lastAudioRMS;
          health.audioSilent = this._lastAudioRMS < 0.005;
        }

        // Fetch system diagnostics (CPU, memory, battery) from main process
        try {
          if (window.recorder?.getSystemDiagnostics) {
            const diag = await window.recorder.getSystemDiagnostics();
            if (diag.success) {
              health.system = diag;
            }
          }
        } catch (e) {
          // Non-critical, skip if unavailable
        }

        return health;
      },

      // Track recent errors for health reporting
      _recentErrors: [],
      _trackError(source, message) {
        this._recentErrors.push({ source, message, at: Date.now() });
        // Keep only last 10, within last 60 seconds
        const cutoff = Date.now() - 60000;
        this._recentErrors = this._recentErrors.filter(e => e.at > cutoff).slice(-10);
      },

      // Display a monitor alert toast in the recorder
      showMonitorAlert(alert) {
        const container = this.elements.monitorAlertContainer;
        if (!container) return;

        const el = document.createElement('div');
        el.className = `monitor-alert ${alert.severity || 'info'}`;
        el.innerHTML = `
          <svg class="monitor-alert-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
            ${alert.severity === 'warning'
              ? '<path d="M10.29 3.86L1.82 18a2 2 0 001.71 3h16.94a2 2 0 001.71-3L13.71 3.86a2 2 0 00-3.42 0z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/>'
              : '<circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/>'
            }
          </svg>
          <div class="monitor-alert-body">
            <div class="monitor-alert-message">${alert.message}</div>
            ${alert.suggestion ? `<div class="monitor-alert-suggestion">${alert.suggestion}</div>` : ''}
          </div>
          <button class="monitor-alert-dismiss" onclick="app.dismissMonitorAlert(this.closest('.monitor-alert'))">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/>
            </svg>
          </button>
        `;

        container.appendChild(el);

        // Auto-dismiss after 12 seconds
        setTimeout(() => {
          this.dismissMonitorAlert(el);
        }, 12000);
      },

      dismissMonitorAlert(el) {
        if (!el || !el.parentNode) return;
        el.classList.add('dismissing');
        setTimeout(() => {
          if (el.parentNode) el.parentNode.removeChild(el);
        }, 300);
      },

      async flushTranscriptToFile(isFinal = false) {
        if (!window.recorder?.writeLiveTranscript) return;

        const spaceId = this.elements.targetSpace?.value || 'gsx-agent';
        const filename = 'live-transcript.md';

        // Collect health metrics (async for system diagnostics)
        const health = await this.collectHealthMetrics();

        // Build markdown content
        const now = new Date();
        const elapsed = this.recordingStartTime
          ? Math.floor((Date.now() - this.recordingStartTime - (this.totalPausedMs || 0)) / 1000)
          : 0;
        const elapsedStr = this.formatDuration ? this.formatDuration(elapsed) : `${elapsed}s`;

        let md = `# Live Transcript\n\n`;
        md += `## Session\n\n`;
        md += `- **Status:** ${isFinal ? 'Recording ended' : (this.isPaused ? 'Paused' : 'Recording')}\n`;
        md += `- **Session:** ${this.transcriptSessionId || 'unknown'}\n`;
        md += `- **Started:** ${this.transcriptRecordingStartedAt || 'unknown'}\n`;
        md += `- **Elapsed:** ${elapsedStr}\n`;
        md += `- **Updated:** ${now.toISOString()}\n`;
        md += `- **Lines:** ${this.accumulatedTranscript.length}\n\n`;

        // Health section -- structured for agent parsing
        md += `## Health\n\n`;
        md += `| Metric | Value |\n|--------|-------|\n`;
        md += `| Video active | ${health.videoActive ? 'Yes' : 'NO'} |\n`;
        md += `| Mic active | ${health.audioTracks.mic ? 'Yes' : 'NO'} |\n`;
        md += `| Desktop audio | ${health.audioTracks.desktop ? 'Yes' : 'NO'} |\n`;
        md += `| Audio level | ${health.audioLevel !== undefined ? health.audioLevel.toFixed(4) : 'N/A'} |\n`;
        md += `| Audio silent | ${health.audioSilent ? 'YES -- possible issue' : 'No'} |\n`;
        md += `| Captions connected | ${health.captionsConnected ? 'Yes' : 'No'} |\n`;
        md += `| Mic volume | ${Math.round((health.volumes.mic || 0) * 100)}% |\n`;
        md += `| Desktop volume | ${Math.round((health.volumes.desktop || 0) * 100)}% |\n`;

        // System diagnostics
        if (health.system) {
          const sys = health.system;
          const cpuStr = sys.cpu?.percent != null ? `${sys.cpu.percent}%` : 'N/A';
          const cpuHigh = sys.cpu?.percent > 80;
          md += `| CPU (app) | ${cpuStr}${cpuHigh ? ' -- HIGH' : ''} |\n`;
          md += `| CPU load avg | ${sys.cpu?.loadAvg?.toFixed(1) || 'N/A'} / ${sys.cpu?.cores || '?'} cores |\n`;
          const memPct = sys.memory?.percentUsed || 0;
          const memHigh = memPct > 85;
          md += `| Memory (system) | ${memPct}% used${memHigh ? ' -- HIGH' : ''} (${sys.memory?.systemFreeMB || '?'} MB free) |\n`;
          md += `| Memory (app) | ${sys.memory?.appMB || '?'} MB |\n`;
          md += `| Battery | ${sys.battery?.onBattery ? 'ON BATTERY' : 'AC power'} |\n`;
          if (sys.throttled > 0) {
            md += `| Throttled windows | ${sys.throttled} -- performance may be degraded |\n`;
          }
        }

        if (health.errors.length > 0) {
          md += `\n### Recent Errors\n\n`;
          for (const err of health.errors) {
            md += `- **${err.source}:** ${err.message} (${new Date(err.at).toISOString()})\n`;
          }
        }

        md += `\n---\n\n`;
        md += `## Transcript\n\n`;

        // Append all transcript lines with relative timestamps
        if (this.accumulatedTranscript.length === 0) {
          md += `*Waiting for speech...*\n`;
        } else {
          for (const entry of this.accumulatedTranscript) {
            const relMs = this.recordingStartTime ? entry.timestamp - this.recordingStartTime : 0;
            const relSec = Math.max(0, Math.floor(relMs / 1000));
            const mm = String(Math.floor(relSec / 60)).padStart(2, '0');
            const ss = String(relSec % 60).padStart(2, '0');
            md += `**[${mm}:${ss}]** ${entry.text}\n\n`;
          }
        }

        if (isFinal) {
          md += `---\n\n*Recording ended at ${now.toISOString()}*\n`;
        }

        try {
          const flushResult = await window.recorder.writeLiveTranscript({
            spaceId,
            content: md,
            filename
          });
        } catch (err) {
          console.warn('[Transcription] Flush to file failed:', err.message);
        }
      },

      // ==========================================
      // POST-SAVE DIARIZED TRANSCRIPTION
      // ==========================================

      async triggerPostSaveTranscription(itemId) {
        try {
          // Show transcription in-progress status
          this.elements.transcriptionStatus.classList.add('visible');
          this.elements.transcriptionStatus.classList.remove('active');
          this.elements.transcriptionStatusText.textContent = 'Transcribing...';

          console.log(`[Recorder] Triggering post-save transcription for ${itemId}`);
          const result = await window.recorder.transcribeItem(itemId);

          if (result.success) {
            this.elements.transcriptionStatus.classList.add('active');
            const speakerInfo = result.speakerCount ? ` (${result.speakerCount} speakers)` : '';
            this.elements.transcriptionStatusText.textContent = `Transcript saved${speakerInfo}`;
            this.showStatus(`Transcript saved${speakerInfo}`, 'success');
            console.log(`[Recorder] Post-save transcription complete: ${result.wordCount} words, ${result.speakerCount} speakers`);

            // Fade out status after a few seconds
            setTimeout(() => {
              this.elements.transcriptionStatus.classList.remove('visible', 'active');
            }, 6000);
          } else {
            this.elements.transcriptionStatusText.textContent = 'Transcription failed';
            console.warn('[Recorder] Post-save transcription failed:', result.error);
            // Show briefly then hide
            setTimeout(() => {
              this.elements.transcriptionStatus.classList.remove('visible');
            }, 4000);
          }
        } catch (error) {
          console.error('[Recorder] Post-save transcription error:', error);
          this.elements.transcriptionStatus.classList.remove('visible', 'active');
        }
      },

      // Change audio source
      async changeAudioSource() {
        if (this.elements.videoSource.value && this.elements.videoSource.value !== 'screen') {
          await this.changeVideoSource();
        }
      },

      // Volume controls
      updateMicVolume(value) {
        const percent = parseInt(value);
        this.elements.micVolumeValue.textContent = `${percent}%`;
        this.micVolumeLevel = percent / 100;
        if (this.pipMicGain) {
          this.pipMicGain.gain.value = this.micVolumeLevel;
        }
      },

      updateDesktopVolume(value) {
        const percent = parseInt(value);
        this.elements.desktopVolumeValue.textContent = `${percent}%`;
        this.desktopVolumeLevel = percent / 100;
        if (this.pipDesktopGain) {
          this.pipDesktopGain.gain.value = this.desktopVolumeLevel;
        }
      },

      updateExternalMicVolume(micNum, value) {
        const percent = parseInt(value);
        if (micNum === 1) {
          this.elements.externalMicVolumeValue.textContent = `${percent}%`;
          this.externalMicVolumeLevel = percent / 100;
          if (this.pipExternalMicGain) {
            this.pipExternalMicGain.gain.value = this.externalMicVolumeLevel;
          }
        } else if (micNum === 2) {
          this.elements.externalMic2VolumeValue.textContent = `${percent}%`;
          this.externalMic2VolumeLevel = percent / 100;
          if (this.pipExternalMic2Gain) {
            this.pipExternalMic2Gain.gain.value = this.externalMic2VolumeLevel;
          }
        }
      },

      async updateExternalMicSource(micNum) {
        const sourceElement = micNum === 1 ? this.elements.externalMicSource : this.elements.externalMic2Source;
        const deviceId = sourceElement.value;
        const streamKey = micNum === 1 ? 'externalMicStream' : 'externalMic2Stream';
        const gainKey = micNum === 1 ? 'pipExternalMicGain' : 'pipExternalMic2Gain';
        const volumeKey = micNum === 1 ? 'externalMicVolumeLevel' : 'externalMic2VolumeLevel';

        if (this[streamKey]) {
          this[streamKey].getTracks().forEach(t => t.stop());
          this[streamKey] = null;
        }

        if (!deviceId) {
          if (this[gainKey] && this.pipAudioContext) {
            this[gainKey].disconnect();
            this[gainKey] = null;
          }
          return;
        }

        try {
          this[streamKey] = await navigator.mediaDevices.getUserMedia({
            audio: { deviceId: { exact: deviceId } },
            video: false
          });

          if (this.pipAudioContext && this.pipAudioDestination) {
            const micSource = this.pipAudioContext.createMediaStreamSource(this[streamKey]);
            const micGain = this.pipAudioContext.createGain();
            micGain.gain.value = this[volumeKey] !== undefined ? this[volumeKey] : 1.0;
            micSource.connect(micGain);
            micGain.connect(this.pipAudioDestination);
            this[gainKey] = micGain;
          }
        } catch (error) {
          console.error(`[Recorder] Failed to get external mic ${micNum}:`, error);
          this.showStatus(`Failed to access external mic ${micNum}: ` + error.message, 'error');
          sourceElement.value = '';
        }
      },

      populateExternalMicDropdown() {
        navigator.mediaDevices.enumerateDevices().then(devices => {
          const audioDevices = devices.filter(d => d.kind === 'audioinput');
          const primaryMicId = this.elements.audioSource.value;
          const extMic1Id = this.elements.externalMicSource.value;
          const extMic2Id = this.elements.externalMic2Source.value;

          this.elements.externalMicSource.innerHTML = '<option value="">None (disabled)</option>';
          audioDevices.forEach((device, i) => {
            if (device.deviceId === primaryMicId) return;
            if (device.deviceId === extMic2Id) return;
            const option = document.createElement('option');
            option.value = device.deviceId;
            option.textContent = device.label || `Microphone ${i + 1}`;
            if (device.deviceId === extMic1Id) option.selected = true;
            this.elements.externalMicSource.appendChild(option);
          });

          this.elements.externalMic2Source.innerHTML = '<option value="">None (disabled)</option>';
          audioDevices.forEach((device, i) => {
            if (device.deviceId === primaryMicId) return;
            if (device.deviceId === extMic1Id) return;
            const option = document.createElement('option');
            option.value = device.deviceId;
            option.textContent = device.label || `Microphone ${i + 1}`;
            if (device.deviceId === extMic2Id) option.selected = true;
            this.elements.externalMic2Source.appendChild(option);
          });
        });
      },

      updateAudioMixControlsVisibility() {
        const isScreenMode = this.currentMode === 'screen' || this.currentMode === 'both';
        this.elements.audioMixControls.classList.toggle('visible', isScreenMode);

        if (isScreenMode) {
          this.populateExternalMicDropdown();
        }
      },

      // Instructions
      setInstructions(data) {
        this.instructions = data;

        if (data.instructions) {
          this.elements.instructionsContent.textContent = data.instructions;
          this.elements.instructionsContent.classList.remove('empty');
        }

        if (data.targetDuration) {
          this.elements.targetDuration.textContent = `/ ~${this.formatDuration(data.targetDuration)}`;
        }

        // Pre-select target space from instructions
        if (data.spaceId) {
          if (this.elements.targetSpace) {
            this.elements.targetSpace.value = data.spaceId;
            this.updateTargetSpaceHighlight();
          }
          if (this.elements.saveSpace) {
            this.elements.saveSpace.value = data.spaceId;
            this.elements.saveSpace.dispatchEvent(new Event('change'));
          }
        }

        // Auto-open settings if instructions present
        if (data.instructions && !this.settingsOpen) {
          this.toggleSettings();
        }
      },

      // ==========================================
      // AUDIO LEVEL METERING
      // ==========================================
      startAudioMeter(stream) {
        this.stopAudioMeter();

        const audioTracks = stream.getAudioTracks();
        if (audioTracks.length === 0) return;

        try {
          const audioContext = new (window.AudioContext || window.webkitAudioContext)();
          const analyser = audioContext.createAnalyser();
          analyser.fftSize = 64;
          analyser.smoothingTimeConstant = 0.8;

          const source = audioContext.createMediaStreamSource(stream);
          source.connect(analyser);

          this.audioAnalyser = analyser;
          this.audioMeterContext = audioContext;
          this.elements.audioMeter.classList.add('visible');

          const bars = this.elements.audioMeter.querySelectorAll('.audio-meter-bar');
          const dataArray = new Uint8Array(analyser.frequencyBinCount);

          const updateMeter = () => {
            analyser.getByteFrequencyData(dataArray);

            const numBars = bars.length;
            for (let i = 0; i < numBars; i++) {
              const dataIndex = Math.floor(i * dataArray.length / numBars);
              const value = dataArray[dataIndex] / 255;
              const height = Math.max(3, value * 32);
              bars[i].style.height = height + 'px';
              bars[i].classList.toggle('peak', value > 0.85);
            }

            this.audioMeterFrame = requestAnimationFrame(updateMeter);
          };

          updateMeter();
        } catch (error) {
          console.warn('[Recorder] Audio metering not available:', error);
        }
      },

      stopAudioMeter() {
        if (this.audioMeterFrame) {
          cancelAnimationFrame(this.audioMeterFrame);
          this.audioMeterFrame = null;
        }
        if (this.audioMeterContext) {
          this.audioMeterContext.close();
          this.audioMeterContext = null;
        }
        this.audioAnalyser = null;
        this.elements.audioMeter && this.elements.audioMeter.classList.remove('visible');
      },

      // ==========================================
      // RECORDING WITH COUNTDOWN
      // ==========================================
      toggleRecording() {
        if (this.countdownActive) return;

        if (this.isRecording) {
          this.stopRecording();
        } else {
          this.startCountdown();
        }
      },

      // 3-2-1 countdown
      async startCountdown() {
        if (!this.stream) {
          this.showStatus('No media stream available. Select a source first.', 'error');
          return;
        }

        this.countdownActive = true;
        const overlay = this.elements.countdownOverlay;
        const number = this.elements.countdownNumber;

        for (let i = 3; i >= 1; i--) {
          number.textContent = i;
          number.style.animation = 'none';
          // Force reflow
          number.offsetHeight;
          number.style.animation = 'countdown-pop 0.8s ease-out';
          overlay.classList.add('active');
          await new Promise(r => setTimeout(r, 800));
        }

        overlay.classList.remove('active');
        this.countdownActive = false;
        this.startRecording();
      },

      startRecording() {
        if (!this.stream) {
          this.showStatus('No media stream available', 'error');
          return;
        }

        this.recordedChunks = [];
        this.isPaused = false;
        this.totalPausedMs = 0;
        this.pauseStartTime = null;

        const options = { mimeType: 'video/webm;codecs=vp9,opus' };
        try {
          this.mediaRecorder = new MediaRecorder(this.stream, options);
        } catch (e) {
          this.mediaRecorder = new MediaRecorder(this.stream);
        }

        this.mediaRecorder.ondataavailable = (event) => {
          if (event.data.size > 0) {
            this.recordedChunks.push(event.data);
          }
        };

        this.mediaRecorder.onstop = () => {
          this.recordedBlob = new Blob(this.recordedChunks, { type: 'video/webm' });
          this.showReview();
        };

        this.mediaRecorder.start(1000);
        this.isRecording = true;
        this.recordingStartTime = Date.now();

        // In session mode, notify the other side to start recording too
        if (this.sessionConnected && this.dataChannel && this.dataChannel.readyState === 'open') {
          this.dataChannel.send(JSON.stringify({
            type: 'recording-start',
            timestamp: this.recordingStartTime
          }));
        }

        // Update UI
        this.elements.recordBtn.classList.add('recording');
        this.elements.recordingIndicator.classList.add('active');
        this.elements.durationDisplay.classList.add('visible');
        this.elements.previewContainer.classList.add('recording-active');
        this.elements.recordLabel.textContent = 'STOP';
        this.elements.pauseBtn.classList.add('visible');

        // Duration counter (excludes paused time)
        this.durationInterval = setInterval(() => {
          if (!this.isPaused) {
            const elapsed = (Date.now() - this.recordingStartTime - this.totalPausedMs) / 1000;
            this.elements.currentDuration.textContent = this.formatDuration(elapsed);
          }
        }, 100);

        // Start live transcription (async, non-blocking)
        this.startLiveTranscription();

        // Start meeting monitor agent
        const monitorSpaceId = this.elements.targetSpace?.value || 'gsx-agent';
        if (window.recorder?.startMonitor) {
          window.recorder.startMonitor(monitorSpaceId).catch(() => {});
        }

        console.log('[Recorder] Recording started');
      },

      togglePause() {
        if (!this.isRecording || !this.mediaRecorder) return;

        if (this.isPaused) {
          // Resume
          this.mediaRecorder.resume();
          this.isPaused = false;

          // Track paused duration
          if (this.pauseStartTime) {
            this.totalPausedMs += Date.now() - this.pauseStartTime;
            this.pauseStartTime = null;
          }

          // Restore audio gain levels
          if (this.pipMicGain) this.pipMicGain.gain.value = this.savedMicGain || 1.0;
          if (this.pipDesktopGain) this.pipDesktopGain.gain.value = this.savedDesktopGain || 1.0;
          if (this.pipExternalMicGain) this.pipExternalMicGain.gain.value = this.savedExtMic1Gain || 1.0;
          if (this.pipExternalMic2Gain) this.pipExternalMic2Gain.gain.value = this.savedExtMic2Gain || 1.0;

          // Update UI
          this.elements.pauseBtn.classList.remove('paused');
          this.elements.pauseBtn.title = 'Pause recording';
          this.elements.pausedOverlay.classList.remove('active');
          this.elements.recordingIndicator.querySelector('span').textContent = 'REC';
          // Restore pause icon (two bars)
          this.elements.pauseIcon.innerHTML = '<rect x="6" y="4" width="4" height="16" rx="1"/><rect x="14" y="4" width="4" height="16" rx="1"/>';

          console.log('[Recorder] Recording resumed');
        } else {
          // Pause
          this.mediaRecorder.pause();
          this.isPaused = true;
          this.pauseStartTime = Date.now();

          // Save current gain levels then mute all audio
          this.savedMicGain = this.pipMicGain ? this.pipMicGain.gain.value : 1.0;
          this.savedDesktopGain = this.pipDesktopGain ? this.pipDesktopGain.gain.value : 1.0;
          this.savedExtMic1Gain = this.pipExternalMicGain ? this.pipExternalMicGain.gain.value : 1.0;
          this.savedExtMic2Gain = this.pipExternalMic2Gain ? this.pipExternalMic2Gain.gain.value : 1.0;

          if (this.pipMicGain) this.pipMicGain.gain.value = 0;
          if (this.pipDesktopGain) this.pipDesktopGain.gain.value = 0;
          if (this.pipExternalMicGain) this.pipExternalMicGain.gain.value = 0;
          if (this.pipExternalMic2Gain) this.pipExternalMic2Gain.gain.value = 0;

          // Update UI
          this.elements.pauseBtn.classList.add('paused');
          this.elements.pauseBtn.title = 'Resume recording';
          this.elements.pausedOverlay.classList.add('active');
          this.elements.recordingIndicator.querySelector('span').textContent = 'PAUSED';
          // Switch to play/resume icon (triangle)
          this.elements.pauseIcon.innerHTML = '<polygon points="6,4 20,12 6,20"/>';

          console.log('[Recorder] Recording paused');
        }
      },

      stopRecording() {
        // In session mode, notify the other side to stop recording too
        if (this.sessionConnected && this.dataChannel && this.dataChannel.readyState === 'open') {
          this.dataChannel.send(JSON.stringify({
            type: 'recording-stop',
            timestamp: Date.now()
          }));
        }

        // If paused, account for final pause duration
        if (this.isPaused && this.pauseStartTime) {
          this.totalPausedMs += Date.now() - this.pauseStartTime;
        }

        if (this.mediaRecorder && this.mediaRecorder.state !== 'inactive') {
          // Resume if paused before stopping (MediaRecorder requires active state to stop cleanly)
          if (this.mediaRecorder.state === 'paused') {
            this.mediaRecorder.resume();
          }
          this.mediaRecorder.stop();
        }

        this.isRecording = false;
        this.isPaused = false;
        clearInterval(this.durationInterval);

        // Update UI
        this.elements.recordBtn.classList.remove('recording');
        this.elements.recordingIndicator.classList.remove('active');
        this.elements.recordingIndicator.querySelector('span').textContent = 'REC';
        this.elements.previewContainer.classList.remove('recording-active');
        this.elements.recordLabel.textContent = 'REC';
        this.elements.pauseBtn.classList.remove('visible', 'paused');
        this.elements.pausedOverlay.classList.remove('active');
        // Reset pause icon
        this.elements.pauseIcon.innerHTML = '<rect x="6" y="4" width="4" height="16" rx="1"/><rect x="14" y="4" width="4" height="16" rx="1"/>';

        // Stop live transcription
        this.stopLiveTranscription();
        this.elements.captionOverlay.classList.remove('visible');

        // Stop meeting monitor agent
        if (window.recorder?.stopMonitor) {
          window.recorder.stopMonitor().catch(() => {});
        }

        console.log('[Recorder] Recording stopped');
      },

      // Review mode
      showReview() {
        this.lastRecordingDuration = (Date.now() - this.recordingStartTime - (this.totalPausedMs || 0)) / 1000;

        if (this.reviewBlobUrl) {
          URL.revokeObjectURL(this.reviewBlobUrl);
        }

        this.elements.previewVideo.style.display = 'none';
        this.elements.reviewVideo.style.display = 'block';
        this.reviewBlobUrl = URL.createObjectURL(this.recordedBlob);
        this.elements.reviewVideo.src = this.reviewBlobUrl;

        // Switch controls
        this.elements.controlsBar.style.display = 'none';
        this.elements.reviewControls.classList.add('visible');
        this.elements.durationDisplay.classList.remove('visible');

        // Set filename
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
        this.elements.saveFilename.value = `recording_${timestamp}.webm`;
      },

      recordAgain() {
        if (this.reviewBlobUrl) {
          URL.revokeObjectURL(this.reviewBlobUrl);
          this.reviewBlobUrl = null;
        }

        this.elements.previewVideo.style.display = 'block';
        this.elements.reviewVideo.style.display = 'none';
        this.elements.reviewVideo.src = '';

        this.elements.controlsBar.style.display = 'flex';
        this.elements.reviewControls.classList.remove('visible');

        this.elements.currentDuration.textContent = '00:00';
        this.elements.durationDisplay.classList.remove('visible');
        this.recordedBlob = null;
        this.recordedChunks = [];
        this.lastRecordingDuration = null;

        // Reset live transcription state
        this.accumulatedTranscript = [];
        this.interimText = '';
        this.transcriptLastFlushedIndex = 0;
        this.transcriptSessionId = null;
        this.transcriptRecordingStartedAt = null;
        this.elements.captionText.textContent = '';
        this.elements.transcriptionStatus.classList.remove('visible', 'active');
      },

      discardRecording() {
        this.recordAgain();
        this.showStatus('Recording discarded', 'error');
      },

      // Save dialog
      showSaveDialog() {
        // Sync target space into save dialog
        const targetSpaceId = this.elements.targetSpace.value;
        if (targetSpaceId && !this.elements.saveSpace.value) {
          this.elements.saveSpace.value = targetSpaceId;
          this.elements.saveSpace.dispatchEvent(new Event('change'));
        }
        this.elements.saveDialog.classList.add('active');
      },

      hideSaveDialog() {
        this.elements.saveDialog.classList.remove('active');
      },

      async saveRecording() {
        if (!this.recordedBlob) {
          this.showStatus('No recording to save', 'error');
          return;
        }

        const filename = this.elements.saveFilename.value || 'recording.webm';
        const spaceId = this.elements.saveSpace.value;

        // Require a space to be selected
        if (!spaceId) {
          this.showStatus('Please select a space to save to', 'error');
          this.elements.saveSpace.focus();
          return;
        }

        try {
          // Show saving state
          this.showStatus('Saving recording...', 'info');

          // Convert blob to base64
          const reader = new FileReader();
          const base64Promise = new Promise((resolve, reject) => {
            reader.onload = () => {
              const base64 = reader.result.split(',')[1];
              resolve(base64);
            };
            reader.onerror = reject;
          });
          reader.readAsDataURL(this.recordedBlob);
          const base64Data = await base64Promise;

          // Save via IPC (goes through clipboard storage for proper Spaces indexing)
          if (window.recorder) {
            const result = await window.recorder.saveToSpace({
              blob: base64Data,
              filename,
              spaceId,
              metadata: {
                duration: this.lastRecordingDuration || 0,
                instructions: this.instructions?.instructions || null,
                recordedAt: new Date().toISOString()
              }
            });

            if (result.success) {
              const spaceName = result.spaceName || 'space';
              this.showStatus(`Saved to ${spaceName}`, 'success');
              this.hideSaveDialog();

              // Auto-trigger diarized transcription in the background
              if (result.itemId && window.recorder.transcribeItem) {
                this.triggerPostSaveTranscription(result.itemId);
              }

              setTimeout(() => {
                this.recordAgain();
              }, 2000);
            } else {
              throw new Error(result.error || 'Save failed');
            }
          }
        } catch (error) {
          console.error('[Recorder] Save error:', error);
          this.showStatus('Failed to save: ' + error.message, 'error');
        }
      },

      // Utilities
      formatDuration(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
      },

      showStatus(message, type = 'info') {
        this.elements.statusText.textContent = message;
        this.elements.statusMessage.className = 'status-message active ' + type;

        setTimeout(() => {
          this.elements.statusMessage.classList.remove('active');
        }, 3000);
      },

      // Window controls
      minimize() {
        if (window.recorder) {
          window.recorder.minimize();
        }
      },

      // ==========================================
      // P2P SESSION (Riverside-style dual recording)
      // ==========================================

      // Session state
      peerConnection: null,
      dataChannel: null,
      remoteStream: null,
      sessionCode: null,
      sessionRole: null, // 'host' | 'guest'
      sessionConnected: false,

      // Session state for host address
      hostAddress: null,

      // Session elements (cached on first use)
      getSessionElements() {
        if (!this._sessionEls) {
          this._sessionEls = {
            setup: document.getElementById('sessionSetup'),
            hostWaiting: document.getElementById('sessionHostWaiting'),
            codeDisplay: document.getElementById('sessionCodeDisplay'),
            hostAddressDisplay: document.getElementById('sessionHostAddress'),
            hostStatus: document.getElementById('hostSessionStatus'),
            joinPanel: document.getElementById('sessionJoinPanel'),
            joinHostInput: document.getElementById('joinHostInput'),
            joinInput: document.getElementById('joinCodeInput'),
            joinBtn: document.getElementById('joinConnectBtn'),
            joinStatus: document.getElementById('joinSessionStatus'),
            connectedBadge: document.getElementById('sessionConnectedBadge'),
            endSessionBtn: document.getElementById('endSessionBtn'),
            remoteVideo: document.getElementById('remoteVideo')
          };
        }
        return this._sessionEls;
      },

      // Show setup (choose host or join)
      sessionShowSetup() {
        const els = this.getSessionElements();
        els.setup.classList.add('visible');
        els.hostWaiting.classList.remove('visible');
        els.joinPanel.classList.remove('visible');
      },

      // Show join panel
      sessionShowJoin() {
        const els = this.getSessionElements();
        els.setup.classList.remove('visible');
        els.joinPanel.classList.add('visible');
        els.joinStatus.textContent = '';
        els.joinInput.value = '';
        els.joinInput.focus();
      },

      // Hide all session panels
      sessionHideAllPanels() {
        const els = this.getSessionElements();
        els.setup.classList.remove('visible');
        els.hostWaiting.classList.remove('visible');
        els.joinPanel.classList.remove('visible');
      },

      // HOST: Start hosting a session
      async sessionHost() {
        const els = this.getSessionElements();
        els.setup.classList.remove('visible');
        els.hostWaiting.classList.add('visible');
        els.hostStatus.textContent = 'Setting up...';
        this.sessionRole = 'host';

        try {
          // 1. Get local camera stream if not already active
          if (!this.stream) {
            await this.ensureLocalStream();
          }

          // 2. Create RTCPeerConnection
          this.peerConnection = new RTCPeerConnection({
            iceServers: [
              { urls: 'stun:stun.l.google.com:19302' },
              { urls: 'stun:stun1.l.google.com:19302' }
            ]
          });

          // Set up data channel (host creates it)
          this.dataChannel = this.peerConnection.createDataChannel('capture-sync', {
            ordered: true
          });
          this.setupDataChannelHandlers(this.dataChannel);

          // Handle remote stream
          this.peerConnection.ontrack = (event) => {
            console.log('[Session] Remote track received');
            this.remoteStream = event.streams[0];
            this.onRemoteStreamReady();
          };

          // Add local tracks
          if (this.stream) {
            this.stream.getTracks().forEach(track => {
              this.peerConnection.addTrack(track, this.stream);
            });
          }

          // 3. Gather all ICE candidates (vanilla ICE) with timeout
          els.hostStatus.textContent = 'Gathering network info...';
          const gatherComplete = new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
              // If we have a local description with at least some candidates, proceed
              if (this.peerConnection.localDescription) {
                resolve();
              } else {
                reject(new Error('ICE gathering timed out'));
              }
            }, 15000); // 15s timeout

            this.peerConnection.onicecandidate = (e) => {
              if (e.candidate === null) {
                clearTimeout(timeout);
                resolve();
              }
            };
          });

          const offer = await this.peerConnection.createOffer();
          await this.peerConnection.setLocalDescription(offer);
          await gatherComplete;

          const fullOffer = JSON.stringify(this.peerConnection.localDescription);

          // 4. Create session via local signaling server
          els.hostStatus.textContent = 'Starting session...';
          const result = await window.recorder.createSession(fullOffer);

          if (!result.success) {
            throw new Error(result.error || 'Failed to create session');
          }

          this.sessionCode = result.code;
          this.hostAddress = result.hostAddress;
          els.codeDisplay.childNodes[0].textContent = result.code;
          els.hostAddressDisplay.textContent = result.hostAddress;
          els.hostStatus.textContent = '';

          // 5. Start polling for guest's answer
          await window.recorder.startPollingForAnswer(result.code);

          // Listen for answer (removeAllListeners called in preload to prevent leaks)
          window.recorder.onSessionAnswer(async (answer) => {
            try {
              console.log('[Session] Guest answer received');
              els.hostStatus.textContent = 'Connecting...';
              const desc = new RTCSessionDescription(answer);
              await this.peerConnection.setRemoteDescription(desc);
              // Connection should now be establishing via ICE
            } catch (err) {
              console.error('[Session] Error setting remote description:', err);
              els.hostStatus.textContent = 'Connection failed: ' + err.message;
              els.hostStatus.classList.add('error');
            }
          });

          window.recorder.onSessionTimeout(() => {
            els.hostStatus.textContent = 'Session timed out. No one joined.';
            els.hostStatus.classList.add('error');
          });

          window.recorder.onSessionError((errMsg) => {
            els.hostStatus.textContent = errMsg || 'Session error';
            els.hostStatus.classList.add('error');
          });

          // Monitor connection state
          this.peerConnection.onconnectionstatechange = () => {
            const state = this.peerConnection.connectionState;
            console.log('[Session] Connection state:', state);
            if (state === 'connected') {
              this.onSessionConnected();
            } else if (state === 'failed' || state === 'disconnected') {
              this.onSessionDisconnected(state);
            }
          };

        } catch (error) {
          console.error('[Session] Host error:', error);
          els.hostStatus.textContent = 'Error: ' + error.message;
          els.hostStatus.classList.add('error');
        }
      },

      // Copy host address to clipboard
      copyHostAddress() {
        if (this.hostAddress) {
          navigator.clipboard.writeText(this.hostAddress).then(() => {
            const el = this.getSessionElements().hostAddressDisplay;
            const original = el.textContent;
            el.textContent = 'Copied';
            setTimeout(() => { el.textContent = original; }, 1500);
          });
        }
      },

      // GUEST: Join an existing session
      async sessionJoin() {
        const els = this.getSessionElements();
        const hostAddr = els.joinHostInput.value.trim();
        const code = els.joinInput.value.trim().toLowerCase();

        if (!hostAddr) {
          els.joinStatus.textContent = 'Please enter the host address';
          els.joinStatus.classList.add('error');
          return;
        }

        if (!code) {
          els.joinStatus.textContent = 'Please enter a code';
          els.joinStatus.classList.add('error');
          return;
        }

        els.joinBtn.disabled = true;
        els.joinStatus.textContent = 'Looking up session...';
        els.joinStatus.classList.remove('error');
        this.sessionRole = 'guest';
        this.sessionCode = code;
        this.hostAddress = hostAddr;

        try {
          // 1. Get local camera stream
          if (!this.stream) {
            await this.ensureLocalStream();
          }

          // 2. Find session on host's signaling server
          const result = await window.recorder.findSession(code, hostAddr);
          if (!result.success) {
            throw new Error(result.error || 'Session not found');
          }

          const hostOffer = result.sdpOffer;

          // 3. Create RTCPeerConnection
          this.peerConnection = new RTCPeerConnection({
            iceServers: [
              { urls: 'stun:stun.l.google.com:19302' },
              { urls: 'stun:stun1.l.google.com:19302' }
            ]
          });

          // Handle data channel (guest receives it)
          this.peerConnection.ondatachannel = (event) => {
            this.dataChannel = event.channel;
            this.setupDataChannelHandlers(this.dataChannel);
          };

          // Handle remote stream
          this.peerConnection.ontrack = (event) => {
            console.log('[Session] Remote track received');
            this.remoteStream = event.streams[0];
            this.onRemoteStreamReady();
          };

          // Add local tracks
          if (this.stream) {
            this.stream.getTracks().forEach(track => {
              this.peerConnection.addTrack(track, this.stream);
            });
          }

          // 4. Set remote description (host's offer)
          els.joinStatus.textContent = 'Connecting...';
          const offerDesc = new RTCSessionDescription(
            typeof hostOffer === 'string' ? JSON.parse(hostOffer) : hostOffer
          );
          await this.peerConnection.setRemoteDescription(offerDesc);

          // 5. Create answer and gather ICE (with timeout)
          const gatherComplete = new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
              if (this.peerConnection.localDescription) {
                resolve();
              } else {
                reject(new Error('ICE gathering timed out'));
              }
            }, 15000);

            this.peerConnection.onicecandidate = (e) => {
              if (e.candidate === null) {
                clearTimeout(timeout);
                resolve();
              }
            };
          });

          const answer = await this.peerConnection.createAnswer();
          await this.peerConnection.setLocalDescription(answer);
          await gatherComplete;

          const fullAnswer = JSON.stringify(this.peerConnection.localDescription);

          // 6. Post answer to host's signaling server
          els.joinStatus.textContent = 'Finalizing connection...';
          const answerResult = await window.recorder.postAnswer(code, fullAnswer, this.hostAddress);
          if (!answerResult.success) {
            throw new Error(answerResult.error || 'Failed to post answer');
          }

          // Monitor connection state
          this.peerConnection.onconnectionstatechange = () => {
            const state = this.peerConnection.connectionState;
            console.log('[Session] Connection state:', state);
            if (state === 'connected') {
              this.onSessionConnected();
            } else if (state === 'failed' || state === 'disconnected') {
              this.onSessionDisconnected(state);
            }
          };

        } catch (error) {
          console.error('[Session] Join error:', error);
          els.joinStatus.textContent = error.message;
          els.joinStatus.classList.add('error');
          els.joinBtn.disabled = false;
        }
      },

      // Ensure we have a local camera stream
      async ensureLocalStream() {
        try {
          this.stream = await navigator.mediaDevices.getUserMedia({
            video: true,
            audio: true
          });
          this.elements.previewVideo.srcObject = this.stream;
          this.elements.previewPlaceholder.style.display = 'none';
          this.elements.previewVideo.style.display = 'block';
          this.startAudioMeter(this.stream);
        } catch (err) {
          console.error('[Session] Could not get local media:', err);
          throw new Error('Camera/mic access required for sessions');
        }
      },

      // Called when remote stream arrives
      onRemoteStreamReady() {
        const els = this.getSessionElements();
        els.remoteVideo.srcObject = this.remoteStream;
        els.remoteVideo.style.display = 'block';
      },

      // Called when WebRTC connection is established
      onSessionConnected() {
        console.log('[Session] P2P Connected!');
        this.sessionConnected = true;
        const els = this.getSessionElements();

        // Hide setup panels
        this.sessionHideAllPanels();

        // Switch to split-view
        this.elements.previewContainer.classList.add('session-active');

        // Wrap existing preview video in a participant container
        const previewVideo = this.elements.previewVideo;
        const remoteVideo = els.remoteVideo;

        // Create participant wrappers
        const localParticipant = document.createElement('div');
        localParticipant.className = 'session-participant';
        localParticipant.id = 'localParticipant';
        localParticipant.innerHTML = '<div class="participant-label">You</div>';

        const remoteParticipant = document.createElement('div');
        remoteParticipant.className = 'session-participant';
        remoteParticipant.id = 'remoteParticipant';
        remoteParticipant.innerHTML = '<div class="participant-label remote">Guest</div>';

        // Move videos into participant containers
        previewVideo.style.display = 'block';
        remoteVideo.style.display = 'block';
        localParticipant.prepend(previewVideo);
        remoteParticipant.prepend(remoteVideo);

        // Add to preview container
        this.elements.previewContainer.appendChild(localParticipant);
        this.elements.previewContainer.appendChild(remoteParticipant);

        // Show connected badge
        els.connectedBadge.classList.add('visible');
        els.endSessionBtn.classList.add('visible');

        // Clean up OmniGraph session node only (keep window split-view)
        if (this.sessionCode) {
          window.recorder.cleanupSignaling().catch(() => {});
        }

        this.showStatus('Session connected - ready to record', 'success');
      },

      // Called when connection drops
      onSessionDisconnected(state) {
        console.log('[Session] Disconnected:', state);
        this.showStatus(`Session ${state}`, 'error');
      },

      // Data channel handlers
      setupDataChannelHandlers(channel) {
        channel.onopen = () => {
          console.log('[Session] Data channel open');
          // Send full HUD state to peer on connect (so guest catches up)
          if (this.sessionRole === 'host' && this.hudItems.length > 0) {
            setTimeout(() => this._sendHUDFullSync(), 500);
          }
        };

        channel.onmessage = (event) => {
          try {
            const msg = JSON.parse(event.data);
            console.log('[Session] Data message:', msg.type);

            if (msg.type === 'recording-start') {
              // Remote side started recording -- start ours too
              if (!this.isRecording && this.sessionRole === 'guest') {
                this.startRecording();
              }
            } else if (msg.type === 'recording-stop') {
              // Remote side stopped -- stop ours too
              if (this.isRecording && this.sessionRole === 'guest') {
                this.stopRecording();
              }
            } else if (msg.type === 'hud-item-add' || msg.type === 'hud-item-remove' || msg.type === 'hud-sync-full') {
              // Meeting HUD P2P sync
              this._handleHUDSyncMessage(msg);
            }
          } catch {
            // Binary data (for future track transfer)
          }
        };

        channel.onclose = () => {
          console.log('[Session] Data channel closed');
        };
      },

      // Copy session code + host address to clipboard
      copySessionCode() {
        if (this.sessionCode) {
          const text = this.hostAddress
            ? `Code: ${this.sessionCode}\nAddress: ${this.hostAddress}`
            : this.sessionCode;
          navigator.clipboard.writeText(text).then(() => {
            this.showStatus('Session info copied!', 'success');
          });
        }
      },

      // Cancel hosting
      async sessionCancel() {
        await this.sessionCleanup();
        this.sessionShowSetup();
      },

      // End an active session
      async sessionEnd() {
        const els = this.getSessionElements();

        // Restore video elements BEFORE removing participant wrappers
        // (remoteVideo is a child of remoteParticipant -- removing parent removes it from DOM)
        const localP = document.getElementById('localParticipant');
        const remoteP = document.getElementById('remoteParticipant');
        if (localP) {
          this.elements.previewContainer.prepend(this.elements.previewVideo);
          localP.remove();
        }
        if (remoteP) {
          // Move remoteVideo back to preview container before removing wrapper
          this.elements.previewContainer.appendChild(els.remoteVideo);
          remoteP.remove();
        }

        // Remove split view
        this.elements.previewContainer.classList.remove('session-active');

        // Clean up remote video
        els.connectedBadge.classList.remove('visible');
        els.endSessionBtn.classList.remove('visible');
        els.remoteVideo.style.display = 'none';
        els.remoteVideo.srcObject = null;

        // Clean up WebRTC and signaling
        await this.sessionCleanup();

        // Switch back to camera mode
        this.switchMode('camera');
        this.showStatus('Session ended', 'info');
      },

      // Cleanup session resources
      async sessionCleanup() {
        this.sessionConnected = false;
        this.sessionRole = null;

        if (this.dataChannel) {
          this.dataChannel.close();
          this.dataChannel = null;
        }

        if (this.peerConnection) {
          this.peerConnection.close();
          this.peerConnection = null;
        }

        if (this.remoteStream) {
          this.remoteStream.getTracks().forEach(t => t.stop());
          this.remoteStream = null;
        }

        // Tell main process to fully end session (includes stopPolling + window resize)
        try {
          await window.recorder.endSession();
        } catch {}

        this.sessionCode = null;
        this.sessionHideAllPanels();
      },

      close() {
        this.stopAudioMeter();
        this.sessionCleanup().catch(() => {});
        if (this.stream) {
          this.stream.getTracks().forEach(t => t.stop());
        }
        this.cleanupPipResources();
        if (window.recorder) {
          window.recorder.close();
        }
      }
    };

    document.addEventListener('DOMContentLoaded', () => app.init());
  </script>
</body>
</html>
