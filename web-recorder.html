<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Web Recorder - Dual Video Capture</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-darkest: #0d0d0d;
      --bg-dark: #181818;
      --bg-surface: #1e1e1e;
      --bg-panel: #232323;
      --bg-elevated: #2a2a2a;
      --bg-hover: #333333;
      --accent-primary: #e84c3d;
      --accent-secondary: #4a9eff;
      --accent-success: #22c55e;
      --accent-warning: #f59e0b;
      --text-primary: #e4e4e4;
      --text-secondary: #909090;
      --text-muted: #5c5c5c;
      --border-color: #2a2a2a;
      --border-light: #383838;
      --recording-red: #ef4444;
      --radius-sm: 4px;
      --radius-md: 8px;
      --radius-lg: 12px;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      background: var(--bg-darkest);
      color: var(--text-primary);
      min-height: 100vh;
      overflow-x: hidden;
    }

    /* Header */
    .header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 20px;
      height: 56px;
      background: linear-gradient(180deg, #252525 0%, #1a1a1a 100%);
      border-bottom: 1px solid #141414;
    }

    .header-left {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .logo {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .logo-icon {
      width: 32px;
      height: 32px;
      background: linear-gradient(135deg, var(--accent-primary) 0%, #f05545 100%);
      border-radius: var(--radius-sm);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .logo-icon svg {
      width: 18px;
      height: 18px;
      color: white;
    }

    .logo-text {
      font-size: 16px;
      font-weight: 600;
      color: var(--text-primary);
    }

    .header-actions {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .header-btn {
      background: var(--bg-elevated);
      border: 1px solid var(--border-color);
      color: var(--text-secondary);
      padding: 8px 16px;
      border-radius: var(--radius-md);
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 6px;
      transition: all 0.15s;
    }

    .header-btn:hover {
      background: var(--bg-hover);
      color: var(--text-primary);
      border-color: var(--border-light);
    }

    .header-btn svg {
      width: 16px;
      height: 16px;
    }

    /* Main Container */
    .main-container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 24px;
    }

    /* Preview Section */
    .preview-section {
      display: grid;
      grid-template-columns: 280px 1fr;
      gap: 20px;
      margin-bottom: 24px;
    }

    .preview-panel {
      background: var(--bg-surface);
      border-radius: var(--radius-lg);
      overflow: hidden;
      position: relative;
    }

    .preview-panel.camera {
      aspect-ratio: 4/3;
    }

    .preview-panel.screen {
      aspect-ratio: 16/9;
      min-height: 400px;
    }

    .preview-label {
      position: absolute;
      top: 12px;
      left: 12px;
      background: rgba(0, 0, 0, 0.7);
      padding: 6px 12px;
      border-radius: 20px;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      z-index: 10;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .preview-label .dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--accent-secondary);
    }

    .preview-label.recording .dot {
      background: var(--recording-red);
      animation: pulse 1s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.4; }
    }

    .preview-video {
      width: 100%;
      height: 100%;
      object-fit: cover;
      background: #000;
    }

    .preview-video.mirror {
      transform: scaleX(-1);
    }

    .preview-placeholder {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 12px;
      color: var(--text-muted);
      background: var(--bg-dark);
    }

    .preview-placeholder svg {
      width: 48px;
      height: 48px;
      opacity: 0.5;
    }

    .preview-placeholder span {
      font-size: 13px;
    }

    .preview-placeholder.hidden {
      display: none;
    }

    /* Recording indicator overlay */
    .recording-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border: 3px solid var(--recording-red);
      border-radius: var(--radius-lg);
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
    }

    .recording-overlay.active {
      opacity: 1;
      animation: recordingBorder 2s infinite;
    }

    @keyframes recordingBorder {
      0%, 100% { border-color: var(--recording-red); }
      50% { border-color: rgba(239, 68, 68, 0.5); }
    }

    /* Controls Section */
    .controls-section {
      background: var(--bg-surface);
      border-radius: var(--radius-lg);
      padding: 20px;
      margin-bottom: 24px;
    }

    .controls-row {
      display: flex;
      align-items: center;
      gap: 20px;
      flex-wrap: wrap;
    }

    .source-group {
      flex: 1;
      min-width: 200px;
    }

    .source-label {
      font-size: 11px;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .source-label svg {
      width: 14px;
      height: 14px;
    }

    .source-select {
      width: 100%;
      padding: 10px 36px 10px 12px;
      background: var(--bg-panel);
      border: 1px solid var(--border-color);
      border-radius: var(--radius-md);
      color: var(--text-primary);
      font-size: 13px;
      cursor: pointer;
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%23909090' stroke-width='2'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 12px center;
    }

    .source-select:hover {
      border-color: var(--border-light);
    }

    .source-select:focus {
      outline: none;
      border-color: var(--accent-primary);
    }

    .toggle-group {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .toggle-label {
      font-size: 13px;
      color: var(--text-secondary);
    }

    .toggle-switch {
      position: relative;
      width: 44px;
      height: 24px;
      background: var(--bg-panel);
      border-radius: 12px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .toggle-switch.active {
      background: var(--accent-primary);
    }

    .toggle-switch::after {
      content: '';
      position: absolute;
      width: 18px;
      height: 18px;
      background: white;
      border-radius: 50%;
      top: 3px;
      left: 3px;
      transition: transform 0.2s;
    }

    .toggle-switch.active::after {
      transform: translateX(20px);
    }

    /* Audio Level Meter */
    .audio-meter-container {
      flex: 1;
      min-width: 150px;
    }

    .audio-meter {
      height: 8px;
      background: var(--bg-panel);
      border-radius: 4px;
      overflow: hidden;
      position: relative;
    }

    .audio-meter-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--accent-success) 0%, var(--accent-warning) 70%, var(--recording-red) 100%);
      width: 0%;
      transition: width 0.05s;
      border-radius: 4px;
    }

    /* Main Recording Controls */
    .recording-controls {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 24px;
      padding: 32px;
      background: var(--bg-surface);
      border-radius: var(--radius-lg);
      margin-bottom: 24px;
    }

    .record-btn {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      border: 4px solid var(--text-muted);
      background: transparent;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      position: relative;
    }

    .record-btn:hover {
      border-color: var(--recording-red);
      transform: scale(1.05);
    }

    .record-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .record-btn-inner {
      width: 52px;
      height: 52px;
      background: var(--recording-red);
      border-radius: 50%;
      transition: all 0.2s;
    }

    .record-btn.recording .record-btn-inner {
      width: 28px;
      height: 28px;
      border-radius: var(--radius-sm);
    }

    .record-btn.recording {
      border-color: var(--recording-red);
    }

    .control-btn {
      padding: 14px 24px;
      border: none;
      border-radius: var(--radius-md);
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.15s;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .control-btn svg {
      width: 18px;
      height: 18px;
    }

    .control-btn.secondary {
      background: var(--bg-elevated);
      color: var(--text-primary);
      border: 1px solid var(--border-color);
    }

    .control-btn.secondary:hover {
      background: var(--bg-hover);
      border-color: var(--border-light);
    }

    .control-btn.primary {
      background: var(--accent-primary);
      color: white;
    }

    .control-btn.primary:hover {
      filter: brightness(1.1);
    }

    .control-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Duration Display */
    .duration-display {
      font-family: 'JetBrains Mono', monospace;
      font-size: 32px;
      font-weight: 600;
      color: var(--text-primary);
      min-width: 140px;
      text-align: center;
    }

    .duration-display .target {
      font-size: 14px;
      color: var(--text-muted);
      font-weight: 400;
      margin-left: 8px;
    }

    .duration-display.recording {
      color: var(--recording-red);
    }

    /* Countdown Overlay */
    .countdown-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: all 0.2s;
    }

    .countdown-overlay.active {
      opacity: 1;
      visibility: visible;
    }

    .countdown-number {
      font-size: 180px;
      font-weight: 700;
      color: var(--accent-primary);
      text-shadow: 0 0 60px rgba(232, 76, 61, 0.5);
      animation: countdownPulse 1s ease-out;
    }

    @keyframes countdownPulse {
      0% { transform: scale(1.3); opacity: 0; }
      50% { transform: scale(1); opacity: 1; }
      100% { transform: scale(0.9); opacity: 0.8; }
    }

    .countdown-text {
      font-size: 18px;
      color: var(--text-secondary);
      margin-top: 20px;
    }

    /* Download Section */
    .download-section {
      background: var(--bg-surface);
      border-radius: var(--radius-lg);
      padding: 24px;
      display: none;
    }

    .download-section.active {
      display: block;
    }

    .download-title {
      font-size: 16px;
      font-weight: 600;
      margin-bottom: 20px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .download-title svg {
      width: 20px;
      height: 20px;
      color: var(--accent-success);
    }

    .download-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 16px;
    }

    .download-card {
      background: var(--bg-panel);
      border: 1px solid var(--border-color);
      border-radius: var(--radius-md);
      padding: 16px;
    }

    .download-card-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 12px;
    }

    .download-card-icon {
      width: 40px;
      height: 40px;
      background: var(--bg-elevated);
      border-radius: var(--radius-md);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .download-card-icon svg {
      width: 20px;
      height: 20px;
      color: var(--accent-secondary);
    }

    .download-card-icon.camera svg {
      color: var(--accent-success);
    }

    .download-card-info h4 {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 2px;
    }

    .download-card-info span {
      font-size: 12px;
      color: var(--text-muted);
    }

    .download-card-actions {
      display: flex;
      gap: 8px;
    }

    .download-btn {
      flex: 1;
      padding: 10px 16px;
      background: var(--accent-secondary);
      color: white;
      border: none;
      border-radius: var(--radius-md);
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      transition: all 0.15s;
    }

    .download-btn:hover {
      filter: brightness(1.1);
    }

    .download-btn svg {
      width: 16px;
      height: 16px;
    }

    .download-btn.secondary {
      background: var(--bg-elevated);
      color: var(--text-primary);
    }

    /* Upload Section */
    .upload-section {
      margin-top: 20px;
      padding-top: 20px;
      border-top: 1px solid var(--border-color);
    }

    .upload-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 16px;
    }

    .upload-title {
      font-size: 14px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .upload-title svg {
      width: 16px;
      height: 16px;
      color: var(--accent-warning);
    }

    .upload-endpoint {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
    }

    .upload-input {
      flex: 1;
      padding: 10px 14px;
      background: var(--bg-panel);
      border: 1px solid var(--border-color);
      border-radius: var(--radius-md);
      color: var(--text-primary);
      font-size: 13px;
      font-family: 'JetBrains Mono', monospace;
    }

    .upload-input:focus {
      outline: none;
      border-color: var(--accent-primary);
    }

    .upload-btn {
      padding: 10px 20px;
      background: var(--accent-warning);
      color: white;
      border: none;
      border-radius: var(--radius-md);
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .upload-btn:hover {
      filter: brightness(1.1);
    }

    .upload-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .upload-progress {
      display: none;
    }

    .upload-progress.active {
      display: block;
    }

    .progress-bar {
      height: 8px;
      background: var(--bg-panel);
      border-radius: 4px;
      overflow: hidden;
      margin-bottom: 8px;
    }

    .progress-fill {
      height: 100%;
      background: var(--accent-warning);
      width: 0%;
      transition: width 0.2s;
      border-radius: 4px;
    }

    .progress-text {
      font-size: 12px;
      color: var(--text-secondary);
      text-align: center;
    }

    /* Settings Panel */
    .settings-panel {
      position: fixed;
      top: 0;
      right: 0;
      bottom: 0;
      width: 360px;
      background: var(--bg-surface);
      border-left: 1px solid var(--border-color);
      transform: translateX(100%);
      transition: transform 0.3s;
      z-index: 100;
      overflow-y: auto;
    }

    .settings-panel.active {
      transform: translateX(0);
    }

    .settings-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 16px 20px;
      border-bottom: 1px solid var(--border-color);
    }

    .settings-title {
      font-size: 16px;
      font-weight: 600;
    }

    .settings-close {
      background: none;
      border: none;
      color: var(--text-secondary);
      cursor: pointer;
      padding: 4px;
    }

    .settings-close:hover {
      color: var(--text-primary);
    }

    .settings-content {
      padding: 20px;
    }

    .settings-group {
      margin-bottom: 24px;
    }

    .settings-group-title {
      font-size: 12px;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 12px;
    }

    .settings-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 0;
      border-bottom: 1px solid var(--border-color);
    }

    .settings-row:last-child {
      border-bottom: none;
    }

    .settings-row-label {
      font-size: 14px;
      color: var(--text-primary);
    }

    .settings-row-value {
      font-size: 13px;
      color: var(--text-secondary);
    }

    .settings-input {
      width: 80px;
      padding: 6px 10px;
      background: var(--bg-panel);
      border: 1px solid var(--border-color);
      border-radius: var(--radius-sm);
      color: var(--text-primary);
      font-size: 13px;
      text-align: center;
    }

    /* Status Toast */
    .status-toast {
      position: fixed;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--bg-elevated);
      border: 1px solid var(--border-color);
      padding: 12px 24px;
      border-radius: var(--radius-md);
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 10px;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s;
      z-index: 1000;
    }

    .status-toast.active {
      opacity: 1;
      visibility: visible;
    }

    .status-toast.success {
      border-color: var(--accent-success);
    }

    .status-toast.success svg {
      color: var(--accent-success);
    }

    .status-toast.error {
      border-color: var(--recording-red);
    }

    .status-toast.error svg {
      color: var(--recording-red);
    }

    .status-toast svg {
      width: 18px;
      height: 18px;
    }

    /* Help Modal */
    .help-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 200;
      opacity: 0;
      visibility: hidden;
      transition: all 0.2s;
    }

    .help-modal.active {
      opacity: 1;
      visibility: visible;
    }

    .help-content {
      background: var(--bg-surface);
      border-radius: var(--radius-lg);
      padding: 32px;
      max-width: 600px;
      max-height: 80vh;
      overflow-y: auto;
    }

    .help-content h2 {
      font-size: 20px;
      margin-bottom: 20px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .help-content h3 {
      font-size: 14px;
      font-weight: 600;
      color: var(--accent-primary);
      margin: 20px 0 10px;
    }

    .help-content p {
      font-size: 14px;
      color: var(--text-secondary);
      line-height: 1.6;
      margin-bottom: 12px;
    }

    .help-content ul {
      margin-left: 20px;
      margin-bottom: 16px;
    }

    .help-content li {
      font-size: 14px;
      color: var(--text-secondary);
      line-height: 1.8;
    }

    .help-close {
      margin-top: 20px;
      width: 100%;
    }

    /* Responsive */
    @media (max-width: 900px) {
      .preview-section {
        grid-template-columns: 1fr;
      }

      .preview-panel.camera {
        aspect-ratio: 16/9;
        max-height: 200px;
      }
    }
  </style>
</head>
<body>
  <!-- Header -->
  <header class="header">
    <div class="header-left">
      <div class="logo">
        <div class="logo-icon">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="10"/>
            <circle cx="12" cy="12" r="3" fill="currentColor"/>
          </svg>
        </div>
        <span class="logo-text">Web Recorder</span>
      </div>
    </div>
    <div class="header-actions">
      <button class="header-btn" onclick="app.toggleSettings()">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <circle cx="12" cy="12" r="3"/>
          <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/>
        </svg>
        Settings
      </button>
      <button class="header-btn" onclick="app.showHelp()">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <circle cx="12" cy="12" r="10"/>
          <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/>
          <line x1="12" y1="17" x2="12.01" y2="17"/>
        </svg>
        Help
      </button>
    </div>
  </header>

  <!-- Main Content -->
  <div class="main-container">
    <!-- Preview Section -->
    <div class="preview-section">
      <!-- Camera Preview -->
      <div class="preview-panel camera" id="cameraPanel">
        <div class="preview-label" id="cameraLabel">
          <span class="dot"></span>
          Camera
        </div>
        <video class="preview-video mirror" id="cameraPreview" autoplay muted playsinline></video>
        <div class="preview-placeholder" id="cameraPlaceholder">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
            <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/>
            <circle cx="12" cy="13" r="4"/>
          </svg>
          <span>Select a camera</span>
        </div>
        <div class="recording-overlay" id="cameraRecordingOverlay"></div>
      </div>

      <!-- Screen Preview -->
      <div class="preview-panel screen" id="screenPanel">
        <div class="preview-label" id="screenLabel">
          <span class="dot"></span>
          Screen
        </div>
        <video class="preview-video" id="screenPreview" autoplay muted playsinline></video>
        <div class="preview-placeholder" id="screenPlaceholder">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
            <rect x="2" y="3" width="20" height="14" rx="2" ry="2"/>
            <line x1="8" y1="21" x2="16" y2="21"/>
            <line x1="12" y1="17" x2="12" y2="21"/>
          </svg>
          <span>Click "Share Screen" to start</span>
        </div>
        <div class="recording-overlay" id="screenRecordingOverlay"></div>
      </div>
    </div>

    <!-- Device Controls -->
    <div class="controls-section">
      <div class="controls-row">
        <div class="source-group">
          <div class="source-label">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/>
              <circle cx="12" cy="13" r="4"/>
            </svg>
            Camera
          </div>
          <select class="source-select" id="cameraSelect" onchange="app.changeCamera()">
            <option value="">Select camera...</option>
          </select>
        </div>

        <div class="source-group">
          <div class="source-label">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/>
              <path d="M19 10v2a7 7 0 0 1-14 0v-2"/>
              <line x1="12" y1="19" x2="12" y2="23"/>
              <line x1="8" y1="23" x2="16" y2="23"/>
            </svg>
            Microphone
          </div>
          <select class="source-select" id="micSelect" onchange="app.changeMic()">
            <option value="">Select microphone...</option>
          </select>
        </div>

        <div class="audio-meter-container">
          <div class="source-label">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/>
              <path d="M19.07 4.93a10 10 0 0 1 0 14.14"/>
              <path d="M15.54 8.46a5 5 0 0 1 0 7.07"/>
            </svg>
            Audio Level
          </div>
          <div class="audio-meter">
            <div class="audio-meter-fill" id="audioMeterFill"></div>
          </div>
        </div>

        <div class="toggle-group">
          <span class="toggle-label">Screen Audio</span>
          <div class="toggle-switch" id="screenAudioToggle" onclick="app.toggleScreenAudio()"></div>
        </div>

        <button class="control-btn secondary" onclick="app.shareScreen()">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <rect x="2" y="3" width="20" height="14" rx="2" ry="2"/>
            <line x1="8" y1="21" x2="16" y2="21"/>
            <line x1="12" y1="17" x2="12" y2="21"/>
          </svg>
          Share Screen
        </button>
      </div>
    </div>

    <!-- Recording Controls -->
    <div class="recording-controls">
      <button class="control-btn secondary" id="pauseBtn" onclick="app.togglePause()" disabled>
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" id="pauseIcon">
          <rect x="6" y="4" width="4" height="16"/>
          <rect x="14" y="4" width="4" height="16"/>
        </svg>
        <span id="pauseText">Pause</span>
      </button>

      <div class="duration-display" id="durationDisplay">
        <span id="currentDuration">00:00:00</span>
        <span class="target" id="targetDuration"></span>
      </div>

      <button class="record-btn" id="recordBtn" onclick="app.toggleRecording()">
        <div class="record-btn-inner"></div>
      </button>

      <div class="duration-display" style="visibility: hidden;">00:00:00</div>

      <button class="control-btn secondary" id="discardBtn" onclick="app.discardRecording()" disabled>
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M3 6h18"/>
          <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
        </svg>
        Discard
      </button>
    </div>

    <!-- Download Section -->
    <div class="download-section" id="downloadSection">
      <div class="download-title">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/>
          <polyline points="22 4 12 14.01 9 11.01"/>
        </svg>
        Recording Complete
      </div>

      <div class="download-grid">
        <!-- Screen Recording Card -->
        <div class="download-card" id="screenDownloadCard">
          <div class="download-card-header">
            <div class="download-card-icon">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="2" y="3" width="20" height="14" rx="2" ry="2"/>
                <line x1="8" y1="21" x2="16" y2="21"/>
                <line x1="12" y1="17" x2="12" y2="21"/>
              </svg>
            </div>
            <div class="download-card-info">
              <h4>Screen Recording</h4>
              <span id="screenFileInfo">--</span>
            </div>
          </div>
          <div class="download-card-actions">
            <button class="download-btn" onclick="app.downloadScreen()">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                <polyline points="7 10 12 15 17 10"/>
                <line x1="12" y1="15" x2="12" y2="3"/>
              </svg>
              Download
            </button>
          </div>
        </div>

        <!-- Camera Recording Card -->
        <div class="download-card" id="cameraDownloadCard">
          <div class="download-card-header">
            <div class="download-card-icon camera">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/>
                <circle cx="12" cy="13" r="4"/>
              </svg>
            </div>
            <div class="download-card-info">
              <h4>Camera Recording</h4>
              <span id="cameraFileInfo">--</span>
            </div>
          </div>
          <div class="download-card-actions">
            <button class="download-btn" onclick="app.downloadCamera()">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                <polyline points="7 10 12 15 17 10"/>
                <line x1="12" y1="15" x2="12" y2="3"/>
              </svg>
              Download
            </button>
          </div>
        </div>
      </div>

      <!-- Cloud Upload -->
      <div class="upload-section">
        <div class="upload-header">
          <div class="upload-title">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
              <polyline points="17 8 12 3 7 8"/>
              <line x1="12" y1="3" x2="12" y2="15"/>
            </svg>
            Cloud Upload
          </div>
        </div>
        <div class="upload-endpoint">
          <input type="text" class="upload-input" id="uploadEndpoint" placeholder="https://em.edison.api.onereach.ai/http/YOUR_ACCOUNT_ID/upload" value="">
          <button class="upload-btn" id="uploadBtn" onclick="app.uploadBoth()">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
              <polyline points="17 8 12 3 7 8"/>
              <line x1="12" y1="3" x2="12" y2="15"/>
            </svg>
            Upload Both
          </button>
        </div>
        <div class="upload-progress" id="uploadProgress">
          <div class="progress-bar">
            <div class="progress-fill" id="uploadProgressFill"></div>
          </div>
          <div class="progress-text" id="uploadProgressText">Uploading...</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Countdown Overlay -->
  <div class="countdown-overlay" id="countdownOverlay">
    <div class="countdown-number" id="countdownNumber">3</div>
    <div class="countdown-text">Recording will start...</div>
  </div>

  <!-- Settings Panel -->
  <div class="settings-panel" id="settingsPanel">
    <div class="settings-header">
      <span class="settings-title">Settings</span>
      <button class="settings-close" onclick="app.toggleSettings()">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <line x1="18" y1="6" x2="6" y2="18"/>
          <line x1="6" y1="6" x2="18" y2="18"/>
        </svg>
      </button>
    </div>
    <div class="settings-content">
      <div class="settings-group">
        <div class="settings-group-title">Recording</div>
        <div class="settings-row">
          <span class="settings-row-label">Countdown Timer</span>
          <input type="number" class="settings-input" id="countdownSetting" value="3" min="0" max="10">
        </div>
        <div class="settings-row">
          <span class="settings-row-label">Target Duration (min)</span>
          <input type="number" class="settings-input" id="targetDurationSetting" value="" min="0" placeholder="âˆž">
        </div>
      </div>

      <div class="settings-group">
        <div class="settings-group-title">Video Quality</div>
        <div class="settings-row">
          <span class="settings-row-label">Video Codec</span>
          <select class="source-select" id="videoCodecSetting" style="width: auto;">
            <option value="vp9">VP9 (WebM)</option>
            <option value="vp8">VP8 (WebM)</option>
            <option value="h264">H.264 (MP4)</option>
          </select>
        </div>
        <div class="settings-row">
          <span class="settings-row-label">Video Bitrate (Mbps)</span>
          <input type="number" class="settings-input" id="videoBitrateSetting" value="8" min="1" max="25" step="0.5">
        </div>
      </div>

      <div class="settings-group">
        <div class="settings-group-title">Crash Recovery</div>
        <div class="settings-row">
          <span class="settings-row-label">Auto-save interval (min)</span>
          <input type="number" class="settings-input" id="autoSaveIntervalSetting" value="2" min="1" max="10">
        </div>
        <div class="settings-row">
          <span class="settings-row-label">Enable crash recovery</span>
          <div class="toggle-switch active" id="crashRecoveryToggle" onclick="app.toggleCrashRecovery()"></div>
        </div>
      </div>

      <div class="settings-group">
        <div class="settings-group-title">Camera</div>
        <div class="settings-row">
          <span class="settings-row-label">Mirror Preview</span>
          <div class="toggle-switch active" id="mirrorToggle" onclick="app.toggleMirror()"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Help Modal -->
  <div class="help-modal" id="helpModal" onclick="app.hideHelp(event)">
    <div class="help-content" onclick="event.stopPropagation()">
      <h2>
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <circle cx="12" cy="12" r="10"/>
          <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/>
          <line x1="12" y1="17" x2="12.01" y2="17"/>
        </svg>
        Web Recorder Help
      </h2>

      <h3>Getting Started</h3>
      <p>This recorder captures your screen and camera simultaneously as separate video files.</p>
      <ul>
        <li>Select your camera and microphone from the dropdowns</li>
        <li>Click "Share Screen" to choose which screen/window to record</li>
        <li>Press the record button to start recording</li>
      </ul>

      <h3>Recording Controls</h3>
      <ul>
        <li><strong>Record Button:</strong> Start/stop recording both streams</li>
        <li><strong>Pause:</strong> Temporarily pause recording</li>
        <li><strong>Discard:</strong> Delete current recording and start over</li>
      </ul>

      <h3>Output Files</h3>
      <p>Two separate files are created:</p>
      <ul>
        <li><strong>Screen Recording:</strong> Contains your screen capture with system audio (if enabled)</li>
        <li><strong>Camera Recording:</strong> Contains your camera with microphone audio</li>
      </ul>

      <h3>Riverside-Quality Recording</h3>
      <p>Like Riverside.fm, this recorder:</p>
      <ul>
        <li><strong>Records locally</strong> at high quality (default 8 Mbps)</li>
        <li><strong>No upload during recording</strong> - full quality preserved</li>
        <li><strong>Crash recovery</strong> - recordings backed up to browser storage</li>
        <li><strong>Auto-save</strong> - periodic backups every 2 minutes (configurable)</li>
      </ul>

      <h3>Browser Support</h3>
      <p>Requires Chrome 72+, Edge 79+, or Firefox 66+. Safari has limited support.</p>

      <h3>Tips</h3>
      <ul>
        <li>Enable "Screen Audio" to capture tab/system audio in the screen recording</li>
        <li>Use the Settings panel to adjust video quality (up to 25 Mbps)</li>
        <li>Enable crash recovery to protect against browser crashes</li>
        <li>Upload happens AFTER recording - you wait while it uploads</li>
        <li>Files can be combined in a video editor after download</li>
      </ul>

      <button class="control-btn primary help-close" onclick="app.hideHelp()">Got it!</button>
    </div>
  </div>

  <!-- Status Toast -->
  <div class="status-toast" id="statusToast">
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/>
      <polyline points="22 4 12 14.01 9 11.01"/>
    </svg>
    <span id="statusText"></span>
  </div>

  <script>
    /**
     * Dual Video Recorder
     * Records screen and camera simultaneously as separate files
     */
    const app = {
      // Streams
      cameraStream: null,
      screenStream: null,

      // Recorders
      cameraRecorder: null,
      screenRecorder: null,

      // Recorded data
      cameraChunks: [],
      screenChunks: [],
      cameraBlob: null,
      screenBlob: null,

      // State
      isRecording: false,
      isPaused: false,
      isUploading: false,
      recordingStartTime: null,
      pausedTime: 0,
      durationInterval: null,
      audioContext: null,
      audioAnalyser: null,
      audioMeterAnimationFrame: null,
      includeScreenAudio: false,

      // Settings (Riverside-quality defaults)
      settings: {
        countdown: 3,
        targetDuration: null,
        videoCodec: 'vp9',
        videoBitrate: 8,          // Higher quality default (8 Mbps like Riverside)
        mirrorCamera: true,
        autoSaveInterval: 2,      // Auto-save every 2 minutes
        enableCrashRecovery: true // IndexedDB backup
      },

      // IndexedDB for crash recovery
      db: null,
      DB_NAME: 'WebRecorderDB',
      DB_VERSION: 1,
      autoSaveTimer: null,

      // DOM Elements
      elements: {},

      /**
       * Initialize the recorder
       */
      async init() {
        console.log('[WebRecorder] Initializing...');
        this.cacheElements();
        this.loadSettings();
        await this.initIndexedDB();
        await this.checkForRecovery();
        await this.loadDevices();
        this.setupAudioMeter();
        console.log('[WebRecorder] Ready - Riverside-quality local recording enabled');
      },

      /**
       * Initialize IndexedDB for crash recovery
       */
      async initIndexedDB() {
        return new Promise((resolve, reject) => {
          const request = indexedDB.open(this.DB_NAME, this.DB_VERSION);

          request.onerror = () => {
            console.warn('[WebRecorder] IndexedDB not available, crash recovery disabled');
            resolve();
          };

          request.onsuccess = (event) => {
            this.db = event.target.result;
            console.log('[WebRecorder] IndexedDB initialized for crash recovery');
            resolve();
          };

          request.onupgradeneeded = (event) => {
            const db = event.target.result;

            // Store for camera chunks
            if (!db.objectStoreNames.contains('cameraChunks')) {
              db.createObjectStore('cameraChunks', { keyPath: 'id', autoIncrement: true });
            }

            // Store for screen chunks
            if (!db.objectStoreNames.contains('screenChunks')) {
              db.createObjectStore('screenChunks', { keyPath: 'id', autoIncrement: true });
            }

            // Store for recording metadata
            if (!db.objectStoreNames.contains('metadata')) {
              db.createObjectStore('metadata', { keyPath: 'key' });
            }
          };
        });
      },

      /**
       * Save chunk to IndexedDB
       */
      async saveChunkToDB(storeName, chunk) {
        if (!this.db) return;

        return new Promise((resolve, reject) => {
          const transaction = this.db.transaction([storeName], 'readwrite');
          const store = transaction.objectStore(storeName);
          const request = store.add({ data: chunk, timestamp: Date.now() });

          request.onsuccess = () => resolve();
          request.onerror = () => reject(request.error);
        });
      },

      /**
       * Get all chunks from IndexedDB
       */
      async getChunksFromDB(storeName) {
        if (!this.db) return [];

        return new Promise((resolve, reject) => {
          const transaction = this.db.transaction([storeName], 'readonly');
          const store = transaction.objectStore(storeName);
          const request = store.getAll();

          request.onsuccess = () => {
            const chunks = request.result.map(item => item.data);
            resolve(chunks);
          };
          request.onerror = () => reject(request.error);
        });
      },

      /**
       * Clear IndexedDB store
       */
      async clearDBStore(storeName) {
        if (!this.db) return;

        return new Promise((resolve, reject) => {
          const transaction = this.db.transaction([storeName], 'readwrite');
          const store = transaction.objectStore(storeName);
          const request = store.clear();

          request.onsuccess = () => resolve();
          request.onerror = () => reject(request.error);
        });
      },

      /**
       * Save recording metadata to IndexedDB
       */
      async saveMetadataToDB(metadata) {
        if (!this.db) return;

        return new Promise((resolve, reject) => {
          const transaction = this.db.transaction(['metadata'], 'readwrite');
          const store = transaction.objectStore('metadata');
          const request = store.put({ key: 'currentRecording', ...metadata });

          request.onsuccess = () => resolve();
          request.onerror = () => reject(request.error);
        });
      },

      /**
       * Check for recoverable recording from previous session
       */
      async checkForRecovery() {
        if (!this.db) return;

        try {
          const cameraChunks = await this.getChunksFromDB('cameraChunks');
          const screenChunks = await this.getChunksFromDB('screenChunks');

          if (cameraChunks.length > 0 || screenChunks.length > 0) {
            const totalSize = [...cameraChunks, ...screenChunks].reduce((sum, chunk) => sum + chunk.size, 0);
            const sizeMB = (totalSize / (1024 * 1024)).toFixed(1);

            if (confirm(`Found ${sizeMB} MB of recoverable recording data from a previous session.\n\nWould you like to recover it?`)) {
              console.log('[WebRecorder] Recovering previous recording...');

              if (cameraChunks.length > 0) {
                this.cameraChunks = cameraChunks;
                this.cameraBlob = new Blob(cameraChunks, { type: this.getMimeType() });
              }

              if (screenChunks.length > 0) {
                this.screenChunks = screenChunks;
                this.screenBlob = new Blob(screenChunks, { type: this.getMimeType() });
              }

              this.showDownloadSection();
              this.showStatus('Recording recovered! You can download your files.', 'success');
            } else {
              // User declined, clear the stored data
              await this.clearAllRecoveryData();
            }
          }
        } catch (error) {
          console.error('[WebRecorder] Recovery check failed:', error);
        }
      },

      /**
       * Clear all recovery data from IndexedDB
       */
      async clearAllRecoveryData() {
        await this.clearDBStore('cameraChunks');
        await this.clearDBStore('screenChunks');
        await this.clearDBStore('metadata');
        console.log('[WebRecorder] Recovery data cleared');
      },

      /**
       * Periodic auto-save to IndexedDB
       */
      startAutoSave() {
        if (!this.db || !this.settings.enableCrashRecovery) return;

        const intervalMs = (this.settings.autoSaveInterval || 2) * 60 * 1000; // Default 2 minutes

        this.autoSaveTimer = setInterval(async () => {
          if (!this.isRecording || this.isPaused) return;

          console.log('[WebRecorder] Auto-saving to IndexedDB...');

          try {
            // Save current chunks
            for (const chunk of this.cameraChunks) {
              await this.saveChunkToDB('cameraChunks', chunk);
            }
            for (const chunk of this.screenChunks) {
              await this.saveChunkToDB('screenChunks', chunk);
            }

            // Save metadata
            await this.saveMetadataToDB({
              recordingStartTime: this.recordingStartTime,
              lastSaveTime: Date.now(),
              duration: (Date.now() - this.recordingStartTime) / 1000
            });

            console.log('[WebRecorder] Auto-save complete');
          } catch (error) {
            console.error('[WebRecorder] Auto-save failed:', error);
          }
        }, intervalMs);
      },

      /**
       * Stop auto-save timer
       */
      stopAutoSave() {
        if (this.autoSaveTimer) {
          clearInterval(this.autoSaveTimer);
          this.autoSaveTimer = null;
        }
      },

      /**
       * Cache DOM elements
       */
      cacheElements() {
        this.elements = {
          // Previews
          cameraPreview: document.getElementById('cameraPreview'),
          screenPreview: document.getElementById('screenPreview'),
          cameraPlaceholder: document.getElementById('cameraPlaceholder'),
          screenPlaceholder: document.getElementById('screenPlaceholder'),
          cameraLabel: document.getElementById('cameraLabel'),
          screenLabel: document.getElementById('screenLabel'),
          cameraRecordingOverlay: document.getElementById('cameraRecordingOverlay'),
          screenRecordingOverlay: document.getElementById('screenRecordingOverlay'),

          // Controls
          cameraSelect: document.getElementById('cameraSelect'),
          micSelect: document.getElementById('micSelect'),
          screenAudioToggle: document.getElementById('screenAudioToggle'),
          recordBtn: document.getElementById('recordBtn'),
          pauseBtn: document.getElementById('pauseBtn'),
          pauseIcon: document.getElementById('pauseIcon'),
          pauseText: document.getElementById('pauseText'),
          discardBtn: document.getElementById('discardBtn'),

          // Duration
          durationDisplay: document.getElementById('durationDisplay'),
          currentDuration: document.getElementById('currentDuration'),
          targetDuration: document.getElementById('targetDuration'),

          // Audio meter
          audioMeterFill: document.getElementById('audioMeterFill'),

          // Download section
          downloadSection: document.getElementById('downloadSection'),
          screenFileInfo: document.getElementById('screenFileInfo'),
          cameraFileInfo: document.getElementById('cameraFileInfo'),
          screenDownloadCard: document.getElementById('screenDownloadCard'),
          cameraDownloadCard: document.getElementById('cameraDownloadCard'),

          // Upload
          uploadEndpoint: document.getElementById('uploadEndpoint'),
          uploadBtn: document.getElementById('uploadBtn'),
          uploadProgress: document.getElementById('uploadProgress'),
          uploadProgressFill: document.getElementById('uploadProgressFill'),
          uploadProgressText: document.getElementById('uploadProgressText'),

          // Countdown
          countdownOverlay: document.getElementById('countdownOverlay'),
          countdownNumber: document.getElementById('countdownNumber'),

          // Settings
          settingsPanel: document.getElementById('settingsPanel'),
          countdownSetting: document.getElementById('countdownSetting'),
          targetDurationSetting: document.getElementById('targetDurationSetting'),
          videoCodecSetting: document.getElementById('videoCodecSetting'),
          videoBitrateSetting: document.getElementById('videoBitrateSetting'),
          mirrorToggle: document.getElementById('mirrorToggle'),
          autoSaveIntervalSetting: document.getElementById('autoSaveIntervalSetting'),
          crashRecoveryToggle: document.getElementById('crashRecoveryToggle'),

          // Status
          statusToast: document.getElementById('statusToast'),
          statusText: document.getElementById('statusText'),

          // Help
          helpModal: document.getElementById('helpModal')
        };
      },

      /**
       * Load settings from localStorage
       */
      loadSettings() {
        try {
          const saved = localStorage.getItem('webRecorderSettings');
          if (saved) {
            this.settings = { ...this.settings, ...JSON.parse(saved) };
          }
        } catch (e) {
          console.warn('[WebRecorder] Failed to load settings:', e);
        }

        // Apply settings to UI
        this.elements.countdownSetting.value = this.settings.countdown;
        this.elements.targetDurationSetting.value = this.settings.targetDuration || '';
        this.elements.videoCodecSetting.value = this.settings.videoCodec;
        this.elements.videoBitrateSetting.value = this.settings.videoBitrate;
        this.elements.autoSaveIntervalSetting.value = this.settings.autoSaveInterval || 2;

        if (this.settings.targetDuration) {
          this.elements.targetDuration.textContent = `/ ${this.formatDuration(this.settings.targetDuration * 60)}`;
        }

        if (!this.settings.mirrorCamera) {
          this.elements.mirrorToggle.classList.remove('active');
          this.elements.cameraPreview.classList.remove('mirror');
        }

        if (!this.settings.enableCrashRecovery) {
          this.elements.crashRecoveryToggle.classList.remove('active');
        }
      },

      /**
       * Save settings to localStorage
       */
      saveSettings() {
        this.settings.countdown = parseInt(this.elements.countdownSetting.value) || 3;
        this.settings.targetDuration = parseInt(this.elements.targetDurationSetting.value) || null;
        this.settings.videoCodec = this.elements.videoCodecSetting.value;
        this.settings.videoBitrate = parseFloat(this.elements.videoBitrateSetting.value) || 8;
        this.settings.autoSaveInterval = parseInt(this.elements.autoSaveIntervalSetting.value) || 2;

        localStorage.setItem('webRecorderSettings', JSON.stringify(this.settings));

        // Update target duration display
        if (this.settings.targetDuration) {
          this.elements.targetDuration.textContent = `/ ${this.formatDuration(this.settings.targetDuration * 60)}`;
        } else {
          this.elements.targetDuration.textContent = '';
        }
      },

      /**
       * Load available media devices
       */
      async loadDevices() {
        try {
          // Request permission first to get device labels
          const tempStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
          tempStream.getTracks().forEach(t => t.stop());

          const devices = await navigator.mediaDevices.enumerateDevices();

          // Video devices
          const videoDevices = devices.filter(d => d.kind === 'videoinput');
          this.elements.cameraSelect.innerHTML = '<option value="">Select camera...</option>';
          videoDevices.forEach((device, i) => {
            const option = document.createElement('option');
            option.value = device.deviceId;
            option.textContent = device.label || `Camera ${i + 1}`;
            this.elements.cameraSelect.appendChild(option);
          });

          // Audio devices
          const audioDevices = devices.filter(d => d.kind === 'audioinput');
          this.elements.micSelect.innerHTML = '<option value="">Select microphone...</option>';
          audioDevices.forEach((device, i) => {
            const option = document.createElement('option');
            option.value = device.deviceId;
            option.textContent = device.label || `Microphone ${i + 1}`;
            this.elements.micSelect.appendChild(option);
          });

          // Auto-select first devices
          if (videoDevices.length > 0) {
            this.elements.cameraSelect.value = videoDevices[0].deviceId;
            await this.changeCamera();
          }
          if (audioDevices.length > 0) {
            this.elements.micSelect.value = audioDevices[0].deviceId;
          }
        } catch (error) {
          console.error('[WebRecorder] Device enumeration error:', error);
          this.showStatus('Failed to access media devices: ' + error.message, 'error');
        }
      },

      /**
       * Setup audio level meter
       */
      setupAudioMeter() {
        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        this.audioAnalyser = this.audioContext.createAnalyser();
        this.audioAnalyser.fftSize = 256;
      },

      /**
       * Update audio meter visualization
       */
      updateAudioMeter() {
        if (!this.audioAnalyser) return;

        const dataArray = new Uint8Array(this.audioAnalyser.frequencyBinCount);
        this.audioAnalyser.getByteFrequencyData(dataArray);

        // Calculate average volume
        const average = dataArray.reduce((a, b) => a + b, 0) / dataArray.length;
        const percentage = Math.min(100, (average / 128) * 100);

        this.elements.audioMeterFill.style.width = `${percentage}%`;

        this.audioMeterAnimationFrame = requestAnimationFrame(() => this.updateAudioMeter());
      },

      /**
       * Change camera device
       */
      async changeCamera() {
        const deviceId = this.elements.cameraSelect.value;
        if (!deviceId) {
          if (this.cameraStream) {
            this.cameraStream.getTracks().forEach(t => t.stop());
            this.cameraStream = null;
          }
          this.elements.cameraPreview.srcObject = null;
          this.elements.cameraPlaceholder.classList.remove('hidden');
          return;
        }

        try {
          // Stop existing camera stream
          if (this.cameraStream) {
            this.cameraStream.getTracks().forEach(t => t.stop());
          }

          const micId = this.elements.micSelect.value;

          this.cameraStream = await navigator.mediaDevices.getUserMedia({
            video: { deviceId: { exact: deviceId }, width: { ideal: 1280 }, height: { ideal: 720 } },
            audio: micId ? { deviceId: { exact: micId } } : true
          });

          this.elements.cameraPreview.srcObject = this.cameraStream;
          this.elements.cameraPlaceholder.classList.add('hidden');

          // Connect to audio meter
          if (this.cameraStream.getAudioTracks().length > 0) {
            const source = this.audioContext.createMediaStreamSource(this.cameraStream);
            source.connect(this.audioAnalyser);
            if (!this.audioMeterAnimationFrame) {
              this.updateAudioMeter();
            }
          }
        } catch (error) {
          console.error('[WebRecorder] Camera error:', error);
          this.showStatus('Failed to access camera: ' + error.message, 'error');
        }
      },

      /**
       * Change microphone device
       */
      async changeMic() {
        // Re-initialize camera stream with new mic
        if (this.elements.cameraSelect.value) {
          await this.changeCamera();
        }
      },

      /**
       * Share screen
       */
      async shareScreen() {
        try {
          // Stop existing screen stream
          if (this.screenStream) {
            this.screenStream.getTracks().forEach(t => t.stop());
          }

          const constraints = {
            video: {
              cursor: 'always',
              displaySurface: 'monitor'
            },
            audio: this.includeScreenAudio
          };

          this.screenStream = await navigator.mediaDevices.getDisplayMedia(constraints);

          this.elements.screenPreview.srcObject = this.screenStream;
          this.elements.screenPlaceholder.classList.add('hidden');

          // Handle stream ended (user clicked stop sharing)
          this.screenStream.getVideoTracks()[0].onended = () => {
            this.screenStream = null;
            this.elements.screenPreview.srcObject = null;
            this.elements.screenPlaceholder.classList.remove('hidden');

            // Stop recording if active
            if (this.isRecording) {
              this.stopRecording();
            }
          };
        } catch (error) {
          if (error.name !== 'AbortError') {
            console.error('[WebRecorder] Screen share error:', error);
            this.showStatus('Failed to share screen: ' + error.message, 'error');
          }
        }
      },

      /**
       * Toggle screen audio
       */
      toggleScreenAudio() {
        this.includeScreenAudio = !this.includeScreenAudio;
        this.elements.screenAudioToggle.classList.toggle('active', this.includeScreenAudio);

        // If screen is already shared, re-share with audio
        if (this.screenStream) {
          this.shareScreen();
        }
      },

      /**
       * Toggle recording
       */
      async toggleRecording() {
        if (this.isRecording) {
          this.stopRecording();
        } else {
          await this.startRecording();
        }
      },

      /**
       * Start recording with countdown
       */
      async startRecording() {
        // Validate streams
        if (!this.cameraStream && !this.screenStream) {
          this.showStatus('Please select a camera or share your screen first', 'error');
          return;
        }

        // Save settings
        this.saveSettings();

        // Show countdown
        const countdownTime = this.settings.countdown;
        if (countdownTime > 0) {
          await this.showCountdown(countdownTime);
        }

        // Reset chunks
        this.cameraChunks = [];
        this.screenChunks = [];
        this.cameraBlob = null;
        this.screenBlob = null;

        // Hide download section
        this.elements.downloadSection.classList.remove('active');

        // Get mime type based on codec setting
        const mimeType = this.getMimeType();

        // Create camera recorder
        if (this.cameraStream) {
          try {
            this.cameraRecorder = new MediaRecorder(this.cameraStream, {
              mimeType,
              videoBitsPerSecond: this.settings.videoBitrate * 1000000
            });
          } catch (e) {
            // Fallback
            this.cameraRecorder = new MediaRecorder(this.cameraStream);
          }

          this.cameraRecorder.ondataavailable = (e) => {
            if (e.data.size > 0) {
              this.cameraChunks.push(e.data);
            }
          };

          this.cameraRecorder.onstop = () => {
            this.cameraBlob = new Blob(this.cameraChunks, { type: mimeType });
          };
        }

        // Create screen recorder
        if (this.screenStream) {
          try {
            this.screenRecorder = new MediaRecorder(this.screenStream, {
              mimeType,
              videoBitsPerSecond: this.settings.videoBitrate * 1000000
            });
          } catch (e) {
            // Fallback
            this.screenRecorder = new MediaRecorder(this.screenStream);
          }

          this.screenRecorder.ondataavailable = (e) => {
            if (e.data.size > 0) {
              this.screenChunks.push(e.data);
            }
          };

          this.screenRecorder.onstop = () => {
            this.screenBlob = new Blob(this.screenChunks, { type: mimeType });
          };
        }

        // Clear previous recovery data before starting new recording
        await this.clearAllRecoveryData();

        // Start both recorders
        if (this.cameraRecorder) this.cameraRecorder.start(1000);
        if (this.screenRecorder) this.screenRecorder.start(1000);

        this.isRecording = true;
        this.isPaused = false;
        this.pausedTime = 0;
        this.recordingStartTime = Date.now();

        // Start auto-save for crash recovery
        this.startAutoSave();

        // Update UI
        this.elements.recordBtn.classList.add('recording');
        this.elements.durationDisplay.classList.add('recording');
        this.elements.cameraLabel.classList.add('recording');
        this.elements.screenLabel.classList.add('recording');
        this.elements.cameraRecordingOverlay.classList.add('active');
        this.elements.screenRecordingOverlay.classList.add('active');
        this.elements.pauseBtn.disabled = false;
        this.elements.discardBtn.disabled = false;

        // Start duration counter
        this.durationInterval = setInterval(() => this.updateDuration(), 100);

        console.log('[WebRecorder] Recording started');
      },

      /**
       * Stop recording
       */
      async stopRecording() {
        // Stop auto-save
        this.stopAutoSave();

        // Stop recorders
        if (this.cameraRecorder && this.cameraRecorder.state !== 'inactive') {
          this.cameraRecorder.stop();
        }
        if (this.screenRecorder && this.screenRecorder.state !== 'inactive') {
          this.screenRecorder.stop();
        }

        this.isRecording = false;
        this.isPaused = false;
        clearInterval(this.durationInterval);

        // Update UI
        this.elements.recordBtn.classList.remove('recording');
        this.elements.durationDisplay.classList.remove('recording');
        this.elements.cameraLabel.classList.remove('recording');
        this.elements.screenLabel.classList.remove('recording');
        this.elements.cameraRecordingOverlay.classList.remove('active');
        this.elements.screenRecordingOverlay.classList.remove('active');
        this.elements.pauseBtn.disabled = true;
        this.elements.discardBtn.disabled = true;

        // Reset pause button
        this.elements.pauseText.textContent = 'Pause';
        this.elements.pauseIcon.innerHTML = '<rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/>';

        console.log('[WebRecorder] Recording stopped - preparing upload...');

        // Wait for blobs to finalize, then auto-upload
        setTimeout(() => this.handleRecordingComplete(), 200);
      },

      /**
       * Handle recording complete - auto-upload or show download
       */
      async handleRecordingComplete() {
        // Finalize blobs if not already done
        if (this.cameraChunks.length > 0 && !this.cameraBlob) {
          this.cameraBlob = new Blob(this.cameraChunks, { type: this.getMimeType() });
        }
        if (this.screenChunks.length > 0 && !this.screenBlob) {
          this.screenBlob = new Blob(this.screenChunks, { type: this.getMimeType() });
        }

        const endpoint = this.elements.uploadEndpoint.value.trim();

        if (endpoint && (this.cameraBlob || this.screenBlob)) {
          // Auto-upload to server
          console.log('[WebRecorder] Auto-uploading to:', endpoint);
          await this.autoUpload(endpoint);
        } else {
          // No endpoint configured - show download section
          console.log('[WebRecorder] No upload endpoint - showing download options');
          this.showDownloadSection();
          
          if (!endpoint) {
            this.showStatus('Recording complete! Configure upload endpoint or download files.', 'success');
          }
        }

        // Clear recovery data after successful handling
        await this.clearAllRecoveryData();
      },

      /**
       * Auto-upload after recording stops
       */
      async autoUpload(endpoint) {
        // Set uploading state
        this.isUploading = true;

        // Show download section with upload in progress
        this.elements.downloadSection.classList.add('active');
        this.elements.uploadProgress.classList.add('active');
        this.elements.uploadBtn.disabled = true;
        this.elements.uploadBtn.textContent = 'Uploading...';

        try {
          const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
          const totalBytes = (this.screenBlob?.size || 0) + (this.cameraBlob?.size || 0);
          let uploadedBytes = 0;

          const updateOverallProgress = (fileBytes, currentFileProgress) => {
            const currentFileBytes = (currentFileProgress / 100) * fileBytes;
            const overallProgress = ((uploadedBytes + currentFileBytes) / totalBytes) * 100;
            this.elements.uploadProgressFill.style.width = `${overallProgress}%`;
          };

          // Update file info while uploading
          if (this.screenBlob) {
            const sizeMB = (this.screenBlob.size / (1024 * 1024)).toFixed(1);
            this.elements.screenFileInfo.textContent = `${sizeMB} MB â€¢ Uploading...`;
          }
          if (this.cameraBlob) {
            const sizeMB = (this.cameraBlob.size / (1024 * 1024)).toFixed(1);
            this.elements.cameraFileInfo.textContent = `${sizeMB} MB â€¢ Uploading...`;
          }

          // Upload screen recording
          if (this.screenBlob) {
            const sizeMB = (this.screenBlob.size / (1024 * 1024)).toFixed(1);
            this.elements.uploadProgressText.textContent = `Uploading screen recording (${sizeMB} MB)...`;

            await this.uploadFile(
              endpoint,
              this.screenBlob,
              `recording_screen_${timestamp}.${this.getFileExtension()}`,
              'screen',
              (percent, loaded, total) => {
                updateOverallProgress(this.screenBlob.size, percent);
                this.elements.uploadProgressText.textContent = `Uploading screen: ${percent}% (${(loaded / 1024 / 1024).toFixed(1)} / ${sizeMB} MB)`;
              }
            );
            uploadedBytes += this.screenBlob.size;
            this.elements.screenFileInfo.textContent = `${sizeMB} MB â€¢ âœ“ Uploaded`;
          }

          // Upload camera recording
          if (this.cameraBlob) {
            const sizeMB = (this.cameraBlob.size / (1024 * 1024)).toFixed(1);
            this.elements.uploadProgressText.textContent = `Uploading camera recording (${sizeMB} MB)...`;

            await this.uploadFile(
              endpoint,
              this.cameraBlob,
              `recording_camera_${timestamp}.${this.getFileExtension()}`,
              'camera',
              (percent, loaded, total) => {
                updateOverallProgress(this.cameraBlob.size, percent);
                this.elements.uploadProgressText.textContent = `Uploading camera: ${percent}% (${(loaded / 1024 / 1024).toFixed(1)} / ${sizeMB} MB)`;
              }
            );
            uploadedBytes += this.cameraBlob.size;
            this.elements.cameraFileInfo.textContent = `${sizeMB} MB â€¢ âœ“ Uploaded`;
          }

          // Success!
          this.isUploading = false;
          this.elements.uploadProgressFill.style.width = '100%';
          this.elements.uploadProgressText.textContent = `âœ“ Upload complete! (${(totalBytes / 1024 / 1024).toFixed(1)} MB)`;
          this.showStatus('Recording uploaded successfully!', 'success');

          // Keep progress visible for a moment
          setTimeout(() => {
            this.elements.uploadBtn.disabled = false;
            this.elements.uploadBtn.innerHTML = `
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                <polyline points="17 8 12 3 7 8"/>
                <line x1="12" y1="3" x2="12" y2="15"/>
              </svg>
              Re-upload`;
          }, 2000);

        } catch (error) {
          this.isUploading = false;
          console.error('[WebRecorder] Auto-upload failed:', error);
          this.elements.uploadProgressText.textContent = `âœ— Upload failed: ${error.message}`;
          this.showStatus('Upload failed - you can download files or retry', 'error');

          // Update file info to show failed status
          if (this.screenBlob) {
            const sizeMB = (this.screenBlob.size / (1024 * 1024)).toFixed(1);
            this.elements.screenFileInfo.textContent = `${sizeMB} MB â€¢ âœ— Upload failed`;
          }
          if (this.cameraBlob) {
            const sizeMB = (this.cameraBlob.size / (1024 * 1024)).toFixed(1);
            this.elements.cameraFileInfo.textContent = `${sizeMB} MB â€¢ âœ— Upload failed`;
          }

          // Re-enable upload button for retry
          this.elements.uploadBtn.disabled = false;
          this.elements.uploadBtn.innerHTML = `
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
              <polyline points="17 8 12 3 7 8"/>
              <line x1="12" y1="3" x2="12" y2="15"/>
            </svg>
            Retry Upload`;
        }
      },

      /**
       * Toggle pause
       */
      togglePause() {
        if (!this.isRecording) return;

        if (this.isPaused) {
          // Resume
          if (this.cameraRecorder) this.cameraRecorder.resume();
          if (this.screenRecorder) this.screenRecorder.resume();
          this.isPaused = false;
          this.recordingStartTime = Date.now() - this.pausedTime;

          this.elements.pauseText.textContent = 'Pause';
          this.elements.pauseIcon.innerHTML = '<rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/>';
        } else {
          // Pause
          if (this.cameraRecorder) this.cameraRecorder.pause();
          if (this.screenRecorder) this.screenRecorder.pause();
          this.isPaused = true;
          this.pausedTime = Date.now() - this.recordingStartTime;

          this.elements.pauseText.textContent = 'Resume';
          this.elements.pauseIcon.innerHTML = '<polygon points="5 3 19 12 5 21 5 3"/>';
        }
      },

      /**
       * Discard recording
       */
      discardRecording() {
        if (confirm('Are you sure you want to discard the current recording?')) {
          this.stopRecording();
          this.cameraChunks = [];
          this.screenChunks = [];
          this.cameraBlob = null;
          this.screenBlob = null;
          this.elements.currentDuration.textContent = '00:00:00';
          this.elements.downloadSection.classList.remove('active');
          this.showStatus('Recording discarded', 'error');
        }
      },

      /**
       * Show countdown overlay
       */
      showCountdown(seconds) {
        return new Promise((resolve) => {
          this.elements.countdownOverlay.classList.add('active');
          let remaining = seconds;

          const tick = () => {
            if (remaining <= 0) {
              this.elements.countdownOverlay.classList.remove('active');
              resolve();
              return;
            }

            this.elements.countdownNumber.textContent = remaining;
            this.elements.countdownNumber.style.animation = 'none';
            void this.elements.countdownNumber.offsetHeight; // Trigger reflow
            this.elements.countdownNumber.style.animation = 'countdownPulse 1s ease-out';

            remaining--;
            setTimeout(tick, 1000);
          };

          tick();
        });
      },

      /**
       * Update duration display
       */
      updateDuration() {
        if (this.isPaused) return;

        const elapsed = (Date.now() - this.recordingStartTime) / 1000;
        this.elements.currentDuration.textContent = this.formatDuration(elapsed);

        // Check target duration
        if (this.settings.targetDuration && elapsed >= this.settings.targetDuration * 60) {
          this.stopRecording();
          this.showStatus('Target duration reached', 'success');
        }
      },

      /**
       * Show download section
       */
      showDownloadSection() {
        this.elements.downloadSection.classList.add('active');

        // Update file info
        if (this.screenBlob) {
          const sizeMB = (this.screenBlob.size / (1024 * 1024)).toFixed(2);
          this.elements.screenFileInfo.textContent = `${sizeMB} MB â€¢ ${this.getFileExtension()}`;
          this.elements.screenDownloadCard.style.display = 'block';
        } else {
          this.elements.screenDownloadCard.style.display = 'none';
        }

        if (this.cameraBlob) {
          const sizeMB = (this.cameraBlob.size / (1024 * 1024)).toFixed(2);
          this.elements.cameraFileInfo.textContent = `${sizeMB} MB â€¢ ${this.getFileExtension()}`;
          this.elements.cameraDownloadCard.style.display = 'block';
        } else {
          this.elements.cameraDownloadCard.style.display = 'none';
        }
      },

      /**
       * Download screen recording
       */
      downloadScreen() {
        if (!this.screenBlob) return;

        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
        const filename = `recording_screen_${timestamp}.${this.getFileExtension()}`;
        this.downloadBlob(this.screenBlob, filename);
        this.showStatus('Screen recording downloaded', 'success');
      },

      /**
       * Download camera recording
       */
      downloadCamera() {
        if (!this.cameraBlob) return;

        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
        const filename = `recording_camera_${timestamp}.${this.getFileExtension()}`;
        this.downloadBlob(this.cameraBlob, filename);
        this.showStatus('Camera recording downloaded', 'success');
      },

      /**
       * Download both recordings as separate files
       */
      downloadBoth() {
        if (this.screenBlob) this.downloadScreen();
        if (this.cameraBlob) {
          setTimeout(() => this.downloadCamera(), 500);
        }
      },

      /**
       * Download a blob as file
       */
      downloadBlob(blob, filename) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      },

      /**
       * Upload both recordings
       */
      async uploadBoth() {
        const endpoint = this.elements.uploadEndpoint.value.trim();
        if (!endpoint) {
          this.showStatus('Please enter an upload endpoint', 'error');
          return;
        }

        if (!this.screenBlob && !this.cameraBlob) {
          this.showStatus('No recordings to upload', 'error');
          return;
        }

        this.isUploading = true;
        this.elements.uploadProgress.classList.add('active');
        this.elements.uploadBtn.disabled = true;

        try {
          const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
          const totalFiles = (this.screenBlob ? 1 : 0) + (this.cameraBlob ? 1 : 0);
          const totalBytes = (this.screenBlob?.size || 0) + (this.cameraBlob?.size || 0);
          let uploadedBytes = 0;
          let uploadedFiles = 0;

          const updateOverallProgress = (fileBytes, currentFileProgress) => {
            const currentFileBytes = (currentFileProgress / 100) * fileBytes;
            const overallProgress = ((uploadedBytes + currentFileBytes) / totalBytes) * 100;
            this.elements.uploadProgressFill.style.width = `${overallProgress}%`;
          };

          // Upload screen recording
          if (this.screenBlob) {
            const sizeMB = (this.screenBlob.size / (1024 * 1024)).toFixed(1);
            this.elements.uploadProgressText.textContent = `Uploading screen recording (${sizeMB} MB)...`;

            await this.uploadFile(
              endpoint,
              this.screenBlob,
              `recording_screen_${timestamp}.${this.getFileExtension()}`,
              'screen',
              (percent, loaded, total) => {
                updateOverallProgress(this.screenBlob.size, percent);
                this.elements.uploadProgressText.textContent = `Uploading screen: ${percent}% (${(loaded / 1024 / 1024).toFixed(1)} / ${sizeMB} MB)`;
              }
            );
            uploadedBytes += this.screenBlob.size;
            uploadedFiles++;
          }

          // Upload camera recording
          if (this.cameraBlob) {
            const sizeMB = (this.cameraBlob.size / (1024 * 1024)).toFixed(1);
            this.elements.uploadProgressText.textContent = `Uploading camera recording (${sizeMB} MB)...`;

            await this.uploadFile(
              endpoint,
              this.cameraBlob,
              `recording_camera_${timestamp}.${this.getFileExtension()}`,
              'camera',
              (percent, loaded, total) => {
                updateOverallProgress(this.cameraBlob.size, percent);
                this.elements.uploadProgressText.textContent = `Uploading camera: ${percent}% (${(loaded / 1024 / 1024).toFixed(1)} / ${sizeMB} MB)`;
              }
            );
            uploadedBytes += this.cameraBlob.size;
            uploadedFiles++;
          }

          this.elements.uploadProgressFill.style.width = '100%';
          this.elements.uploadProgressText.textContent = `âœ“ Upload complete! (${(totalBytes / 1024 / 1024).toFixed(1)} MB)`;
          this.showStatus('Recordings uploaded successfully', 'success');

          setTimeout(() => {
            this.elements.uploadProgress.classList.remove('active');
            this.elements.uploadProgressFill.style.width = '0%';
          }, 3000);
        } catch (error) {
          console.error('[WebRecorder] Upload error:', error);
          this.elements.uploadProgressText.textContent = 'Upload failed: ' + error.message;
          this.showStatus('Upload failed: ' + error.message, 'error');
        } finally {
          this.isUploading = false;
          this.elements.uploadBtn.disabled = false;
        }
      },

      /**
       * Upload a single file with progress tracking
       */
      async uploadFile(endpoint, blob, filename, type, onProgress) {
        return new Promise((resolve, reject) => {
          const formData = new FormData();
          formData.append('file', blob, filename);
          formData.append('filename', filename);
          formData.append('type', type);
          formData.append('metadata', JSON.stringify({
            duration: this.elements.currentDuration.textContent,
            recordedAt: new Date().toISOString(),
            codec: this.settings.videoCodec,
            bitrate: this.settings.videoBitrate,
            size: blob.size
          }));

          const xhr = new XMLHttpRequest();

          // Track upload progress
          xhr.upload.addEventListener('progress', (e) => {
            if (e.lengthComputable && onProgress) {
              const percent = Math.round((e.loaded / e.total) * 100);
              onProgress(percent, e.loaded, e.total);
            }
          });

          xhr.addEventListener('load', () => {
            if (xhr.status >= 200 && xhr.status < 300) {
              try {
                const response = JSON.parse(xhr.responseText);
                resolve(response);
              } catch (e) {
                resolve({ success: true, status: xhr.status });
              }
            } else {
              reject(new Error(`HTTP ${xhr.status}: ${xhr.statusText}`));
            }
          });

          xhr.addEventListener('error', () => {
            reject(new Error('Network error during upload'));
          });

          xhr.addEventListener('abort', () => {
            reject(new Error('Upload aborted'));
          });

          xhr.open('POST', endpoint);
          xhr.send(formData);
        });
      },

      /**
       * Legacy upload method for compatibility
       */
      async uploadFileFetch(endpoint, blob, filename, type) {
        const formData = new FormData();
        formData.append('file', blob, filename);
        formData.append('filename', filename);
        formData.append('type', type);
        formData.append('metadata', JSON.stringify({
          duration: this.elements.currentDuration.textContent,
          recordedAt: new Date().toISOString(),
          codec: this.settings.videoCodec,
          bitrate: this.settings.videoBitrate
        }));

        const response = await fetch(endpoint, {
          method: 'POST',
          body: formData
        });

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        return response.json();
      },

      /**
       * Get MIME type based on codec setting
       */
      getMimeType() {
        switch (this.settings.videoCodec) {
          case 'h264':
            return 'video/mp4;codecs=avc1.42E01E,mp4a.40.2';
          case 'vp8':
            return 'video/webm;codecs=vp8,opus';
          case 'vp9':
          default:
            return 'video/webm;codecs=vp9,opus';
        }
      },

      /**
       * Get file extension based on codec setting
       */
      getFileExtension() {
        return this.settings.videoCodec === 'h264' ? 'mp4' : 'webm';
      },

      /**
       * Format duration as HH:MM:SS
       */
      formatDuration(seconds) {
        const hrs = Math.floor(seconds / 3600);
        const mins = Math.floor((seconds % 3600) / 60);
        const secs = Math.floor(seconds % 60);
        return `${hrs.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
      },

      /**
       * Toggle settings panel
       */
      toggleSettings() {
        this.elements.settingsPanel.classList.toggle('active');
        if (!this.elements.settingsPanel.classList.contains('active')) {
          this.saveSettings();
        }
      },

      /**
       * Toggle camera mirror
       */
      toggleMirror() {
        this.settings.mirrorCamera = !this.settings.mirrorCamera;
        this.elements.mirrorToggle.classList.toggle('active', this.settings.mirrorCamera);
        this.elements.cameraPreview.classList.toggle('mirror', this.settings.mirrorCamera);
        this.saveSettings();
      },

      /**
       * Toggle crash recovery
       */
      toggleCrashRecovery() {
        this.settings.enableCrashRecovery = !this.settings.enableCrashRecovery;
        this.elements.crashRecoveryToggle.classList.toggle('active', this.settings.enableCrashRecovery);
        this.saveSettings();

        if (this.settings.enableCrashRecovery) {
          this.showStatus('Crash recovery enabled - recordings will be backed up', 'success');
        } else {
          this.showStatus('Crash recovery disabled', 'error');
        }
      },

      /**
       * Show help modal
       */
      showHelp() {
        this.elements.helpModal.classList.add('active');
      },

      /**
       * Hide help modal
       */
      hideHelp(event) {
        if (!event || event.target === this.elements.helpModal) {
          this.elements.helpModal.classList.remove('active');
        }
      },

      /**
       * Show status toast
       */
      showStatus(message, type = 'success') {
        this.elements.statusText.textContent = message;
        this.elements.statusToast.className = `status-toast active ${type}`;

        // Update icon
        const icon = type === 'success'
          ? '<path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/>'
          : '<circle cx="12" cy="12" r="10"/><line x1="15" y1="9" x2="9" y2="15"/><line x1="9" y1="9" x2="15" y2="15"/>';
        this.elements.statusToast.querySelector('svg').innerHTML = icon;

        setTimeout(() => {
          this.elements.statusToast.classList.remove('active');
        }, 3000);
      }
    };

    // Initialize on load
    document.addEventListener('DOMContentLoaded', () => app.init());

    // Handle page unload - warn during recording OR upload
    window.addEventListener('beforeunload', (e) => {
      if (app.isRecording) {
        e.preventDefault();
        e.returnValue = 'Recording in progress. Are you sure you want to leave?';
      } else if (app.isUploading) {
        e.preventDefault();
        e.returnValue = 'Upload in progress. Leaving now will cancel the upload. Are you sure?';
      }
    });
  </script>
</body>
</html>





































