/**
 * YouTube Downloader Module
 * Downloads YouTube videos and stores them in OR-Spaces
 * Uses yt-dlp for reliable downloads (prefers system install, falls back to bundled)
 */

const path = require('path');
const fs = require('fs');
const os = require('os');
const https = require('https');
const { execSync, spawn } = require('child_process');

let youtubedl;
let ytdlpPath = null;

// Try to find system-installed yt-dlp first (avoids Python version issues)
function findYtdlp() {
  const possiblePaths = [
    '/opt/homebrew/bin/yt-dlp',      // Homebrew on Apple Silicon
    '/usr/local/bin/yt-dlp',          // Homebrew on Intel Mac
    '/usr/bin/yt-dlp',                // System install
    path.join(os.homedir(), '.local/bin/yt-dlp'), // pip install --user
  ];
  
  for (const p of possiblePaths) {
    if (fs.existsSync(p)) {
      console.log('[YouTubeDownloader] Found system yt-dlp at:', p);
      return p;
    }
  }
  
  // Try which command
  try {
    const result = execSync('which yt-dlp', { encoding: 'utf8' }).trim();
    if (result && fs.existsSync(result)) {
      console.log('[YouTubeDownloader] Found yt-dlp via which:', result);
      return result;
    }
  } catch (e) {
    // yt-dlp not found in PATH
  }
  
  return null;
}

// Initialize yt-dlp
ytdlpPath = findYtdlp();
console.log('[YouTubeDownloader] System yt-dlp path:', ytdlpPath);

try {
  const ytdlModule = require('youtube-dl-exec');
  console.log('[YouTubeDownloader] youtube-dl-exec module loaded, has create:', typeof ytdlModule.create);
  
  if (ytdlpPath && typeof ytdlModule.create === 'function') {
    // Use system yt-dlp with youtube-dl-exec
    youtubedl = ytdlModule.create(ytdlpPath);
    console.log('[YouTubeDownloader] Created custom instance with system yt-dlp:', ytdlpPath);
    console.log('[YouTubeDownloader] youtubedl is function:', typeof youtubedl === 'function');
  } else {
    // Use default (bundled) version
    youtubedl = ytdlModule;
    console.log('[YouTubeDownloader] Using default youtube-dl-exec instance');
    console.log('[YouTubeDownloader] youtubedl is function:', typeof youtubedl === 'function');
  }
} catch (e) {
  console.error('[YouTubeDownloader] Failed to initialize youtube-dl-exec:', e.message);
}

class YouTubeDownloader {
  constructor() {
    this.downloadDir = path.join(os.tmpdir(), 'or-youtube-downloads');
    this.ensureDownloadDir();
  }

  ensureDownloadDir() {
    if (!fs.existsSync(this.downloadDir)) {
      fs.mkdirSync(this.downloadDir, { recursive: true });
    }
  }

  /**
   * Check if a URL is a YouTube video
   */
  static isYouTubeUrl(url) {
    if (!url || typeof url !== 'string') return false;
    
    const patterns = [
      /^(https?:\/\/)?(www\.)?youtube\.com\/watch\?v=[\w-]+/i,
      /^(https?:\/\/)?(www\.)?youtube\.com\/shorts\/[\w-]+/i,
      /^(https?:\/\/)?youtu\.be\/[\w-]+/i,
      /^(https?:\/\/)?(www\.)?youtube\.com\/embed\/[\w-]+/i,
      /^(https?:\/\/)?(www\.)?youtube\.com\/v\/[\w-]+/i,
      /^(https?:\/\/)?m\.youtube\.com\/watch\?v=[\w-]+/i,
    ];
    
    return patterns.some(pattern => pattern.test(url.trim()));
  }

  /**
   * Extract video ID from YouTube URL
   */
  static extractVideoId(url) {
    if (!url) return null;
    
    const patterns = [
      /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/|youtube\.com\/v\/|youtube\.com\/shorts\/)([a-zA-Z0-9_-]{11})/,
    ];
    
    for (const pattern of patterns) {
      const match = url.match(pattern);
      if (match) return match[1];
    }
    
    return null;
  }

  /**
   * Check if yt-dlp is available
   */
  static isAvailable() {
    return !!youtubedl && !!ytdlpPath;
  }

  /**
   * Get transcript/captions from a YouTube video
   * @param {string} url - YouTube URL
   * @param {string} lang - Language code (default: 'en')
   * @returns {object} - { success, transcript, language, isAutoGenerated }
   */
  async getTranscript(url, lang = 'en') {
    if (!youtubedl) {
      const instructions = YouTubeDownloader.getInstallInstructions();
      throw new Error(`yt-dlp not found. ${instructions}`);
    }

    try {
      console.log('[YouTubeDownloader] Fetching transcript for:', url, 'lang:', lang);
      
      // First, get available subtitles
      const info = await youtubedl(url, {
        dumpSingleJson: true,
        noCheckCertificates: true,
        noWarnings: true,
        skipDownload: true,
      });

      // Check for available subtitles
      const subtitles = info.subtitles || {};
      const automaticCaptions = info.automatic_captions || {};
      
      console.log('[YouTubeDownloader] Available subtitles:', Object.keys(subtitles));
      console.log('[YouTubeDownloader] Available auto-captions:', Object.keys(automaticCaptions));

      // Prefer manual subtitles, fall back to auto-generated
      let selectedLang = null;
      let isAutoGenerated = false;
      let subtitleData = null;

      // Try exact language match first
      if (subtitles[lang]) {
        selectedLang = lang;
        subtitleData = subtitles[lang];
      } else if (automaticCaptions[lang]) {
        selectedLang = lang;
        subtitleData = automaticCaptions[lang];
        isAutoGenerated = true;
      }
      // Try language variants (e.g., 'en-US' when 'en' requested)
      else {
        for (const key of Object.keys(subtitles)) {
          if (key.startsWith(lang)) {
            selectedLang = key;
            subtitleData = subtitles[key];
            break;
          }
        }
        if (!selectedLang) {
          for (const key of Object.keys(automaticCaptions)) {
            if (key.startsWith(lang)) {
              selectedLang = key;
              subtitleData = automaticCaptions[key];
              isAutoGenerated = true;
              break;
            }
          }
        }
      }

      if (!selectedLang || !subtitleData) {
        return {
          success: false,
          error: `No ${lang} transcript available for this video`,
          availableLanguages: [...Object.keys(subtitles), ...Object.keys(automaticCaptions).map(k => k + ' (auto)')],
        };
      }

      // Download the transcript
      this.ensureDownloadDir();
      const outputPath = path.join(this.downloadDir, `transcript-${Date.now()}`);
      
      await youtubedl(url, {
        skipDownload: true,
        writeSub: !isAutoGenerated,
        writeAutoSub: isAutoGenerated,
        subLang: selectedLang,
        subFormat: 'vtt',
        output: outputPath,
        noCheckCertificates: true,
        noWarnings: true,
      });

      // Read the transcript file
      const vttFile = `${outputPath}.${selectedLang}.vtt`;
      let transcriptData = null;
      
      if (fs.existsSync(vttFile)) {
        const vttContent = fs.readFileSync(vttFile, 'utf8');
        transcriptData = this.parseVTT(vttContent);
        fs.unlinkSync(vttFile); // Clean up
      } else {
        // Try alternate naming
        const files = fs.readdirSync(this.downloadDir);
        const transcriptFile = files.find(f => f.includes('transcript-') && f.endsWith('.vtt'));
        if (transcriptFile) {
          const vttContent = fs.readFileSync(path.join(this.downloadDir, transcriptFile), 'utf8');
          transcriptData = this.parseVTT(vttContent);
          fs.unlinkSync(path.join(this.downloadDir, transcriptFile));
        }
      }

      if (!transcriptData || !transcriptData.plainText) {
        return {
          success: false,
          error: 'Could not extract transcript text',
        };
      }

      return {
        success: true,
        transcript: transcriptData.plainText,      // Plain text version
        segments: transcriptData.segments,          // Timestamped segments [{start, end, text}]
        language: selectedLang,
        isAutoGenerated: isAutoGenerated,
        videoTitle: info.title,
        videoDuration: info.duration,
        segmentCount: transcriptData.segments.length,
      };

    } catch (error) {
      console.error('[YouTubeDownloader] Error getting transcript:', error);
      return {
        success: false,
        error: error.message,
      };
    }
  }

  /**
   * Parse VTT subtitle format - returns both plain text and timestamped segments
   * @param {string} vttContent - Raw VTT file content
   * @returns {object} - { plainText, segments: [{start, end, text}] }
   */
  parseVTT(vttContent) {
    const lines = vttContent.split('\n');
    const segments = [];
    const textLines = [];
    let currentSegment = null;
    let lastText = '';

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      
      // Skip WEBVTT header and empty lines
      if (line.startsWith('WEBVTT') || line.match(/^\d+$/) || line === '') {
        continue;
      }
      
      // Check for timestamp line (00:00:00.000 --> 00:00:05.000)
      const timestampMatch = line.match(/(\d{2}:\d{2}:\d{2}\.\d{3})\s*-->\s*(\d{2}:\d{2}:\d{2}\.\d{3})/);
      if (timestampMatch) {
        // Save previous segment if exists
        if (currentSegment && currentSegment.text) {
          segments.push(currentSegment);
        }
        currentSegment = {
          start: this.parseTimestamp(timestampMatch[1]),
          end: this.parseTimestamp(timestampMatch[2]),
          startFormatted: timestampMatch[1],
          endFormatted: timestampMatch[2],
          text: '',
        };
        continue;
      }
      
      // This is a text line
      if (currentSegment) {
        // Remove VTT formatting tags like <c>, </c>, <00:00:00.000>, etc.
        let cleanLine = line
          .replace(/<[^>]+>/g, '')
          .replace(/&nbsp;/g, ' ')
          .replace(/&amp;/g, '&')
          .replace(/&lt;/g, '<')
          .replace(/&gt;/g, '>')
          .trim();
        
        if (cleanLine) {
          currentSegment.text += (currentSegment.text ? ' ' : '') + cleanLine;
          
          // Add to plain text (avoid duplicates)
          if (cleanLine !== lastText) {
            textLines.push(cleanLine);
            lastText = cleanLine;
          }
        }
      }
    }
    
    // Don't forget the last segment
    if (currentSegment && currentSegment.text) {
      segments.push(currentSegment);
    }

    // Merge segments that have the same text (common in auto-captions)
    const mergedSegments = this.mergeSegments(segments);

    return {
      plainText: textLines.join(' '),
      segments: mergedSegments,
    };
  }

  /**
   * Parse VTT timestamp to seconds
   */
  parseTimestamp(timestamp) {
    const parts = timestamp.split(':');
    const hours = parseInt(parts[0], 10);
    const minutes = parseInt(parts[1], 10);
    const seconds = parseFloat(parts[2]);
    return hours * 3600 + minutes * 60 + seconds;
  }

  /**
   * Format seconds to readable timestamp
   */
  formatTimestamp(seconds) {
    const h = Math.floor(seconds / 3600);
    const m = Math.floor((seconds % 3600) / 60);
    const s = Math.floor(seconds % 60);
    if (h > 0) {
      return `${h}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
    }
    return `${m}:${s.toString().padStart(2, '0')}`;
  }

  /**
   * Merge consecutive segments with same/similar text
   */
  mergeSegments(segments) {
    if (segments.length === 0) return [];
    
    const merged = [];
    let current = { ...segments[0] };

    for (let i = 1; i < segments.length; i++) {
      const seg = segments[i];
      
      // If text is the same or very similar, extend the current segment
      if (seg.text === current.text) {
        current.end = seg.end;
        current.endFormatted = seg.endFormatted;
      } else {
        merged.push(current);
        current = { ...seg };
      }
    }
    merged.push(current);

    return merged;
  }

  /**
   * Download just audio from YouTube (for Whisper transcription)
   */
  async downloadAudio(url, progressCallback = null) {
    if (!youtubedl) {
      throw new Error('yt-dlp not found');
    }

    const videoId = YouTubeDownloader.extractVideoId(url);
    if (!videoId) {
      throw new Error('Invalid YouTube URL');
    }

    this.ensureDownloadDir();
    const outputPath = path.join(this.downloadDir, `audio-${videoId}.mp3`);
    
    try {
      if (progressCallback) progressCallback(5, 'Getting video info...');
      
      // Download audio only
      await youtubedl(url, {
        output: outputPath,
        extractAudio: true,
        audioFormat: 'mp3',
        audioQuality: '128K',
        noCheckCertificates: true,
        noWarnings: true,
      });

      if (progressCallback) progressCallback(50, 'Audio downloaded');

      if (!fs.existsSync(outputPath)) {
        // Try to find the file with different extension
        const files = fs.readdirSync(this.downloadDir);
        const audioFile = files.find(f => f.includes(videoId) && (f.endsWith('.mp3') || f.endsWith('.m4a') || f.endsWith('.opus')));
        if (audioFile) {
          return path.join(this.downloadDir, audioFile);
        }
        throw new Error('Audio file not found after download');
      }

      return outputPath;
    } catch (error) {
      console.error('[YouTubeDownloader] Audio download error:', error);
      throw error;
    }
  }

  /**
   * Transcribe audio using OpenAI Whisper API
   * Returns timestamped segments with word-level timing
   * @param {string} audioPath - Path to audio file
   * @param {string} language - Language code
   * @param {string} openaiKey - OpenAI API key
   * @returns {object} - { text, segments, words, duration }
   */
  async transcribeWithWhisper(audioPath, language = 'en', openaiKey = null) {
    // Get API key from settings if not provided
    if (!openaiKey) {
      const { app } = require('electron');
      const settingsPath = path.join(app.getPath('userData'), 'settings.json');
      
      if (fs.existsSync(settingsPath)) {
        const settings = JSON.parse(fs.readFileSync(settingsPath, 'utf8'));
        openaiKey = settings.openaiApiKey;
      }
    }

    if (!openaiKey) {
      throw new Error('OpenAI API key not configured. Please set it in Settings.');
    }

    const audioBuffer = fs.readFileSync(audioPath);
    const audioSize = audioBuffer.length;

    console.log(`[YouTubeDownloader] Transcribing ${(audioSize / 1024 / 1024).toFixed(2)}MB with Whisper`);

    // Check file size (Whisper limit is 25MB)
    if (audioSize > 25 * 1024 * 1024) {
      throw new Error('Audio file too large for Whisper (max 25MB). Try a shorter video or use YouTube captions.');
    }

    // Build multipart form data
    const boundary = '----WebKitFormBoundary' + Math.random().toString(36).substring(2);
    
    const parts = [];
    
    // File part
    parts.push(Buffer.from(
      `--${boundary}\r\n` +
      `Content-Disposition: form-data; name="file"; filename="audio.mp3"\r\n` +
      `Content-Type: audio/mpeg\r\n\r\n`
    ));
    parts.push(audioBuffer);
    parts.push(Buffer.from('\r\n'));
    
    // Model part
    parts.push(Buffer.from(
      `--${boundary}\r\n` +
      `Content-Disposition: form-data; name="model"\r\n\r\n` +
      `whisper-1\r\n`
    ));
    
    // Language part (optional - Whisper auto-detects if not specified)
    if (language) {
      parts.push(Buffer.from(
        `--${boundary}\r\n` +
        `Content-Disposition: form-data; name="language"\r\n\r\n` +
        `${language}\r\n`
      ));
    }
    
    // Response format - verbose_json gives us timestamps
    parts.push(Buffer.from(
      `--${boundary}\r\n` +
      `Content-Disposition: form-data; name="response_format"\r\n\r\n` +
      `verbose_json\r\n`
    ));

    // Timestamp granularity - segment and word level
    parts.push(Buffer.from(
      `--${boundary}\r\n` +
      `Content-Disposition: form-data; name="timestamp_granularities[]"\r\n\r\n` +
      `segment\r\n`
    ));
    parts.push(Buffer.from(
      `--${boundary}\r\n` +
      `Content-Disposition: form-data; name="timestamp_granularities[]"\r\n\r\n` +
      `word\r\n`
    ));
    
    // End boundary
    parts.push(Buffer.from(`--${boundary}--\r\n`));
    
    const fullBody = Buffer.concat(parts);

    // Send to OpenAI
    return new Promise((resolve, reject) => {
      const req = https.request({
        hostname: 'api.openai.com',
        path: '/v1/audio/transcriptions',
        method: 'POST',
        headers: {
          'Content-Type': `multipart/form-data; boundary=${boundary}`,
          'Content-Length': fullBody.length,
          'Authorization': `Bearer ${openaiKey}`
        }
      }, (res) => {
        let data = '';
        res.on('data', chunk => data += chunk);
        res.on('end', () => {
          if (res.statusCode !== 200) {
            try {
              const errorJson = JSON.parse(data);
              reject(new Error(errorJson.error?.message || `HTTP ${res.statusCode}`));
            } catch {
              reject(new Error(`HTTP ${res.statusCode}: ${data}`));
            }
            return;
          }
          
          try {
            const result = JSON.parse(data);
            console.log(`[YouTubeDownloader] Whisper transcription complete: ${result.segments?.length || 0} segments`);
            resolve(result);
          } catch (e) {
            reject(new Error('Failed to parse Whisper response'));
          }
        });
      });
      
      req.on('error', reject);
      req.write(fullBody);
      req.end();
    });
  }

  /**
   * Process speaker recognition using AssemblyAI
   * Returns transcription with speaker labels (Speaker A, Speaker B, etc.)
   * @param {string} audioPath - Path to audio file
   * @param {string} assemblyaiKey - AssemblyAI API key
   * @param {function} progressCallback - Progress callback
   * @returns {object} - { text, utterances: [{speaker, text, start, end}], speakers }
   */
  async transcribeWithSpeakerRecognition(audioPath, assemblyaiKey = null, progressCallback = null) {
    // Get API key from settings if not provided
    if (!assemblyaiKey) {
      const { app } = require('electron');
      const settingsPath = path.join(app.getPath('userData'), 'settings.json');
      
      if (fs.existsSync(settingsPath)) {
        const settings = JSON.parse(fs.readFileSync(settingsPath, 'utf8'));
        assemblyaiKey = settings.assemblyaiApiKey;
      }
    }

    if (!assemblyaiKey) {
      throw new Error('AssemblyAI API key not configured. Please set it in Settings.');
    }

    const audioBuffer = fs.readFileSync(audioPath);
    console.log(`[YouTubeDownloader] Processing speaker recognition for ${(audioBuffer.length / 1024 / 1024).toFixed(2)}MB audio`);

    // Step 1: Upload audio to AssemblyAI
    if (progressCallback) progressCallback(10, 'Uploading audio...');
    
    const uploadUrl = await new Promise((resolve, reject) => {
      const req = https.request({
        hostname: 'api.assemblyai.com',
        path: '/v2/upload',
        method: 'POST',
        headers: {
          'Authorization': assemblyaiKey,
          'Content-Type': 'application/octet-stream',
          'Content-Length': audioBuffer.length,
        }
      }, (res) => {
        let data = '';
        res.on('data', chunk => data += chunk);
        res.on('end', () => {
          if (res.statusCode !== 200) {
            reject(new Error(`Upload failed: HTTP ${res.statusCode}`));
            return;
          }
          try {
            const result = JSON.parse(data);
            resolve(result.upload_url);
          } catch (e) {
            reject(new Error('Failed to parse upload response'));
          }
        });
      });
      
      req.on('error', reject);
      req.write(audioBuffer);
      req.end();
    });

    console.log('[YouTubeDownloader] Audio uploaded to AssemblyAI');

    // Step 2: Start transcription with speaker diarization
    if (progressCallback) progressCallback(30, 'Starting transcription...');
    
    const transcriptId = await new Promise((resolve, reject) => {
      const body = JSON.stringify({
        audio_url: uploadUrl,
        speaker_labels: true,  // Enable speaker diarization
        speakers_expected: null,  // Auto-detect number of speakers
      });

      const req = https.request({
        hostname: 'api.assemblyai.com',
        path: '/v2/transcript',
        method: 'POST',
        headers: {
          'Authorization': assemblyaiKey,
          'Content-Type': 'application/json',
        }
      }, (res) => {
        let data = '';
        res.on('data', chunk => data += chunk);
        res.on('end', () => {
          if (res.statusCode !== 200) {
            reject(new Error(`Transcription request failed: HTTP ${res.statusCode}`));
            return;
          }
          try {
            const result = JSON.parse(data);
            resolve(result.id);
          } catch (e) {
            reject(new Error('Failed to parse transcription response'));
          }
        });
      });
      
      req.on('error', reject);
      req.write(body);
      req.end();
    });

    console.log('[YouTubeDownloader] Transcription started, ID:', transcriptId);

    // Step 3: Poll for completion
    if (progressCallback) progressCallback(40, 'Processing speakers...');
    
    let result = null;
    let pollCount = 0;
    const maxPolls = 300; // 5 minutes max (1 second per poll)

    while (pollCount < maxPolls) {
      await new Promise(r => setTimeout(r, 1000)); // Wait 1 second
      pollCount++;

      result = await new Promise((resolve, reject) => {
        const req = https.request({
          hostname: 'api.assemblyai.com',
          path: `/v2/transcript/${transcriptId}`,
          method: 'GET',
          headers: {
            'Authorization': assemblyaiKey,
          }
        }, (res) => {
          let data = '';
          res.on('data', chunk => data += chunk);
          res.on('end', () => {
            try {
              resolve(JSON.parse(data));
            } catch (e) {
              reject(new Error('Failed to parse status response'));
            }
          });
        });
        
        req.on('error', reject);
        req.end();
      });

      if (result.status === 'completed') {
        break;
      } else if (result.status === 'error') {
        throw new Error(result.error || 'Transcription failed');
      }

      // Update progress (40-90% range during processing)
      const progress = 40 + Math.min(50, pollCount);
      if (progressCallback) progressCallback(progress, `Processing speakers... (${pollCount}s)`);
    }

    if (result.status !== 'completed') {
      throw new Error('Transcription timed out');
    }

    if (progressCallback) progressCallback(95, 'Formatting results...');

    // Format the results
    const utterances = (result.utterances || []).map(u => ({
      speaker: u.speaker,  // "A", "B", "C", etc.
      speakerLabel: `Speaker ${u.speaker}`,
      text: u.text,
      start: u.start / 1000,  // Convert ms to seconds
      end: u.end / 1000,
      startFormatted: this.formatTimestamp(u.start / 1000),
      endFormatted: this.formatTimestamp(u.end / 1000),
      confidence: u.confidence,
    }));

    // Get unique speakers
    const speakers = [...new Set(utterances.map(u => u.speaker))].sort();

    if (progressCallback) progressCallback(100, 'Complete');

    return {
      success: true,
      text: result.text,
      utterances: utterances,
      speakers: speakers,
      speakerCount: speakers.length,
      words: (result.words || []).map(w => ({
        text: w.text,
        start: w.start / 1000,
        end: w.end / 1000,
        speaker: w.speaker,
        confidence: w.confidence,
      })),
      duration: result.audio_duration,
      confidence: result.confidence,
    };
  }

  /**
   * Process speaker recognition for a YouTube video
   * Downloads audio, transcribes with speaker labels
   * @param {string} url - YouTube URL
   * @param {function} progressCallback - Progress callback
   * @returns {object} - { success, text, utterances, speakers }
   */
  async processSpeakerRecognition(url, progressCallback = null) {
    let audioPath = null;
    
    try {
      // Download audio
      if (progressCallback) progressCallback(5, 'Downloading audio from YouTube...');
      audioPath = await this.downloadAudio(url, (p, s) => {
        if (progressCallback) progressCallback(5 + p * 0.2, s);
      });
      
      console.log('[YouTubeDownloader] Audio downloaded for speaker recognition:', audioPath);
      
      // Process with speaker recognition
      if (progressCallback) progressCallback(25, 'Processing speaker recognition...');
      const result = await this.transcribeWithSpeakerRecognition(audioPath, null, (p, s) => {
        if (progressCallback) progressCallback(25 + p * 0.7, s);
      });
      
      // Clean up
      if (audioPath && fs.existsSync(audioPath)) {
        fs.unlinkSync(audioPath);
      }
      
      if (progressCallback) progressCallback(100, 'Complete');
      
      return result;
      
    } catch (error) {
      // Clean up on error
      if (audioPath && fs.existsSync(audioPath)) {
        fs.unlinkSync(audioPath);
      }
      
      console.error('[YouTubeDownloader] Speaker recognition error:', error);
      return {
        success: false,
        error: error.message,
      };
    }
  }

  /**
   * Get transcript using OpenAI Whisper (more accurate than YouTube captions)
   * @param {string} url - YouTube URL
   * @param {string} language - Language code
   * @param {function} progressCallback - Progress callback
   * @returns {object} - { success, text, segments, words }
   */
  async getTranscriptWithWhisper(url, language = 'en', progressCallback = null) {
    let audioPath = null;
    
    try {
      // Download audio
      if (progressCallback) progressCallback(10, 'Downloading audio...');
      audioPath = await this.downloadAudio(url, progressCallback);
      
      // Check file size
      const stats = fs.statSync(audioPath);
      if (stats.size > 25 * 1024 * 1024) {
        // File too large - need to split it
        // For now, return error - could implement chunking later
        throw new Error('Audio file too large for Whisper (max 25MB). Video may be too long.');
      }
      
      // Transcribe
      if (progressCallback) progressCallback(60, 'Transcribing with Whisper...');
      const whisperResult = await this.transcribeWithWhisper(audioPath, language);
      
      if (progressCallback) progressCallback(95, 'Processing...');
      
      // Format segments
      const segments = (whisperResult.segments || []).map(seg => ({
        start: seg.start,
        end: seg.end,
        startFormatted: this.formatTimestamp(seg.start),
        endFormatted: this.formatTimestamp(seg.end),
        text: seg.text.trim(),
      }));
      
      // Format words (if available)
      const words = (whisperResult.words || []).map(word => ({
        start: word.start,
        end: word.end,
        word: word.word,
      }));
      
      // Clean up
      if (audioPath && fs.existsSync(audioPath)) {
        fs.unlinkSync(audioPath);
      }
      
      if (progressCallback) progressCallback(100, 'Complete');
      
      return {
        success: true,
        transcript: whisperResult.text,
        segments: segments,
        words: words,
        language: whisperResult.language || language,
        duration: whisperResult.duration,
        isWhisper: true,
        segmentCount: segments.length,
        wordCount: words.length,
      };
      
    } catch (error) {
      // Clean up on error
      if (audioPath && fs.existsSync(audioPath)) {
        fs.unlinkSync(audioPath);
      }
      
      console.error('[YouTubeDownloader] Whisper transcription error:', error);
      return {
        success: false,
        error: error.message,
        isWhisper: true,
      };
    }
  }
  
  /**
   * Get installation instructions
   */
  static getInstallInstructions() {
    if (process.platform === 'darwin') {
      return 'Install yt-dlp: brew install yt-dlp';
    } else if (process.platform === 'win32') {
      return 'Install yt-dlp: pip install yt-dlp';
    } else {
      return 'Install yt-dlp: pip install yt-dlp or sudo apt install yt-dlp';
    }
  }

  /**
   * Get video info without downloading
   */
  async getVideoInfo(url) {
    if (!youtubedl) {
      const instructions = YouTubeDownloader.getInstallInstructions();
      throw new Error(`yt-dlp not found. ${instructions}`);
    }

    try {
      const info = await youtubedl(url, {
        dumpSingleJson: true,
        noCheckCertificates: true,
        noWarnings: true,
        preferFreeFormats: true,
      });

      return {
        success: true,
        id: info.id,
        title: info.title,
        description: info.description,
        duration: info.duration,
        thumbnail: info.thumbnail,
        uploader: info.uploader,
        uploadDate: info.upload_date,
        viewCount: info.view_count,
        likeCount: info.like_count,
        categories: info.categories,
        tags: info.tags,
        url: url,
      };
    } catch (error) {
      console.error('[YouTubeDownloader] Error getting video info:', error);
      
      // Check for Python version error
      if (error.message && error.message.includes('unsupported version of Python')) {
        const instructions = YouTubeDownloader.getInstallInstructions();
        return {
          success: false,
          error: `Python version too old for bundled yt-dlp. ${instructions}`,
          needsInstall: true,
        };
      }
      
      return {
        success: false,
        error: error.message,
      };
    }
  }

  /**
   * Download a YouTube video
   * @param {string} url - YouTube URL
   * @param {object} options - Download options
   * @param {function} progressCallback - Progress callback (percent, status)
   */
  async download(url, options = {}, progressCallback = null) {
    if (!youtubedl) {
      throw new Error('youtube-dl-exec not installed. Run: npm install youtube-dl-exec');
    }

    const videoId = YouTubeDownloader.extractVideoId(url);
    if (!videoId) {
      throw new Error('Invalid YouTube URL');
    }

    this.ensureDownloadDir();
    
    const outputTemplate = path.join(this.downloadDir, '%(title)s-%(id)s.%(ext)s');
    
    // Check if ffmpeg is available for merging video+audio
    const { execSync } = require('child_process');
    let hasFFmpeg = false;
    try {
      execSync('which ffmpeg', { stdio: 'ignore' });
      hasFFmpeg = true;
    } catch (e) {
      console.log('[YouTubeDownloader] ffmpeg not found - will use pre-merged formats only');
    }
    
    const quality = options.quality || 'best';
    
    try {
      // First get video info for metadata
      if (progressCallback) progressCallback(5, 'Getting video info...');
      
      const info = await this.getVideoInfo(url);
      if (!info.success) {
        throw new Error(info.error);
      }

      if (progressCallback) progressCallback(10, 'Starting download...');

      // Download the video
      const downloadOptions = {
        output: outputTemplate,
        noCheckCertificates: true,
        noWarnings: true,
      };

      // Set format based on ffmpeg availability
      if (hasFFmpeg) {
        // With ffmpeg, we can merge separate video+audio streams
        downloadOptions.mergeOutputFormat = 'mp4';
        
        if (quality === 'high') {
          downloadOptions.format = 'bestvideo[height<=1080][ext=mp4]+bestaudio[ext=m4a]/bestvideo[height<=1080]+bestaudio/best[height<=1080][ext=mp4]/best[ext=mp4]/best';
        } else if (quality === 'medium') {
          downloadOptions.format = 'bestvideo[height<=720][ext=mp4]+bestaudio[ext=m4a]/bestvideo[height<=720]+bestaudio/best[height<=720][ext=mp4]/best[ext=mp4]/best';
        } else if (quality === 'low') {
          downloadOptions.format = 'bestvideo[height<=480][ext=mp4]+bestaudio[ext=m4a]/bestvideo[height<=480]+bestaudio/best[height<=480][ext=mp4]/best[ext=mp4]/best';
        } else {
          downloadOptions.format = 'bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best';
        }
      } else {
        // Without ffmpeg, ONLY use pre-merged formats (single file with video+audio)
        // Format 18 = 360p mp4 with video+audio (always available)
        // Format 22 = 720p mp4 with video+audio (sometimes available)
        // IMPORTANT: Do NOT use 'best' as fallback - it picks video-only or audio-only
        console.log('[YouTubeDownloader] No ffmpeg - using ONLY pre-merged format 18 (360p)');
        downloadOptions.format = '18';  // 360p is the only guaranteed pre-merged format
      }

      // Execute download
      const result = await youtubedl(url, downloadOptions);
      
      if (progressCallback) progressCallback(90, 'Finalizing...');

      // Find the downloaded file
      const files = fs.readdirSync(this.downloadDir);
      const downloadedFile = files.find(f => f.includes(videoId) && (f.endsWith('.mp4') || f.endsWith('.webm') || f.endsWith('.mkv')));
      
      if (!downloadedFile) {
        throw new Error('Downloaded file not found');
      }

      const filePath = path.join(this.downloadDir, downloadedFile);
      const stats = fs.statSync(filePath);

      if (progressCallback) progressCallback(100, 'Complete!');

      return {
        success: true,
        filePath: filePath,
        fileName: downloadedFile,
        fileSize: stats.size,
        videoInfo: info,
      };

    } catch (error) {
      console.error('[YouTubeDownloader] Download error:', error);
      return {
        success: false,
        error: error.message || 'Download failed',
      };
    }
  }

  /**
   * Download and add to Space
   * @param {string} url - YouTube URL
   * @param {object} clipboardManager - ClipboardManager instance
   * @param {string} spaceId - Target space ID
   * @param {function} progressCallback - Progress callback
   */
  async downloadToSpace(url, clipboardManager, spaceId = null, progressCallback = null) {
    try {
      // Download the video
      const result = await this.download(url, {}, progressCallback);
      
      if (!result.success) {
        return result;
      }

      console.log('[YouTubeDownloader] Downloaded file:', result.filePath, 'size:', result.fileSize);
      
      // Try to get transcript (don't fail if unavailable)
      let transcript = null;
      try {
        if (progressCallback) progressCallback(92, 'Fetching transcript...');
        const transcriptResult = await this.getTranscript(url, 'en');
        if (transcriptResult.success) {
          transcript = {
            text: transcriptResult.transcript,           // Plain text
            segments: transcriptResult.segments,         // Timestamped segments
            language: transcriptResult.language,
            isAutoGenerated: transcriptResult.isAutoGenerated,
            segmentCount: transcriptResult.segmentCount,
          };
          console.log('[YouTubeDownloader] Transcript fetched:', transcript.language, 
            transcript.isAutoGenerated ? '(auto)' : '(manual)', 
            transcript.segmentCount, 'segments');
        } else {
          console.log('[YouTubeDownloader] No transcript available:', transcriptResult.error);
        }
      } catch (e) {
        console.log('[YouTubeDownloader] Could not fetch transcript:', e.message);
      }
      
      // Create item for storage - pass filePath so storage can copy the file
      const item = {
        type: 'file',
        fileName: result.fileName,
        fileSize: result.fileSize,
        fileType: 'video/mp4',
        fileCategory: 'video',
        fileExt: path.extname(result.fileName).toLowerCase(),
        filePath: result.filePath,  // Storage will copy from this path
        spaceId: spaceId || clipboardManager.currentSpace || 'unclassified',
        source: 'youtube',
        metadata: {
          youtubeUrl: url,
          youtubeId: result.videoInfo.id,
          title: result.videoInfo.title,
          description: result.videoInfo.description,
          duration: result.videoInfo.duration,
          thumbnail: result.videoInfo.thumbnail,
          uploader: result.videoInfo.uploader,
          uploadDate: result.videoInfo.uploadDate,
          viewCount: result.videoInfo.viewCount,
          transcript: transcript,  // Include transcript if available
        },
        tags: result.videoInfo.tags?.slice(0, 10) || [], // Limit to 10 tags
      };

      console.log('[YouTubeDownloader] Adding item to storage with filePath:', item.filePath);
      
      // Add to storage (storage will copy the file)
      const indexEntry = clipboardManager.storage.addItem(item);
      
      console.log('[YouTubeDownloader] Item added with id:', indexEntry.id);
      
      // Also add to in-memory history so UI updates immediately
      if (clipboardManager.history) {
        const historyItem = {
          ...item,
          id: indexEntry.id,
          _needsContent: true, // Mark as needing content load
        };
        clipboardManager.history.unshift(historyItem);
        console.log('[YouTubeDownloader] Added to in-memory history');
        
        // Update space counts and notify UI
        if (clipboardManager.updateSpaceCounts) {
          clipboardManager.updateSpaceCounts();
        }
        if (clipboardManager.notifyHistoryUpdate) {
          clipboardManager.notifyHistoryUpdate();
          console.log('[YouTubeDownloader] Notified UI of history update');
        }
      }
      
      // Clean up temp file AFTER storage has copied it
      try {
        fs.unlinkSync(result.filePath);
        console.log('[YouTubeDownloader] Cleaned up temp file');
      } catch (e) {
        console.warn('[YouTubeDownloader] Could not clean up temp file:', e);
      }

      return {
        success: true,
        itemId: indexEntry.id,
        videoInfo: result.videoInfo,
        message: `Downloaded "${result.videoInfo.title}" to Spaces`,
      };

    } catch (error) {
      console.error('[YouTubeDownloader] Error downloading to space:', error);
      return {
        success: false,
        error: error.message,
      };
    }
  }

  /**
   * Clean up temp directory
   */
  cleanup() {
    try {
      if (fs.existsSync(this.downloadDir)) {
        const files = fs.readdirSync(this.downloadDir);
        files.forEach(file => {
          fs.unlinkSync(path.join(this.downloadDir, file));
        });
      }
    } catch (e) {
      console.warn('[YouTubeDownloader] Cleanup error:', e);
    }
  }
}

// Setup IPC handlers
function setupYouTubeIPC(ipcMain, clipboardManager) {
  const downloader = new YouTubeDownloader();

  // Check if URL is YouTube
  ipcMain.handle('youtube:is-youtube-url', (event, url) => {
    return YouTubeDownloader.isYouTubeUrl(url);
  });

  // Get video info
  ipcMain.handle('youtube:get-info', async (event, url) => {
    return await downloader.getVideoInfo(url);
  });

  // Download video to Space
  ipcMain.handle('youtube:download-to-space', async (event, url, spaceId) => {
    return await downloader.downloadToSpace(url, clipboardManager, spaceId, (percent, status) => {
      // Send progress to renderer
      event.sender.send('youtube:download-progress', { percent, status });
    });
  });

  // Download video only (returns file path)
  ipcMain.handle('youtube:download', async (event, url, options) => {
    return await downloader.download(url, options, (percent, status) => {
      event.sender.send('youtube:download-progress', { percent, status });
    });
  });

  console.log('[YouTubeDownloader] IPC handlers registered');
  
  return downloader;
}

module.exports = {
  YouTubeDownloader,
  setupYouTubeIPC,
  isYouTubeUrl: YouTubeDownloader.isYouTubeUrl,
  extractVideoId: YouTubeDownloader.extractVideoId,
};

