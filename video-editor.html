<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com; media-src 'self' file: blob:; img-src 'self' file: blob: data:;">
  <title>Video Editor - Onereach.ai</title>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&family=Space+Grotesk:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-darkest: #0d0d0d;
      --bg-dark: #181818;
      --bg-surface: #1e1e1e;
      --bg-panel: #232323;
      --bg-elevated: #2a2a2a;
      --bg-hover: #333333;
      --accent-primary: #e84c3d; /* DaVinci Red/Orange */
      --accent-secondary: #4a9eff; /* Video Blue */
      --accent-tertiary: #22c55e; /* Audio Green */
      --accent-gradient: linear-gradient(135deg, #e84c3d 0%, #f05545 100%);
      --accent-glow: rgba(232, 76, 61, 0.25);
      --text-primary: #d4d4d4;
      --text-secondary: #909090;
      --text-muted: #5c5c5c;
      --border-color: #2a2a2a;
      --border-light: #383838;
      --success: #22c55e;
      --warning: #f59e0b;
      --error: #ef4444;
      --timeline-height: 220px;
      --sidebar-width: 280px;
      --inspector-width: 280px;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
      background: var(--bg-darkest);
      color: var(--text-primary);
      height: 100vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      font-size: 12px;
    }

    /* ============================================
       DAVINCI-STYLE HEADER / TOP TOOLBAR
       ============================================ */
    .header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 12px;
      background: linear-gradient(180deg, #2d2d2d 0%, #252525 100%);
      border-bottom: 1px solid #1a1a1a;
      height: 36px;
      -webkit-app-region: drag;
    }

    .header-center {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      gap: 12px;
      -webkit-app-region: no-drag;
    }

    .project-title {
      color: #b0b0b0;
      font-size: 13px;
      font-weight: 500;
    }

    .project-status {
      color: #666;
      font-size: 11px;
    }

    /* Mode Switcher - Hidden in header, moved to bottom bar */
    .mode-switcher {
      display: none;
    }

    .mode-btn {
      display: none;
    }

    .file-info-separator {
      display: none;
    }

    /* Mode Content Visibility */
    body[data-mode="edit"] .mode-annotate-only { display: none !important; }
    body[data-mode="annotate"] .mode-edit-only { display: none !important; }
    
    /* Annotate Mode - Hide ALL editing controls */
    body[data-mode="annotate"] .timeline { --timeline-height: 140px; }
    body[data-mode="annotate"] .trim-region,
    body[data-mode="annotate"] .trim-marker,
    body[data-mode="annotate"] #trimMarkerStart,
    body[data-mode="annotate"] #trimMarkerEnd { display: none !important; }
    
    /* Hide audio track controls in annotate mode (no audio editing) */
    body[data-mode="annotate"] .track-controls { display: none !important; }
    body[data-mode="annotate"] #audioTrackContainer { display: none !important; }
    
    /* Annotate mode - COLLAPSE SIDEBAR */
    body[data-mode="annotate"] .sidebar {
      width: 0;
      min-width: 0;
      padding: 0;
      overflow: hidden;
      border-right: none;
      transition: width 0.2s ease, padding 0.2s ease;
    }
    
    body[data-mode="annotate"] .sidebar > * {
      opacity: 0;
      visibility: hidden;
    }
    
    /* Annotate mode - emphasize markers track */
    body[data-mode="annotate"] .markers-track {
      height: 32px;
      background: #1f1f1f;
      border: 1px solid #2a2a2a;
      border-radius: 3px;
      margin: 4px 100px 4px 100px;
    }
    
    /* Annotate mode - simpler video track, adjust for no sidebar */
    body[data-mode="annotate"] .timeline-row { min-height: 48px; }
    body[data-mode="annotate"] .timeline-ruler { margin-left: 100px; }
    body[data-mode="annotate"] .track-label { width: 100px; }

    .header-left {
      display: flex;
      align-items: center;
      gap: 8px;
      -webkit-app-region: no-drag;
    }

    .logo {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .logo-icon {
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
    }

    .logo-text {
      display: none;
    }

    .file-name {
      color: #888;
      font-size: 11px;
      font-family: -apple-system, sans-serif;
      padding: 2px 8px;
      background: transparent;
      max-width: 250px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      border: none;
    }

    .header-actions {
      display: flex;
      align-items: center;
      gap: 2px;
      -webkit-app-region: no-drag;
    }

    /* Header icon buttons */
    .header-icon-btn {
      width: 28px;
      height: 28px;
      background: transparent;
      border: none;
      border-radius: 3px;
      color: #888;
      font-size: 14px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.1s;
    }

    .header-icon-btn:hover {
      background: #3a3a3a;
      color: #ccc;
    }

    .header-icon-btn.active {
      background: #454545;
      color: #fff;
    }

    .btn {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 4px 10px;
      border: none;
      border-radius: 3px;
      font-family: inherit;
      font-size: 11px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.1s ease;
    }

    .btn-ghost {
      background: transparent;
      color: #888;
    }

    .btn-ghost:hover {
      background: #333;
      color: #ccc;
    }

    .btn-secondary {
      background: #383838;
      color: #ccc;
    }

    .btn-secondary:hover {
      background: #444;
    }

    .btn-primary {
      background: var(--accent-primary);
      color: white;
    }

    .btn-primary:hover {
      background: #f05545;
    }

    .btn-primary:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    /* Main Layout */
    .main-container {
      display: flex;
      flex: 1;
      overflow: hidden;
    }

    /* ============================================
       DAVINCI-STYLE LEFT SIDEBAR / MEDIA POOL
       ============================================ */
    .sidebar {
      width: var(--sidebar-width);
      background: var(--bg-dark);
      border-right: 1px solid #141414;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      transition: width 0.25s ease, opacity 0.2s ease;
    }
    
    .sidebar > * {
      transition: opacity 0.15s ease, visibility 0.15s ease;
    }

    .sidebar-tabs {
      display: flex;
      background: #1f1f1f;
      border-bottom: 1px solid #141414;
      padding: 0;
    }

    .sidebar-tab {
      flex: 1;
      padding: 8px 4px;
      background: transparent;
      border: none;
      color: #666;
      font-family: inherit;
      font-size: 10px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.1s ease;
      text-transform: uppercase;
      letter-spacing: 0.3px;
      border-bottom: 2px solid transparent;
    }

    .sidebar-tab:hover {
      color: #aaa;
    }

    .sidebar-tab.active {
      color: #ddd;
      border-bottom-color: var(--accent-primary);
    }

    .sidebar-content {
      flex: 1;
      overflow-y: auto;
      padding: 0;
      background: var(--bg-dark);
    }

    .sidebar-content::-webkit-scrollbar {
      width: 6px;
    }

    .sidebar-content::-webkit-scrollbar-track {
      background: transparent;
    }

    .sidebar-content::-webkit-scrollbar-thumb {
      background: #333;
      border-radius: 3px;
    }

    .sidebar-section {
      background: var(--bg-dark);
      border-bottom: 1px solid #141414;
    }

    .sidebar-section-title {
      font-size: 10px;
      font-weight: 600;
      color: #888;
      padding: 6px 10px;
      background: #1c1c1c;
      margin: 0;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: space-between;
      transition: background 0.1s ease;
      user-select: none;
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }

    .sidebar-section-title:hover {
      background: #252525;
      color: #aaa;
    }

    .sidebar-section-content {
      padding: 8px 10px;
      background: #1a1a1a;
    }

    .section-icon {
      margin-right: 6px;
    }

    .section-icon-svg {
      margin-right: 8px;
      stroke: currentColor;
      fill: none;
      stroke-width: 2;
      vertical-align: -2px;
    }

    .section-toggle {
      font-size: 8px;
      color: #555;
    }

    /* ============================================
       MODE HEADERS
       ============================================ */
    .mode-header {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 14px 12px;
      background: linear-gradient(180deg, #1f1f1f 0%, #1a1a1a 100%);
      border-bottom: 1px solid #141414;
    }

    .mode-header-icon {
      width: 36px;
      height: 36px;
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .edit-mode-header .mode-header-icon {
      background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
      color: white;
    }

    .annotate-mode-header .mode-header-icon {
      background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
      color: white;
    }

    .mode-header-text {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .mode-header-title {
      font-size: 13px;
      font-weight: 600;
      color: #ddd;
    }

    .mode-header-subtitle {
      font-size: 10px;
      color: #666;
    }

    /* Annotation Action Buttons */
    .annotation-action-btn {
      padding: 4px !important;
    }

    .annotation-action-btn svg {
      stroke: currentColor;
      fill: none;
      stroke-width: 2;
    }

    /* Form Controls - DaVinci Style */
    .form-group {
      margin-bottom: 10px;
    }

    .form-label {
      display: block;
      font-size: 10px;
      color: #777;
      margin-bottom: 4px;
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }

    .form-input, .form-select {
      width: 100%;
      padding: 5px 8px;
      background: #141414;
      border: 1px solid #2a2a2a;
      border-radius: 3px;
      color: #ccc;
      font-family: 'JetBrains Mono', -apple-system, monospace;
      font-size: 11px;
      transition: border-color 0.15s ease;
    }

    .form-input:focus, .form-select:focus {
      outline: none;
      border-color: #444;
    }

    .form-input:disabled, .form-select:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .form-select {
      cursor: pointer;
    }

    .form-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }

    .time-input-group {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .time-input {
      flex: 1;
    }

    .time-input-separator {
      color: var(--text-muted);
      font-size: 14px;
    }

    /* Range Slider */
    /* Range Slider - DaVinci Style */
    .range-slider {
      width: 100%;
      height: 4px;
      background: #1a1a1a;
      border-radius: 2px;
      -webkit-appearance: none;
      appearance: none;
      cursor: pointer;
    }

    .range-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 12px;
      height: 12px;
      background: #888;
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid #555;
    }

    .range-slider::-webkit-slider-thumb:hover {
      background: #aaa;
    }

    /* Toggle - DaVinci Style */
    .toggle-group {
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .toggle {
      width: 36px;
      height: 18px;
      background: #2a2a2a;
      border-radius: 9px;
      position: relative;
      cursor: pointer;
      transition: background 0.15s ease;
      border: 1px solid #333;
    }

    .toggle.active {
      background: var(--accent-primary);
      border-color: var(--accent-primary);
    }

    .toggle::after {
      content: '';
      position: absolute;
      top: 2px;
      left: 2px;
      width: 12px;
      height: 12px;
      background: #888;
      border-radius: 50%;
      transition: all 0.15s ease;
    }

    .toggle.active::after {
      transform: translateX(18px);
      background: #fff;
    }

    /* Preset Buttons - DaVinci Style */
    .preset-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 4px;
    }

    .preset-btn {
      padding: 4px 6px;
      background: #1a1a1a;
      border: 1px solid #2a2a2a;
      border-radius: 2px;
      color: #777;
      font-family: inherit;
      font-size: 10px;
      cursor: pointer;
      transition: all 0.1s ease;
      text-align: center;
    }

    .preset-btn:hover {
      background: #252525;
      color: #aaa;
    }

    .preset-btn.active {
      background: var(--accent-primary);
      border-color: var(--accent-primary);
      color: white;
    }

    /* Speed Presets - DaVinci Style */
    .speed-presets {
      display: flex;
      gap: 3px;
    }

    .speed-btn {
      flex: 1;
      padding: 4px 2px;
      background: #1a1a1a;
      border: 1px solid #2a2a2a;
      border-radius: 2px;
      color: #666;
      font-family: 'JetBrains Mono', -apple-system, monospace;
      font-size: 9px;
      cursor: pointer;
      transition: all 0.1s ease;
      text-align: center;
    }

    .speed-btn:hover {
      background: #252525;
      color: #999;
    }

    .speed-btn.active {
      background: var(--accent-primary);
      border-color: var(--accent-primary);
      color: white;
    }

    /* ============================================
       DAVINCI-STYLE PREVIEW AREA / VIEWER
       ============================================ */
    .preview-area {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: #0a0a0a;
      overflow: hidden;
    }

    .video-container {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #000;
      position: relative;
      min-height: 0;
      border: 1px solid #1a1a1a;
      margin: 4px;
      border-radius: 2px;
    }

    .video-player {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
    }

    /* ============================================
       TELEPROMPTER OVERLAY STYLES
       ============================================ */
    .teleprompter-container {
      position: absolute;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      width: 90%;
      max-width: 800px;
      max-height: 120px;
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      overflow: hidden;
      z-index: 100;
      transition: all 0.3s ease;
    }

    .teleprompter-container.expanded {
      max-height: 200px;
    }

    .teleprompter-container.hidden {
      display: none;
    }

    .teleprompter-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 6px 12px;
      background: rgba(99, 102, 241, 0.2);
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .teleprompter-title {
      font-size: 11px;
      font-weight: 600;
      color: rgba(255, 255, 255, 0.8);
      letter-spacing: 0.5px;
    }

    .teleprompter-controls {
      display: flex;
      gap: 4px;
    }

    .teleprompter-btn {
      background: rgba(255, 255, 255, 0.1);
      border: none;
      color: rgba(255, 255, 255, 0.7);
      padding: 4px 8px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      transition: all 0.2s;
    }

    .teleprompter-btn:hover {
      background: rgba(255, 255, 255, 0.2);
      color: white;
    }

    .teleprompter-content {
      padding: 12px 16px;
      overflow-y: auto;
      max-height: calc(100% - 32px);
    }

    .teleprompter-words {
      display: flex;
      flex-wrap: wrap;
      gap: 6px 8px;
      line-height: 1.8;
      justify-content: center;
    }

    .teleprompter-word {
      font-size: 16px;
      font-weight: 500;
      color: rgba(255, 255, 255, 0.4);
      transition: all 0.15s ease;
      padding: 2px 6px;
      border-radius: 4px;
      cursor: pointer;
    }

    .teleprompter-word:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    .teleprompter-word.upcoming {
      color: rgba(255, 255, 255, 0.6);
    }

    .teleprompter-word.current {
      color: #fff;
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.8), rgba(139, 92, 246, 0.8));
      transform: scale(1.1);
      font-weight: 700;
      box-shadow: 0 2px 12px rgba(99, 102, 241, 0.4);
    }

    .teleprompter-word.spoken {
      color: rgba(16, 185, 129, 0.9);
    }

    .teleprompter-empty {
      text-align: center;
      color: rgba(255, 255, 255, 0.5);
      font-size: 13px;
      padding: 20px;
    }

    .teleprompter-empty button {
      margin-top: 10px;
      background: rgba(99, 102, 241, 0.3);
      border: 1px solid rgba(99, 102, 241, 0.5);
      color: white;
      padding: 6px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 12px;
      transition: all 0.2s;
    }

    .teleprompter-empty button:hover {
      background: rgba(99, 102, 241, 0.5);
    }

    /* Toggle button in video controls */
    .teleprompter-toggle-btn {
      background: rgba(99, 102, 241, 0.2);
      border: 1px solid rgba(99, 102, 241, 0.4);
    }

    .teleprompter-toggle-btn.active {
      background: rgba(99, 102, 241, 0.5);
      border-color: rgba(99, 102, 241, 0.8);
    }

    .video-placeholder {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 16px;
      padding: 40px;
      text-align: center;
    }

    .video-placeholder-icon {
      width: 64px;
      height: 64px;
      background: #1a1a1a;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 28px;
      color: #444;
    }

    .video-placeholder h2 {
      font-size: 14px;
      font-weight: 500;
      color: #666;
    }

    .video-placeholder p {
      color: #444;
      font-size: 12px;
      max-width: 280px;
    }

    .drop-zone {
      border: 1px dashed #333;
      border-radius: 4px;
      padding: 40px 30px;
      transition: all 0.2s ease;
    }

    .drop-zone.drag-over {
      border-color: var(--accent-primary);
      background: rgba(232, 76, 61, 0.05);
    }

    /* Video Controls - DaVinci Transport Bar */
    .video-controls {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
      padding: 8px 16px;
      background: #1a1a1a;
      border-top: 1px solid #252525;
    }

    .control-btn {
      width: 32px;
      height: 32px;
      background: transparent;
      border: 1px solid #333;
      border-radius: 3px;
      color: #888;
      font-size: 14px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.1s ease;
    }

    .control-btn:hover {
      background: #2a2a2a;
      color: #ccc;
      border-color: #444;
    }

    .control-btn.play-btn {
      width: 36px;
      height: 36px;
      background: #333;
      border: none;
      color: #fff;
    }

    .control-btn.play-btn:hover {
      background: #444;
    }

    .time-display {
      font-family: 'JetBrains Mono', monospace;
      font-size: 18px;
      color: #ccc;
      min-width: 160px;
      text-align: center;
      padding: 0 20px;
      letter-spacing: 1px;
    }

    .time-current {
      color: #fff;
    }

    .volume-control {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-left: 20px;
    }

    .volume-slider {
      width: 60px;
    }

    /* ============================================
       DAVINCI-STYLE TIMELINE
       ============================================ */
    .timeline {
      height: var(--timeline-height);
      background: #151515;
      border-top: 1px solid #0a0a0a;
      display: flex;
      flex-direction: column;
    }

    .timeline-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 2px 8px;
      font-size: 10px;
      color: #666;
      background: #1c1c1c;
      border-bottom: 1px solid #0a0a0a;
      height: 24px;
    }

    .timeline-track-container {
      flex: 1;
      position: relative;
      display: flex;
      flex-direction: column;
      background: #111;
      overflow-y: auto;
    }

    .timeline-row {
      display: flex;
      min-height: 56px;
      background: #1a1a1a;
      border-bottom: 1px solid #0d0d0d;
    }

    .timeline-row.audio {
      min-height: 52px; /* Increased to accommodate transcript words */
    }

    /* Track Labels - DaVinci Style with Badge */
    .track-label {
      width: 100px;
      background: #1f1f1f;
      border-right: 1px solid #0d0d0d;
      display: flex;
      flex-direction: column;
      justify-content: center;
      padding: 4px 6px;
      flex-shrink: 0;
    }

    .track-label-header {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .track-badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 22px;
      height: 16px;
      border-radius: 2px;
      font-size: 9px;
      font-weight: 700;
      color: #fff;
    }

    .track-badge.video {
      background: var(--accent-secondary);
    }

    .track-badge.audio {
      background: var(--accent-tertiary);
    }

    .track-info {
      display: flex;
      flex-direction: column;
    }

    .track-name {
      color: #999;
      font-size: 10px;
      font-weight: 500;
    }

    .track-clip-count {
      color: #555;
      font-size: 9px;
    }

    .track-controls {
      display: flex;
      gap: 2px;
      margin-top: 4px;
    }

    .track-action-btn {
      width: 18px;
      height: 18px;
      background: #2a2a2a;
      border: none;
      border-radius: 2px;
      color: #666;
      font-size: 9px;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .track-action-btn:hover {
      background: #3a3a3a;
      color: #aaa;
    }

    .track-action-btn.active {
      background: var(--accent-primary);
      color: #fff;
    }

    .timeline-track {
      flex: 1;
      position: relative;
      background: #1a1a1a;
      overflow: hidden;
    }

    /* Clip Styles - DaVinci Look */
    .timeline-clip {
      position: absolute;
      top: 2px;
      bottom: 2px;
      background: var(--accent-secondary);
      border: 1px solid rgba(255,255,255,0.1);
      border-top-color: rgba(255,255,255,0.2);
      border-radius: 2px;
      overflow: hidden;
      display: flex;
      align-items: flex-end;
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.1);
    }

    .timeline-clip.audio {
      background: var(--accent-tertiary);
    }

    .timeline-clip.selected {
      border-color: #fff;
      box-shadow: 0 0 0 1px #fff, inset 0 1px 0 rgba(255,255,255,0.1);
    }

    .timeline-clip-name {
      color: rgba(255,255,255,0.95);
      font-size: 9px;
      font-weight: 500;
      padding: 2px 4px;
      white-space: nowrap;
      text-shadow: 0 1px 2px rgba(0,0,0,0.6);
      position: absolute;
      bottom: 2px;
      left: 2px;
      z-index: 2;
      background: rgba(0,0,0,0.3);
      border-radius: 2px;
    }

    .timeline-thumbnails {
      display: flex;
      height: 100%;
      width: 100%;
      opacity: 0.9;
      overflow: hidden;
      transition: opacity 0.2s ease;
    }
    
    .timeline-thumbnails.loading {
      opacity: 0.5;
    }
    
    .timeline-thumb {
      height: 100%;
      min-width: 60px; /* Minimum thumbnail width for aspect ratio */
      max-width: 120px; /* Cap maximum width */
      object-fit: cover;
      object-position: center;
      flex-shrink: 0;
      border-right: 1px solid rgba(0,0,0,0.3);
      animation: thumbFadeIn 0.3s ease;
    }
    
    @keyframes thumbFadeIn {
      from { opacity: 0; transform: scale(0.95); }
      to { opacity: 1; transform: scale(1); }
    }
    
    .timeline-thumb:last-child {
      border-right: none;
    }

    /* Playhead - DaVinci Red Line */
    .timeline-playhead {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 2px;
      background: #e84c3d;
      z-index: 100;
      pointer-events: none;
    }

    .timeline-playhead::before {
      content: '';
      position: absolute;
      top: -6px;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 5px solid transparent;
      border-right: 5px solid transparent;
      border-top: 6px solid #e84c3d;
    }

    /* Scrollable Timeline Wrapper */
    .timeline-scroll-wrapper {
      flex: 1;
      overflow-x: auto;
      overflow-y: hidden;
      position: relative;
      background: #1a1a1a;
    }

    .timeline-scroll-wrapper::-webkit-scrollbar {
      height: 8px;
    }

    .timeline-scroll-wrapper::-webkit-scrollbar-track {
      background: #111;
    }

    .timeline-scroll-wrapper::-webkit-scrollbar-thumb {
      background: #333;
      border-radius: 0;
    }

    .timeline-scroll-wrapper::-webkit-scrollbar-thumb:hover {
      background: #444;
    }

    .timeline-content {
      min-width: 100%;
    }

    /* Timeline Zoom Controls */
    .timeline-zoom-controls {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      background: #1c1c1c;
      border-bottom: 1px solid #0d0d0d;
    }

    .zoom-btn {
      width: 24px;
      height: 24px;
      background: #2a2a2a;
      border: 1px solid #333;
      border-radius: 3px;
      color: #888;
      font-size: 14px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.1s;
    }

    .zoom-btn:hover {
      background: #3a3a3a;
      color: #ccc;
    }

    .zoom-slider-container {
      width: 80px;
    }

    .zoom-slider {
      width: 100%;
      height: 4px;
      background: #1a1a1a;
      border-radius: 2px;
      -webkit-appearance: none;
      cursor: pointer;
    }

    .zoom-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 10px;
      height: 10px;
      background: #666;
      border-radius: 50%;
      cursor: pointer;
    }

    .zoom-level {
      font-size: 10px;
      color: #666;
      min-width: 32px;
      text-align: center;
      font-family: 'JetBrains Mono', monospace;
    }

    .zoom-presets {
      display: flex;
      gap: 2px;
      margin-left: 8px;
    }

    .zoom-preset-btn {
      padding: 3px 8px;
      background: #252525;
      border: 1px solid #333;
      border-radius: 3px;
      color: #666;
      font-size: 9px;
      cursor: pointer;
      transition: all 0.1s;
    }

    .zoom-preset-btn:hover {
      background: #333;
      color: #999;
    }

    .zoom-preset-btn.active {
      background: #3a3a3a;
      color: #ddd;
      border-color: #555;
    }

    /* Timeline Ruler - DaVinci Style */
    .timeline-ruler {
      height: 22px;
      background: #1f1f1f;
      position: relative;
      margin-left: 100px;
      border-bottom: 1px solid #0d0d0d;
    }

    .ruler-marks {
      display: flex;
      height: 100%;
      position: relative;
    }

    .ruler-mark {
      position: absolute;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-end;
    }

    .ruler-mark-line {
      width: 1px;
      background: #333;
    }

    .ruler-mark-line.major {
      height: 8px;
    }

    .ruler-mark-line.minor {
      height: 4px;
      background: #282828;
    }

    .ruler-mark-label {
      font-size: 9px;
      font-family: 'JetBrains Mono', -apple-system, monospace;
      color: #666;
      position: absolute;
      top: 3px;
      transform: translateX(-50%);
    }

    /* ============================================
       DAVINCI-STYLE BOTTOM PAGE BAR
       ============================================ */
    .page-bar {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 44px;
      background: linear-gradient(180deg, #252525 0%, #1a1a1a 100%);
      border-top: 1px solid #333;
      padding: 0 20px;
      gap: 2px;
    }

    .page-btn {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 6px 20px;
      background: transparent;
      border: none;
      border-radius: 4px;
      color: #555;
      font-size: 9px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      gap: 3px;
      min-width: 70px;
    }

    .page-btn:hover {
      color: #888;
      background: rgba(255,255,255,0.05);
    }

    .page-btn.active {
      color: #fff;
      background: rgba(255,255,255,0.1);
    }

    .page-btn.active .page-btn-icon svg {
      stroke: var(--accent-primary);
    }

    .page-btn-icon {
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .page-btn-icon svg {
      width: 16px;
      height: 16px;
      stroke: currentColor;
      stroke-width: 1.5;
      fill: none;
    }

    .page-divider {
      width: 1px;
      height: 24px;
      background: #333;
      margin: 0 12px;
    }

    /* Markers - DaVinci Style */
    .markers-track {
      position: relative;
      height: 18px;
      background: #1a1a1a;
      margin-left: 100px;
      border-bottom: 1px solid #0d0d0d;
    }

    .marker {
      position: absolute;
      top: 0;
      width: 2px;
      height: 100%;
      cursor: pointer;
      transform: translateX(-50%);
      transition: all 0.1s ease;
      z-index: 10;
    }

    .marker:hover {
      transform: translateX(-50%) scaleX(1.5);
    }

    .marker.dragging {
      z-index: 100;
      cursor: grabbing;
    }

    .marker-flag {
      position: absolute;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 10px;
      height: 10px;
      border-radius: 1px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 7px;
      color: white;
    }

    .marker-label {
      position: absolute;
      top: -18px;
      left: 50%;
      transform: translateX(-50%);
      background: #2a2a2a;
      border: 1px solid #444;
      border-radius: 2px;
      padding: 2px 5px;
      font-size: 9px;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.1s ease;
      z-index: 20;
      color: #ccc;
    }

    .marker:hover .marker-label {
      opacity: 1;
    }

    .marker.selected {
      z-index: 15;
    }

    .marker.selected .marker-flag {
      box-shadow: 0 0 0 1px white;
    }

    /* Markers Panel - DaVinci Style */
    .markers-panel {
      background: #1a1a1a;
      border-radius: 2px;
      padding: 8px;
      margin-top: 8px;
    }

    .markers-panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 8px;
    }

    .markers-panel-title {
      font-size: 10px;
      font-weight: 600;
      color: #888;
      display: flex;
      align-items: center;
      gap: 6px;
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }

    .markers-count {
      background: #333;
      color: #aaa;
      font-size: 9px;
      padding: 1px 5px;
      border-radius: 2px;
    }

    .markers-list {
      max-height: 150px;
      overflow-y: auto;
    }

    .markers-list::-webkit-scrollbar {
      width: 4px;
    }

    .markers-list::-webkit-scrollbar-track {
      background: transparent;
    }

    .markers-list::-webkit-scrollbar-thumb {
      background: #333;
      border-radius: 2px;
    }

    .marker-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 5px 6px;
      border-radius: 2px;
      cursor: pointer;
      transition: all 0.1s ease;
    }

    .marker-item:hover {
      background: #252525;
    }

    .marker-item.active {
      background: #2a2a2a;
    }

    .marker-color-dot {
      width: 8px;
      height: 8px;
      border-radius: 1px;
      flex-shrink: 0;
    }

    .marker-item-info {
      flex: 1;
      min-width: 0;
    }

    .marker-item-name {
      font-size: 10px;
      color: #aaa;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .marker-item-time {
      font-size: 9px;
      font-family: 'JetBrains Mono', -apple-system, monospace;
      color: #555;
    }

    .marker-item-actions {
      display: flex;
      gap: 2px;
      opacity: 0;
      transition: opacity 0.1s ease;
    }

    .marker-item:hover .marker-item-actions {
      opacity: 1;
    }

    .marker-action-btn {
      width: 18px;
      height: 18px;
      border-radius: 2px;
      background: transparent;
      border: none;
      color: #666;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      transition: all 0.1s ease;
    }

    .marker-action-btn:hover {
      background: #333;
      color: #aaa;
    }

    .marker-action-btn.delete:hover {
      background: rgba(239, 68, 68, 0.2);
      color: #ef4444;
    }

    .markers-empty {
      text-align: center;
      padding: 16px;
      color: #555;
      font-size: 10px;
    }

    /* Add Marker Modal - DaVinci Style */
    .marker-modal {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #252525;
      border: 1px solid #3a3a3a;
      border-radius: 4px;
      padding: 16px;
      min-width: 280px;
      z-index: 3000;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.6);
    }

    .marker-modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.6);
      z-index: 2999;
    }

    .marker-modal-title {
      font-size: 12px;
      font-weight: 600;
      margin-bottom: 12px;
      color: #ccc;
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }

    .marker-color-picker {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      margin-bottom: 12px;
    }

    .marker-color-option {
      width: 22px;
      height: 22px;
      border-radius: 2px;
      cursor: pointer;
      border: 2px solid transparent;
      transition: all 0.1s ease;
    }

    .marker-color-option:hover {
      transform: scale(1.05);
    }

    .marker-color-option.selected {
      border-color: white;
    }

    .marker-modal-actions {
      display: flex;
      gap: 6px;
      justify-content: flex-end;
      margin-top: 16px;
    }

    /* Extended Metadata Section */
    .marker-metadata-section {
      margin-top: 16px;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      overflow: hidden;
    }

    .marker-metadata-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 14px;
      background: var(--bg-dark);
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      color: var(--text-secondary);
      transition: all 0.2s ease;
    }

    .marker-metadata-header:hover {
      background: var(--bg-hover);
      color: var(--text-primary);
    }

    .metadata-toggle {
      font-size: 10px;
      transition: transform 0.2s ease;
    }

    .metadata-toggle.collapsed {
      transform: rotate(-90deg);
    }

    .marker-metadata-content {
      padding: 14px;
      background: var(--bg-surface);
    }

    .marker-metadata-content.collapsed {
      display: none;
    }

    .form-textarea {
      resize: vertical;
      min-height: 60px;
      font-family: inherit;
      line-height: 1.5;
    }

    .marker-metadata-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid var(--border-color);
    }

    .metadata-stat {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .metadata-stat-label {
      font-size: 10px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .metadata-stat-value {
      font-size: 12px;
      font-family: 'JetBrains Mono', monospace;
      color: var(--text-secondary);
    }

    /* Marker Details Panel in Sidebar */
    .marker-details-panel {
      background: var(--bg-surface);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      margin-top: 12px;
      overflow: hidden;
    }

    .marker-details-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      background: var(--bg-dark);
      border-bottom: 1px solid var(--border-color);
    }

    .marker-details-title {
      font-size: 13px;
      font-weight: 600;
      color: var(--text-primary);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .marker-details-close {
      width: 24px;
      height: 24px;
      border-radius: 4px;
      background: transparent;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
    }

    .marker-details-close:hover {
      background: var(--bg-hover);
      color: var(--text-primary);
    }

    .marker-details-content {
      padding: 12px;
    }

    .marker-detail-row {
      margin-bottom: 12px;
    }

    .marker-detail-row:last-child {
      margin-bottom: 0;
    }

    .marker-detail-label {
      font-size: 10px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 4px;
    }

    .marker-detail-value {
      font-size: 12px;
      color: var(--text-primary);
      line-height: 1.5;
    }

    .marker-detail-value.mono {
      font-family: 'JetBrains Mono', monospace;
    }

    .marker-detail-value.transcription {
      background: var(--bg-dark);
      padding: 8px;
      border-radius: 6px;
      font-style: italic;
      max-height: 100px;
      overflow-y: auto;
    }

    .marker-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
    }

    .marker-tag {
      background: var(--accent-primary);
      color: white;
      font-size: 10px;
      padding: 2px 8px;
      border-radius: 10px;
    }

    .marker-timecode-display {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px;
      background: var(--bg-dark);
      border-radius: 6px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 13px;
    }

    .marker-timecode-display .tc-in {
      color: var(--success);
    }

    .marker-timecode-display .tc-out {
      color: var(--error);
    }

    .marker-timecode-display .tc-duration {
      color: var(--accent-primary);
      margin-left: auto;
    }

    /* Screen Grabs Preview */
    .screengrabs-preview {
      margin-top: 12px;
      padding: 12px;
      background: var(--bg-dark);
      border-radius: 8px;
    }

    .screengrabs-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
      gap: 8px;
      margin-bottom: 10px;
    }

    .screengrab-item {
      position: relative;
      aspect-ratio: 16/9;
      border-radius: 6px;
      overflow: hidden;
      cursor: pointer;
      transition: transform 0.15s ease;
    }

    .screengrab-item:hover {
      transform: scale(1.05);
    }

    .screengrab-item img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .screengrab-time {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 4px 6px;
      background: linear-gradient(transparent, rgba(0,0,0,0.8));
      font-size: 9px;
      font-family: 'JetBrains Mono', monospace;
      color: white;
      text-align: center;
    }

    .screengrabs-actions {
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .screengrabs-count {
      font-size: 11px;
      color: var(--text-muted);
    }

    /* Screengrab Modal for full view */
    .screengrab-modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.9);
      z-index: 4000;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .screengrab-modal img {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
      border-radius: 8px;
    }

    .screengrab-modal-close {
      position: absolute;
      top: 20px;
      right: 20px;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.1);
      border: none;
      color: white;
      font-size: 20px;
      cursor: pointer;
    }

    .screengrab-modal-info {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.7);
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 12px;
      color: white;
      font-family: 'JetBrains Mono', monospace;
    }

    /* Story Beats Tab */
    .scenes-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 10px;
      background: #1c1c1c;
      border-bottom: 1px solid #141414;
    }

    .scenes-title {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 11px;
      font-weight: 600;
      color: #999;
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }

    .scenes-count {
      background: #333;
      color: #aaa;
      font-size: 9px;
      padding: 2px 6px;
      border-radius: 2px;
      font-weight: 500;
    }

    .scenes-actions {
      display: flex;
      gap: 2px;
    }

    .scenes-actions .btn {
      padding: 4px 6px;
    }

    .scenes-actions svg {
      stroke: currentColor;
      fill: none;
      stroke-width: 2;
    }

    .scenes-list {
      padding: 12px;
      overflow-y: auto;
      max-height: 300px;
    }

    .scenes-empty {
      text-align: center;
      padding: 30px 16px;
    }

    .scenes-empty-icon {
      color: #444;
      margin-bottom: 10px;
    }

    .scenes-empty-text {
      font-size: 12px;
      color: #777;
      margin-bottom: 4px;
    }

    .scenes-empty-hint {
      font-size: 10px;
      color: #555;
    }

    /* Scene Card */
    .scene-card {
      display: flex;
      gap: 12px;
      padding: 10px;
      background: var(--bg-dark);
      border-radius: 10px;
      margin-bottom: 10px;
      cursor: pointer;
      transition: all 0.2s ease;
      border: 2px solid transparent;
    }

    .scene-card:hover {
      background: var(--bg-hover);
      border-color: var(--border-color);
    }

    .scene-card.active {
      border-color: var(--accent-primary);
      background: rgba(59, 130, 246, 0.1);
    }

    .scene-thumbnail {
      width: 100px;
      height: 56px;
      border-radius: 6px;
      overflow: hidden;
      flex-shrink: 0;
      background: var(--bg-surface);
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }

    .scene-thumbnail img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .scene-thumbnail-placeholder {
      font-size: 24px;
      opacity: 0.3;
    }

    .scene-thumbnail-loading {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.5);
      font-size: 12px;
    }

    .scene-type-badge {
      position: absolute;
      top: 4px;
      left: 4px;
      font-size: 10px;
      background: rgba(0, 0, 0, 0.7);
      padding: 2px 4px;
      border-radius: 3px;
    }

    .scene-info {
      flex: 1;
      min-width: 0;
      display: flex;
      flex-direction: column;
      justify-content: center;
    }

    .scene-number {
      font-size: 10px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 2px;
    }

    .scene-title {
      font-size: 13px;
      font-weight: 600;
      color: var(--text-primary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      margin-bottom: 4px;
    }

    .scene-time {
      font-size: 11px;
      font-family: 'JetBrains Mono', monospace;
      color: var(--text-muted);
    }

    .scene-time .duration {
      color: var(--accent-primary);
    }

    .scene-meta-icons {
      display: flex;
      gap: 6px;
      margin-top: 4px;
    }

    .scene-meta-icon {
      font-size: 10px;
      opacity: 0.6;
    }

    .scene-color-bar {
      width: 4px;
      border-radius: 2px;
      flex-shrink: 0;
    }

    /* Scene Details Panel */
    .scene-details {
      background: var(--bg-panel);
      display: flex;
      flex-direction: column;
      border-top: 1px solid var(--border-color);
      margin-top: 12px;
    }

    .scene-details-header {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 16px;
      border-bottom: 1px solid var(--border-color);
    }

    .scene-details-back {
      background: var(--bg-dark);
      border: 1px solid var(--border-color);
      color: var(--text-secondary);
      cursor: pointer;
      font-size: 12px;
      padding: 4px 10px;
      border-radius: 4px;
    }

    .scene-details-back:hover {
      background: var(--bg-hover);
      color: var(--text-primary);
    }

    .scene-details-title {
      font-size: 14px;
      font-weight: 600;
      color: var(--text-primary);
    }

    .scene-details-content {
      overflow-y: auto;
      padding: 16px;
      max-height: 400px;
    }

    .scene-details-thumbnail {
      width: 100%;
      aspect-ratio: 16/9;
      border-radius: 8px;
      overflow: hidden;
      margin-bottom: 16px;
      background: var(--bg-dark);
    }

    .scene-details-thumbnail img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .scene-details-section {
      margin-bottom: 16px;
    }

    .scene-details-label {
      font-size: 10px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 6px;
    }

    .scene-details-value {
      font-size: 13px;
      color: var(--text-primary);
      line-height: 1.5;
    }

    .scene-details-timecode {
      display: flex;
      gap: 12px;
      padding: 10px;
      background: var(--bg-dark);
      border-radius: 8px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 12px;
    }

    .scene-details-timecode .in { color: var(--success); }
    .scene-details-timecode .out { color: var(--error); }
    .scene-details-timecode .duration { color: var(--accent-primary); margin-left: auto; }

    .scene-details-transcription {
      background: var(--bg-dark);
      padding: 12px;
      border-radius: 8px;
      font-style: italic;
      max-height: 150px;
      overflow-y: auto;
    }

    .scene-details-actions {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      margin-top: 16px;
    }

    /* Playlist Styles */
    .playlist-panel {
      background: #1a1a1a;
      border-radius: 3px;
      margin: 8px;
      overflow: hidden;
      transition: all 0.15s ease;
      border: 1px solid #252525;
    }

    .playlist-panel.drag-over {
      border-color: var(--accent-primary);
      background: rgba(232, 76, 61, 0.05);
    }

    .scene-card {
      cursor: grab;
    }

    .scene-card:active {
      cursor: grabbing;
    }

    .scene-card.dragging {
      opacity: 0.5;
    }

    .scene-add-btn {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      background: var(--bg-surface);
      border: 1px solid var(--border-color);
      color: var(--text-muted);
      font-size: 16px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      transition: all 0.2s ease;
    }

    .scene-add-btn:hover {
      background: var(--accent-primary);
      border-color: var(--accent-primary);
      color: white;
    }

    .playlist-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 10px;
      background: #1f1f1f;
      border-bottom: 1px solid #141414;
    }

    .playlist-title {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 11px;
      font-weight: 600;
      color: #999;
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }

    .playlist-count {
      background: #333;
      color: #aaa;
      font-size: 9px;
      padding: 2px 8px;
      border-radius: 10px;
    }

    .playlist-duration {
      font-size: 11px;
      font-family: 'JetBrains Mono', monospace;
      color: var(--text-muted);
    }

    .playlist-controls {
      display: flex;
      gap: 4px;
      padding: 8px 12px;
      border-bottom: 1px solid var(--border-color);
    }

    .playlist-play-btn {
      flex: 1;
      padding: 8px 12px;
      background: #333;
      border: none;
      border-radius: 3px;
      color: #ccc;
      font-size: 11px;
      font-weight: 500;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      transition: all 0.1s ease;
    }

    .playlist-play-btn:hover {
      background: #444;
      color: #fff;
    }

    .playlist-play-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .playlist-play-btn.playing {
      background: var(--accent-primary);
      color: #fff;
    }

    .playlist-play-btn svg {
      flex-shrink: 0;
    }

    .playlist-items {
      max-height: 250px;
      overflow-y: auto;
    }

    .playlist-empty {
      padding: 30px 20px;
      text-align: center;
      color: var(--text-muted);
      font-size: 12px;
    }

    .playlist-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 12px;
      border-bottom: 1px solid var(--border-color);
      cursor: grab;
      transition: all 0.15s ease;
    }

    .playlist-item:hover {
      background: var(--bg-hover);
    }

    .playlist-item.playing {
      background: rgba(59, 130, 246, 0.15);
      border-left: 3px solid var(--accent-primary);
    }

    .playlist-item.dragging {
      opacity: 0.5;
      background: var(--bg-surface);
    }

    .playlist-item-drag {
      color: var(--text-muted);
      font-size: 12px;
      cursor: grab;
    }

    .playlist-item-number {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: var(--bg-surface);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      font-weight: 600;
      color: var(--text-secondary);
      flex-shrink: 0;
    }

    .playlist-item.playing .playlist-item-number {
      background: var(--accent-primary);
      color: white;
    }

    .playlist-item-color {
      width: 4px;
      height: 30px;
      border-radius: 2px;
      flex-shrink: 0;
    }

    .playlist-item-info {
      flex: 1;
      min-width: 0;
    }

    .playlist-item-name {
      font-size: 12px;
      color: var(--text-primary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .playlist-item-time {
      font-size: 10px;
      font-family: 'JetBrains Mono', monospace;
      color: var(--text-muted);
    }

    .playlist-item-remove {
      width: 24px;
      height: 24px;
      border-radius: 4px;
      background: transparent;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: all 0.15s ease;
    }

    .playlist-item:hover .playlist-item-remove {
      opacity: 1;
    }

    .playlist-item-remove:hover {
      background: rgba(239, 68, 68, 0.2);
      color: var(--error);
    }

    .playlist-footer {
      padding: 8px 12px;
      display: flex;
      gap: 8px;
    }

    .playlist-footer button {
      flex: 1;
    }

    /* Playing indicator animation */
    @keyframes playingPulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .playlist-item.playing .playlist-item-number {
      animation: playingPulse 1s ease-in-out infinite;
    }

    /* AI Playlist Builder */
    .ai-playlist-builder {
      border-top: 1px solid var(--border-color);
    }

    .ai-builder-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      cursor: pointer;
      font-size: 12px;
      font-weight: 600;
      color: var(--text-secondary);
      background: linear-gradient(135deg, rgba(139, 92, 246, 0.1) 0%, rgba(59, 130, 246, 0.1) 100%);
      transition: all 0.2s ease;
    }

    .ai-builder-header:hover {
      background: linear-gradient(135deg, rgba(139, 92, 246, 0.2) 0%, rgba(59, 130, 246, 0.2) 100%);
      color: var(--text-primary);
    }

    .ai-builder-toggle {
      font-size: 10px;
      transition: transform 0.2s ease;
    }

    .ai-builder-toggle.collapsed {
      transform: rotate(-90deg);
    }

    .ai-builder-content {
      padding: 12px;
      background: var(--bg-surface);
    }

    .ai-builder-content.collapsed {
      display: none;
    }

    .ai-builder-options {
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin-bottom: 12px;
    }

    .ai-option {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 11px;
      color: var(--text-secondary);
      cursor: pointer;
    }

    .ai-option input[type="checkbox"] {
      width: 14px;
      height: 14px;
      accent-color: var(--accent-primary);
    }

    .ai-builder-status {
      margin-top: 10px;
      padding: 10px;
      border-radius: 6px;
      font-size: 12px;
      text-align: center;
    }

    .ai-builder-status.loading {
      background: rgba(59, 130, 246, 0.1);
      color: var(--accent-primary);
    }

    .ai-builder-status.success {
      background: rgba(34, 197, 94, 0.1);
      color: var(--success);
    }

    .ai-builder-status.error {
      background: rgba(239, 68, 68, 0.1);
      color: var(--error);
    }

    /* Marker Type Selector */
    .marker-type-selector {
      display: flex;
      gap: 10px;
    }

    .marker-type-btn {
      flex: 1;
      padding: 12px;
      background: var(--bg-dark);
      border: 2px solid var(--border-color);
      border-radius: 10px;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      transition: all 0.2s ease;
    }

    .marker-type-btn:hover {
      border-color: var(--accent-primary);
    }

    .marker-type-btn.active {
      border-color: var(--accent-primary);
      background: rgba(59, 130, 246, 0.1);
    }

    .marker-type-icon {
      font-size: 24px;
    }

    .marker-type-label {
      font-size: 13px;
      font-weight: 600;
      color: var(--text-primary);
    }

    .marker-type-desc {
      font-size: 10px;
      color: var(--text-muted);
    }

    /* Range Time Inputs */
    .range-time-inputs {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .range-time-input {
      flex: 1;
      text-align: center;
    }

    .range-time-value {
      font-size: 18px;
      font-family: 'JetBrains Mono', monospace;
      color: var(--accent-primary);
      padding: 8px;
      background: var(--bg-dark);
      border-radius: 6px;
      margin: 6px 0;
    }

    .range-time-arrow {
      font-size: 20px;
      color: var(--text-muted);
      padding-top: 20px;
    }

    .range-duration {
      text-align: center;
      font-size: 12px;
      color: var(--text-secondary);
      margin-top: 8px;
      padding: 6px;
      background: var(--bg-dark);
      border-radius: 4px;
    }

    .btn-sm {
      padding: 4px 8px;
      font-size: 10px;
    }

    /* Range Marker on Timeline */
    .marker-range {
      position: absolute;
      top: 0;
      height: 100%;
      opacity: 0.3;
      cursor: pointer;
      transition: opacity 0.15s ease;
    }

    .marker-range:hover {
      opacity: 0.5;
    }

    .marker-range-label {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 10px;
      white-space: nowrap;
      opacity: 0;
      transition: opacity 0.15s ease;
    }

    .marker-range:hover .marker-range-label {
      opacity: 1;
    }

    .marker-range.dragging {
      opacity: 0.7;
      cursor: grabbing;
    }

    .marker-range-handle {
      position: absolute;
      top: 0;
      width: 8px;
      height: 100%;
      cursor: ew-resize;
      z-index: 5;
    }

    .marker-range-handle.left {
      left: 0;
    }

    .marker-range-handle.right {
      right: 0;
    }

    .marker-range-handle:hover {
      background: rgba(255, 255, 255, 0.3);
    }

    /* Pending Range Indicator */
    .pending-range-indicator {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--accent-primary);
      color: white;
      padding: 10px 20px;
      border-radius: 8px;
      font-size: 13px;
      display: flex;
      align-items: center;
      gap: 10px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      z-index: 1000;
    }

    .pending-range-indicator button {
      background: rgba(255, 255, 255, 0.2);
      border: none;
      color: white;
      padding: 4px 10px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }

    .pending-range-indicator button:hover {
      background: rgba(255, 255, 255, 0.3);
    }

    /* Audio Track */
    .audio-track {
      flex: 1;
      height: 50px;
      background: var(--bg-dark);
      border-radius: 0 8px 8px 0;
      position: relative;
      overflow: hidden;
      cursor: pointer;
    }

    .audio-waveform {
      width: 100%;
      height: 100%;
      opacity: 0.8;
    }

    .audio-playhead {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 2px;
      background: var(--accent-primary);
      transform: translateX(-50%);
      pointer-events: none;
      z-index: 5;
    }

    .audio-track.detached {
      border: 2px dashed var(--accent-secondary);
      opacity: 0.6;
    }

    .audio-track.detached::after {
      content: 'Audio Detached';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 11px;
      color: var(--accent-secondary);
      background: var(--bg-dark);
      padding: 4px 8px;
      border-radius: 4px;
    }

    /* Progress Modal */
    /* Modal - DaVinci Style */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.75);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: all 0.2s ease;
    }

    .modal-overlay.visible {
      opacity: 1;
      visibility: visible;
    }

    .modal {
      background: #252525;
      border-radius: 4px;
      padding: 20px;
      min-width: 360px;
      border: 1px solid #3a3a3a;
      transform: scale(0.98);
      transition: transform 0.2s ease;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
    }

    .modal-overlay.visible .modal {
      transform: scale(1);
    }

    .modal-title {
      font-size: 13px;
      font-weight: 600;
      margin-bottom: 6px;
      color: #ddd;
    }

    .modal-subtitle {
      color: #777;
      font-size: 11px;
      margin-bottom: 16px;
    }

    .progress-bar {
      height: 4px;
      background: #1a1a1a;
      border-radius: 2px;
      overflow: hidden;
      margin-bottom: 12px;
    }

    .progress-fill {
      height: 100%;
      background: var(--accent-gradient);
      border-radius: 4px;
      transition: width 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .progress-fill::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
      animation: shimmer 1.5s infinite;
    }

    @keyframes shimmer {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }

    .progress-text {
      display: flex;
      justify-content: space-between;
      font-size: 13px;
      color: var(--text-secondary);
    }

    .progress-percent {
      color: var(--accent-primary);
      font-weight: 600;
    }

    /* Spaces Panel */
    .spaces-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .space-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px;
      background: var(--bg-dark);
      border: 1px solid var(--border-color);
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .space-item:hover {
      border-color: var(--accent-primary);
      background: var(--bg-elevated);
    }

    .space-item.active {
      border-color: var(--accent-primary);
      background: rgba(99, 102, 241, 0.1);
    }

    .space-icon {
      width: 36px;
      height: 36px;
      background: var(--accent-gradient);
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
    }

    .space-info {
      flex: 1;
    }

    .space-name {
      font-size: 14px;
      font-weight: 500;
    }

    .space-count {
      font-size: 12px;
      color: var(--text-muted);
    }

    /* Video List in Space */
    .video-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 16px;
    }

    .video-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 10px;
      background: var(--bg-dark);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .video-item:hover {
      border-color: var(--accent-primary);
    }

    .video-thumb {
      width: 64px;
      height: 36px;
      background: var(--bg-elevated);
      border-radius: 4px;
      object-fit: cover;
    }

    .video-info {
      flex: 1;
      min-width: 0;
    }

    .video-name {
      font-size: 13px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .video-meta {
      font-size: 11px;
      color: var(--text-muted);
    }

    /* Export Panel */
    .export-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .export-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px;
      background: var(--bg-dark);
      border: 1px solid var(--border-color);
      border-radius: 10px;
      transition: all 0.2s ease;
    }

    .export-item:hover {
      border-color: var(--accent-primary);
    }

    .export-icon {
      width: 40px;
      height: 40px;
      background: var(--bg-elevated);
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
    }

    .export-info {
      flex: 1;
      min-width: 0;
    }

    .export-name {
      font-size: 13px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .export-size {
      font-size: 11px;
      color: var(--text-muted);
    }

    .export-actions {
      display: flex;
      gap: 4px;
    }

    .export-action-btn {
      width: 32px;
      height: 32px;
      background: transparent;
      border: 1px solid var(--border-color);
      border-radius: 6px;
      color: var(--text-secondary);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
    }

    .export-action-btn:hover {
      border-color: var(--accent-primary);
      color: var(--accent-primary);
    }

    /* Info Panel */
    .info-grid {
      display: grid;
      gap: 12px;
    }

    .info-item {
      display: flex;
      justify-content: space-between;
      padding: 10px 12px;
      background: var(--bg-dark);
      border-radius: 8px;
    }

    .info-label {
      color: var(--text-muted);
      font-size: 12px;
    }

    .info-value {
      font-family: 'JetBrains Mono', monospace;
      font-size: 12px;
      color: var(--text-primary);
    }

    /* Toast Notifications */
    .toast-container {
      position: fixed;
      bottom: 20px;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      z-index: 1001;
    }

    .toast {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 14px 20px;
      background: var(--bg-surface);
      border: 1px solid var(--border-color);
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
      transform: translateX(120%);
      transition: transform 0.3s ease;
    }

    .toast.visible {
      transform: translateX(0);
    }

    .toast-icon {
      font-size: 20px;
    }

    .toast.success .toast-icon { color: var(--success); }
    .toast.error .toast-icon { color: var(--error); }
    .toast.warning .toast-icon { color: var(--warning); }

    .toast-message {
      font-size: 14px;
    }

    /* Scrollbar */
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }

    ::-webkit-scrollbar-track {
      background: transparent;
    }

    ::-webkit-scrollbar-thumb {
      background: var(--border-color);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: var(--text-muted);
    }

    /* Animations */
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .fade-in {
      animation: fadeIn 0.3s ease;
    }

    /* Hidden */
    .hidden {
      display: none !important;
    }

    /* Context Menu */
    .context-menu {
      position: fixed;
      z-index: 2000;
      min-width: 180px;
      max-width: 280px;
      background: var(--bg-surface);
      border: 1px solid var(--border-color);
      border-radius: 10px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
      padding: 6px;
      display: none;
      animation: contextMenuFadeIn 0.15s ease;
    }

    @keyframes contextMenuFadeIn {
      from {
        opacity: 0;
        transform: scale(0.95);
      }
      to {
        opacity: 1;
        transform: scale(1);
      }
    }

    .context-menu.visible {
      display: block;
    }

    .context-menu-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      color: var(--text-primary);
      transition: all 0.15s ease;
    }

    .context-menu-item:hover {
      background: var(--bg-hover);
    }

    .context-menu-item.danger {
      color: var(--error);
    }

    .context-menu-item.danger:hover {
      background: rgba(239, 68, 68, 0.15);
    }

    .context-menu-item.disabled {
      opacity: 0.4;
      pointer-events: none;
    }

    .context-menu-item-icon {
      font-size: 16px;
      width: 20px;
      text-align: center;
    }

    .context-menu-item-label {
      flex: 1;
    }

    .context-menu-item-shortcut {
      font-size: 11px;
      color: var(--text-muted);
      font-family: 'JetBrains Mono', monospace;
    }

    .context-menu-divider {
      height: 1px;
      background: var(--border-color);
      margin: 6px 0;
    }

    .context-menu-header {
      padding: 8px 12px 6px;
      font-size: 10px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-muted);
    }

    /* ============================================
       LAYOUT NAVIGATION (Edit / Story Beats)
       ============================================ */
    .layout-nav {
      display: flex;
      align-items: center;
      gap: 4px;
      background: var(--bg-dark);
      border-radius: 8px;
      padding: 4px;
    }

    .layout-nav-btn {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 8px 16px;
      background: transparent;
      border: none;
      border-radius: 6px;
      color: var(--text-secondary);
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .layout-nav-btn:hover {
      color: var(--text-primary);
      background: var(--bg-elevated);
    }

    .layout-nav-btn.active {
      background: var(--accent-primary);
      color: white;
    }

    .layout-nav-btn svg {
      width: 14px;
      height: 14px;
    }

    .layout-nav-arrow {
      color: var(--text-muted);
      font-size: 16px;
      padding: 0 4px;
    }

    /* Layout visibility */
    body[data-layout="edit"] .layout-beats-only { display: none !important; }
    body[data-layout="beats"] .layout-edit-only { display: none !important; }

    /* Story Beats Layout Styles */
    .beats-inspector {
      width: var(--inspector-width);
      background: var(--bg-dark);
      border-left: 1px solid #141414;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .beats-inspector-header {
      padding: 16px;
      border-bottom: 1px solid var(--border-color);
    }

    .beats-inspector-title {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 4px;
    }

    .beats-inspector-subtitle {
      font-size: 11px;
      color: var(--text-muted);
    }

    .beats-inspector-content {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
    }

    .beat-form-group {
      margin-bottom: 16px;
    }

    .beat-form-label {
      display: block;
      font-size: 11px;
      font-weight: 600;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 6px;
    }

    .beat-form-input,
    .beat-form-textarea {
      width: 100%;
      padding: 10px 12px;
      background: var(--bg-surface);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      color: var(--text-primary);
      font-size: 13px;
      font-family: inherit;
    }

    .beat-form-input:focus,
    .beat-form-textarea:focus {
      outline: none;
      border-color: var(--accent-primary);
    }

    .beat-form-textarea {
      min-height: 80px;
      resize: vertical;
    }

    .beat-tags-container {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .beat-tag {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 4px 10px;
      background: var(--bg-elevated);
      border-radius: 12px;
      font-size: 11px;
      color: var(--text-primary);
    }

    .beat-tag-remove {
      background: none;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      padding: 0;
      font-size: 14px;
      line-height: 1;
    }

    .beat-tag-remove:hover {
      color: var(--error);
    }

    .beat-links-section {
      margin-top: 24px;
      padding-top: 16px;
      border-top: 1px solid var(--border-color);
    }

    .beat-link-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px;
      background: var(--bg-surface);
      border-radius: 6px;
      margin-bottom: 8px;
    }

    .beat-link-info {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .beat-link-type {
      font-size: 10px;
      padding: 2px 6px;
      background: var(--accent-secondary);
      color: white;
      border-radius: 4px;
    }

    /* Beat Graph Visualization */
    .beat-graph-container {
      background: var(--bg-surface);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      min-height: 200px;
      margin-top: 16px;
      position: relative;
      overflow: hidden;
    }

    .beat-graph-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px;
      border-bottom: 1px solid var(--border-color);
    }

    .beat-graph-title {
      font-size: 12px;
      font-weight: 600;
    }

    .beat-graph-canvas {
      padding: 16px;
      min-height: 150px;
    }

    /* Beats Timeline Track */
    .beats-timeline {
      background: var(--bg-surface);
      border-radius: 6px;
      padding: 8px;
      margin: 8px 0;
    }

    .beat-marker {
      display: inline-block;
      padding: 6px 12px;
      background: var(--accent-secondary);
      color: white;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 500;
      cursor: pointer;
      margin-right: 4px;
      transition: all 0.15s;
    }

    .beat-marker:hover {
      filter: brightness(1.1);
      transform: translateY(-1px);
    }

    .beat-marker.selected {
      box-shadow: 0 0 0 2px var(--accent-primary);
    }

    /* Translation Panel Styles */
    .translation-panel {
      position: fixed;
      right: 0;
      top: 48px;
      bottom: 0;
      width: 450px;
      background: var(--bg-surface);
      border-left: 1px solid var(--border-color);
      z-index: 100;
      display: flex;
      flex-direction: column;
      transform: translateX(100%);
      transition: transform 0.3s ease;
    }

    .translation-panel.open {
      transform: translateX(0);
    }

    .translation-panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 16px;
      border-bottom: 1px solid var(--border-color);
    }

    .translation-panel-title {
      font-size: 14px;
      font-weight: 600;
    }

    .translation-panel-close {
      background: none;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      padding: 4px;
    }

    .translation-panel-close:hover {
      color: var(--text-primary);
    }

    .translation-panel-content {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
    }

    .translation-step {
      margin-bottom: 24px;
    }

    .translation-step-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 12px;
    }

    .translation-step-number {
      width: 24px;
      height: 24px;
      background: var(--accent-primary);
      color: white;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: 600;
    }

    .translation-step-title {
      font-size: 13px;
      font-weight: 600;
    }

    .translation-text-box {
      background: var(--bg-panel);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 12px;
      font-size: 13px;
      line-height: 1.6;
    }

    .translation-score-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
      margin-top: 12px;
    }

    .translation-score-item {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
    }

    .translation-score-bar {
      flex: 1;
      height: 6px;
      background: var(--bg-elevated);
      border-radius: 3px;
      overflow: hidden;
    }

    .translation-score-fill {
      height: 100%;
      background: var(--accent-success);
      border-radius: 3px;
    }

    .translation-score-value {
      width: 30px;
      text-align: right;
      color: var(--text-secondary);
    }

    .translation-composite-score {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 16px;
      background: var(--bg-panel);
      border-radius: 8px;
      margin-top: 16px;
    }

    .translation-composite-value {
      font-size: 32px;
      font-weight: 700;
      color: var(--accent-success);
    }

    .translation-composite-label {
      font-size: 12px;
      color: var(--text-muted);
      margin-left: 8px;
    }

    /* Deploy Panel Styles */
    .deploy-panel {
      background: var(--bg-surface);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 16px;
      margin-top: 16px;
    }

    .deploy-btn {
      width: 100%;
      padding: 14px;
      background: var(--accent-success);
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      transition: all 0.15s;
    }

    .deploy-btn:hover {
      filter: brightness(1.1);
    }

    .embed-code-box {
      background: var(--bg-panel);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      padding: 12px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 11px;
      color: var(--text-secondary);
      margin-top: 12px;
      white-space: pre-wrap;
      word-break: break-all;
    }

    /* ============================================
       MULTI-TRACK TIMELINE SYSTEM
       ============================================ */
    .track-controls-container {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .timeline-row.audio-track {
      min-height: 50px;
    }

    .track-action-btn {
      width: 24px;
      height: 24px;
      padding: 0;
      font-size: 10px;
      font-weight: 600;
    }

    .track-action-btn.active {
      background: var(--accent-primary);
      color: white;
    }

    .track-action-btn.muted {
      background: var(--error);
      color: white;
    }

    .track-action-btn.solo {
      background: var(--warning);
      color: white;
    }

    .add-track-row {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 8px;
      margin-top: 4px;
      background: var(--bg-dark);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.15s;
    }

    .add-track-row:hover {
      background: var(--bg-surface);
    }

    .add-track-btn {
      display: flex;
      align-items: center;
      gap: 8px;
      background: transparent;
      border: 1px dashed var(--border-light);
      border-radius: 6px;
      padding: 8px 16px;
      color: var(--text-muted);
      font-size: 12px;
      cursor: pointer;
      transition: all 0.15s;
    }

    .add-track-btn:hover {
      border-color: var(--accent-primary);
      color: var(--accent-primary);
    }

    .add-track-menu {
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: var(--bg-surface);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 8px;
      display: none;
      z-index: 100;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    .add-track-menu.visible {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .add-track-option {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      background: transparent;
      border: none;
      color: var(--text-primary);
      font-size: 12px;
      cursor: pointer;
      border-radius: 4px;
      white-space: nowrap;
    }

    .add-track-option:hover {
      background: var(--bg-hover);
    }

    .track-type-badge {
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 4px;
      font-weight: 600;
    }

    .track-type-badge.voice {
      background: #8b5cf6;
      color: white;
    }

    .track-type-badge.music {
      background: #22c55e;
      color: white;
    }

    .track-type-badge.sfx {
      background: #f97316;
      color: white;
    }

    .track-type-badge.ambience {
      background: #06b6d4;
      color: white;
    }

    /* Audio clip styling on multi-track */
    .audio-clip {
      position: absolute;
      height: calc(100% - 8px);
      top: 4px;
      background: var(--accent-tertiary);
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      align-items: center;
      padding: 0 8px;
      font-size: 10px;
      color: white;
      overflow: hidden;
      transition: all 0.15s;
    }

    .audio-clip:hover {
      filter: brightness(1.1);
    }

    .audio-clip.selected {
      box-shadow: 0 0 0 2px var(--accent-primary);
    }

    .audio-clip.dragging {
      opacity: 0.7;
      z-index: 10;
    }

    .audio-clip-waveform {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      opacity: 0.5;
    }

    .audio-clip-name {
      position: relative;
      z-index: 1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* Track volume/gain control */
    .track-volume-slider {
      width: 60px;
      height: 4px;
      -webkit-appearance: none;
      background: var(--bg-elevated);
      border-radius: 2px;
      cursor: pointer;
    }

    .track-volume-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 12px;
      height: 12px;
      background: var(--accent-tertiary);
      border-radius: 50%;
      cursor: pointer;
    }

    /* Track empty state */
    .track-empty-state {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
      color: var(--text-muted);
      font-size: 11px;
      pointer-events: none;
    }

    /* Translation Segment Progress */
    .translation-segments-layer {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      z-index: 2;
    }

    .translation-segment {
      position: absolute;
      height: 100%;
      border-left: 2px solid #8b5cf6;
      border-right: 2px solid #8b5cf6;
      background: rgba(139, 92, 246, 0.1);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      color: white;
    }

    .translation-segment.empty {
      background: rgba(139, 92, 246, 0.05);
    }

    .translation-segment.marked {
      background: rgba(139, 92, 246, 0.15);
    }

    .translation-segment.working {
      background: rgba(251, 191, 36, 0.2);
      border-color: #fbbf24;
      animation: pulse-segment 1.5s infinite;
    }

    .translation-segment.approved {
      background: rgba(34, 197, 94, 0.2);
      border-color: #22c55e;
    }

    @keyframes pulse-segment {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }

    .translation-segment-label {
      font-size: 10px;
      font-weight: 600;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
    }

    /* Segment Navigation */
    .segment-nav {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      background: var(--bg-surface);
      border-radius: 6px;
      margin: 8px 0;
    }

    .segment-nav-info {
      flex: 1;
      font-size: 11px;
      color: var(--text-secondary);
    }

    /* Drag indicator for adding clips */
    .track-drop-indicator {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 3px;
      background: var(--accent-primary);
      pointer-events: none;
      display: none;
    }

    .timeline-track.drag-over .track-drop-indicator {
      display: block;
    }

    .timeline-track.drag-over {
      background: rgba(232, 76, 61, 0.1);
    }

    /* ============================================
       AI VIDEO REPLACEMENT PANEL
       ============================================ */
    .ai-video-panel {
      position: fixed;
      right: 0;
      top: 48px;
      bottom: 0;
      width: 480px;
      background: var(--bg-surface);
      border-left: 1px solid var(--border-color);
      z-index: 100;
      display: flex;
      flex-direction: column;
      transform: translateX(100%);
      transition: transform 0.3s ease;
    }

    .ai-video-panel.open {
      transform: translateX(0);
    }

    .ai-video-panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 16px;
      border-bottom: 1px solid var(--border-color);
      background: linear-gradient(180deg, #252525 0%, var(--bg-surface) 100%);
    }

    .ai-video-panel-title {
      font-size: 14px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .ai-video-panel-title svg {
      color: var(--accent-secondary);
    }

    .ai-video-panel-close {
      background: none;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      padding: 4px;
    }

    .ai-video-panel-close:hover {
      color: var(--text-primary);
    }

    .ai-video-panel-content {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
    }

    .ai-video-section {
      margin-bottom: 24px;
    }

    .ai-video-section-title {
      font-size: 12px;
      font-weight: 600;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 12px;
    }

    .ai-video-info-bar {
      display: flex;
      gap: 16px;
      padding: 12px;
      background: var(--bg-panel);
      border-radius: 8px;
      margin-bottom: 16px;
    }

    .ai-video-info-item {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .ai-video-info-label {
      font-size: 10px;
      color: var(--text-muted);
      text-transform: uppercase;
    }

    .ai-video-info-value {
      font-size: 14px;
      font-weight: 600;
      color: var(--text-primary);
    }

    .ai-video-description {
      width: 100%;
      min-height: 100px;
      padding: 12px;
      background: var(--bg-panel);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      color: var(--text-primary);
      font-size: 13px;
      font-family: inherit;
      resize: vertical;
      transition: border-color 0.15s;
    }

    .ai-video-description:focus {
      outline: none;
      border-color: var(--accent-secondary);
    }

    .ai-video-prompt-box {
      background: var(--bg-darkest);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 12px;
      font-size: 12px;
      line-height: 1.6;
      color: var(--text-secondary);
      font-family: 'JetBrains Mono', monospace;
      position: relative;
    }

    .ai-video-prompt-actions {
      display: flex;
      gap: 8px;
      margin-top: 12px;
    }

    .ai-video-prompt-actions .btn {
      flex: 1;
    }

    .ai-video-services {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
    }

    .ai-video-service-btn {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 12px;
      background: var(--bg-panel);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      color: var(--text-primary);
      font-size: 13px;
      cursor: pointer;
      transition: all 0.15s;
    }

    .ai-video-service-btn:hover {
      border-color: var(--accent-secondary);
      background: var(--bg-elevated);
    }

    .ai-video-service-btn .service-icon {
      font-size: 20px;
    }

    .ai-video-service-btn .service-name {
      font-weight: 500;
    }

    .ai-video-divider {
      display: flex;
      align-items: center;
      gap: 16px;
      margin: 20px 0;
      color: var(--text-muted);
      font-size: 11px;
      text-transform: uppercase;
    }

    .ai-video-divider::before,
    .ai-video-divider::after {
      content: '';
      flex: 1;
      height: 1px;
      background: var(--border-color);
    }

    .ai-video-upload-zone {
      border: 2px dashed var(--border-light);
      border-radius: 12px;
      padding: 32px;
      text-align: center;
      cursor: pointer;
      transition: all 0.15s;
    }

    .ai-video-upload-zone:hover,
    .ai-video-upload-zone.drag-over {
      border-color: var(--accent-primary);
      background: rgba(232, 76, 61, 0.05);
    }

    .ai-video-upload-icon {
      font-size: 48px;
      color: var(--text-muted);
      margin-bottom: 12px;
    }

    .ai-video-upload-text {
      font-size: 14px;
      color: var(--text-secondary);
      margin-bottom: 4px;
    }

    .ai-video-upload-hint {
      font-size: 11px;
      color: var(--text-muted);
    }

    .ai-video-upload-input {
      display: none;
    }

    /* ============================================
       STORY BEATS LAYOUT
       ============================================ */
    .beats-layout {
      display: flex;
      flex: 1;
      overflow: hidden;
    }

    .beats-main {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .beats-sidebar {
      width: 320px;
      background: var(--bg-dark);
      border-left: 1px solid var(--border-color);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .beats-sidebar-header {
      padding: 16px;
      border-bottom: 1px solid var(--border-color);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .beats-sidebar-title {
      font-size: 14px;
      font-weight: 600;
    }

    .beats-sidebar-tabs {
      display: flex;
      padding: 8px;
      gap: 4px;
      border-bottom: 1px solid var(--border-color);
    }

    .beats-sidebar-tab {
      flex: 1;
      padding: 8px 12px;
      background: transparent;
      border: none;
      color: var(--text-muted);
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      border-radius: 6px;
      transition: all 0.15s;
    }

    .beats-sidebar-tab.active {
      background: var(--accent-primary);
      color: white;
    }

    .beats-sidebar-tab:hover:not(.active) {
      background: var(--bg-hover);
      color: var(--text-primary);
    }

    .beats-sidebar-content {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
    }

    /* Beat List */
    .beat-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .beat-item {
      background: var(--bg-surface);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 12px;
      cursor: pointer;
      transition: all 0.15s;
    }

    .beat-item:hover {
      border-color: var(--accent-secondary);
    }

    .beat-item.selected {
      border-color: var(--accent-primary);
      background: rgba(232, 76, 61, 0.1);
    }

    .beat-item-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 8px;
    }

    .beat-item-name {
      font-size: 13px;
      font-weight: 600;
    }

    .beat-item-time {
      font-size: 11px;
      color: var(--text-muted);
      font-family: 'JetBrains Mono', monospace;
    }

    .beat-item-description {
      font-size: 12px;
      color: var(--text-secondary);
      line-height: 1.4;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }

    .beat-item-links {
      display: flex;
      gap: 4px;
      margin-top: 8px;
    }

    .beat-link-badge {
      font-size: 10px;
      padding: 2px 6px;
      background: var(--bg-elevated);
      border-radius: 4px;
      color: var(--text-secondary);
    }

    /* Beat Inspector */
    .beat-inspector {
      padding: 16px;
    }

    .beat-inspector-empty {
      text-align: center;
      padding: 40px 20px;
      color: var(--text-muted);
    }

    .beat-field {
      margin-bottom: 16px;
    }

    .beat-field-label {
      font-size: 11px;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 6px;
    }

    .beat-field-input,
    .beat-field-textarea {
      width: 100%;
      padding: 10px;
      background: var(--bg-surface);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      color: var(--text-primary);
      font-size: 13px;
    }

    .beat-field-input:focus,
    .beat-field-textarea:focus {
      outline: none;
      border-color: var(--accent-primary);
    }

    .beat-field-textarea {
      min-height: 80px;
      resize: vertical;
      font-family: inherit;
    }

    .beat-tags-input-container {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      padding: 8px;
      background: var(--bg-surface);
      border: 1px solid var(--border-color);
      border-radius: 6px;
    }

    .beat-tag-input {
      flex: 1;
      min-width: 60px;
      background: none;
      border: none;
      color: var(--text-primary);
      font-size: 12px;
    }

    .beat-tag-input:focus {
      outline: none;
    }

    /* Beat Graph Visualization */
    .beat-graph {
      background: var(--bg-darkest);
      border-radius: 8px;
      height: 300px;
      position: relative;
      overflow: hidden;
    }

    .beat-graph-toolbar {
      position: absolute;
      top: 8px;
      right: 8px;
      display: flex;
      gap: 4px;
      z-index: 10;
    }

    .beat-graph-btn {
      padding: 6px 10px;
      background: var(--bg-surface);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      color: var(--text-secondary);
      font-size: 11px;
      cursor: pointer;
    }

    .beat-graph-btn:hover {
      background: var(--bg-elevated);
      color: var(--text-primary);
    }

    .beat-graph-canvas {
      width: 100%;
      height: 100%;
    }

    .beat-node {
      position: absolute;
      padding: 12px 16px;
      background: var(--bg-surface);
      border: 2px solid var(--accent-secondary);
      border-radius: 8px;
      cursor: move;
      font-size: 12px;
      font-weight: 500;
      white-space: nowrap;
      user-select: none;
      z-index: 5;
    }

    .beat-node:hover {
      border-color: var(--accent-primary);
    }

    .beat-node.selected {
      border-color: var(--accent-primary);
      box-shadow: 0 0 0 3px rgba(232, 76, 61, 0.3);
    }

    .beat-node-connector {
      position: absolute;
      width: 12px;
      height: 12px;
      background: var(--accent-secondary);
      border-radius: 50%;
      cursor: crosshair;
      z-index: 6;
    }

    .beat-node-connector.left {
      left: -6px;
      top: 50%;
      transform: translateY(-50%);
    }

    .beat-node-connector.right {
      right: -6px;
      top: 50%;
      transform: translateY(-50%);
    }

    /* Beat Link Lines */
    .beat-link-line {
      position: absolute;
      pointer-events: none;
      z-index: 1;
    }

    .beat-link-label {
      position: absolute;
      background: var(--bg-panel);
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 10px;
      color: var(--text-muted);
      z-index: 2;
    }

    /* Cross-Video Beat Section */
    .cross-video-section {
      margin-top: 24px;
      padding-top: 16px;
      border-top: 1px solid var(--border-color);
    }

    .cross-video-title {
      font-size: 12px;
      font-weight: 600;
      color: var(--text-secondary);
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .cross-video-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .cross-video-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 10px;
      background: var(--bg-surface);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      cursor: pointer;
    }

    .cross-video-item:hover {
      border-color: var(--accent-secondary);
    }

    .cross-video-thumb {
      width: 48px;
      height: 32px;
      background: var(--bg-elevated);
      border-radius: 4px;
      object-fit: cover;
    }

    .cross-video-info {
      flex: 1;
    }

    .cross-video-name {
      font-size: 12px;
      font-weight: 500;
    }

    .cross-video-beats {
      font-size: 11px;
      color: var(--text-muted);
    }

    /* Deploy Panel */
    .deploy-section {
      padding: 16px;
      border-top: 1px solid var(--border-color);
    }

    .deploy-buttons {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .deploy-btn-large {
      padding: 16px;
      background: var(--accent-success);
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    .deploy-btn-large:hover {
      filter: brightness(1.1);
    }

    .deploy-btn-secondary {
      padding: 12px;
      background: var(--bg-surface);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      color: var(--text-primary);
      font-size: 13px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    .deploy-btn-secondary:hover {
      background: var(--bg-elevated);
    }
  </style>
</head>
<body>
  <!-- Header -->
  <!-- DaVinci-Style Header -->
  <header class="header">
    <div class="header-left">
      <button class="header-icon-btn" onclick="app.openFile()" title="Open">
        <svg viewBox="0 0 24 24" width="14" height="14" stroke="currentColor" fill="none" stroke-width="2"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/></svg>
      </button>
      <button class="header-icon-btn" onclick="app.openRecorder()" title="Open Recorder">
        <svg viewBox="0 0 24 24" width="14" height="14" stroke="currentColor" fill="none" stroke-width="2"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="3" fill="currentColor"/></svg>
      </button>
      <button class="header-icon-btn mode-edit-only" id="saveToSpaceBtn" onclick="app.saveToSpace()" style="display: none;" title="Save">
        <svg viewBox="0 0 24 24" width="14" height="14" stroke="currentColor" fill="none" stroke-width="2"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></svg>
      </button>
      <span class="file-name" id="fileName">No file loaded</span>
    </div>
    <div class="header-center">
      <!-- Layout Navigation -->
      <div class="layout-nav">
        <button class="layout-nav-btn active" id="layoutEditBtn" onclick="app.switchLayout('edit')">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="3"/><path d="M12 2v4m0 12v4M2 12h4m12 0h4"/>
          </svg>
          Edit
        </button>
        <span class="layout-nav-arrow"></span>
        <button class="layout-nav-btn" id="layoutBeatsBtn" onclick="app.switchLayout('beats')">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M12 2L2 7l10 5 10-5-10-5z"/><path d="M2 17l10 5 10-5"/><path d="M2 12l10 5 10-5"/>
          </svg>
          Story Beats
        </button>
      </div>
    </div>
    <div class="header-actions">
      <!-- Edit Mode Actions -->
      <button class="header-icon-btn mode-edit-only" title="Undo">
        <svg viewBox="0 0 24 24" width="14" height="14" stroke="currentColor" fill="none" stroke-width="2"><path d="M3 7v6h6"/><path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"/></svg>
      </button>
      <button class="header-icon-btn mode-edit-only" title="Redo">
        <svg viewBox="0 0 24 24" width="14" height="14" stroke="currentColor" fill="none" stroke-width="2"><path d="M21 7v6h-6"/><path d="M3 17a9 9 0 0 1 9-9 9 9 0 0 1 6 2.3l3 2.7"/></svg>
      </button>
      <button class="btn btn-primary mode-edit-only" id="exportBtn" onclick="app.showExportOptions()" disabled>
        Export
      </button>
      <!-- Annotate Mode Actions -->
      <button class="btn btn-secondary mode-annotate-only" onclick="app.exportToAgenticPlayer()" id="exportAnnotationsBtn">
        Export Annotations
      </button>
    </div>
  </header>

  <!-- Main Container -->
  <div class="main-container">
    <!-- Sidebar -->
    <aside class="sidebar">
      <!-- Tabs -->
      <div class="sidebar-tabs">
        <!-- Edit Mode Tabs -->
        <button class="sidebar-tab mode-edit-only active" data-tab="edit" onclick="app.switchTab('edit')">Tools</button>
        
        <!-- Annotate Mode Tabs -->
        <button class="sidebar-tab mode-annotate-only" data-tab="scenes" onclick="app.switchTab('scenes')">Annotations</button>
        
        <!-- Shared Tabs -->
        <button class="sidebar-tab" data-tab="spaces" onclick="app.switchTab('spaces')">Media</button>
        <button class="sidebar-tab" data-tab="exports" onclick="app.switchTab('exports')">Exports</button>
      </div>

      <!-- Edit Tab (Tools) - Edit Mode Only -->
      <div class="sidebar-content mode-edit-only" id="editTab">
        <!-- Edit Mode Header -->
        <div class="mode-header edit-mode-header">
          <div class="mode-header-icon">
            <svg viewBox="0 0 24 24" width="20" height="20" stroke="currentColor" fill="none" stroke-width="1.5">
              <circle cx="12" cy="12" r="3"/><path d="M12 2v4m0 12v4M2 12h4m12 0h4"/>
            </svg>
          </div>
          <div class="mode-header-text">
            <span class="mode-header-title">Edit Tools</span>
            <span class="mode-header-subtitle">Trim, splice, convert & adjust</span>
          </div>
        </div>

        <!-- Trim Section -->
        <div class="sidebar-section" id="trimSection">
          <div class="sidebar-section-title" onclick="app.toggleSection('trimSection')">
            <span><svg class="section-icon-svg" viewBox="0 0 24 24" width="14" height="14"><path d="M6 9a3 3 0 1 0 0-6 3 3 0 0 0 0 6zM6 21a3 3 0 1 0 0-6 3 3 0 0 0 0 6zM20 4L8.12 15.88M14.47 14.48L20 20M8.12 8.12L12 12"/></svg>Trim</span>
            <span class="section-toggle"></span>
          </div>
          <div class="sidebar-section-content">
            <div class="form-row" style="margin-bottom: 12px;">
              <div class="form-group" style="margin-bottom: 0;">
                <label class="form-label">Start</label>
                <input type="text" class="form-input" id="trimStart" value="00:00:00" placeholder="00:00:00">
              </div>
              <div class="form-group" style="margin-bottom: 0;">
                <label class="form-label">End</label>
                <input type="text" class="form-input" id="trimEnd" value="00:00:00" placeholder="00:00:00">
              </div>
            </div>
            <button class="btn btn-secondary" style="width: 100%;" onclick="app.trimVideo()" id="trimBtn" disabled>
              Trim Video
            </button>
          </div>
        </div>

        <!-- Splice Section -->
        <div class="sidebar-section collapsed" id="spliceSection">
          <div class="sidebar-section-title" onclick="app.toggleSection('spliceSection')">
            <span><svg class="section-icon-svg" viewBox="0 0 24 24" width="14" height="14"><path d="M4 12h16M12 4v16"/><path d="M8 8l-4 4 4 4M16 8l4 4-4 4"/></svg>Splice</span>
            <span class="section-toggle"></span>
          </div>
          <div class="sidebar-section-content">
            <p style="font-size: 11px; color: var(--text-muted); margin-bottom: 12px;">
              Remove a portion from the middle
            </p>
            <div class="form-row" style="margin-bottom: 8px;">
              <div class="form-group" style="margin-bottom: 0;">
                <label class="form-label">Cut Start</label>
                <input type="text" class="form-input" id="spliceStart" value="00:00:00">
              </div>
              <div class="form-group" style="margin-bottom: 0;">
                <label class="form-label">Cut End</label>
                <input type="text" class="form-input" id="spliceEnd" value="00:00:00">
              </div>
            </div>
            <div class="splice-preview" id="splicePreview" style="display: none; padding: 8px; background: rgba(239, 68, 68, 0.1); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 6px; margin-bottom: 12px; font-size: 11px;">
              <div style="color: var(--error);">Will remove: <span id="spliceRemoveTime">0:00</span></div>
              <div style="color: var(--text-secondary);">Result: <span id="spliceResultTime">0:00</span></div>
            </div>
            <div style="display: flex; gap: 8px; margin-bottom: 8px;">
              <button class="btn btn-ghost" style="flex: 1; font-size: 11px;" onclick="app.setSpliceStart()" id="setSpliceStartBtn" disabled>
                Set In
              </button>
              <button class="btn btn-ghost" style="flex: 1; font-size: 11px;" onclick="app.setSpliceEnd()" id="setSpliceEndBtn" disabled>
                Set Out
              </button>
            </div>
            <button class="btn btn-secondary" style="width: 100%; background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%); border: none;" onclick="app.spliceVideo()" id="spliceBtn" disabled>
              Remove Section
            </button>
          </div>
        </div>

        <!-- Convert Section -->
        <div class="sidebar-section collapsed" id="convertSection">
          <div class="sidebar-section-title" onclick="app.toggleSection('convertSection')">
            <span><svg class="section-icon-svg" viewBox="0 0 24 24" width="14" height="14"><path d="M17 1l4 4-4 4"/><path d="M3 11V9a4 4 0 0 1 4-4h14"/><path d="M7 23l-4-4 4-4"/><path d="M21 13v2a4 4 0 0 1-4 4H3"/></svg>Convert</span>
            <span class="section-toggle"></span>
          </div>
          <div class="sidebar-section-content">
            <div class="form-row" style="margin-bottom: 12px;">
              <div class="form-group" style="margin-bottom: 0;">
                <label class="form-label">Format</label>
                <select class="form-select" id="outputFormat">
                  <option value="mp4">MP4</option>
                  <option value="webm">WebM</option>
                  <option value="mov">MOV</option>
                  <option value="avi">AVI</option>
                  <option value="mkv">MKV</option>
                </select>
              </div>
              <div class="form-group" style="margin-bottom: 0;">
                <label class="form-label">Resolution</label>
                <select class="form-select" id="resolution">
                  <option value="">Original</option>
                  <option value="3840x2160">4K</option>
                  <option value="1920x1080">1080p</option>
                  <option value="1280x720">720p</option>
                  <option value="854x480">480p</option>
                </select>
              </div>
            </div>
            <div class="form-group">
              <label class="form-label">Quality</label>
              <div class="preset-grid">
                <button class="preset-btn" data-quality="high">High</button>
                <button class="preset-btn active" data-quality="medium">Medium</button>
                <button class="preset-btn" data-quality="low">Low</button>
                <button class="preset-btn" data-quality="custom">Custom</button>
              </div>
            </div>
            <button class="btn btn-secondary" style="width: 100%;" onclick="app.transcodeVideo()" id="transcodeBtn" disabled>
              Convert Video
            </button>
          </div>
        </div>

        <!-- Speed Section -->
        <div class="sidebar-section collapsed" id="speedSection">
          <div class="sidebar-section-title" onclick="app.toggleSection('speedSection')">
            <span><svg class="section-icon-svg" viewBox="0 0 24 24" width="14" height="14"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>Speed</span>
            <span class="section-toggle"></span>
          </div>
          <div class="sidebar-section-content">
            <div class="speed-presets" style="margin-bottom: 12px;">
              <button class="speed-btn" data-speed="0.5" onclick="app.setSpeedPreset(0.5)">0.5x</button>
              <button class="speed-btn active" data-speed="1" onclick="app.setSpeedPreset(1)">1x</button>
              <button class="speed-btn" data-speed="1.5" onclick="app.setSpeedPreset(1.5)">1.5x</button>
              <button class="speed-btn" data-speed="2" onclick="app.setSpeedPreset(2)">2x</button>
              <button class="speed-btn" data-speed="4" onclick="app.setSpeedPreset(4)">4x</button>
            </div>
            <div class="form-group">
              <label class="form-label">Custom: <span id="speedValue">1.0</span>x</label>
              <input type="range" class="range-slider" id="speedSlider" min="0.25" max="4" step="0.25" value="1" oninput="app.updateSpeedValue(this.value)">
            </div>
            <div style="display: flex; gap: 8px;">
              <button class="btn btn-secondary" style="flex: 1;" onclick="app.applySpeed()" id="applySpeedBtn" disabled>
                Apply
              </button>
              <button class="btn btn-ghost" style="flex: 1;" onclick="app.reverseVideo()" id="reverseBtn" disabled>
                Reverse
              </button>
            </div>
          </div>
        </div>

        <!-- Tools Section -->
        <div class="sidebar-section collapsed" id="toolsSection">
          <div class="sidebar-section-title" onclick="app.toggleSection('toolsSection')">
            <span><svg class="section-icon-svg" viewBox="0 0 24 24" width="14" height="14"><path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"/></svg>Quick Tools</span>
            <span class="section-toggle"></span>
          </div>
          <div class="sidebar-section-content">
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
              <button class="btn btn-ghost" onclick="app.extractAudio()" id="extractAudioBtn" disabled>
                 Audio
              </button>
              <button class="btn btn-ghost" onclick="app.compressVideo()" id="compressBtn" disabled>
                 Compress
              </button>
              <button class="btn btn-ghost" onclick="app.generateThumbnails()" id="thumbnailBtn" disabled>
                 Thumbs
              </button>
              <button class="btn btn-ghost" onclick="app.transcribeVideo()" id="transcribeBtn" disabled>
                 Transcribe
              </button>
            </div>
          </div>
        </div>

        <!-- Markers Section -->
        <div class="sidebar-section" id="markersSection">
          <div class="sidebar-section-title" onclick="app.toggleSection('markersSection')">
            <span><svg class="section-icon-svg" viewBox="0 0 24 24" width="14" height="14"><path d="M12 2L2 7l10 5 10-5-10-5z"/><path d="M2 17l10 5 10-5"/><path d="M2 12l10 5 10-5"/></svg>Markers</span>
            <span class="section-toggle"></span>
          </div>
          <div class="sidebar-section-content">
            <div style="display: flex; gap: 8px; margin-bottom: 8px;">
              <button class="btn btn-secondary" style="flex: 2;" onclick="app.addMarkerAtPlayhead()" id="addMarkerBtn" disabled>
                + Add Scene
              </button>
              <button class="btn btn-ghost" style="flex: 1;" onclick="app.markRangeIn()" id="markInBtn" disabled title="Mark IN">
                In
              </button>
              <button class="btn btn-ghost" style="flex: 1;" onclick="app.markRangeOut()" id="markOutBtn" disabled title="Mark OUT">
                Out
              </button>
            </div>
            <div class="markers-panel" id="markersPanel" style="margin-top: 0; background: transparent; padding: 0;">
              <div class="markers-panel-header" style="margin-bottom: 8px;">
                <div class="markers-panel-title" style="font-size: 11px;">
                  <span class="markers-count" id="markersCount">0</span> story beats
                </div>
                <div style="display: flex; gap: 4px;">
                  <button class="btn btn-ghost" style="padding: 4px 8px; font-size: 10px;" onclick="app.goToPrevMarker()" id="prevMarkerBtn" disabled></button>
                  <button class="btn btn-ghost" style="padding: 4px 8px; font-size: 10px;" onclick="app.goToNextMarker()" id="nextMarkerBtn" disabled></button>
                  <button class="btn btn-ghost" onclick="app.clearAllMarkers()" title="Clear All" style="padding: 4px 8px; font-size: 10px;"></button>
                </div>
              </div>
              <div class="markers-list" id="markersList" style="max-height: 150px;">
                <div class="markers-empty" style="padding: 12px;">No story beats yet</div>
              </div>
            </div>
          </div>
        </div>

        <!-- Video Info -->
        <div class="sidebar-section collapsed" id="videoInfoSection" style="display: none;">
          <div class="sidebar-section-title" onclick="app.toggleSection('videoInfoSection')">
            <span><svg class="section-icon-svg" viewBox="0 0 24 24" width="14" height="14"><circle cx="12" cy="12" r="10"/><line x1="12" y1="16" x2="12" y2="12"/><line x1="12" y1="8" x2="12.01" y2="8"/></svg>Video Info</span>
            <span class="section-toggle"></span>
          </div>
          <div class="sidebar-section-content">
            <div class="info-grid" id="videoInfo"></div>
          </div>
        </div>
      </div>

      <!-- Annotations Tab (Annotate Mode) -->
      <div class="sidebar-content mode-annotate-only hidden" id="scenesTab">
        <!-- Annotate Mode Header -->
        <div class="mode-header annotate-mode-header">
          <div class="mode-header-icon">
            <svg viewBox="0 0 24 24" width="20" height="20" stroke="currentColor" fill="none" stroke-width="1.5">
              <path d="M12 2L2 7l10 5 10-5-10-5z"/><path d="M2 17l10 5 10-5"/><path d="M2 12l10 5 10-5"/>
            </svg>
          </div>
          <div class="mode-header-text">
            <span class="mode-header-title">Annotations</span>
            <span class="mode-header-subtitle">Mark scenes & create story beats</span>
          </div>
        </div>

        <div class="scenes-header">
          <div class="scenes-title">
            <span>Story Beats</span>
            <span class="scenes-count" id="scenesCount">0</span>
          </div>
          <div class="scenes-actions">
            <button class="btn btn-sm btn-ghost annotation-action-btn" onclick="app.addMarkerAtPlayhead()" title="Add Marker">
              <svg viewBox="0 0 24 24" width="14" height="14"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"/><circle cx="12" cy="10" r="3"/></svg>
            </button>
            <button class="btn btn-sm btn-ghost annotation-action-btn" onclick="app.markRangeIn()" title="Mark In">
              <svg viewBox="0 0 24 24" width="14" height="14"><path d="M5 3l14 9-14 9V3z"/></svg>
            </button>
            <button class="btn btn-sm btn-ghost annotation-action-btn" onclick="app.generateAllSceneThumbnails()" title="Refresh">
              <svg viewBox="0 0 24 24" width="14" height="14"><path d="M23 4v6h-6"/><path d="M1 20v-6h6"/><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"/></svg>
            </button>
            <button class="btn btn-sm btn-ghost annotation-action-btn" onclick="app.exportToAgenticPlayer()" title="Export">
              <svg viewBox="0 0 24 24" width="14" height="14"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>
            </button>
          </div>
        </div>
        
        <div class="scenes-list" id="scenesList">
          <div class="scenes-empty">
            <div class="scenes-empty-icon">
              <svg viewBox="0 0 24 24" width="40" height="40" stroke="currentColor" fill="none" stroke-width="1">
                <path d="M12 2L2 7l10 5 10-5-10-5z"/><path d="M2 17l10 5 10-5"/><path d="M2 12l10 5 10-5"/>
              </svg>
            </div>
            <div class="scenes-empty-text">No annotations yet</div>
            <div class="scenes-empty-hint">Add markers to create story beats</div>
            <button class="btn btn-secondary" style="margin-top: 12px;" onclick="app.addMarkerAtPlayhead()" id="addFirstSceneBtn" disabled>
              + Add First Scene
            </button>
          </div>
        </div>

        <!-- Playlist Panel -->
        <div class="playlist-panel" id="playlistPanel"
             ondragover="app.onPlaylistDragOverFromScene(event)"
             ondragleave="app.onPlaylistDragLeave(event)"
             ondrop="app.onPlaylistDropFromScene(event)">
          <div class="playlist-header">
            <div class="playlist-title">
              Playlist <span class="playlist-count" id="playlistCount">0</span>
            </div>
            <span class="playlist-duration" id="playlistDuration">0:00</span>
          </div>
          <div class="playlist-controls">
            <button class="playlist-play-btn" id="playlistPlayBtn" onclick="app.togglePlaylistPlayback()" disabled>
              <svg viewBox="0 0 24 24" width="12" height="12" fill="currentColor"><path d="M5 3l14 9-14 9V3z"/></svg>
              Play All
            </button>
            <button class="btn btn-ghost" onclick="app.exportPlaylist()" id="exportPlaylistBtn" disabled title="Export as single video">
              <svg viewBox="0 0 24 24" width="14" height="14" stroke="currentColor" fill="none" stroke-width="2"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></svg>
            </button>
          </div>
          <div class="playlist-items" id="playlistItems">
            <div class="playlist-empty">
              Drag story beats here or right-click  "Add to Playlist"
            </div>
          </div>
          <div class="playlist-footer">
            <button class="btn btn-ghost btn-sm" onclick="app.clearPlaylist()" id="clearPlaylistBtn" disabled>
              Clear
            </button>
            <button class="btn btn-ghost btn-sm" onclick="app.shufflePlaylist()" id="shufflePlaylistBtn" disabled>
              Shuffle
            </button>
          </div>
          
          <!-- AI Playlist Builder -->
          <div class="ai-playlist-builder">
            <div class="ai-builder-header" onclick="app.toggleAIBuilder()">
              <span>AI Playlist Builder</span>
              <span class="ai-builder-toggle" id="aiBuilderToggle"></span>
            </div>
            <div class="ai-builder-content" id="aiBuilderContent">
              <div class="form-group">
                <textarea class="form-input form-textarea" id="aiPlaylistPrompt" rows="2" 
                  placeholder="Describe the playlist you want...&#10;e.g., 'Create a 2-minute highlight reel' or 'Show story beats about the product demo'"></textarea>
              </div>
              <div class="ai-builder-options">
                <label class="ai-option">
                  <input type="checkbox" id="aiKeepOrder" checked> Keep chronological order
                </label>
                <label class="ai-option">
                  <input type="checkbox" id="aiIncludeAll"> Include all story beats
                </label>
              </div>
              <button class="btn btn-primary" style="width: 100%;" onclick="app.buildPlaylistWithAI()" id="aiBuilderBtn">
                Build with AI
              </button>
              <div class="ai-builder-status hidden" id="aiBuilderStatus"></div>
            </div>
          </div>
        </div>

        <!-- Story Beat Details Panel (shows below list when a story beat is selected) -->
        <div class="scene-details hidden" id="sceneDetails">
          <div class="scene-details-header">
            <button class="scene-details-back" onclick="app.closeSceneDetails()"> Close</button>
            <span class="scene-details-title" id="sceneDetailsTitle">Scene Details</span>
          </div>
          <div class="scene-details-content" id="sceneDetailsContent">
            <!-- Populated by JS -->
          </div>
        </div>
      </div>

      <!-- Spaces Tab -->
      <div class="sidebar-content hidden" id="spacesTab">
        <div class="sidebar-section">
          <div class="sidebar-section-title"> Your Spaces</div>
          <div class="spaces-list" id="spacesList">
            <p style="color: var(--text-muted); font-size: 13px;">Loading spaces...</p>
          </div>
        </div>
        <div class="sidebar-section" id="spaceVideosSection" style="display: none;">
          <div class="sidebar-section-title"> Videos in Space</div>
          <div class="video-list" id="spaceVideos"></div>
        </div>
      </div>

      <!-- Exports Tab -->
      <div class="sidebar-content hidden" id="exportsTab">
        <div class="sidebar-section">
          <div class="sidebar-section-title"> Exported Files</div>
          <button class="btn btn-ghost" style="width: 100%; margin-bottom: 12px;" onclick="app.openExportFolder()">
             Open Export Folder
          </button>
          <div class="export-list" id="exportsList">
            <p style="color: var(--text-muted); font-size: 13px;">No exports yet</p>
          </div>
        </div>
      </div>
    </aside>

    <!-- Preview Area -->
    <main class="preview-area">
      <div class="video-container" id="videoContainer">
        <!-- Placeholder when no video is loaded -->
        <div class="video-placeholder" id="videoPlaceholder">
          <div class="drop-zone" id="dropZone">
            <div class="video-placeholder-icon"></div>
            <h2>Drop a video here</h2>
            <p>or click "Open" to select a video file from your computer or Spaces</p>
            <button class="btn btn-primary" onclick="app.openFile()">
               Choose Video
            </button>
          </div>
        </div>
        
        <!-- Video Player (hidden until video is loaded) -->
        <video class="video-player hidden" id="videoPlayer" controls>
          Your browser doesn't support video playback.
        </video>
        
        <!-- Teleprompter Overlay - Shows transcript words as they are spoken -->
        <div class="teleprompter-container hidden" id="teleprompterContainer">
          <div class="teleprompter-header">
            <span class="teleprompter-title"> Transcript</span>
            <div class="teleprompter-controls">
              <button class="teleprompter-btn" onclick="app.toggleTeleprompterSize()" title="Toggle Size">
                <svg viewBox="0 0 24 24" width="14" height="14" fill="currentColor"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/></svg>
              </button>
              <button class="teleprompter-btn" onclick="app.toggleTeleprompter()" title="Hide"></button>
            </div>
          </div>
          <div class="teleprompter-content" id="teleprompterContent">
            <div class="teleprompter-words" id="teleprompterWords">
              <!-- Words will be rendered here -->
            </div>
          </div>
        </div>
      </div>

      <!-- Video Controls -->
      <div class="video-controls hidden" id="videoControls">
        <button class="control-btn" onclick="app.skipBack()" title="Skip Back 10s">
          <svg viewBox="0 0 24 24" width="14" height="14" fill="currentColor"><path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"/></svg>
        </button>
        <button class="control-btn play-btn" onclick="app.togglePlay()" id="playBtn" title="Play/Pause">
          <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>
        </button>
        <button class="control-btn" onclick="app.skipForward()" title="Skip Forward 10s">
          <svg viewBox="0 0 24 24" width="14" height="14" fill="currentColor"><path d="M12 5V1l5 5-5 5V7c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6h2c0 4.42-3.58 8-8 8s-8-3.58-8-8 3.58-8 8-8z"/></svg>
        </button>

        <div class="time-display">
          <span class="time-current" id="currentTime">00:00:00</span>
          <span> / </span>
          <span id="duration">00:00:00</span>
        </div>

        <div class="volume-control">
          <button class="control-btn" onclick="app.toggleMute()" id="muteBtn">
            <svg viewBox="0 0 24 24" width="14" height="14" fill="currentColor"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/></svg>
          </button>
          <input type="range" class="range-slider volume-slider" id="volumeSlider" min="0" max="1" step="0.1" value="1">
        </div>

        <!-- Edit Mode Only: Trim Controls -->
        <button class="control-btn mode-edit-only" onclick="app.setTrimStart()" title="Set Trim Start (I)">
          <svg viewBox="0 0 24 24" width="14" height="14" stroke="currentColor" fill="none" stroke-width="2"><path d="M5 3v18"/><path d="M9 6h10v12H9z"/></svg>
        </button>
        <button class="control-btn mode-edit-only" onclick="app.setTrimEnd()" title="Set Trim End (O)">
          <svg viewBox="0 0 24 24" width="14" height="14" stroke="currentColor" fill="none" stroke-width="2"><path d="M19 3v18"/><path d="M5 6h10v12H5z"/></svg>
        </button>
        
        <!-- Annotate Mode Only: Add Marker -->
        <button class="control-btn mode-annotate-only" onclick="app.addMarkerAtPlayhead()" title="Add Marker (M)" style="background: #8b5cf6;">
          <svg viewBox="0 0 24 24" width="14" height="14" stroke="currentColor" fill="none" stroke-width="2"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"/><circle cx="12" cy="10" r="3"/></svg>
        </button>
        
        <!-- Teleprompter Toggle -->
        <button class="control-btn teleprompter-toggle-btn" onclick="app.toggleTeleprompter()" id="teleprompterToggleBtn" title="Toggle Transcript (T)">
          <svg viewBox="0 0 24 24" width="14" height="14" fill="currentColor"><path d="M14 17H4v2h10v-2zm6-8H4v2h16V9zM4 15h16v-2H4v2zM4 5v2h16V5H4z"/></svg>
        </button>
      </div>

      <!-- Timeline -->
      <div class="timeline hidden" id="timeline" style="height: auto; padding-bottom: 16px;">
        <!-- Zoom Controls -->
        <div class="timeline-zoom-controls">
          <button class="zoom-btn" onclick="app.zoomOut()" id="zoomOutBtn" title="Zoom Out (-)"></button>
          <div class="zoom-slider-container">
            <input type="range" class="zoom-slider" id="zoomSlider" min="1" max="20" step="0.5" value="1" oninput="app.setZoom(this.value)">
          </div>
          <button class="zoom-btn" onclick="app.zoomIn()" id="zoomInBtn" title="Zoom In (+)">+</button>
          <span class="zoom-level" id="zoomLevel">1.0x</span>
          <div class="zoom-presets">
            <button class="zoom-preset-btn active" data-zoom="1" onclick="app.setZoomPreset(1)">Fit</button>
            <button class="zoom-preset-btn" data-zoom="2" onclick="app.setZoomPreset(2)">2x</button>
            <button class="zoom-preset-btn" data-zoom="5" onclick="app.setZoomPreset(5)">5x</button>
            <button class="zoom-preset-btn" data-zoom="10" onclick="app.setZoomPreset(10)">10x</button>
          </div>
          <button class="zoom-btn" onclick="app.fitToView()" title="Fit to View (0)"></button>
        </div>

        <div class="timeline-header">
          <span id="timelineStart">00:00:00</span>
          <span id="timelineEnd">00:00:00</span>
        </div>

        <!-- Timeline Action Bar (shown when region selected) -->
        <div id="timelineActionBar" class="layout-edit-only" style="display: none; padding: 8px 12px; background: var(--bg-elevated); border-radius: 6px; margin: 8px 0; gap: 8px; align-items: center;">
          <div style="flex: 1; font-size: 11px; color: var(--text-secondary);">
            <span id="regionDurationText">Region: 00:00 - 00:00</span>
          </div>
          <button class="btn btn-ghost" onclick="app.openTranslationForRegion()" title="Translate this region" style="font-size: 11px; padding: 6px 12px;">
             Translate
          </button>
          <button class="btn btn-ghost" onclick="app.openAIVideoForRegion()" title="Replace with AI video" style="font-size: 11px; padding: 6px 12px;">
             AI Video
          </button>
          <button class="btn btn-ghost" onclick="app.openAudioSweeteningPanel()" title="Add sound effects" style="font-size: 11px; padding: 6px 12px;">
             Sweetening
          </button>
        </div>

        <!-- Translation Segment Navigation -->
        <div id="segmentNav" class="segment-nav layout-edit-only" style="display: none;">
          <button class="btn btn-ghost" onclick="app.navigateToSegment('prev')" style="padding: 4px 8px; font-size: 11px;" title="Previous segment">
             Prev
          </button>
          <div class="segment-nav-info">
            <span id="segmentNavText">Segment 0 of 0</span>
            <span style="margin-left: 8px; color: var(--text-muted);">
               <span id="approvedSegmentsCount">0</span> approved
            </span>
          </div>
          <button class="btn btn-ghost" onclick="app.navigateToSegment('next')" style="padding: 4px 8px; font-size: 11px;" title="Next segment">
            Next 
          </button>
        </div>

        <!-- Timeline Ruler -->
        <div class="timeline-ruler" id="timelineRuler">
          <div class="ruler-marks" id="rulerMarks"></div>
        </div>

        <!-- Markers Track -->
        <div class="markers-track" id="markersTrack" onclick="app.handleMarkerTrackClick(event)">
          <!-- Markers will be rendered here -->
        </div>

        <!-- Scrollable Timeline Wrapper -->
        <div class="timeline-scroll-wrapper" id="timelineScrollWrapper">
          <div class="timeline-content" id="timelineContent">
            <!-- Video Track 1 -->
            <div class="timeline-row">
              <div class="track-label">
                <div class="track-label-header">
                  <span class="track-badge video">V1</span>
                  <div class="track-info">
                    <span class="track-name">Video 1</span>
                    <span class="track-clip-count">1 Clip</span>
                  </div>
                </div>
              </div>
              <div class="timeline-track" id="timelineTrack" onclick="app.seekToPosition(event)">
                <!-- Main Clip Container -->
                <div class="timeline-clip" id="videoClip" style="left: 0; width: 100%;">
                    <div class="timeline-thumbnails" id="timelineThumbnails"></div>
                    <span class="timeline-clip-name" id="videoClipName"></span>
                </div>
                
                <!-- Overlay Elements -->
                <div class="trim-region" id="trimRegion"></div>
                <div class="trim-marker start" id="trimMarkerStart"></div>
                <div class="trim-marker end" id="trimMarkerEnd"></div>
                <div class="timeline-progress" id="timelineProgress"></div>
                <div class="timeline-playhead" id="playhead"></div>
              </div>
            </div>

            <!-- Audio Tracks Container -->
            <div id="audioTracksContainer">
              <!-- Audio Track 1 (Original) -->
              <div class="timeline-row audio audio-track" id="audioTrackContainer" data-track-id="A1">
                <div class="track-label">
                  <div class="track-label-header">
                    <span class="track-badge audio">A1</span>
                    <div class="track-info">
                      <span class="track-name">Original</span>
                    <span class="track-clip-count">1 Clip</span>
                  </div>
                </div>
                <div class="track-controls">
                  <button class="track-action-btn" onclick="app.toggleAudioMute()" id="audioMuteBtn" title="Mute">M</button>
                  <button class="track-action-btn" onclick="app.detachAudio()" id="detachAudioBtn" title="Solo">S</button>
                </div>
              </div>
              <div class="timeline-track" id="audioTrack" onclick="app.seekToPosition(event)">
                 <div class="timeline-clip audio" style="left: 0; width: 100%;">
                    <canvas id="audioWaveform" class="audio-waveform"></canvas>
                    <span class="timeline-clip-name" id="audioClipName">Original Audio</span>
                 </div>
                 <div class="audio-playhead" id="audioPlayhead"></div>
              </div>
              </div>
            </div><!-- end audioTracksContainer -->

            <!-- Add Track Button -->
            <div class="add-track-row" id="addTrackRow">
              <button class="add-track-btn" onclick="app.toggleAddTrackMenu(event)">
                <svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M12 5v14M5 12h14"/>
                </svg>
                Add Audio Track
              </button>
              <div class="add-track-menu" id="addTrackMenu">
                <button class="add-track-option" onclick="app.addAudioTrack('voice')">
                  <span class="track-type-badge voice">Voice</span>
                  Translation / Narration
                </button>
                <button class="add-track-option" onclick="app.addAudioTrack('music')">
                  <span class="track-type-badge music">Music</span>
                  Background Music
                </button>
                <button class="add-track-option" onclick="app.addAudioTrack('sfx')">
                  <span class="track-type-badge sfx">SFX</span>
                  Sound Effects
                </button>
                <button class="add-track-option" onclick="app.addAudioTrack('ambience')">
                  <span class="track-type-badge ambience">Ambience</span>
                  Background Audio
                </button>
              </div>
            </div>
          </div><!-- end timeline-content -->
        </div><!-- end timeline-scroll-wrapper -->
      </div><!-- end timeline -->
    </main>

    <!-- Story Beats Inspector (shown in beats layout) -->
    <aside class="beats-sidebar layout-beats-only" id="beatsInspector">
      <div class="beats-sidebar-header">
        <span class="beats-sidebar-title">Story Beats</span>
        <button class="btn btn-ghost" onclick="app.addNewBeat()" style="padding: 4px 8px; font-size: 11px;">
          + Add Beat
        </button>
      </div>

      <div class="beats-sidebar-tabs">
        <button class="beats-sidebar-tab active" data-tab="list" onclick="app.switchBeatsTab('list')">
          List
        </button>
        <button class="beats-sidebar-tab" data-tab="graph" onclick="app.switchBeatsTab('graph')">
          Graph
        </button>
        <button class="beats-sidebar-tab" data-tab="deploy" onclick="app.switchBeatsTab('deploy')">
          Deploy
        </button>
      </div>

      <div class="beats-sidebar-content">
        <!-- Beat List Tab -->
        <div id="beatsListTab" class="beats-tab-content">
          <div class="beat-list" id="beatList">
            <!-- Beats will be rendered here -->
            <div class="beat-inspector-empty">
              <p>No beats marked yet.</p>
              <p style="font-size: 11px; margin-top: 8px;">Select a region on the timeline and click "Add Beat"</p>
            </div>
          </div>
        </div>

        <!-- Graph Tab -->
        <div id="beatsGraphTab" class="beats-tab-content" style="display: none;">
          <div class="beat-graph" id="beatGraph">
            <div class="beat-graph-toolbar">
              <button class="beat-graph-btn" onclick="app.zoomBeatGraph(1.2)">+</button>
              <button class="beat-graph-btn" onclick="app.zoomBeatGraph(0.8)"></button>
              <button class="beat-graph-btn" onclick="app.resetBeatGraphView()">Fit</button>
            </div>
            <svg class="beat-graph-canvas" id="beatGraphCanvas">
              <!-- Graph will be rendered here -->
            </svg>
          </div>
          
          <div class="cross-video-section">
            <div class="cross-video-title">
               Link to Other Videos
            </div>
            <div class="cross-video-list" id="crossVideoList">
              <div style="font-size: 12px; color: var(--text-muted); text-align: center; padding: 20px;">
                No other videos in this Space
              </div>
            </div>
          </div>
        </div>

        <!-- Deploy Tab -->
        <div id="beatsDeployTab" class="beats-tab-content" style="display: none;">
          <div class="deploy-buttons">
            <button class="deploy-btn-large" onclick="app.testInPlayer()">
               Test in Agentic Player
            </button>
            
            <button class="deploy-btn-secondary" onclick="app.generateEmbedCode()">
               Copy Embed Code
            </button>
            
            <button class="deploy-btn-secondary" onclick="app.exportPlayerPackage()">
               Export Player Package
            </button>
          </div>

          <div id="embedCodeSection" style="margin-top: 16px; display: none;">
            <div class="beat-field-label">Embed Code</div>
            <div class="embed-code-box" id="embedCodeBox"></div>
          </div>

          <div style="margin-top: 20px; padding: 16px; background: var(--bg-surface); border-radius: 8px;">
            <div style="font-size: 12px; font-weight: 600; margin-bottom: 8px;">Export Package Includes:</div>
            <ul style="font-size: 11px; color: var(--text-secondary); margin-left: 16px;">
              <li>player.html, player.js, styles.css</li>
              <li>Video file (or video URL config)</li>
              <li>beats.json (story beats metadata)</li>
              <li>README with hosting instructions</li>
            </ul>
          </div>
        </div>
      </div>

      <!-- Beat Inspector (shows when beat is selected) -->
      <div class="beat-inspector" id="beatInspectorPanel" style="display: none;">
        <div class="beat-field">
          <div class="beat-field-label">Beat Name</div>
          <input type="text" class="beat-field-input" id="beatName" placeholder="e.g., Introduction">
        </div>

        <div class="beat-field">
          <div class="beat-field-label">Time Range</div>
          <div style="display: flex; gap: 8px;">
            <input type="text" class="beat-field-input" id="beatInTime" placeholder="In" style="flex: 1;">
            <span style="padding: 8px; color: var(--text-muted);"></span>
            <input type="text" class="beat-field-input" id="beatOutTime" placeholder="Out" style="flex: 1;">
          </div>
        </div>

        <div class="beat-field">
          <div class="beat-field-label">Description</div>
          <textarea class="beat-field-textarea" id="beatDescription" placeholder="What happens in this beat?"></textarea>
        </div>

        <div class="beat-field">
          <div class="beat-field-label">Transcription</div>
          <textarea class="beat-field-textarea" id="beatTranscription" placeholder="Spoken words in this segment..."></textarea>
          <button class="btn btn-ghost" onclick="app.transcribeBeat()" style="margin-top: 8px; width: 100%; font-size: 11px;">
             Auto-Transcribe
          </button>
        </div>

        <div class="beat-field">
          <div class="beat-field-label">Tags</div>
          <div class="beat-tags-input-container" id="beatTagsContainer">
            <input type="text" class="beat-tag-input" id="beatTagInput" placeholder="Add tag..." onkeydown="app.handleBeatTagKeydown(event)">
          </div>
        </div>

        <div class="beat-field">
          <div class="beat-field-label">Links to Other Beats</div>
          <div id="beatLinksList" style="margin-bottom: 8px;">
            <!-- Links will be rendered here -->
          </div>
          <button class="btn btn-ghost" onclick="app.addBeatLink()" style="width: 100%; font-size: 11px;">
            + Add Link
          </button>
        </div>

        <div style="display: flex; gap: 8px; margin-top: 16px;">
          <button class="btn btn-secondary" onclick="app.saveBeat()" style="flex: 1;">
            Save Beat
          </button>
          <button class="btn btn-ghost" onclick="app.deleteBeat()" style="color: var(--error);">
            
          </button>
        </div>
      </div>
    </aside>
  </div>

  <!-- DaVinci-Style Bottom Page Bar -->
  <div class="page-bar">
    <button class="page-btn" onclick="app.switchTab('spaces')">
      <span class="page-btn-icon">
        <svg viewBox="0 0 24 24"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/></svg>
      </span>
      <span>Media</span>
    </button>
    <div class="page-divider"></div>
    <button class="page-btn active" onclick="app.setMode('edit')" data-mode="edit">
      <span class="page-btn-icon">
        <svg viewBox="0 0 24 24"><path d="M6 9l6 6 6-6"/><path d="M4 4h16v16H4z" stroke-dasharray="4 2"/><circle cx="12" cy="12" r="2"/></svg>
      </span>
      <span>Edit</span>
    </button>
    <button class="page-btn" onclick="app.setMode('annotate')" data-mode="annotate">
      <span class="page-btn-icon">
        <svg viewBox="0 0 24 24"><path d="M12 2L2 7l10 5 10-5-10-5z"/><path d="M2 17l10 5 10-5"/><path d="M2 12l10 5 10-5"/></svg>
      </span>
      <span>Annotate</span>
    </button>
    <div class="page-divider"></div>
    <button class="page-btn" onclick="app.switchTab('exports')">
      <span class="page-btn-icon">
        <svg viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>
      </span>
      <span>Deliver</span>
    </button>
  </div>

  <!-- Progress Modal -->
  <div class="modal-overlay" id="progressModal">
    <div class="modal">
      <h3 class="modal-title" id="progressTitle">Processing Video...</h3>
      <p class="modal-subtitle" id="progressSubtitle">This may take a few minutes</p>
      <div class="progress-bar">
        <div class="progress-fill" id="progressFill" style="width: 0%"></div>
      </div>
      <div class="progress-text">
        <span id="progressStatus">Starting...</span>
        <span class="progress-percent" id="progressPercent">0%</span>
      </div>
      <div style="margin-top: 20px; text-align: center;">
        <button class="btn btn-ghost" onclick="app.cancelJob()">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Toast Container -->
  <div class="toast-container" id="toastContainer"></div>

  <!-- Pending Range Marker Indicator -->
  <div class="pending-range-indicator hidden" id="pendingRangeIndicator">
    <span> Range IN set at <strong id="pendingInTime">00:00:00</strong></span>
    <span> Now set the OUT point</span>
    <button onclick="app.markRangeOut()">Set OUT Here</button>
    <button onclick="app.cancelPendingRange()">Cancel</button>
  </div>

  <!-- Dynamic Context Menu -->
  <div class="context-menu" id="contextMenu">
    <div class="context-menu-items" id="contextMenuItems">
      <!-- Items populated dynamically -->
    </div>
  </div>

  <!-- Add/Edit Marker Modal -->
  <div class="marker-modal-backdrop hidden" id="markerModalBackdrop" onclick="app.closeMarkerModal()"></div>
  <div class="marker-modal hidden" id="markerModal" style="max-width: 500px; max-height: 90vh; overflow-y: auto;">
    <div class="marker-modal-title" id="markerModalTitle">Add Marker</div>
    
    <!-- Marker Type Selection -->
    <div class="form-group" id="markerTypeGroup">
      <label class="form-label">Marker Type</label>
      <div class="marker-type-selector">
        <button class="marker-type-btn active" data-type="spot" onclick="app.setMarkerType('spot')">
          <span class="marker-type-icon"></span>
          <span class="marker-type-label">Spot</span>
          <span class="marker-type-desc">Single point</span>
        </button>
        <button class="marker-type-btn" data-type="range" onclick="app.setMarkerType('range')">
          <span class="marker-type-icon"></span>
          <span class="marker-type-label">Range</span>
          <span class="marker-type-desc">In & Out points</span>
        </button>
      </div>
    </div>

    <div class="form-group">
      <label class="form-label">Scene Name *</label>
      <input type="text" class="form-input" id="markerNameInput" placeholder="e.g., Intro, Chapter 1, Credits...">
    </div>
    
    <!-- Spot marker time -->
    <div class="form-group" id="spotTimeGroup">
      <label class="form-label">Time: <span id="markerTimeDisplay">00:00:00</span></label>
    </div>
    
    <!-- Range marker times -->
    <div class="form-group hidden" id="rangeTimeGroup">
      <div class="range-time-inputs">
        <div class="range-time-input">
          <label class="form-label">IN Point</label>
          <div class="range-time-value" id="rangeInDisplay">00:00:00</div>
          <button class="btn btn-ghost btn-sm" onclick="app.setRangeInNow()">Set to Now</button>
        </div>
        <div class="range-time-arrow"></div>
        <div class="range-time-input">
          <label class="form-label">OUT Point</label>
          <div class="range-time-value" id="rangeOutDisplay">00:00:00</div>
          <button class="btn btn-ghost btn-sm" onclick="app.setRangeOutNow()">Set to Now</button>
        </div>
      </div>
      <div class="range-duration" id="rangeDuration">Duration: 00:00:00</div>
    </div>

    <div class="form-group">
      <label class="form-label">Color</label>
      <div class="marker-color-picker" id="markerColorPicker">
        <!-- Colors populated by JS -->
      </div>
    </div>

    <!-- Extended Metadata Section -->
    <div class="marker-metadata-section">
      <div class="marker-metadata-header" onclick="app.toggleMetadataSection()">
        <span> Extended Metadata</span>
        <span class="metadata-toggle" id="metadataToggle"></span>
      </div>
      <div class="marker-metadata-content" id="metadataContent">
        <div class="form-group">
          <label class="form-label">Description</label>
          <textarea class="form-input form-textarea" id="markerDescription" rows="3" placeholder="Detailed description of this scene or moment..."></textarea>
        </div>
        
        <div class="form-group">
          <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 6px;">
            <label class="form-label" style="margin: 0;">Transcription / Dialogue</label>
            <button class="btn btn-ghost btn-sm" onclick="app.transcribeMarkerRange()" id="transcribeRangeBtn" style="font-size: 10px;">
               Auto-Transcribe
            </button>
          </div>
          <textarea class="form-input form-textarea" id="markerTranscription" rows="4" placeholder="What is being said in this segment..."></textarea>
          <div class="transcription-status hidden" id="transcriptionStatus" style="margin-top: 6px; font-size: 11px; color: var(--text-muted);"></div>
          
          <!-- ElevenLabs Replace Audio Button -->
          <div class="elevenlabs-section hidden" id="elevenLabsSection" style="margin-top: 12px; padding: 12px; background: rgba(99, 102, 241, 0.1); border: 1px solid rgba(99, 102, 241, 0.3); border-radius: 8px;">
            <button class="btn btn-primary" onclick="app.replaceAudioWithElevenLabsFromModal()" id="elevenLabsBtn" style="width: 100%; display: flex; align-items: center; justify-content: center; gap: 8px;">
              <span style="font-size: 16px;"></span>
              <span>Replace Audio with ElevenLabs</span>
            </button>
            <div style="font-size: 11px; color: var(--text-muted); margin-top: 8px; text-align: center;">
              Generate AI voice from transcription and replace audio in this range
            </div>
          </div>
        </div>
        
        <div class="form-group">
          <label class="form-label">Tags</label>
          <input type="text" class="form-input" id="markerTags" placeholder="interview, intro, b-roll (comma separated)">
        </div>
        
        <div class="form-group">
          <label class="form-label">Notes</label>
          <textarea class="form-input form-textarea" id="markerNotes" rows="2" placeholder="Internal notes, reminders..."></textarea>
        </div>

        <!-- Screen Grabs Section -->
        <div class="form-group" id="screenGrabsSection">
          <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 6px;">
            <label class="form-label" style="margin: 0;"> Screen Grabs</label>
          </div>
          <div style="display: flex; gap: 8px; align-items: center;">
            <input type="number" class="form-input" id="screenGrabCount" value="5" min="1" max="50" style="width: 70px;">
            <span style="font-size: 12px; color: var(--text-secondary);">frames</span>
            <button class="btn btn-secondary btn-sm" onclick="app.generateMarkerScreengrabs()" id="generateGrabsBtn" style="margin-left: auto;">
               Generate
            </button>
          </div>
          <div class="screengrabs-preview hidden" id="screengrabsPreview">
            <div class="screengrabs-grid" id="screengrabsGrid"></div>
            <div class="screengrabs-actions">
              <button class="btn btn-ghost btn-sm" onclick="app.openScreengrabsFolder()"> Open Folder</button>
              <span class="screengrabs-count" id="screengrabsCount"></span>
            </div>
          </div>
        </div>
        
        <div class="marker-metadata-grid">
          <div class="metadata-stat">
            <span class="metadata-stat-label">Created</span>
            <span class="metadata-stat-value" id="markerCreated">-</span>
          </div>
          <div class="metadata-stat">
            <span class="metadata-stat-label">Modified</span>
            <span class="metadata-stat-value" id="markerModified">-</span>
          </div>
        </div>
      </div>
    </div>

    <div class="marker-modal-actions">
      <button class="btn btn-ghost" onclick="app.closeMarkerModal()">Cancel</button>
      <button class="btn btn-primary" onclick="app.saveMarker()" id="saveMarkerBtn">Add Marker</button>
    </div>
  </div>

  <script>
    // Video Editor Application
    const app = {
      videoPath: null,
      videoInfo: null,
      isPlaying: false,
      currentJobId: null,
      currentTab: 'edit',
      currentMode: 'edit', // 'edit' or 'mark'
      currentLayout: 'edit', // 'edit' or 'beats'
      selectedSpace: null,
      trimStart: 0,
      trimEnd: 0,
      quality: 'medium',
      audioMuted: false,
      audioDetached: false,
      audioContext: null,
      audioBuffer: null,
      currentSpeed: 1.0,
      timelineZoom: 1,
      timelineScrollOffset: 0,
      maxZoom: 20,
      minZoom: 1,
      markers: [],
      nextMarkerId: 1,
      markerColors: ['#ef4444', '#f97316', '#eab308', '#22c55e', '#06b6d4', '#3b82f6', '#8b5cf6', '#ec4899'],
      pendingRangeMarker: null, // For tracking incomplete range markers (IN set, waiting for OUT)
      draggingMarker: null, // { id, type: 'spot'|'range-in'|'range-out'|'range-move', startX, startTime }
      
      // Playlist
      playlist: [],
      playlistPlaying: false,
      playlistCurrentIndex: -1,
      
      // Space tracking (for Save to Space)
      spaceItemId: null,  // Set when video is loaded from a Space
      spaceItemName: null,
      
      // Transcript segments for waveform display
      transcriptSegments: null,  // Array of { start, end, text } for displaying words on waveform
      pendingTranscriptText: null,  // Raw transcript text pending segment creation (after video loads)

      // Web Audio API for smooth scrubbing
      audioContext: null,
      audioBuffer: null,
      audioSource: null,
      audioGain: null,
      scrubAudioPath: null,
      isAudioLoaded: false,
      lastPlayedWord: null,  // Track last played word to avoid repeats

      // Toggle collapsible section
      toggleSection(sectionId) {
        const section = document.getElementById(sectionId);
        if (section) {
          section.classList.toggle('collapsed');
        }
      },

      // Initialize
      async init() {
        // Bind drag handlers
        this.handleMarkerDrag = this._handleMarkerDrag.bind(this);
        this.handleMarkerDragEnd = this._handleMarkerDragEnd.bind(this);
        
        this.setupEventListeners();
        this.setupDragDrop();
        this.setupProgressListener();
        this.setupContextMenu();
        this.setupScrollScrub();
        this.setupTimelineScrubbing();
        this.setupTimelineZoom();
        this.loadSpaces();
        this.loadExports();
        
        // Setup quality preset buttons
        document.querySelectorAll('.preset-btn[data-quality]').forEach(btn => {
          btn.addEventListener('click', () => {
            document.querySelectorAll('.preset-btn[data-quality]').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            this.quality = btn.dataset.quality;
          });
        });
        
        // Set initial mode and layout
        this.setMode('edit');
        this.switchLayout('edit');
      },

      // Mode Switching
      setMode(mode) {
        this.currentMode = mode;
        document.body.setAttribute('data-mode', mode);
        
        // Update page bar buttons
        document.querySelectorAll('.page-btn[data-mode]').forEach(btn => {
          btn.classList.toggle('active', btn.dataset.mode === mode);
        });
        
        const modeTitle = document.getElementById('modeTitle');
        const modeIndicator = document.getElementById('modeIndicator');
        
        // Switch sidebar tab and update header based on mode
        if (mode === 'edit') {
          this.switchTab('edit');
          if (modeTitle) modeTitle.textContent = 'Edit Mode';
          if (modeIndicator) {
            modeIndicator.textContent = '';
            modeIndicator.style.color = '#4a9eff';
          }
        } else if (mode === 'annotate') {
          this.switchTab('scenes');
          if (modeTitle) modeTitle.textContent = 'Annotate Mode';
          if (modeIndicator) {
            modeIndicator.textContent = '';
            modeIndicator.style.color = '#8b5cf6';
          }
        }
      },

      // Layout Switching (Edit / Story Beats)
      switchLayout(layout) {
        this.currentLayout = layout;
        document.body.setAttribute('data-layout', layout);
        
        // Update layout nav buttons
        document.getElementById('layoutEditBtn').classList.toggle('active', layout === 'edit');
        document.getElementById('layoutBeatsBtn').classList.toggle('active', layout === 'beats');
        
        // Update mode based on layout
        if (layout === 'edit') {
          this.setMode('edit');
        } else if (layout === 'beats') {
          this.setMode('annotate');
        }
        
        console.log('[VideoEditor] Switched to layout:', layout);
      },

      // Open Recorder
      async openRecorder() {
        try {
          // Prepare recording instructions if we have a video loaded
          const options = {};
          
          if (this.videoPath) {
            options.instructions = `Record a segment to replace or add to: ${this.videoPath.split('/').pop()}`;
            if (this.selectedSpace) {
              options.spaceId = this.selectedSpace;
            }
          }
          
          // Call IPC to open recorder
          if (window.videoEditor && window.videoEditor.openRecorder) {
            const result = await window.videoEditor.openRecorder(options);
            if (result.success) {
              this.showToast('Recorder opened', 'info');
            } else {
              throw new Error(result.error || 'Failed to open recorder');
            }
          } else {
            console.warn('[VideoEditor] Recorder API not available');
            this.showToast('Recorder not available', 'error');
          }
        } catch (error) {
          console.error('[VideoEditor] Error opening recorder:', error);
          this.showToast('Failed to open recorder: ' + error.message, 'error');
        }
      },

      // Setup event listeners
      setupEventListeners() {
        const video = document.getElementById('videoPlayer');
        
        video.addEventListener('timeupdate', () => {
          this.updateTimeDisplay();
          this.updateAudioPlayhead();
          this.updateTeleprompterHighlight(video.currentTime);
        });
        video.addEventListener('loadedmetadata', () => this.onVideoLoaded());
        video.addEventListener('play', () => {
          this.isPlaying = true;
          document.getElementById('playBtn').textContent = '';
        });
        video.addEventListener('pause', () => {
          this.isPlaying = false;
          document.getElementById('playBtn').textContent = '';
        });
        video.addEventListener('ended', () => {
          this.isPlaying = false;
          document.getElementById('playBtn').textContent = '';
        });

        // Volume slider
        document.getElementById('volumeSlider').addEventListener('input', (e) => {
          video.volume = e.target.value;
          this.updateMuteIcon();
        });

        // Trim inputs
        document.getElementById('trimStart').addEventListener('change', (e) => {
          this.trimStart = this.parseTime(e.target.value);
          this.updateTrimRegion();
        });
        document.getElementById('trimEnd').addEventListener('change', (e) => {
          this.trimEnd = this.parseTime(e.target.value);
          this.updateTrimRegion();
        });
        
        // Splice inputs
        document.getElementById('spliceStart').addEventListener('change', () => {
          this.updateSplicePreview();
        });
        document.getElementById('spliceEnd').addEventListener('change', () => {
          this.updateSplicePreview();
        });
      },

      // Setup drag and drop
      setupDragDrop() {
        const dropZone = document.getElementById('dropZone');
        
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
          dropZone.addEventListener(eventName, (e) => {
            e.preventDefault();
            e.stopPropagation();
          });
        });

        ['dragenter', 'dragover'].forEach(eventName => {
          dropZone.addEventListener(eventName, () => dropZone.classList.add('drag-over'));
        });

        ['dragleave', 'drop'].forEach(eventName => {
          dropZone.addEventListener(eventName, () => dropZone.classList.remove('drag-over'));
        });

        dropZone.addEventListener('drop', (e) => {
          const files = e.dataTransfer.files;
          if (files.length > 0) {
            const file = files[0];
            if (file.type.startsWith('video/') || this.isVideoFile(file.name)) {
              this.loadVideo(file.path);
            } else {
              this.showToast('error', 'Please drop a video file');
            }
          }
        });
      },

      isVideoFile(filename) {
        const videoExtensions = ['.mp4', '.avi', '.mov', '.wmv', '.flv', '.mkv', '.webm', '.m4v', '.mpg', '.mpeg'];
        return videoExtensions.some(ext => filename.toLowerCase().endsWith(ext));
      },

      // Setup progress listener
      setupProgressListener() {
        if (window.videoEditor) {
          window.videoEditor.onProgress((progress) => {
            this.updateProgress(progress);
          });
          
          // Listen for file load requests (from Spaces)
          window.videoEditor.onLoadFile((filePath) => {
            console.log('[VideoEditor] Received load file request:', filePath);
            if (filePath) {
              this.loadVideo(filePath);
            }
          });
        }
      },

      // Marker Functions
      editingMarkerId: null,
      selectedMarkerColor: null,
      selectedMarkerType: 'spot',
      rangeInTime: 0,
      rangeOutTime: 0,
      selectedMarkerForDetails: null,
      metadataExpanded: true,

      toggleMetadataSection() {
        this.metadataExpanded = !this.metadataExpanded;
        document.getElementById('metadataContent').classList.toggle('collapsed', !this.metadataExpanded);
        document.getElementById('metadataToggle').classList.toggle('collapsed', !this.metadataExpanded);
      },

      async transcribeMarkerRange() {
        if (!this.videoPath) {
          this.showToast('error', 'No video loaded');
          return;
        }

        const btn = document.getElementById('transcribeRangeBtn');
        const status = document.getElementById('transcriptionStatus');
        const textarea = document.getElementById('markerTranscription');
        
        // Determine the time range based on marker type
        let startTime, endTime;
        
        if (this.selectedMarkerType === 'range') {
          startTime = this.rangeInTime;
          endTime = this.rangeOutTime;
        } else {
          // For spot markers, transcribe 10 seconds around the marker
          const spotTime = parseFloat(document.getElementById('markerModal').dataset.time);
          startTime = Math.max(0, spotTime - 5);
          const video = document.getElementById('videoPlayer');
          endTime = Math.min(video.duration, spotTime + 5);
        }

        const duration = endTime - startTime;
        
        // Show loading state
        btn.disabled = true;
        btn.innerHTML = ' Loading...';
        status.classList.remove('hidden');
        status.innerHTML = `Checking for existing transcription...`;

        try {
          // FIRST: Try to get transcription from Space metadata (if video loaded from Space)
          if (this.spaceItemId) {
            console.log('[Transcription] Checking Space for existing transcription:', this.spaceItemId);
            status.innerHTML = ` Fetching transcription from Space...`;
            
            const transcriptResult = await window.clipboard.getTranscription(this.spaceItemId);
            
            if (transcriptResult?.success && transcriptResult.transcription) {
              console.log('[Transcription] Found existing transcription:', transcriptResult.transcription.length, 'chars');
              
              // Check if we have timecoded segments in metadata
              const metadataResult = await window.clipboard.getMetadata(this.spaceItemId);
              
              console.log('[Transcription] Metadata result:', metadataResult ? 'found' : 'not found');
              
              // Check multiple possible locations for segments
              const segments = metadataResult?.transcriptSegments || 
                               metadataResult?.transcript?.segments || 
                               null;
              
              if (segments && segments.length > 0) {
                console.log('[Transcription] Found', segments.length, 'timecoded segments');
                
                // Filter segments that overlap with our range
                const relevantSegments = segments.filter(seg => {
                  const segStart = seg.start || 0;
                  const segEnd = (seg.end !== undefined) ? seg.end : (seg.start + (seg.duration || 5));
                  // Segment overlaps if it starts before range ends AND ends after range starts
                  return segStart < endTime && segEnd > startTime;
                });
                
                console.log('[Transcription] Filtered to', relevantSegments.length, 'relevant segments for range:', startTime, '-', endTime);
                
                if (relevantSegments.length > 0) {
                  // Extract text from relevant segments
                  const extractedText = relevantSegments.map(seg => seg.text).join(' ');
                  
                  console.log('[Transcription] Extracted text length:', extractedText.length);
                  
                  textarea.value = extractedText;
                  status.innerHTML = ` Extracted from ${relevantSegments.length} segments (${this.formatTime(startTime)}  ${this.formatTime(endTime)})`;
                  this.showToast('success', 'Transcription loaded from Space!');
                  this.updateElevenLabsButton(); // Show ElevenLabs button if range marker
                  
                  btn.disabled = false;
                  btn.innerHTML = ' Auto-Transcribe';
                  return; // Success! No need to call OpenAI
                }
              } else {
                console.log('[Transcription] No segments found in metadata');
              }
              
              // Try plain text transcription if segments not available
              if (transcriptResult.transcription) {
                // No segments, but we have plain text - extract rough portion
                console.log('[Transcription] Using plain text transcription (no timecodes)');
                const fullDuration = this.videoInfo?.duration || 1;
                const startRatio = startTime / fullDuration;
                const endRatio = endTime / fullDuration;
                const transcriptLength = transcriptResult.transcription.length;
                
                const startChar = Math.floor(startRatio * transcriptLength);
                const endChar = Math.floor(endRatio * transcriptLength);
                const extractedText = transcriptResult.transcription.substring(startChar, endChar);
                
                if (extractedText.trim()) {
                  textarea.value = extractedText;
                  status.innerHTML = ` Estimated portion from full transcription (approximate)`;
                  this.showToast('success', 'Transcription loaded from Space (estimated)!');
                  this.updateElevenLabsButton();
                  
                  btn.disabled = false;
                  btn.innerHTML = ' Auto-Transcribe';
                  return;
                }
              }
            }
            
            console.log('[Transcription] No existing transcription found in Space, falling back to OpenAI');
          }
          
          // FALLBACK: Use OpenAI Whisper to transcribe
          status.innerHTML = ` Transcribing audio (${this.formatTime(startTime)}  ${this.formatTime(endTime)})...`;
          btn.innerHTML = ' Transcribing...';
          
          const result = await window.videoEditor.transcribeRange(this.videoPath, {
            startTime,
            endTime,
            language: 'en'
          });

          if (!result.success) {
            throw new Error(result.error);
          }

          // Fill in the transcription
          textarea.value = result.transcription;
          status.innerHTML = ` Transcribed ${this.formatTime(duration)} of audio`;
          this.showToast('success', 'Transcription complete!');
          this.updateElevenLabsButton(); // Show ElevenLabs button if range marker
          
        } catch (error) {
          console.error('[Transcription] Error:', error);
          status.innerHTML = ` ${error.message}`;
          this.showToast('error', 'Transcription failed: ' + error.message);
        } finally {
          btn.disabled = false;
          btn.innerHTML = ' Auto-Transcribe';
        }
      },

      // Screen Grabs
      currentScreengrabsDir: null,
      currentScreengrabs: [],

      async generateMarkerScreengrabs() {
        if (!this.videoPath) {
          this.showToast('error', 'No video loaded');
          return;
        }

        const count = parseInt(document.getElementById('screenGrabCount').value) || 5;
        
        if (count < 1 || count > 50) {
          this.showToast('error', 'Please enter a number between 1 and 50');
          return;
        }

        // Determine the time range based on marker type
        let startTime, endTime;
        
        if (this.selectedMarkerType === 'range') {
          startTime = this.rangeInTime;
          endTime = this.rangeOutTime;
        } else {
          // For spot markers, capture around the marker time
          const spotTime = parseFloat(document.getElementById('markerModal').dataset.time);
          const video = document.getElementById('videoPlayer');
          // Capture 10 seconds centered on the spot
          startTime = Math.max(0, spotTime - 5);
          endTime = Math.min(video.duration, spotTime + 5);
        }

        const duration = endTime - startTime;
        const btn = document.getElementById('generateGrabsBtn');
        
        btn.disabled = true;
        btn.innerHTML = ' Generating...';
        
        this.showToast('info', `Generating ${count} frames from ${this.formatTime(duration)} of video...`);

        try {
          const result = await window.videoEditor.generateScreengrabs(this.videoPath, {
            startTime,
            endTime,
            count,
            prefix: 'frame'
          });

          if (!result.success) {
            throw new Error(result.error);
          }

          this.currentScreengrabsDir = result.outputDir;
          this.currentScreengrabs = result.frames;
          
          // Display the screengrabs
          this.displayScreengrabs(result.frames);
          
          this.showToast('success', `Generated ${result.count} screen grabs!`);
        } catch (error) {
          console.error('[ScreenGrabs] Error:', error);
          this.showToast('error', 'Failed to generate screen grabs: ' + error.message);
        } finally {
          btn.disabled = false;
          btn.innerHTML = ' Generate';
        }
      },

      displayScreengrabs(frames) {
        const preview = document.getElementById('screengrabsPreview');
        const grid = document.getElementById('screengrabsGrid');
        const count = document.getElementById('screengrabsCount');
        
        if (!frames || frames.length === 0) {
          preview.classList.add('hidden');
          return;
        }

        // Build grid HTML
        grid.innerHTML = frames.map((frame, i) => `
          <div class="screengrab-item" onclick="app.showScreengrabFull(${i})" title="Click to view full size">
            <img src="file://${frame.path}" alt="Frame ${frame.index}">
            <div class="screengrab-time">${frame.timeFormatted}</div>
          </div>
        `).join('');
        
        count.textContent = `${frames.length} frames captured`;
        preview.classList.remove('hidden');
      },

      showScreengrabFull(index) {
        const frame = this.currentScreengrabs[index];
        if (!frame) return;

        // Create modal
        const modal = document.createElement('div');
        modal.className = 'screengrab-modal';
        modal.innerHTML = `
          <button class="screengrab-modal-close" onclick="this.parentElement.remove()"></button>
          <img src="file://${frame.path}" alt="Frame ${frame.index}">
          <div class="screengrab-modal-info">Frame ${frame.index} at ${frame.timeFormatted}</div>
        `;
        
        // Close on click outside
        modal.addEventListener('click', (e) => {
          if (e.target === modal) modal.remove();
        });
        
        // Close on escape
        const escHandler = (e) => {
          if (e.key === 'Escape') {
            modal.remove();
            document.removeEventListener('keydown', escHandler);
          }
        };
        document.addEventListener('keydown', escHandler);
        
        document.body.appendChild(modal);
      },

      async openScreengrabsFolder() {
        if (this.currentScreengrabsDir) {
          await window.videoEditor.openExportFolder(this.currentScreengrabsDir);
        }
      },

      // Generate screengrabs for a marker by ID
      async generateScreengrabsForMarker(markerId, count = 5) {
        const marker = this.markers.find(m => m.id === markerId);
        if (!marker) return;

        if (!this.videoPath) {
          this.showToast('error', 'No video loaded');
          return;
        }

        // Prompt for count
        const inputCount = prompt('How many screen grabs?', '5');
        if (!inputCount) return;
        
        count = parseInt(inputCount);
        if (isNaN(count) || count < 1 || count > 50) {
          this.showToast('error', 'Please enter a number between 1 and 50');
          return;
        }

        let startTime, endTime;
        
        if (marker.type === 'range') {
          startTime = marker.inTime;
          endTime = marker.outTime;
        } else {
          startTime = Math.max(0, marker.time - 5);
          const video = document.getElementById('videoPlayer');
          endTime = Math.min(video.duration, marker.time + 5);
        }

        const duration = endTime - startTime;
        
        this.showProgress('Generating Screen Grabs...', `Capturing ${count} frames from ${this.formatTime(duration)}`);

        try {
          const result = await window.videoEditor.generateScreengrabs(this.videoPath, {
            startTime,
            endTime,
            count,
            prefix: `marker_${markerId}_frame`
          });

          this.hideProgress();

          if (!result.success) {
            throw new Error(result.error);
          }

          // Store screengrabs with marker
          marker.screengrabs = result.frames;
          marker.screengrabsDir = result.outputDir;
          marker.modifiedAt = new Date().toISOString();
          
          // Re-render
          this.renderMarkers();
          
          // Open the folder
          await window.videoEditor.openExportFolder(result.outputDir);
          
          this.showToast('success', `Generated ${result.count} screen grabs!`);
        } catch (error) {
          this.hideProgress();
          console.error('[ScreenGrabs] Error:', error);
          this.showToast('error', 'Failed to generate screen grabs: ' + error.message);
        }
      },

      // Transcribe a marker by ID (from details panel)
      // Update ElevenLabs button visibility in modal
      updateElevenLabsButton() {
        const section = document.getElementById('elevenLabsSection');
        const transcription = document.getElementById('markerTranscription')?.value || '';
        const hasTranscription = transcription && transcription.trim() !== '';
        const isRange = this.selectedMarkerType === 'range';
        
        console.log('[ElevenLabs] Button update:', {
          hasSection: !!section,
          hasTranscription,
          isRange,
          transcriptionLength: transcription.length,
          markerType: this.selectedMarkerType
        });
        
        if (section) {
          if (hasTranscription && isRange) {
            console.log('[ElevenLabs] Showing button!');
            section.classList.remove('hidden');
          } else {
            console.log('[ElevenLabs] Hiding button - needs transcription AND range type');
            section.classList.add('hidden');
          }
        } else {
          console.error('[ElevenLabs] Section element not found!');
        }
      },

      // Replace audio from modal (while creating/editing marker)
      async replaceAudioWithElevenLabsFromModal() {
        if (!this.videoPath) {
          this.showToast('error', 'No video loaded');
          return;
        }

        const transcription = document.getElementById('markerTranscription').value;
        if (!transcription || transcription.trim() === '') {
          this.showToast('error', 'Please add transcription first');
          return;
        }

        const markerName = document.getElementById('markerNameInput').value || 'Untitled Range';
        
        // Get range times
        const startTime = this.rangeInTime;
        const endTime = this.rangeOutTime;

        // Show confirmation dialog
        const confirmed = confirm(
          `This will replace the audio in "${markerName}" (${this.formatTime(startTime)} - ${this.formatTime(endTime)}) with AI-generated speech.\n\nTranscription:\n"${transcription.substring(0, 200)}${transcription.length > 200 ? '...' : ''}"\n\nContinue?`
        );
        
        if (!confirmed) return;

        try {
          this.showToast('info', 'Generating audio with ElevenLabs...', 5000);
          this.showProgress('Calling ElevenLabs API...', 10);

          const result = await window.videoEditor.replaceAudioWithElevenLabs(
            this.videoPath,
            {
              startTime,
              endTime,
              text: transcription,
              markerName
            }
          );

          this.hideProgress();

          if (result.error) {
            throw new Error(result.error);
          }

          this.showToast('success', `Audio replaced! Saved to: ${result.outputPath}`);
          
          // If editing existing marker, update it
          if (this.editingMarkerId) {
            const marker = this.markers.find(m => m.id === this.editingMarkerId);
            if (marker) {
              marker.elevenLabsAudio = true;
              marker.elevenLabsGeneratedAt = new Date().toISOString();
              marker.modifiedAt = new Date().toISOString();
              this.renderMarkers();
            }
          }

          // Ask if user wants to close modal and load the new video
          const loadNew = confirm('Audio replacement complete! Would you like to close this dialog and load the new video?');
          if (loadNew) {
            this.closeMarkerModal();
            this.loadVideo(result.outputPath);
          }

        } catch (error) {
          this.hideProgress();
          console.error('[VideoEditor] ElevenLabs error:', error);
          this.showToast('error', 'Failed to replace audio: ' + error.message);
        }
      },

      async replaceAudioWithElevenLabs(markerId) {
        const marker = this.markers.find(m => m.id === markerId);
        if (!marker) {
          this.showToast('error', 'Marker not found');
          return;
        }

        if (!this.videoPath) {
          this.showToast('error', 'No video loaded');
          return;
        }

        if (!marker.transcription || marker.transcription.trim() === '') {
          this.showToast('error', 'No transcription found. Please transcribe this range first.');
          return;
        }

        if (marker.type !== 'range') {
          this.showToast('error', 'Only range markers can have audio replaced');
          return;
        }

        // Show confirmation dialog
        const confirmed = confirm(
          `This will replace the audio in "${marker.name}" (${this.formatTime(marker.inTime)} - ${this.formatTime(marker.outTime)}) with AI-generated speech.\n\nTranscription:\n"${marker.transcription.substring(0, 200)}${marker.transcription.length > 200 ? '...' : ''}"\n\nContinue?`
        );
        
        if (!confirmed) return;

        try {
          this.showToast('info', 'Generating audio with ElevenLabs...', 5000);

          const result = await window.videoEditor.replaceAudioWithElevenLabs(
            this.videoPath,
            {
              startTime: marker.inTime,
              endTime: marker.outTime,
              text: marker.transcription,
              markerName: marker.name
            }
          );

          if (result.error) {
            throw new Error(result.error);
          }

          this.showToast('success', `Audio replaced! Saved to: ${result.outputPath}`);
          
          // Update marker metadata
          marker.elevenLabsAudio = true;
          marker.elevenLabsGeneratedAt = new Date().toISOString();
          marker.modifiedAt = new Date().toISOString();
          this.renderMarkers();

          // Ask if user wants to load the new video
          const loadNew = confirm('Audio replacement complete! Would you like to load the new video?');
          if (loadNew) {
            this.loadVideo(result.outputPath);
          }

        } catch (error) {
          console.error('[VideoEditor] ElevenLabs error:', error);
          this.showToast('error', 'Failed to replace audio: ' + error.message);
        }
      },

      async transcribeMarkerById(markerId) {
        const marker = this.markers.find(m => m.id === markerId);
        if (!marker) return;

        if (!this.videoPath) {
          this.showToast('error', 'No video loaded');
          return;
        }

        let startTime, endTime;
        
        if (marker.type === 'range') {
          startTime = marker.inTime;
          endTime = marker.outTime;
        } else {
          // For spot markers, transcribe 10 seconds around the marker
          startTime = Math.max(0, marker.time - 5);
          const video = document.getElementById('videoPlayer');
          endTime = Math.min(video.duration, marker.time + 5);
        }

        const duration = endTime - startTime;
        
        this.showProgress('Transcribing...', `Processing ${this.formatTime(duration)} of audio`);

        try {
          const result = await window.videoEditor.transcribeRange(this.videoPath, {
            startTime,
            endTime,
            language: 'en'
          });

          this.hideProgress();

          if (!result.success) {
            throw new Error(result.error);
          }

          // Update the marker with transcription
          marker.transcription = result.transcription;
          marker.modifiedAt = new Date().toISOString();
          
          // Re-render
          this.renderMarkers();
          
          this.showToast('success', 'Transcription saved to marker!');
        } catch (error) {
          this.hideProgress();
          console.error('[Transcription] Error:', error);
          this.showToast('error', 'Transcription failed: ' + error.message);
        }
      },

      addMarkerAtPlayhead() {
        if (!this.videoPath) return;
        const video = document.getElementById('videoPlayer');
        this.showMarkerModal(video.currentTime);
      },

      // Mark Range IN - first point of a range marker
      markRangeIn() {
        if (!this.videoPath) return;
        const video = document.getElementById('videoPlayer');
        const time = video.currentTime;
        
        this.pendingRangeMarker = {
          inTime: time,
          color: this.markerColors[Math.floor(Math.random() * this.markerColors.length)]
        };
        
        // Show indicator
        document.getElementById('pendingInTime').textContent = this.formatTime(time);
        document.getElementById('pendingRangeIndicator').classList.remove('hidden');
        
        this.showToast('info', `Range IN set at ${this.formatTime(time)} - now set OUT point`);
      },

      // Mark Range OUT - complete the range marker
      markRangeOut() {
        if (!this.videoPath) return;
        const video = document.getElementById('videoPlayer');
        const outTime = video.currentTime;
        
        if (!this.pendingRangeMarker) {
          // No IN point set, start a new range
          this.markRangeIn();
          return;
        }
        
        const inTime = this.pendingRangeMarker.inTime;
        
        if (outTime <= inTime) {
          this.showToast('error', 'OUT point must be after IN point');
          return;
        }
        
        // Show modal to name the range
        this.rangeInTime = inTime;
        this.rangeOutTime = outTime;
        this.selectedMarkerColor = this.pendingRangeMarker.color;
        this.selectedMarkerType = 'range';
        
        this.showMarkerModal(inTime, null, 'range');
        
        // Hide indicator
        document.getElementById('pendingRangeIndicator').classList.add('hidden');
        this.pendingRangeMarker = null;
      },

      cancelPendingRange() {
        this.pendingRangeMarker = null;
        document.getElementById('pendingRangeIndicator').classList.add('hidden');
        this.showToast('info', 'Range marker cancelled');
      },

      setMarkerType(type) {
        this.selectedMarkerType = type;
        
        // Update UI
        document.querySelectorAll('.marker-type-btn').forEach(btn => {
          btn.classList.toggle('active', btn.dataset.type === type);
        });
        
        // Show/hide time inputs
        document.getElementById('spotTimeGroup').classList.toggle('hidden', type === 'range');
        document.getElementById('rangeTimeGroup').classList.toggle('hidden', type === 'spot');
        
        // Update ElevenLabs button visibility (only shows for range markers with transcription)
        this.updateElevenLabsButton();
      },

      setRangeInNow() {
        const video = document.getElementById('videoPlayer');
        this.rangeInTime = video.currentTime;
        document.getElementById('rangeInDisplay').textContent = this.formatTime(this.rangeInTime);
        this.updateRangeDuration();
      },

      setRangeOutNow() {
        const video = document.getElementById('videoPlayer');
        this.rangeOutTime = video.currentTime;
        document.getElementById('rangeOutDisplay').textContent = this.formatTime(this.rangeOutTime);
        this.updateRangeDuration();
      },

      updateRangeDuration() {
        const duration = Math.max(0, this.rangeOutTime - this.rangeInTime);
        document.getElementById('rangeDuration').textContent = `Duration: ${this.formatTime(duration)}`;
      },

      showMarkerModal(time, editMarker = null, forceType = null) {
        this.editingMarkerId = editMarker?.id || null;
        this.selectedMarkerColor = editMarker?.color || this.markerColors[0];
        this.selectedMarkerType = forceType || editMarker?.type || 'spot';
        
        // Set range times
        if (editMarker?.type === 'range') {
          this.rangeInTime = editMarker.inTime;
          this.rangeOutTime = editMarker.outTime;
        } else if (this.selectedMarkerType === 'range') {
          // Keep the values set by markRangeOut
        } else {
          this.rangeInTime = time;
          this.rangeOutTime = time + 5; // Default 5 second range
        }
        
        // Update modal
        document.getElementById('markerModalTitle').textContent = editMarker ? 'Edit Marker' : 'Add Marker';
        document.getElementById('markerNameInput').value = editMarker?.name || '';
        document.getElementById('markerTimeDisplay').textContent = this.formatTime(time);
        document.getElementById('saveMarkerBtn').textContent = editMarker ? 'Save Changes' : 'Add Marker';
        
        // Update range displays
        document.getElementById('rangeInDisplay').textContent = this.formatTime(this.rangeInTime);
        document.getElementById('rangeOutDisplay').textContent = this.formatTime(this.rangeOutTime);
        this.updateRangeDuration();
        
        // Store time for save
        document.getElementById('markerModal').dataset.time = time;
        
        // Set marker type
        this.setMarkerType(this.selectedMarkerType);
        
        // Hide type selector when editing (can't change type)
        document.getElementById('markerTypeGroup').style.display = editMarker ? 'none' : 'block';
        
        // Populate metadata fields
        document.getElementById('markerDescription').value = editMarker?.description || '';
        document.getElementById('markerTranscription').value = editMarker?.transcription || '';
        document.getElementById('markerTags').value = editMarker?.tags?.join(', ') || '';
        document.getElementById('markerNotes').value = editMarker?.notes || '';
        
        // Show/hide ElevenLabs button based on transcription and marker type
        this.updateElevenLabsButton();
        
        // Show created/modified dates
        if (editMarker?.createdAt) {
          document.getElementById('markerCreated').textContent = new Date(editMarker.createdAt).toLocaleString();
        } else {
          document.getElementById('markerCreated').textContent = 'Now';
        }
        if (editMarker?.modifiedAt) {
          document.getElementById('markerModified').textContent = new Date(editMarker.modifiedAt).toLocaleString();
        } else {
          document.getElementById('markerModified').textContent = '-';
        }
        
        // Build color picker
        const colorPicker = document.getElementById('markerColorPicker');
        colorPicker.innerHTML = this.markerColors.map(color => `
          <div class="marker-color-option ${color === this.selectedMarkerColor ? 'selected' : ''}" 
               style="background: ${color};" 
               data-color="${color}"
               onclick="app.selectMarkerColor('${color}')"></div>
        `).join('');
        
        // Show modal
        document.getElementById('markerModalBackdrop').classList.remove('hidden');
        document.getElementById('markerModal').classList.remove('hidden');
        
        // Focus input
        setTimeout(() => document.getElementById('markerNameInput').focus(), 100);
      },

      closeMarkerModal() {
        document.getElementById('markerModalBackdrop').classList.add('hidden');
        document.getElementById('markerModal').classList.add('hidden');
        this.editingMarkerId = null;
      },

      selectMarkerColor(color) {
        this.selectedMarkerColor = color;
        document.querySelectorAll('.marker-color-option').forEach(el => {
          el.classList.toggle('selected', el.dataset.color === color);
        });
      },

      saveMarker() {
        const modal = document.getElementById('markerModal');
        const name = document.getElementById('markerNameInput').value.trim() || `Scene ${this.markers.length + 1}`;
        const color = this.selectedMarkerColor;
        const type = this.selectedMarkerType;
        
        // Get metadata
        const description = document.getElementById('markerDescription').value.trim();
        const transcription = document.getElementById('markerTranscription').value.trim();
        const tagsInput = document.getElementById('markerTags').value.trim();
        const tags = tagsInput ? tagsInput.split(',').map(t => t.trim()).filter(t => t) : [];
        const notes = document.getElementById('markerNotes').value.trim();
        const now = new Date().toISOString();
        
        if (this.editingMarkerId) {
          // Edit existing marker
          const marker = this.markers.find(m => m.id === this.editingMarkerId);
          if (marker) {
            marker.name = name;
            marker.color = color;
            marker.description = description;
            marker.transcription = transcription;
            marker.tags = tags;
            marker.notes = notes;
            marker.modifiedAt = now;
            if (marker.type === 'range') {
              marker.inTime = this.rangeInTime;
              marker.outTime = this.rangeOutTime;
              marker.duration = this.rangeOutTime - this.rangeInTime;
            }
          }
        } else {
          // Add new marker
          const baseMarker = {
            id: this.nextMarkerId++,
            name: name,
            color: color,
            description: description,
            transcription: transcription,
            tags: tags,
            notes: notes,
            createdAt: now,
            modifiedAt: now
          };
          
          if (type === 'spot') {
            const time = parseFloat(modal.dataset.time);
            this.markers.push({
              ...baseMarker,
              type: 'spot',
              time: time
            });
          } else {
            // Range marker
            if (this.rangeOutTime <= this.rangeInTime) {
              this.showToast('error', 'OUT point must be after IN point');
              return;
            }
            this.markers.push({
              ...baseMarker,
              type: 'range',
              inTime: this.rangeInTime,
              outTime: this.rangeOutTime,
              duration: this.rangeOutTime - this.rangeInTime
            });
          }
          
          // Sort markers by time (use inTime for ranges)
          this.markers.sort((a, b) => {
            const timeA = a.type === 'range' ? a.inTime : a.time;
            const timeB = b.type === 'range' ? b.inTime : b.time;
            return timeA - timeB;
          });
        }
        
        this.closeMarkerModal();
        this.renderMarkers();
        this.showToast('success', this.editingMarkerId ? 'Marker updated' : 'Marker added');
      },

      deleteMarker(id) {
        this.markers = this.markers.filter(m => m.id !== id);
        this.renderMarkers();
        this.showToast('success', 'Marker deleted');
      },

      clearAllMarkers() {
        if (this.markers.length === 0) return;
        if (confirm('Delete all markers?')) {
          this.markers = [];
          this.renderMarkers();
          this.showToast('success', 'All markers cleared');
        }
      },

      renderMarkers() {
        // Render markers on timeline track
        const track = document.getElementById('markersTrack');
        const video = document.getElementById('videoPlayer');
        
        if (!track || !video || !video.duration) {
          if (track) track.innerHTML = '';
          return;
        }
        
        const zoom = this.timelineZoom;
        track.style.width = `calc((100% - 108px) * ${zoom})`;
        
        track.innerHTML = this.markers.map(marker => {
          if (marker.type === 'range') {
            // Range marker - show as a region
            const startPercent = (marker.inTime / video.duration) * 100;
            const endPercent = (marker.outTime / video.duration) * 100;
            const width = endPercent - startPercent;
            const duration = marker.outTime - marker.inTime;
            return `
              <div class="marker-range" style="left: ${startPercent}%; width: ${width}%; background: ${marker.color};" 
                   data-id="${marker.id}"
                   onmousedown="app.startDragRangeMove(event, ${marker.id})"
                   onclick="event.stopPropagation(); app.goToMarker(${marker.id})"
                   oncontextmenu="event.preventDefault(); event.stopPropagation(); app.showMarkerContextMenu(event, ${marker.id})">
                <div class="marker-range-handle left" onmousedown="event.stopPropagation(); app.startDragRangeIn(event, ${marker.id})"></div>
                <div class="marker-range-label">${marker.name} (${this.formatTime(duration)})</div>
                <div class="marker-range-handle right" onmousedown="event.stopPropagation(); app.startDragRangeOut(event, ${marker.id})"></div>
              </div>
              <div class="marker" style="left: ${startPercent}%; background: ${marker.color}; cursor: ew-resize;" 
                   data-id="${marker.id}-in"
                   onmousedown="app.startDragRangeIn(event, ${marker.id})">
                <div class="marker-flag" style="background: ${marker.color};"></div>
                <div class="marker-label">IN: ${marker.name} (${this.formatTime(marker.inTime)})</div>
              </div>
              <div class="marker" style="left: ${endPercent}%; background: ${marker.color}; cursor: ew-resize;" 
                   data-id="${marker.id}-out"
                   onmousedown="app.startDragRangeOut(event, ${marker.id})">
                <div class="marker-flag" style="background: ${marker.color};"></div>
                <div class="marker-label">OUT: ${marker.name} (${this.formatTime(marker.outTime)})</div>
              </div>
            `;
          } else {
            // Spot marker - single point
            const percent = (marker.time / video.duration) * 100;
            return `
              <div class="marker" style="left: ${percent}%; background: ${marker.color}; cursor: ew-resize;" 
                   data-id="${marker.id}"
                   onmousedown="app.startDragSpot(event, ${marker.id})"
                   onclick="event.stopPropagation(); app.goToMarker(${marker.id})"
                   oncontextmenu="event.preventDefault(); event.stopPropagation(); app.showMarkerContextMenu(event, ${marker.id})">
                <div class="marker-flag" style="background: ${marker.color};"></div>
                <div class="marker-label">${marker.name} (${this.formatTime(marker.time)})</div>
              </div>
            `;
          }
        }).join('');
        
        // Render markers list in sidebar
        const list = document.getElementById('markersList');
        const count = document.getElementById('markersCount');
        count.textContent = this.markers.length;
        
        if (this.markers.length === 0) {
          list.innerHTML = '<div class="markers-empty">No markers yet.<br>Click "Add Marker" or press <kbd>N</kbd></div>';
          return;
        }
        
        list.innerHTML = this.markers.map((marker, index) => {
          const hasMetadata = marker.description || marker.transcription || (marker.tags && marker.tags.length > 0);
          const metaIcon = hasMetadata ? '' : '';
          
          if (marker.type === 'range') {
            const duration = marker.outTime - marker.inTime;
            return `
              <div class="marker-item" data-id="${marker.id}" onclick="app.showMarkerDetails(${marker.id})">
                <div class="marker-color-dot" style="background: ${marker.color}; border-radius: 2px; width: 16px;"></div>
                <div class="marker-item-info">
                  <div class="marker-item-name">${index + 1}. ${marker.name} <span style="opacity: 0.5"></span> ${metaIcon}</div>
                  <div class="marker-item-time">${this.formatTime(marker.inTime)}  ${this.formatTime(marker.outTime)} (${this.formatTime(duration)})</div>
                </div>
                <div class="marker-item-actions">
                  <button class="marker-action-btn" onclick="event.stopPropagation(); app.goToMarker(${marker.id})" title="Go to IN"></button>
                  <button class="marker-action-btn" onclick="event.stopPropagation(); app.goToMarkerEnd(${marker.id})" title="Go to OUT"></button>
                  <button class="marker-action-btn" onclick="event.stopPropagation(); app.editMarker(${marker.id})" title="Edit"></button>
                  <button class="marker-action-btn delete" onclick="event.stopPropagation(); app.deleteMarker(${marker.id})" title="Delete"></button>
                </div>
              </div>
            `;
          } else {
            return `
              <div class="marker-item" data-id="${marker.id}" onclick="app.showMarkerDetails(${marker.id})">
                <div class="marker-color-dot" style="background: ${marker.color};"></div>
                <div class="marker-item-info">
                  <div class="marker-item-name">${index + 1}. ${marker.name} <span style="opacity: 0.5"></span> ${metaIcon}</div>
                  <div class="marker-item-time">${this.formatTime(marker.time)}</div>
                </div>
                <div class="marker-item-actions">
                  <button class="marker-action-btn" onclick="event.stopPropagation(); app.goToMarker(${marker.id})" title="Go to marker"></button>
                  <button class="marker-action-btn" onclick="event.stopPropagation(); app.editMarker(${marker.id})" title="Edit"></button>
                  <button class="marker-action-btn delete" onclick="event.stopPropagation(); app.deleteMarker(${marker.id})" title="Delete"></button>
                </div>
              </div>
            `;
          }
        }).join('');
        
        // Update details panel if visible
        if (this.selectedMarkerForDetails) {
          this.showMarkerDetails(this.selectedMarkerForDetails);
        }
        
        // Update scenes list if on scenes tab
        if (this.currentTab === 'scenes') {
          this.renderScenesList();
        }
      },

      // Update markers panel (called after loading scenes from space)
      updateMarkersPanel() {
        // This is handled by renderMarkers() which updates the markers panel
        // This function exists for compatibility with loadScenesFromSpace
      },

      showMarkerDetails(markerId) {
        const marker = this.markers.find(m => m.id === markerId);
        if (!marker) return;
        
        this.selectedMarkerForDetails = markerId;
        
        // Highlight in list
        document.querySelectorAll('.marker-item').forEach(el => el.classList.remove('active'));
        const listItem = document.querySelector(`.marker-item[data-id="${markerId}"]`);
        if (listItem) listItem.classList.add('active');
        
        // Get or create details panel
        let panel = document.getElementById('markerDetailsPanel');
        if (!panel) {
          panel = document.createElement('div');
          panel.id = 'markerDetailsPanel';
          panel.className = 'marker-details-panel';
          document.getElementById('markersPanel').appendChild(panel);
        }
        
        // Build timecode display
        let timecodeHtml;
        if (marker.type === 'range') {
          const duration = marker.outTime - marker.inTime;
          timecodeHtml = `
            <div class="marker-timecode-display">
              <span class="tc-in">IN: ${this.formatTime(marker.inTime)}</span>
              <span></span>
              <span class="tc-out">OUT: ${this.formatTime(marker.outTime)}</span>
              <span class="tc-duration">${this.formatTime(duration)}</span>
            </div>
          `;
        } else {
          timecodeHtml = `
            <div class="marker-timecode-display">
              <span class="tc-in">Time: ${this.formatTime(marker.time)}</span>
            </div>
          `;
        }
        
        // Build tags display
        const tagsHtml = marker.tags && marker.tags.length > 0 
          ? `<div class="marker-tags">${marker.tags.map(t => `<span class="marker-tag">${t}</span>`).join('')}</div>`
          : '<span style="color: var(--text-muted); font-style: italic;">No tags</span>';
        
        panel.innerHTML = `
          <div class="marker-details-header">
            <div class="marker-details-title">
              <div class="marker-color-dot" style="background: ${marker.color};"></div>
              ${marker.name}
            </div>
            <button class="marker-details-close" onclick="app.closeMarkerDetails()"></button>
          </div>
          <div class="marker-details-content">
            <div class="marker-detail-row">
              <div class="marker-detail-label">Timecode</div>
              ${timecodeHtml}
            </div>
            
            ${marker.description ? `
              <div class="marker-detail-row">
                <div class="marker-detail-label">Description</div>
                <div class="marker-detail-value">${marker.description}</div>
              </div>
            ` : ''}
            
            ${marker.transcription ? `
              <div class="marker-detail-row">
                <div class="marker-detail-label">Transcription</div>
                <div class="marker-detail-value transcription">"${marker.transcription}"</div>
              </div>
            ` : ''}
            
            <div class="marker-detail-row">
              <div class="marker-detail-label">Tags</div>
              <div class="marker-detail-value">${tagsHtml}</div>
            </div>
            
            ${marker.notes ? `
              <div class="marker-detail-row">
                <div class="marker-detail-label">Notes</div>
                <div class="marker-detail-value" style="color: var(--text-muted); font-style: italic;">${marker.notes}</div>
              </div>
            ` : ''}
            
            <div class="marker-detail-row" style="display: flex; gap: 16px; margin-top: 16px; padding-top: 12px; border-top: 1px solid var(--border-color);">
              <div>
                <div class="marker-detail-label">Created</div>
                <div class="marker-detail-value mono">${marker.createdAt ? new Date(marker.createdAt).toLocaleDateString() : '-'}</div>
              </div>
              <div>
                <div class="marker-detail-label">Modified</div>
                <div class="marker-detail-value mono">${marker.modifiedAt ? new Date(marker.modifiedAt).toLocaleDateString() : '-'}</div>
              </div>
            </div>
            
            <div style="display: flex; gap: 8px; margin-top: 12px;">
              <button class="btn btn-secondary" style="flex: 1;" onclick="app.goToMarker(${marker.id})"> Go to</button>
              <button class="btn btn-ghost" style="flex: 1;" onclick="app.editMarker(${marker.id})"> Edit</button>
            </div>
            ${marker.type === 'range' ? `
              <div style="display: flex; gap: 8px; margin-top: 8px;">
                <button class="btn btn-ghost" style="flex: 1;" onclick="app.transcribeMarkerById(${marker.id})">
                   Transcribe
                </button>
                <button class="btn btn-ghost" style="flex: 1;" onclick="app.generateScreengrabsForMarker(${marker.id})">
                   Screen Grabs
                </button>
              </div>
              ${marker.transcription ? `
              <div style="margin-top: 8px;">
                <button class="btn btn-primary" style="width: 100%;" onclick="app.replaceAudioWithElevenLabs(${marker.id})">
                   Replace Audio with ElevenLabs
                </button>
              </div>
              ` : ''}
            ` : ''}
          </div>
        `;
        
        panel.style.display = 'block';
      },

      closeMarkerDetails() {
        this.selectedMarkerForDetails = null;
        const panel = document.getElementById('markerDetailsPanel');
        if (panel) panel.style.display = 'none';
        document.querySelectorAll('.marker-item').forEach(el => el.classList.remove('active'));
      },

      // Scenes Tab Functions
      sceneThumbnails: {}, // Cache of scene thumbnails by marker id

      renderScenesList() {
        const list = document.getElementById('scenesList');
        const count = document.getElementById('scenesCount');
        const addFirstBtn = document.getElementById('addFirstSceneBtn');
        
        if (!list) return;
        
        count.textContent = this.markers.length;
        
        if (this.markers.length === 0) {
          list.innerHTML = `
            <div class="scenes-empty">
              <div class="scenes-empty-icon"><svg viewBox="0 0 24 24" width="40" height="40" stroke="currentColor" fill="none" stroke-width="1"><path d="M12 2L2 7l10 5 10-5-10-5z"/><path d="M2 17l10 5 10-5"/><path d="M2 12l10 5 10-5"/></svg></div>
              <div class="scenes-empty-text">No annotations yet</div>
              <div class="scenes-empty-hint">Add markers to create scenes</div>
              <button class="btn btn-secondary" style="margin-top: 12px;" onclick="app.addMarkerAtPlayhead()" ${!this.videoPath ? 'disabled' : ''}>
                + Add First Scene
              </button>
            </div>
          `;
          return;
        }
        
        list.innerHTML = this.markers.map((marker, index) => {
          const thumbnailSrc = this.sceneThumbnails[marker.id];
          const thumbnailHtml = thumbnailSrc 
            ? `<img src="file://${thumbnailSrc}" alt="${marker.name}">`
            : `<span class="scene-thumbnail-placeholder"><svg viewBox="0 0 24 24" width="20" height="20" stroke="currentColor" fill="none" stroke-width="1.5"><rect x="2" y="2" width="20" height="20" rx="2.18" ry="2.18"/><line x1="7" y1="2" x2="7" y2="22"/><line x1="17" y1="2" x2="17" y2="22"/><line x1="2" y1="12" x2="22" y2="12"/><line x1="2" y1="7" x2="7" y2="7"/><line x1="2" y1="17" x2="7" y2="17"/><line x1="17" y1="17" x2="22" y2="17"/><line x1="17" y1="7" x2="22" y2="7"/></svg></span>`;
          
          const typeIcon = marker.type === 'range' ? '' : '';
          
          let timeHtml;
          if (marker.type === 'range') {
            const duration = marker.outTime - marker.inTime;
            timeHtml = `${this.formatTime(marker.inTime)}  ${this.formatTime(marker.outTime)} <span class="duration">(${this.formatTime(duration)})</span>`;
          } else {
            timeHtml = this.formatTime(marker.time);
          }
          
          // Meta icons
          const hasDescription = marker.description ? '' : '';
          const hasTranscription = marker.transcription ? '' : '';
          const hasTags = marker.tags?.length > 0 ? '' : '';
          const hasScreengrabs = marker.screengrabs?.length > 0 ? '' : '';
          
          return `
            <div class="scene-card" data-id="${marker.id}" 
                 draggable="true"
                 ondragstart="app.onSceneDragStart(event, ${marker.id})"
                 ondragend="app.onSceneDragEnd(event)"
                 onclick="app.showSceneDetails(${marker.id})"
                 oncontextmenu="event.preventDefault(); app.showSceneContextMenu(event, ${marker.id})">
              <div class="scene-color-bar" style="background: ${marker.color};"></div>
              <div class="scene-thumbnail">
                ${thumbnailHtml}
                <span class="scene-type-badge">${typeIcon}</span>
              </div>
              <div class="scene-info">
                <div class="scene-number">Scene ${index + 1}</div>
                <div class="scene-title">${marker.name}</div>
                <div class="scene-time">${timeHtml}</div>
                ${hasDescription || hasTranscription || hasTags || hasScreengrabs ? `
                  <div class="scene-meta-icons">
                    ${hasDescription ? `<span class="scene-meta-icon" title="Has description">${hasDescription}</span>` : ''}
                    ${hasTranscription ? `<span class="scene-meta-icon" title="Has transcription">${hasTranscription}</span>` : ''}
                    ${hasTags ? `<span class="scene-meta-icon" title="Has tags">${hasTags}</span>` : ''}
                    ${hasScreengrabs ? `<span class="scene-meta-icon" title="Has screengrabs">${hasScreengrabs}</span>` : ''}
                  </div>
                ` : ''}
              </div>
              <button class="scene-add-btn" onclick="event.stopPropagation(); app.addToPlaylist(${marker.id})" title="Add to Playlist">
                ${this.playlist.some(p => p.markerId === marker.id) ? '' : '+'}
              </button>
            </div>
          `;
        }).join('');
        
        // Generate thumbnails for scenes that don't have them
        this.generateMissingSceneThumbnails();
      },

      async generateMissingSceneThumbnails() {
        if (!this.videoPath) return;
        
        for (const marker of this.markers) {
          if (!this.sceneThumbnails[marker.id]) {
            const time = marker.type === 'range' ? marker.inTime : marker.time;
            try {
              const result = await window.videoEditor.generateThumbnail(this.videoPath, this.formatTimeForFFmpeg(time));
              if (result && !result.error && result.outputPath) {
                this.sceneThumbnails[marker.id] = result.outputPath;
                
                // Update just this thumbnail in the DOM
                const card = document.querySelector(`.scene-card[data-id="${marker.id}"] .scene-thumbnail`);
                if (card) {
                  const img = card.querySelector('img');
                  if (img) {
                    img.src = `file://${result.outputPath}?t=${Date.now()}`;
                  } else {
                    card.innerHTML = `<img src="file://${result.outputPath}"><span class="scene-type-badge">${marker.type === 'range' ? '' : ''}</span>`;
                  }
                }
              }
            } catch (error) {
              console.error(`[Scenes] Error generating thumbnail for marker ${marker.id}:`, error);
            }
          }
        }
      },

      async generateAllSceneThumbnails() {
        if (!this.videoPath || this.markers.length === 0) {
          this.showToast('info', 'No story beats to refresh');
          return;
        }
        
        this.showToast('info', 'Refreshing thumbnails...');
        this.sceneThumbnails = {}; // Clear cache
        await this.generateMissingSceneThumbnails();
        this.showToast('success', 'Thumbnails refreshed');
      },

      formatTimeForFFmpeg(seconds) {
        const h = Math.floor(seconds / 3600);
        const m = Math.floor((seconds % 3600) / 60);
        const s = Math.floor(seconds % 60);
        return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
      },

      showSceneDetails(markerId) {
        const marker = this.markers.find(m => m.id === markerId);
        if (!marker) return;
        
        const index = this.markers.indexOf(marker) + 1;
        const details = document.getElementById('sceneDetails');
        const content = document.getElementById('sceneDetailsContent');
        const title = document.getElementById('sceneDetailsTitle');
        
        title.textContent = marker.name;
        
        // Highlight card
        document.querySelectorAll('.scene-card').forEach(el => el.classList.remove('active'));
        const card = document.querySelector(`.scene-card[data-id="${markerId}"]`);
        if (card) card.classList.add('active');
        
        // Build timecode
        let timecodeHtml;
        if (marker.type === 'range') {
          const duration = marker.outTime - marker.inTime;
          timecodeHtml = `
            <span class="in">IN: ${this.formatTime(marker.inTime)}</span>
            <span class="out">OUT: ${this.formatTime(marker.outTime)}</span>
            <span class="duration">${this.formatTime(duration)}</span>
          `;
        } else {
          timecodeHtml = `<span class="in">Time: ${this.formatTime(marker.time)}</span>`;
        }
        
        // Thumbnail
        const thumbnailSrc = this.sceneThumbnails[marker.id];
        const thumbnailHtml = thumbnailSrc 
          ? `<img src="file://${thumbnailSrc}" alt="${marker.name}">`
          : `<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: var(--text-muted);">No thumbnail</div>`;
        
        // Tags
        const tagsHtml = marker.tags?.length > 0 
          ? marker.tags.map(t => `<span class="marker-tag">${t}</span>`).join('')
          : '<span style="color: var(--text-muted); font-style: italic;">No tags</span>';
        
        content.innerHTML = `
          <div class="scene-details-thumbnail" onclick="app.goToMarker(${marker.id})" style="cursor: pointer;" title="Click to go to this scene">
            ${thumbnailHtml}
          </div>
          
          <div class="scene-details-section">
            <div class="scene-details-label">Scene ${index}  ${marker.type === 'range' ? 'Range' : 'Spot'}</div>
            <div class="scene-details-timecode">${timecodeHtml}</div>
          </div>
          
          ${marker.description ? `
            <div class="scene-details-section">
              <div class="scene-details-label">Description</div>
              <div class="scene-details-value">${marker.description}</div>
            </div>
          ` : ''}
          
          ${marker.transcription ? `
            <div class="scene-details-section">
              <div class="scene-details-label">Transcription</div>
              <div class="scene-details-transcription">"${marker.transcription}"</div>
            </div>
          ` : ''}
          
          <div class="scene-details-section">
            <div class="scene-details-label">Tags</div>
            <div class="marker-tags">${tagsHtml}</div>
          </div>
          
          ${marker.notes ? `
            <div class="scene-details-section">
              <div class="scene-details-label">Notes</div>
              <div class="scene-details-value" style="color: var(--text-muted); font-style: italic;">${marker.notes}</div>
            </div>
          ` : ''}
          
          <div class="scene-details-section" style="display: flex; gap: 16px;">
            <div>
              <div class="scene-details-label">Created</div>
              <div class="scene-details-value" style="font-family: 'JetBrains Mono', monospace; font-size: 11px;">${marker.createdAt ? new Date(marker.createdAt).toLocaleDateString() : '-'}</div>
            </div>
            <div>
              <div class="scene-details-label">Modified</div>
              <div class="scene-details-value" style="font-family: 'JetBrains Mono', monospace; font-size: 11px;">${marker.modifiedAt ? new Date(marker.modifiedAt).toLocaleDateString() : '-'}</div>
            </div>
          </div>
          
          <div class="scene-details-actions">
            <button class="btn btn-secondary" onclick="app.goToMarker(${marker.id})"> Go to Scene</button>
            <button class="btn btn-ghost" onclick="app.editMarker(${marker.id})"> Edit</button>
            ${marker.type === 'range' ? `
              <button class="btn btn-ghost" onclick="app.transcribeMarkerById(${marker.id})"> Transcribe</button>
              <button class="btn btn-ghost" onclick="app.generateScreengrabsForMarker(${marker.id})"> Grabs</button>
            ` : ''}
          </div>
          
          <button class="btn btn-ghost" style="width: 100%; margin-top: 12px; color: var(--error);" onclick="app.deleteMarker(${marker.id}); app.closeSceneDetails();">
             Delete Scene
          </button>
        `;
        
        details.classList.remove('hidden');
      },

      closeSceneDetails() {
        document.getElementById('sceneDetails').classList.add('hidden');
        document.querySelectorAll('.scene-card').forEach(el => el.classList.remove('active'));
      },

      // Export scenes for Agentic Player
      exportToAgenticPlayer() {
        if (this.markers.length === 0) {
          this.showToast('error', 'No story beats to export');
          return;
        }

        const videoFileName = this.videoPath ? this.videoPath.split('/').pop() : 'main.mp4';
        
        const exportData = {
          config: {
            title: videoFileName.replace(/\.[^.]+$/, ''),
            defaultVideo: `videos/${videoFileName}`,
            exportedAt: new Date().toISOString()
          },
          scenes: this.markers.map((marker, index) => {
            const scene = {
              id: marker.id,
              name: marker.name,
              type: marker.type,
              videoSrc: `videos/${videoFileName}`,
              color: marker.color
            };

            if (marker.type === 'range') {
              scene.inTime = marker.inTime;
              scene.outTime = marker.outTime;
            } else {
              scene.time = marker.time;
              scene.inTime = Math.max(0, marker.time - 2.5);
              scene.outTime = marker.time + 2.5;
            }

            if (marker.description) scene.description = marker.description;
            if (marker.transcription) scene.transcription = marker.transcription;
            if (marker.tags && marker.tags.length > 0) scene.tags = marker.tags;
            if (marker.notes) scene.notes = marker.notes;

            return scene;
          })
        };

        // Create and download the JSON file
        const jsonStr = JSON.stringify(exportData, null, 2);
        const blob = new Blob([jsonStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = 'scenes.json';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        this.showToast('success', `Exported ${this.markers.length} story beats for Agentic Player`);
      },

      // Scene context menu
      showSceneContextMenu(event, markerId) {
        const marker = this.markers.find(m => m.id === markerId);
        if (!marker) return;
        
        const index = this.markers.indexOf(marker) + 1;
        const isRange = marker.type === 'range';
        
        const inPlaylist = this.playlist.some(p => p.markerId === markerId);
        
        const items = [
          { type: 'header', label: `Scene ${index}: ${marker.name}` },
          { icon: '', label: 'Go to Scene', action: () => this.goToMarker(markerId) },
          { icon: '', label: 'View Details', action: () => this.showSceneDetails(markerId) },
          { type: 'divider' },
          { icon: inPlaylist ? '' : '', label: inPlaylist ? 'In Playlist' : 'Add to Playlist', action: () => this.addToPlaylist(markerId), disabled: inPlaylist },
          { type: 'divider' },
          { type: 'header', label: 'Edit Metadata' },
          { icon: '', label: 'Edit All Properties', action: () => this.editMarker(markerId) },
          { icon: '', label: 'Edit Name', action: () => this.quickEditSceneName(markerId) },
          { icon: '', label: 'Edit Description', action: () => this.quickEditSceneDescription(markerId) },
          { icon: '', label: 'Edit Tags', action: () => this.quickEditSceneTags(markerId) },
          { type: 'divider' },
          { type: 'header', label: 'Generate' },
          { icon: '', label: 'Auto-Transcribe', action: () => this.transcribeMarkerById(markerId), disabled: !isRange },
          { icon: '', label: 'Capture Frames', action: () => this.generateScreengrabsForMarker(markerId) },
          { icon: '', label: 'Refresh Thumbnail', action: () => this.refreshSceneThumbnail(markerId) },
          { type: 'divider' },
          { icon: '', label: 'Change Color', action: () => this.showColorPicker(markerId) },
          { type: 'divider' },
          { icon: '', label: 'Delete Scene', action: () => this.deleteMarker(markerId), danger: true },
        ];
        
        this.showCustomContextMenu(event.clientX, event.clientY, items);
      },

      showCustomContextMenu(x, y, items) {
        const menu = document.getElementById('contextMenu');
        const menuItems = document.getElementById('contextMenuItems');
        
        let html = '';
        for (const item of items) {
          if (item.type === 'divider') {
            html += '<div class="context-menu-divider"></div>';
          } else if (item.type === 'header') {
            html += `<div class="context-menu-header">${item.label}</div>`;
          } else {
            const disabledClass = item.disabled ? 'disabled' : '';
            const dangerClass = item.danger ? 'danger' : '';
            html += `
              <div class="context-menu-item ${disabledClass} ${dangerClass}" data-action-id="${Math.random()}">
                <span class="context-menu-item-icon">${item.icon}</span>
                <span class="context-menu-item-label">${item.label}</span>
              </div>
            `;
          }
        }
        
        menuItems.innerHTML = html;
        
        // Add click handlers
        const menuItemEls = menuItems.querySelectorAll('.context-menu-item');
        let actionIndex = 0;
        for (const item of items) {
          if (item.type !== 'divider' && item.type !== 'header') {
            const el = menuItemEls[actionIndex];
            if (el && item.action && !item.disabled) {
              el.addEventListener('click', () => {
                item.action();
                this.hideContextMenu();
              });
            }
            actionIndex++;
          }
        }
        
        // Position and show menu
        menu.style.left = `${x}px`;
        menu.style.top = `${y}px`;
        menu.classList.add('visible');
        
        // Adjust if menu goes off screen
        requestAnimationFrame(() => {
          const rect = menu.getBoundingClientRect();
          if (rect.right > window.innerWidth) {
            menu.style.left = `${x - rect.width}px`;
          }
          if (rect.bottom > window.innerHeight) {
            menu.style.top = `${y - rect.height}px`;
          }
        });
      },

      // Quick edit functions
      quickEditSceneName(markerId) {
        const marker = this.markers.find(m => m.id === markerId);
        if (!marker) return;
        
        const newName = prompt('Scene Name:', marker.name);
        if (newName !== null && newName.trim()) {
          marker.name = newName.trim();
          marker.modifiedAt = new Date().toISOString();
          this.renderMarkers();
          this.renderScenesList();
          this.showToast('success', 'Story beat name updated');
        }
      },

      quickEditSceneDescription(markerId) {
        const marker = this.markers.find(m => m.id === markerId);
        if (!marker) return;
        
        const newDesc = prompt('Description:', marker.description || '');
        if (newDesc !== null) {
          marker.description = newDesc.trim();
          marker.modifiedAt = new Date().toISOString();
          this.renderMarkers();
          this.renderScenesList();
          this.showToast('success', 'Description updated');
        }
      },

      quickEditSceneTags(markerId) {
        const marker = this.markers.find(m => m.id === markerId);
        if (!marker) return;
        
        const currentTags = marker.tags?.join(', ') || '';
        const newTags = prompt('Tags (comma separated):', currentTags);
        if (newTags !== null) {
          marker.tags = newTags.split(',').map(t => t.trim()).filter(t => t);
          marker.modifiedAt = new Date().toISOString();
          this.renderMarkers();
          this.renderScenesList();
          this.showToast('success', 'Tags updated');
        }
      },

      async refreshSceneThumbnail(markerId) {
        const marker = this.markers.find(m => m.id === markerId);
        if (!marker || !this.videoPath) return;
        
        const time = marker.type === 'range' ? marker.inTime : marker.time;
        
        try {
          delete this.sceneThumbnails[markerId]; // Clear cached thumbnail
          const result = await window.videoEditor.generateThumbnail(this.videoPath, this.formatTimeForFFmpeg(time));
          
          if (result && !result.error && result.outputPath) {
            this.sceneThumbnails[markerId] = result.outputPath;
            this.renderScenesList();
            this.showToast('success', 'Thumbnail refreshed');
          }
        } catch (error) {
          this.showToast('error', 'Failed to refresh thumbnail');
        }
      },

      // Scene drag to playlist
      draggingSceneId: null,

      onSceneDragStart(event, markerId) {
        this.draggingSceneId = markerId;
        event.target.classList.add('dragging');
        event.dataTransfer.effectAllowed = 'copy';
        event.dataTransfer.setData('text/plain', markerId.toString());
      },

      onSceneDragEnd(event) {
        this.draggingSceneId = null;
        event.target.classList.remove('dragging');
        document.getElementById('playlistPanel').classList.remove('drag-over');
      },

      onPlaylistDragOverFromScene(event) {
        if (this.draggingSceneId !== null) {
          event.preventDefault();
          event.dataTransfer.dropEffect = 'copy';
          document.getElementById('playlistPanel').classList.add('drag-over');
        }
      },

      onPlaylistDragLeave(event) {
        // Only remove if leaving the playlist panel entirely
        if (!event.currentTarget.contains(event.relatedTarget)) {
          document.getElementById('playlistPanel').classList.remove('drag-over');
        }
      },

      onPlaylistDropFromScene(event) {
        event.preventDefault();
        document.getElementById('playlistPanel').classList.remove('drag-over');
        
        const markerId = parseInt(event.dataTransfer.getData('text/plain'));
        if (markerId && !isNaN(markerId)) {
          this.addToPlaylist(markerId);
        }
        
        this.draggingSceneId = null;
      },

      // Playlist Functions
      addToPlaylist(markerId) {
        const marker = this.markers.find(m => m.id === markerId);
        if (!marker) return;
        
        // Check if already in playlist
        if (this.playlist.some(p => p.markerId === markerId)) {
          this.showToast('info', 'Scene already in playlist');
          return;
        }
        
        // Calculate duration
        let duration;
        if (marker.type === 'range') {
          duration = marker.outTime - marker.inTime;
        } else {
          // For spot markers, use 5 seconds
          duration = 5;
        }
        
        this.playlist.push({
          markerId: markerId,
          name: marker.name,
          color: marker.color,
          type: marker.type,
          inTime: marker.type === 'range' ? marker.inTime : Math.max(0, marker.time - 2.5),
          outTime: marker.type === 'range' ? marker.outTime : marker.time + 2.5,
          duration: duration
        });
        
        this.renderPlaylist();
        this.showToast('success', `Added "${marker.name}" to playlist`);
      },

      removeFromPlaylist(index) {
        this.playlist.splice(index, 1);
        this.renderPlaylist();
      },

      clearPlaylist() {
        if (this.playlist.length === 0) return;
        if (confirm('Clear entire playlist?')) {
          this.playlist = [];
          this.playlistPlaying = false;
          this.playlistCurrentIndex = -1;
          this.renderPlaylist();
          this.showToast('success', 'Playlist cleared');
        }
      },

      shufflePlaylist() {
        if (this.playlist.length < 2) return;
        
        // Fisher-Yates shuffle
        for (let i = this.playlist.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [this.playlist[i], this.playlist[j]] = [this.playlist[j], this.playlist[i]];
        }
        
        this.renderPlaylist();
        this.showToast('success', 'Playlist shuffled');
      },

      movePlaylistItem(fromIndex, toIndex) {
        const item = this.playlist.splice(fromIndex, 1)[0];
        this.playlist.splice(toIndex, 0, item);
        this.renderPlaylist();
      },

      renderPlaylist() {
        const container = document.getElementById('playlistItems');
        const countEl = document.getElementById('playlistCount');
        const durationEl = document.getElementById('playlistDuration');
        const playBtn = document.getElementById('playlistPlayBtn');
        const exportBtn = document.getElementById('exportPlaylistBtn');
        const clearBtn = document.getElementById('clearPlaylistBtn');
        const shuffleBtn = document.getElementById('shufflePlaylistBtn');
        
        countEl.textContent = this.playlist.length;
        
        // Calculate total duration
        const totalDuration = this.playlist.reduce((sum, item) => sum + item.duration, 0);
        durationEl.textContent = this.formatTime(totalDuration);
        
        // Enable/disable buttons
        const hasItems = this.playlist.length > 0;
        playBtn.disabled = !hasItems;
        exportBtn.disabled = !hasItems;
        clearBtn.disabled = !hasItems;
        shuffleBtn.disabled = this.playlist.length < 2;
        
        if (this.playlist.length === 0) {
          container.innerHTML = `
            <div class="playlist-empty">
              Drag story beats here or right-click  "Add to Playlist"
            </div>
          `;
          return;
        }
        
        container.innerHTML = this.playlist.map((item, index) => `
          <div class="playlist-item ${this.playlistCurrentIndex === index ? 'playing' : ''}" 
               data-index="${index}"
               draggable="true"
               ondragstart="app.onPlaylistDragStart(event, ${index})"
               ondragover="app.onPlaylistDragOver(event)"
               ondrop="app.onPlaylistDrop(event, ${index})"
               onclick="app.playPlaylistItem(${index})">
            <span class="playlist-item-drag"></span>
            <span class="playlist-item-number">${index + 1}</span>
            <div class="playlist-item-color" style="background: ${item.color};"></div>
            <div class="playlist-item-info">
              <div class="playlist-item-name">${item.name}</div>
              <div class="playlist-item-time">${this.formatTime(item.inTime)}  ${this.formatTime(item.outTime)} (${this.formatTime(item.duration)})</div>
            </div>
            <button class="playlist-item-remove" onclick="event.stopPropagation(); app.removeFromPlaylist(${index})" title="Remove"></button>
          </div>
        `).join('');
      },

      // Drag and drop for playlist reordering
      playlistDragIndex: null,

      onPlaylistDragStart(event, index) {
        this.playlistDragIndex = index;
        event.target.classList.add('dragging');
        event.dataTransfer.effectAllowed = 'move';
      },

      onPlaylistDragOver(event) {
        event.preventDefault();
        event.dataTransfer.dropEffect = 'move';
      },

      onPlaylistDrop(event, dropIndex) {
        event.preventDefault();
        
        if (this.playlistDragIndex !== null && this.playlistDragIndex !== dropIndex) {
          this.movePlaylistItem(this.playlistDragIndex, dropIndex);
        }
        
        this.playlistDragIndex = null;
        document.querySelectorAll('.playlist-item').forEach(el => el.classList.remove('dragging'));
      },

      // Playlist playback
      togglePlaylistPlayback() {
        if (this.playlistPlaying) {
          this.stopPlaylistPlayback();
        } else {
          this.startPlaylistPlayback();
        }
      },

      startPlaylistPlayback() {
        if (this.playlist.length === 0) return;
        
        this.playlistPlaying = true;
        this.playlistCurrentIndex = 0;
        
        const playBtn = document.getElementById('playlistPlayBtn');
        playBtn.innerHTML = '<svg viewBox="0 0 24 24" width="12" height="12" fill="currentColor"><rect x="4" y="4" width="16" height="16"/></svg> Stop';
        playBtn.classList.add('playing');
        
        this.playCurrentPlaylistItem();
        this.renderPlaylist();
      },

      stopPlaylistPlayback() {
        this.playlistPlaying = false;
        this.playlistCurrentIndex = -1;
        
        const video = document.getElementById('videoPlayer');
        video.pause();
        
        const playBtn = document.getElementById('playlistPlayBtn');
        playBtn.innerHTML = '<svg viewBox="0 0 24 24" width="12" height="12" fill="currentColor"><path d="M5 3l14 9-14 9V3z"/></svg> Play All';
        playBtn.classList.remove('playing');
        
        this.renderPlaylist();
      },

      playPlaylistItem(index) {
        if (index < 0 || index >= this.playlist.length) return;
        
        this.playlistCurrentIndex = index;
        this.playCurrentPlaylistItem();
        this.renderPlaylist();
      },

      playCurrentPlaylistItem() {
        if (this.playlistCurrentIndex < 0 || this.playlistCurrentIndex >= this.playlist.length) {
          this.stopPlaylistPlayback();
          return;
        }
        
        const item = this.playlist[this.playlistCurrentIndex];
        const video = document.getElementById('videoPlayer');
        
        video.currentTime = item.inTime;
        video.play();
        
        // Set up listener to detect when we reach the out point
        this.setupPlaylistEndListener(item.outTime);
      },

      setupPlaylistEndListener(outTime) {
        const video = document.getElementById('videoPlayer');
        
        // Remove any existing listener
        if (this.playlistTimeUpdateHandler) {
          video.removeEventListener('timeupdate', this.playlistTimeUpdateHandler);
        }
        
        this.playlistTimeUpdateHandler = () => {
          if (!this.playlistPlaying) return;
          
          if (video.currentTime >= outTime - 0.1) {
            // Move to next item
            this.playlistCurrentIndex++;
            
            if (this.playlistCurrentIndex >= this.playlist.length) {
              // End of playlist
              this.stopPlaylistPlayback();
              this.showToast('success', 'Playlist complete');
            } else {
              // Play next item
              this.playCurrentPlaylistItem();
              this.renderPlaylist();
            }
          }
        };
        
        video.addEventListener('timeupdate', this.playlistTimeUpdateHandler);
      },

      // AI Playlist Builder
      aiBuilderExpanded: true,

      toggleAIBuilder() {
        this.aiBuilderExpanded = !this.aiBuilderExpanded;
        document.getElementById('aiBuilderContent').classList.toggle('collapsed', !this.aiBuilderExpanded);
        document.getElementById('aiBuilderToggle').classList.toggle('collapsed', !this.aiBuilderExpanded);
      },

      async buildPlaylistWithAI() {
        const prompt = document.getElementById('aiPlaylistPrompt').value.trim();
        
        if (!prompt) {
          this.showToast('error', 'Please enter a prompt describing the playlist you want');
          return;
        }
        
        if (this.markers.length === 0) {
          this.showToast('error', 'No story beats available. Add some markers first.');
          return;
        }
        
        const keepOrder = document.getElementById('aiKeepOrder').checked;
        const includeAll = document.getElementById('aiIncludeAll').checked;
        
        const btn = document.getElementById('aiBuilderBtn');
        const status = document.getElementById('aiBuilderStatus');
        
        btn.disabled = true;
        btn.innerHTML = ' Thinking...';
        status.className = 'ai-builder-status loading';
        status.textContent = 'Analyzing your story beats...';
        status.classList.remove('hidden');
        
        try {
          // Build scene data for AI
          const scenesData = this.markers.map((marker, index) => {
            const duration = marker.type === 'range' 
              ? marker.outTime - marker.inTime 
              : 5;
            
            return {
              id: marker.id,
              index: index + 1,
              name: marker.name,
              type: marker.type,
              duration: duration,
              durationFormatted: this.formatTime(duration),
              timeIn: marker.type === 'range' ? this.formatTime(marker.inTime) : this.formatTime(marker.time),
              timeOut: marker.type === 'range' ? this.formatTime(marker.outTime) : null,
              description: marker.description || '',
              transcription: marker.transcription || '',
              tags: marker.tags || [],
              notes: marker.notes || ''
            };
          });
          
          // Call AI to build playlist
          const result = await window.videoEditor.buildPlaylistWithAI({
            prompt,
            scenes: scenesData,
            keepOrder,
            includeAll
          });
          
          if (!result.success) {
            throw new Error(result.error);
          }
          
          // Clear existing playlist and add AI selections
          this.playlist = [];
          
          for (const selectedId of result.selectedSceneIds) {
            const marker = this.markers.find(m => m.id === selectedId);
            if (marker) {
              this.addToPlaylist(marker.id);
            }
          }
          
          status.className = 'ai-builder-status success';
          status.textContent = ` Created playlist with ${result.selectedSceneIds.length} story beats${result.reasoning ? ': ' + result.reasoning : ''}`;
          
          this.renderPlaylist();
          this.showToast('success', `AI created a playlist with ${result.selectedSceneIds.length} story beats!`);
          
        } catch (error) {
          console.error('[AI Playlist] Error:', error);
          status.className = 'ai-builder-status error';
          status.textContent = ' ' + error.message;
          this.showToast('error', 'AI playlist failed: ' + error.message);
        } finally {
          btn.disabled = false;
          btn.innerHTML = ' Build with AI';
        }
      },

      // Export playlist as a single video
      async exportPlaylist() {
        if (this.playlist.length === 0) {
          this.showToast('error', 'Playlist is empty');
          return;
        }
        
        if (!this.videoPath) {
          this.showToast('error', 'No video loaded');
          return;
        }
        
        const totalDuration = this.playlist.reduce((sum, item) => sum + item.duration, 0);
        
        if (!confirm(`Export playlist as single video?\n\n${this.playlist.length} story beats, ${this.formatTime(totalDuration)} total duration`)) {
          return;
        }
        
        this.showProgress('Exporting Playlist...', 'Creating video from story beats');
        
        try {
          // Build segments array for concatenation
          const segments = this.playlist.map(item => ({
            startTime: item.inTime,
            endTime: item.outTime
          }));
          
          const result = await window.videoEditor.exportPlaylist(this.videoPath, { segments });
          
          this.hideProgress();
          
          if (result.error) {
            throw new Error(result.error);
          }
          
          this.showToast('success', 'Playlist exported successfully!');
          this.loadExports();
        } catch (error) {
          this.hideProgress();
          this.showToast('error', 'Export failed: ' + error.message);
        }
      },
      
      // Save scenes (and optionally edited video) back to Space
      async saveToSpace() {
        if (!this.spaceItemId) {
          this.showToast('error', 'Video was not loaded from a Space');
          return;
        }
        
        if (this.markers.length === 0) {
          this.showToast('warning', 'No story beats to save. Add some markers first.');
          return;
        }
        
        // Convert markers to scenes format
        const scenes = this.markers.map((marker, index) => ({
          id: marker.id || index + 1,
          name: marker.name || `Scene ${index + 1}`,
          inTime: marker.type === 'range' ? marker.timeIn : marker.time,
          outTime: marker.type === 'range' ? marker.timeOut : (marker.time + 5), // Default 5s for spot markers
          description: marker.description || '',
          transcription: marker.transcription || '',
          tags: marker.tags || [],
          notes: marker.notes || ''
        }));
        
        try {
          this.showProgress('Saving to Space...', 'Updating scene metadata');
          
          // Save scenes only (no video re-encoding)
          const result = await window.videoEditor.saveScenesOnly(this.spaceItemId, scenes);
          
          this.hideProgress();
          
          if (!result.success) {
            throw new Error(result.error || 'Failed to save');
          }
          
          this.showToast('success', `Saved ${result.scenesCount} story beats to Space!`);
        } catch (error) {
          this.hideProgress();
          this.showToast('error', 'Save failed: ' + error.message);
        }
      },
      
      // Save edited video and scenes back to Space (replaces original)
      async saveEditedVideoToSpace() {
        if (!this.spaceItemId) {
          this.showToast('error', 'Video was not loaded from a Space');
          return;
        }
        
        if (this.playlist.length === 0 && this.markers.length === 0) {
          this.showToast('warning', 'No edits or story beats to save.');
          return;
        }
        
        // If there's a playlist, use it as the edit list
        // Otherwise just save scenes
        if (this.playlist.length === 0) {
          return this.saveToSpace();
        }
        
        const totalDuration = this.playlist.reduce((sum, item) => sum + item.duration, 0);
        
        if (!confirm(`Save edited video back to Space?\n\nThis will:\n Create a new video from ${this.playlist.length} story beats (${this.formatTime(totalDuration)})\n Replace the original video (backup will be created)\n Save story beat markers to metadata\n\nContinue?`)) {
          return;
        }
        
        try {
          // Step 1: Process edit list
          this.showProgress('Processing Video...', 'Combining selected segments');
          
          const editList = this.playlist.map(item => ({
            startTime: item.inTime,
            endTime: item.outTime
          }));
          
          const editResult = await window.videoEditor.processEditList(this.videoPath, editList, {
            quality: 'high'
          });
          
          if (!editResult.success) {
            throw new Error(editResult.error || 'Failed to process video');
          }
          
          // Step 2: Finalize workflow (replace + save scenes)
          this.showProgress('Saving to Space...', 'Replacing original and saving story beats');
          
          // Convert markers to scenes (adjust times for new video)
          const scenes = this.playlist.map((item, index) => {
            // Calculate new times based on cumulative duration
            let newInTime = 0;
            for (let i = 0; i < index; i++) {
              newInTime += this.playlist[i].outTime - this.playlist[i].inTime;
            }
            const duration = item.outTime - item.inTime;
            
            return {
              id: index + 1,
              name: item.name || `Scene ${index + 1}`,
              inTime: newInTime,
              outTime: newInTime + duration,
              description: item.description || '',
              transcription: item.transcription || '',
              tags: item.tags || []
            };
          });
          
          const finalResult = await window.videoEditor.finalizeWorkflow(
            this.spaceItemId,
            editResult.outputPath,
            scenes
          );
          
          this.hideProgress();
          
          if (!finalResult.success) {
            throw new Error(finalResult.error || 'Failed to save to space');
          }
          
          this.showToast('success', `Video saved to Space! (${finalResult.scenesCount} story beats, ${this.formatTime(finalResult.newDuration)})`);
          
          // Clear playlist since it's been saved
          this.clearPlaylist();
          
          // Reload the video from the space
          this.loadVideoFromSpace(this.spaceItemId);
          
        } catch (error) {
          this.hideProgress();
          this.showToast('error', 'Save failed: ' + error.message);
        }
      },

      showColorPicker(markerId) {
        const marker = this.markers.find(m => m.id === markerId);
        if (!marker) return;
        
        // Create a simple color picker modal
        const colors = this.markerColors;
        const currentColor = marker.color;
        
        const modal = document.createElement('div');
        modal.className = 'marker-modal-backdrop';
        modal.style.cssText = 'position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 2999; display: flex; align-items: center; justify-content: center;';
        
        modal.innerHTML = `
          <div style="background: var(--bg-surface); border-radius: 12px; padding: 20px; min-width: 280px;">
            <div style="font-size: 14px; font-weight: 600; margin-bottom: 16px;">Choose Color</div>
            <div style="display: flex; gap: 10px; flex-wrap: wrap; justify-content: center;">
              ${colors.map(color => `
                <div class="color-option" data-color="${color}" 
                     style="width: 36px; height: 36px; border-radius: 50%; background: ${color}; cursor: pointer; 
                            border: 3px solid ${color === currentColor ? 'white' : 'transparent'};
                            box-shadow: ${color === currentColor ? '0 0 0 2px var(--accent-primary)' : 'none'};">
                </div>
              `).join('')}
            </div>
            <div style="display: flex; gap: 8px; margin-top: 20px; justify-content: flex-end;">
              <button class="btn btn-ghost" onclick="this.closest('.marker-modal-backdrop').remove()">Cancel</button>
            </div>
          </div>
        `;
        
        // Add click handlers for colors
        modal.querySelectorAll('.color-option').forEach(el => {
          el.addEventListener('click', () => {
            marker.color = el.dataset.color;
            marker.modifiedAt = new Date().toISOString();
            this.renderMarkers();
            this.renderScenesList();
            modal.remove();
            this.showToast('success', 'Color updated');
          });
        });
        
        // Close on backdrop click
        modal.addEventListener('click', (e) => {
          if (e.target === modal) modal.remove();
        });
        
        document.body.appendChild(modal);
      },

      goToMarker(id) {
        const marker = this.markers.find(m => m.id === id);
        if (!marker) return;
        
        const video = document.getElementById('videoPlayer');
        // For range markers, go to IN point; for spot markers, go to time
        video.currentTime = marker.type === 'range' ? marker.inTime : marker.time;
        
        // Highlight the marker
        document.querySelectorAll('.marker').forEach(el => el.classList.remove('selected'));
        document.querySelectorAll('.marker-range').forEach(el => el.classList.remove('selected'));
        document.querySelectorAll('.marker-item').forEach(el => el.classList.remove('active'));
        
        const markerEl = document.querySelector(`.marker[data-id="${id}"]`);
        const rangeEl = document.querySelector(`.marker-range[data-id="${id}"]`);
        const listItem = document.querySelector(`.marker-item[data-id="${id}"]`);
        
        if (markerEl) markerEl.classList.add('selected');
        if (rangeEl) rangeEl.classList.add('selected');
        if (listItem) listItem.classList.add('active');
      },

      goToMarkerEnd(id) {
        const marker = this.markers.find(m => m.id === id);
        if (!marker || marker.type !== 'range') return;
        
        const video = document.getElementById('videoPlayer');
        video.currentTime = marker.outTime;
      },

      editMarker(id) {
        const marker = this.markers.find(m => m.id === id);
        if (!marker) return;
        this.showMarkerModal(marker.time, marker);
      },

      goToPrevMarker() {
        if (this.markers.length === 0) return;
        const video = document.getElementById('videoPlayer');
        const currentTime = video.currentTime;
        
        // Get marker time (use inTime for ranges)
        const getMarkerTime = (m) => m.type === 'range' ? m.inTime : m.time;
        
        // Find the previous marker (with small tolerance)
        for (let i = this.markers.length - 1; i >= 0; i--) {
          if (getMarkerTime(this.markers[i]) < currentTime - 0.5) {
            this.goToMarker(this.markers[i].id);
            return;
          }
        }
        
        // If no previous, go to last marker
        this.goToMarker(this.markers[this.markers.length - 1].id);
      },

      goToNextMarker() {
        if (this.markers.length === 0) return;
        const video = document.getElementById('videoPlayer');
        const currentTime = video.currentTime;
        
        // Get marker time (use inTime for ranges)
        const getMarkerTime = (m) => m.type === 'range' ? m.inTime : m.time;
        
        // Find the next marker
        for (let i = 0; i < this.markers.length; i++) {
          if (getMarkerTime(this.markers[i]) > currentTime + 0.5) {
            this.goToMarker(this.markers[i].id);
            return;
          }
        }
        
        // If no next, go to first marker
        this.goToMarker(this.markers[0].id);
      },

      handleMarkerTrackClick(event) {
        // Don't add marker if we were dragging
        if (this.wasDragging) {
          this.wasDragging = false;
          return;
        }
        
        if (!this.videoPath) return;
        const video = document.getElementById('videoPlayer');
        if (!video || !video.duration) return;
        
        // If clicking on track (not a marker), add a marker at that position
        const track = event.currentTarget;
        const rect = track.getBoundingClientRect();
        const percent = (event.clientX - rect.left) / rect.width;
        const time = percent * video.duration / this.timelineZoom;
        
        this.showMarkerModal(time);
      },

      // Drag functions for markers
      wasDragging: false,

      startDragSpot(event, markerId) {
        event.preventDefault();
        event.stopPropagation();
        
        const marker = this.markers.find(m => m.id === markerId);
        if (!marker) return;
        
        this.draggingMarker = {
          id: markerId,
          type: 'spot',
          startX: event.clientX,
          startTime: marker.time
        };
        
        // Add dragging class
        const el = document.querySelector(`.marker[data-id="${markerId}"]`);
        if (el) el.classList.add('dragging');
        
        // Add global listeners
        document.addEventListener('mousemove', this.handleMarkerDrag);
        document.addEventListener('mouseup', this.handleMarkerDragEnd);
      },

      startDragRangeIn(event, markerId) {
        event.preventDefault();
        event.stopPropagation();
        
        const marker = this.markers.find(m => m.id === markerId);
        if (!marker || marker.type !== 'range') return;
        
        this.draggingMarker = {
          id: markerId,
          type: 'range-in',
          startX: event.clientX,
          startTime: marker.inTime
        };
        
        const el = document.querySelector(`.marker[data-id="${markerId}-in"]`);
        if (el) el.classList.add('dragging');
        
        document.addEventListener('mousemove', this.handleMarkerDrag);
        document.addEventListener('mouseup', this.handleMarkerDragEnd);
      },

      startDragRangeOut(event, markerId) {
        event.preventDefault();
        event.stopPropagation();
        
        const marker = this.markers.find(m => m.id === markerId);
        if (!marker || marker.type !== 'range') return;
        
        this.draggingMarker = {
          id: markerId,
          type: 'range-out',
          startX: event.clientX,
          startTime: marker.outTime
        };
        
        const el = document.querySelector(`.marker[data-id="${markerId}-out"]`);
        if (el) el.classList.add('dragging');
        
        document.addEventListener('mousemove', this.handleMarkerDrag);
        document.addEventListener('mouseup', this.handleMarkerDragEnd);
      },

      startDragRangeMove(event, markerId) {
        // Only start move if not clicking on handles
        if (event.target.classList.contains('marker-range-handle')) return;
        
        event.preventDefault();
        event.stopPropagation();
        
        const marker = this.markers.find(m => m.id === markerId);
        if (!marker || marker.type !== 'range') return;
        
        this.draggingMarker = {
          id: markerId,
          type: 'range-move',
          startX: event.clientX,
          startInTime: marker.inTime,
          startOutTime: marker.outTime,
          duration: marker.outTime - marker.inTime
        };
        
        const el = document.querySelector(`.marker-range[data-id="${markerId}"]`);
        if (el) el.classList.add('dragging');
        
        document.addEventListener('mousemove', this.handleMarkerDrag);
        document.addEventListener('mouseup', this.handleMarkerDragEnd);
      },

      handleMarkerDrag: null, // Will be bound in init
      handleMarkerDragEnd: null, // Will be bound in init

      _handleMarkerDrag(event) {
        if (!this.draggingMarker) return;
        
        const track = document.getElementById('markersTrack');
        const video = document.getElementById('videoPlayer');
        if (!track || !video || !video.duration) return;
        
        const rect = track.getBoundingClientRect();
        const trackWidth = rect.width;
        const deltaX = event.clientX - this.draggingMarker.startX;
        const deltaTime = (deltaX / trackWidth) * video.duration;
        
        const marker = this.markers.find(m => m.id === this.draggingMarker.id);
        if (!marker) return;
        
        switch (this.draggingMarker.type) {
          case 'spot':
            marker.time = Math.max(0, Math.min(video.duration, this.draggingMarker.startTime + deltaTime));
            break;
            
          case 'range-in':
            const newInTime = Math.max(0, Math.min(marker.outTime - 0.1, this.draggingMarker.startTime + deltaTime));
            marker.inTime = newInTime;
            break;
            
          case 'range-out':
            const newOutTime = Math.max(marker.inTime + 0.1, Math.min(video.duration, this.draggingMarker.startTime + deltaTime));
            marker.outTime = newOutTime;
            break;
            
          case 'range-move':
            let newIn = this.draggingMarker.startInTime + deltaTime;
            let newOut = this.draggingMarker.startOutTime + deltaTime;
            
            // Clamp to video bounds
            if (newIn < 0) {
              newIn = 0;
              newOut = this.draggingMarker.duration;
            }
            if (newOut > video.duration) {
              newOut = video.duration;
              newIn = video.duration - this.draggingMarker.duration;
            }
            
            marker.inTime = newIn;
            marker.outTime = newOut;
            break;
        }
        
        // Re-render to update positions
        this.renderMarkers();
        
        // Re-apply dragging class after re-render
        if (this.draggingMarker.type === 'spot') {
          const el = document.querySelector(`.marker[data-id="${marker.id}"]`);
          if (el) el.classList.add('dragging');
        } else if (this.draggingMarker.type === 'range-in') {
          const el = document.querySelector(`.marker[data-id="${marker.id}-in"]`);
          if (el) el.classList.add('dragging');
        } else if (this.draggingMarker.type === 'range-out') {
          const el = document.querySelector(`.marker[data-id="${marker.id}-out"]`);
          if (el) el.classList.add('dragging');
        } else if (this.draggingMarker.type === 'range-move') {
          const el = document.querySelector(`.marker-range[data-id="${marker.id}"]`);
          if (el) el.classList.add('dragging');
        }
      },

      _handleMarkerDragEnd(event) {
        if (!this.draggingMarker) return;
        
        // Check if we actually moved
        const deltaX = Math.abs(event.clientX - this.draggingMarker.startX);
        if (deltaX > 5) {
          this.wasDragging = true;
        }
        
        // Remove dragging classes
        document.querySelectorAll('.marker.dragging, .marker-range.dragging').forEach(el => {
          el.classList.remove('dragging');
        });
        
        // Sort markers by time after drag
        this.markers.sort((a, b) => {
          const timeA = a.type === 'range' ? a.inTime : a.time;
          const timeB = b.type === 'range' ? b.inTime : b.time;
          return timeA - timeB;
        });
        
        this.draggingMarker = null;
        
        // Remove listeners
        document.removeEventListener('mousemove', this.handleMarkerDrag);
        document.removeEventListener('mouseup', this.handleMarkerDragEnd);
        
        // Re-render with sorted order
        this.renderMarkers();
        
        this.showToast('success', 'Marker moved');
      },

      showMarkerContextMenu(event, markerId) {
        const marker = this.markers.find(m => m.id === markerId);
        if (!marker) return;
        
        // Store for context menu actions
        this.contextData = { markerId };
        
        // Show custom context menu for markers
        const items = [
          { type: 'header', label: marker.name },
          { icon: '', label: 'Go to Marker', action: 'goToMarker' },
          { icon: '', label: 'Edit Marker', action: 'editMarker' },
          { type: 'divider' },
          { icon: '', label: 'Delete Marker', action: 'deleteMarkerCtx', danger: true },
        ];
        
        const menu = document.getElementById('contextMenu');
        const menuItems = document.getElementById('contextMenuItems');
        
        let html = '';
        for (const item of items) {
          if (item.type === 'divider') {
            html += '<div class="context-menu-divider"></div>';
          } else if (item.type === 'header') {
            html += `<div class="context-menu-header">${item.label}</div>`;
          } else {
            const dangerClass = item.danger ? 'danger' : '';
            html += `
              <div class="context-menu-item ${dangerClass}" data-action="${item.action}">
                <span class="context-menu-item-icon">${item.icon}</span>
                <span class="context-menu-item-label">${item.label}</span>
              </div>
            `;
          }
        }
        
        menuItems.innerHTML = html;
        
        // Add click handlers
        menuItems.querySelectorAll('.context-menu-item').forEach(item => {
          item.addEventListener('click', () => {
            const action = item.dataset.action;
            if (action === 'goToMarker') this.goToMarker(markerId);
            else if (action === 'editMarker') this.editMarker(markerId);
            else if (action === 'deleteMarkerCtx') this.deleteMarker(markerId);
            this.hideContextMenu();
          });
        });
        
        // Position and show menu
        menu.style.left = `${event.clientX}px`;
        menu.style.top = `${event.clientY}px`;
        menu.classList.add('visible');
      },

      // Timeline Zoom Functions
      setupTimelineZoom() {
        const wrapper = document.getElementById('timelineScrollWrapper');
        const ruler = document.getElementById('timelineRuler');
        
        // Sync ruler scroll with timeline scroll
        if (wrapper) {
          wrapper.addEventListener('scroll', () => {
            if (ruler) {
              ruler.scrollLeft = wrapper.scrollLeft;
            }
          });
        }
        
        // Pinch-to-zoom on timeline (using ctrl+scroll)
        const timeline = document.getElementById('timeline');
        if (timeline) {
          timeline.addEventListener('wheel', (e) => {
            // Ctrl/Cmd + scroll = zoom
            if (e.ctrlKey || e.metaKey) {
              e.preventDefault();
              const delta = e.deltaY > 0 ? -0.5 : 0.5;
              this.setZoom(this.timelineZoom + delta);
            }
          }, { passive: false });
        }
      },

      setZoom(value) {
        const zoom = Math.max(this.minZoom, Math.min(this.maxZoom, parseFloat(value)));
        const previousZoom = this.timelineZoom;
        this.timelineZoom = zoom;
        
        // Update UI
        document.getElementById('zoomSlider').value = zoom;
        document.getElementById('zoomLevel').textContent = zoom.toFixed(1) + 'x';
        
        // Update preset buttons
        document.querySelectorAll('.zoom-preset-btn').forEach(btn => {
          btn.classList.toggle('active', parseFloat(btn.dataset.zoom) === zoom);
        });
        
        // Apply zoom to timeline content
        const content = document.getElementById('timelineContent');
        if (content) {
          content.style.width = (100 * zoom) + '%';
        }
        
        // Update ruler
        this.updateTimelineRuler();
        
        // Update markers
        this.renderMarkers();
        
        // Reload thumbnails if zoom changed significantly (avoid too frequent reloads)
        // Use debounce to avoid hammering the thumbnail generator
        if (Math.abs(zoom - previousZoom) >= 0.5 || zoom === this.minZoom || zoom === this.maxZoom) {
          this.debouncedThumbnailReload();
        }
        
        // Keep playhead centered during zoom
        this.scrollToPlayhead();
      },
      
      // Debounced thumbnail reload to avoid excessive regeneration
      debouncedThumbnailReload() {
        clearTimeout(this._thumbnailReloadTimeout);
        this._thumbnailReloadTimeout = setTimeout(() => {
          this.loadTimelineThumbnails();
        }, 300);
      },

      setZoomPreset(zoom) {
        this.setZoom(zoom);
      },

      zoomIn() {
        this.setZoom(this.timelineZoom + 1);
      },

      zoomOut() {
        this.setZoom(this.timelineZoom - 1);
      },

      fitToView() {
        this.setZoom(1);
        const wrapper = document.getElementById('timelineScrollWrapper');
        if (wrapper) wrapper.scrollLeft = 0;
      },

      scrollToPlayhead() {
        const video = document.getElementById('videoPlayer');
        const wrapper = document.getElementById('timelineScrollWrapper');
        if (!video || !wrapper || !video.duration) return;
        
        const percent = video.currentTime / video.duration;
        const contentWidth = wrapper.scrollWidth;
        const viewportWidth = wrapper.clientWidth;
        const playheadPosition = percent * contentWidth;
        
        // Only scroll if playhead is outside visible area
        const scrollLeft = wrapper.scrollLeft;
        const scrollRight = scrollLeft + viewportWidth;
        
        if (playheadPosition < scrollLeft || playheadPosition > scrollRight) {
          wrapper.scrollLeft = playheadPosition - viewportWidth / 2;
        }
      },

      updateTimelineRuler() {
        const video = document.getElementById('videoPlayer');
        const rulerMarks = document.getElementById('rulerMarks');
        if (!video || !rulerMarks || !video.duration) return;
        
        const duration = video.duration;
        const zoom = this.timelineZoom;
        
        // Calculate appropriate interval based on zoom
        let interval;
        if (zoom >= 10) {
          interval = 1; // Every second
        } else if (zoom >= 5) {
          interval = 2; // Every 2 seconds
        } else if (zoom >= 2) {
          interval = 5; // Every 5 seconds
        } else {
          interval = 10; // Every 10 seconds
        }
        
        // Adjust for video duration
        if (duration > 300) interval = Math.max(interval, 30);
        if (duration > 600) interval = Math.max(interval, 60);
        
        let html = '';
        const totalWidth = 100 * zoom;
        
        for (let time = 0; time <= duration; time += interval) {
          const percent = (time / duration) * 100;
          const label = this.formatTime(time);
          
          html += `
            <div class="ruler-mark" style="left: ${percent}%;">
              <span class="ruler-mark-label">${label}</span>
              <div class="ruler-mark-line major"></div>
            </div>
          `;
          
          // Add minor marks
          if (zoom >= 3) {
            const minorInterval = interval / 2;
            if (time + minorInterval < duration) {
              const minorPercent = ((time + minorInterval) / duration) * 100;
              html += `
                <div class="ruler-mark" style="left: ${minorPercent}%;">
                  <div class="ruler-mark-line minor"></div>
                </div>
              `;
            }
          }
        }
        
        rulerMarks.innerHTML = html;
        
        // Scale the ruler container
        const ruler = document.getElementById('timelineRuler');
        if (ruler) {
          ruler.style.width = `calc(100% - 108px)`;
          ruler.style.overflow = 'hidden';
          const rulerInner = rulerMarks;
          rulerInner.style.width = (100 * zoom) + '%';
        }
      },

      // ========== Web Audio API Scrubbing ==========
      
      // Initialize Web Audio context
      async initAudioContext() {
        if (!this.audioContext) {
          this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
          this.audioGain = this.audioContext.createGain();
          this.audioGain.connect(this.audioContext.destination);
        }
        // Resume if suspended (browser autoplay policy)
        if (this.audioContext.state === 'suspended') {
          await this.audioContext.resume();
        }
      },

      // Load audio for scrubbing - checks if already loaded by waveform generation
      async loadScrubAudio(videoPath) {
        // Skip if already loaded (waveform generation already decoded the audio)
        if (this.isAudioLoaded && this.audioBuffer) {
          console.log('[Scrub] Audio already loaded from waveform, skipping duplicate decode');
          return;
        }
        
        const video = document.getElementById('videoPlayer');
        if (!video || !video.src) return;
        
        try {
          console.log('[Scrub] Loading audio from video for Web Audio scrubbing...');
          
          // Initialize audio context
          await this.initAudioContext();
          
          // Fetch the video file and decode audio
          const response = await fetch(video.src);
          if (!response.ok) {
            throw new Error('Failed to fetch video: ' + response.status);
          }
          
          const arrayBuffer = await response.arrayBuffer();
          this.audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
          
          this.isAudioLoaded = true;
          console.log('[Scrub] Audio loaded! Duration:', this.audioBuffer.duration.toFixed(2), 's, Sample rate:', this.audioBuffer.sampleRate);
          this.showToast('success', 'Audio scrubbing ready');
        } catch (err) {
          console.error('[Scrub] Failed to load audio:', err);
          this.isAudioLoaded = false;
        }
      },

      // Play audio from a specific position using Web Audio API
      playScrubAudio(startTime, duration = 0.15, playbackRate = 1.0) {
        if (!this.audioBuffer || !this.audioContext) {
          console.log('[Scrub] playScrubAudio - No audio buffer or context:', {
            hasBuffer: !!this.audioBuffer,
            hasContext: !!this.audioContext
          });
          return;
        }
        
        // Resume context if suspended (browser autoplay policy)
        if (this.audioContext.state === 'suspended') {
          console.log('[Scrub] Resuming suspended audio context');
          this.audioContext.resume();
        }
        
        // Stop any currently playing scrub audio
        this.stopScrubAudio();
        
        try {
          // Create a new source node (they're one-shot, can't be reused)
          this.audioSource = this.audioContext.createBufferSource();
          this.audioSource.buffer = this.audioBuffer;
          this.audioSource.playbackRate.value = playbackRate;
          
          // Connect through gain node (ensure volume is up)
          this.audioGain.gain.value = 1.0;
          this.audioSource.connect(this.audioGain);
          
          // Clamp start time to valid range
          const safeStart = Math.max(0, Math.min(startTime, this.audioBuffer.duration - 0.01));
          const safeDuration = Math.min(duration, this.audioBuffer.duration - safeStart);
          
          console.log('[Scrub] Playing audio:', safeStart.toFixed(2) + 's', 'duration:', safeDuration.toFixed(2) + 's', 'context state:', this.audioContext.state);
          
          // Start playback from position
          this.audioSource.start(0, safeStart, safeDuration);
        } catch (err) {
          console.warn('[Scrub] Audio play error:', err);
        }
      },

      // Stop scrub audio
      stopScrubAudio() {
        if (this.audioSource) {
          try {
            this.audioSource.stop();
          } catch (e) {
            // Already stopped
          }
          this.audioSource = null;
        }
      },

      // Scroll wheel video scrubbing with Web Audio
      setupScrollScrub() {
        const videoContainer = document.getElementById('videoContainer');
        const timeline = document.getElementById('timeline');
        
        // Scrub state
        this.lastScrubTime = 0;
        this.scrubAccumulator = 0;

        const handleScroll = (e) => {
          if (!this.videoPath) return;

          const video = document.getElementById('videoPlayer');
          if (!video || !video.duration) return;

          e.preventDefault();
          
          // Initialize audio context on first interaction (browser policy)
          if (!this.audioContext) {
            this.initAudioContext();
          }

          // Calculate time step based on scroll intensity
          // Smaller = finer control, larger = faster scrubbing
          const scrollIntensity = Math.abs(e.deltaY);
          let timeStep = 0.05; // 50ms default step
          
          if (e.altKey) {
            timeStep = 0.02; // Fine: 20ms (hear individual sounds)
          } else if (e.shiftKey) {
            timeStep = 0.2; // Fast: 200ms
          } else if (scrollIntensity > 50) {
            timeStep = 0.1; // Faster scrolling = bigger steps
          }

          // Direction: negative deltaY = scroll up = forward
          const direction = e.deltaY < 0 ? 1 : -1;
          const newTime = Math.max(0, Math.min(video.duration, video.currentTime + (timeStep * direction)));
          
          // Update video position
          video.currentTime = newTime;
          this.updateTimeDisplay();
          
          // Update playhead position
          const percent = (newTime / video.duration) * 100;
          document.getElementById('playhead').style.left = `${percent}%`;

          // Play audio snippet at new position using Web Audio API
          if (this.isAudioLoaded) {
            // Use word-aligned if transcript available, otherwise fixed snippets
            if (this.transcriptSegments && this.transcriptSegments.length > 0) {
              this.playWordAtTime(newTime);
            } else {
              const snippetDuration = e.altKey ? 0.25 : 0.15;
              console.log('[Scrub] Playing snippet at', newTime.toFixed(2));
              this.playScrubAudio(newTime, snippetDuration, 1.0);
            }
          } else {
            console.log('[Scrub] Audio not loaded - isAudioLoaded:', this.isAudioLoaded);
          }
        };

        // Add scroll listeners to video and timeline
        if (videoContainer) {
          videoContainer.addEventListener('wheel', handleScroll, { passive: false });
        }
        if (timeline) {
          timeline.addEventListener('wheel', handleScroll, { passive: false });
        }
      },

      // Context Menu Setup
      setupContextMenu() {
        const menu = document.getElementById('contextMenu');
        
        // Hide menu on click outside
        document.addEventListener('click', () => this.hideContextMenu());
        document.addEventListener('contextmenu', (e) => this.handleContextMenu(e));
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
          // Escape closes context menu
          if (e.key === 'Escape') {
            this.hideContextMenu();
            return;
          }
          
          // Don't handle shortcuts when typing in inputs
          if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
          
          // Video playback shortcuts
          if (this.videoPath) {
            switch (e.key.toLowerCase()) {
              case ' ': // Space = Play/Pause
                e.preventDefault();
                this.togglePlay();
                break;
              case 'arrowleft':
                e.preventDefault();
                if (e.shiftKey) {
                  this.skipBack(); // 10s with shift
                } else {
                  const video = document.getElementById('videoPlayer');
                  video.currentTime = Math.max(0, video.currentTime - 1); // 1s without shift
                }
                break;
              case 'arrowright':
                e.preventDefault();
                if (e.shiftKey) {
                  this.skipForward(); // 10s with shift
                } else {
                  const video = document.getElementById('videoPlayer');
                  video.currentTime = Math.min(video.duration, video.currentTime + 1); // 1s without shift
                }
                break;
              case 'm': // Mute
                this.toggleMute();
                break;
              case 's': // Toggle audio scrubbing (without modifiers)
                if (!e.shiftKey && !e.ctrlKey && !e.metaKey) {
                  this.toggleAudioScrub();
                }
                break;
              case 'i': // Set trim IN point or Mark Range IN (with Shift)
                if (e.shiftKey) {
                  this.markRangeIn();
                } else {
                  this.setTrimStart();
                }
                break;
              case 'o': // Set trim OUT point or Mark Range OUT (with Shift)
                if (e.shiftKey) {
                  this.markRangeOut();
                } else {
                  this.setTrimEnd();
                }
                break;
              case '[': // Set splice IN
                this.setSpliceStart();
                break;
              case ']': // Set splice OUT
                this.setSpliceEnd();
                break;
              case 'n': // New marker
                this.addMarkerAtPlayhead();
                break;
              case ',': // Previous marker
                this.goToPrevMarker();
                break;
              case '.': // Next marker
                this.goToNextMarker();
                break;
              case 'j': // Slow down
                if (this.currentSpeed > 0.25) {
                  this.setSpeedPreset(Math.max(0.25, this.currentSpeed - 0.25));
                }
                break;
              case 'k': // Normal speed / pause
                if (e.shiftKey) {
                  this.setSpeedPreset(1);
                } else {
                  this.togglePlay();
                }
                break;
              case 'l': // Speed up
                if (this.currentSpeed < 4) {
                  this.setSpeedPreset(Math.min(4, this.currentSpeed + 0.25));
                }
                break;
              case 'home':
                e.preventDefault();
                document.getElementById('videoPlayer').currentTime = 0;
                break;
              case 'end':
                e.preventDefault();
                const vid = document.getElementById('videoPlayer');
                vid.currentTime = vid.duration;
                break;
            }
          }
          
          // Timeline zoom shortcuts (work without video too)
          switch (e.key) {
            case '=':
            case '+':
              e.preventDefault();
              this.zoomIn();
              break;
            case '-':
            case '_':
              e.preventDefault();
              this.zoomOut();
              break;
            case '0':
              e.preventDefault();
              this.fitToView();
              break;
          }
        });
      },

      // Context menu definitions for different areas
      getContextMenuItems(context) {
        const hasVideo = !!this.videoPath;
        const video = document.getElementById('videoPlayer');
        const isPlaying = video && !video.paused;
        const isMuted = video && video.muted;
        
        const menus = {
          // Video player context
          'video': [
            { type: 'header', label: 'Playback' },
            { icon: isPlaying ? '' : '', label: isPlaying ? 'Pause' : 'Play', action: 'togglePlay', disabled: !hasVideo },
            { icon: '', label: 'Skip Back 10s', action: 'skipBack', shortcut: '', disabled: !hasVideo },
            { icon: '', label: 'Skip Forward 10s', action: 'skipForward', shortcut: '', disabled: !hasVideo },
            { type: 'divider' },
            { icon: isMuted ? '' : '', label: isMuted ? 'Unmute' : 'Mute', action: 'toggleMute', shortcut: 'M', disabled: !hasVideo },
            { type: 'divider' },
            { type: 'header', label: 'Markers' },
            { icon: '', label: 'Set Trim Start Here', action: 'setTrimStart', shortcut: 'I', disabled: !hasVideo },
            { icon: '', label: 'Set Trim End Here', action: 'setTrimEnd', shortcut: 'O', disabled: !hasVideo },
            { icon: '', label: 'Set Splice IN Here', action: 'setSpliceStart', disabled: !hasVideo },
            { icon: '', label: 'Set Splice OUT Here', action: 'setSpliceEnd', disabled: !hasVideo },
            { type: 'divider' },
            { type: 'header', label: 'Quick Trim' },
            { icon: '', label: 'Trim Head (remove before here)', action: 'trimHead', disabled: !hasVideo },
            { icon: '', label: 'Trim Tail (remove after here)', action: 'trimTail', disabled: !hasVideo },
            { type: 'divider' },
            { type: 'header', label: 'Markers' },
            { icon: '', label: 'Add Marker Here', action: 'addMarker', shortcut: 'N', disabled: !hasVideo },
            { icon: '', label: 'Previous Marker', action: 'prevMarker', shortcut: ',', disabled: !hasVideo || this.markers.length === 0 },
            { icon: '', label: 'Next Marker', action: 'nextMarker', shortcut: '.', disabled: !hasVideo || this.markers.length === 0 },
            { type: 'divider' },
            { icon: '', label: 'Capture Frame', action: 'captureFrame', disabled: !hasVideo },
          ],
          
          // Timeline context
          'timeline': [
            { type: 'header', label: 'Timeline' },
            { icon: '', label: 'Set Trim Start', action: 'setTrimStart', shortcut: 'I', disabled: !hasVideo },
            { icon: '', label: 'Set Trim End', action: 'setTrimEnd', shortcut: 'O', disabled: !hasVideo },
            { type: 'divider' },
            { icon: '', label: 'Set Splice IN', action: 'setSpliceStart', disabled: !hasVideo },
            { icon: '', label: 'Set Splice OUT', action: 'setSpliceEnd', disabled: !hasVideo },
            { type: 'divider' },
            { icon: '', label: 'Reset Trim Points', action: 'resetTrim', disabled: !hasVideo },
            { type: 'divider' },
            { type: 'header', label: 'Zoom' },
            { icon: '', label: 'Zoom In', action: 'zoomIn', shortcut: '+' },
            { icon: '', label: 'Zoom Out', action: 'zoomOut', shortcut: '-' },
            { icon: '', label: 'Fit to View', action: 'fitToView', shortcut: '0' },
          ],
          
          // Audio track context
          'audio': [
            { type: 'header', label: 'Audio Track' },
            { icon: this.audioMuted ? '' : '', label: this.audioMuted ? 'Unmute Audio' : 'Mute Audio', action: 'toggleAudioMute', disabled: !hasVideo },
            { icon: '', label: 'Detach Audio Track', action: 'detachAudio', disabled: !hasVideo || this.audioDetached },
            { icon: '', label: 'Extract Audio to MP3', action: 'extractAudio', disabled: !hasVideo },
            { type: 'divider' },
            { icon: '', label: 'Normalize Volume', action: 'normalizeAudio', disabled: !hasVideo },
          ],
          
          // Export item context
          'export': [
            { icon: '', label: 'Load in Editor', action: 'loadExport' },
            { icon: '', label: 'Show in Finder', action: 'revealExport' },
            { type: 'divider' },
            { icon: '', label: 'Delete', action: 'deleteExport', danger: true },
          ],
          
          // Default/generic context
          'default': [
            { icon: '', label: 'Open Video...', action: 'openFile' },
            { icon: '', label: 'Export...', action: 'showExportOptions', disabled: !hasVideo },
            { type: 'divider' },
            { icon: '', label: 'Settings', action: 'openSettings' },
          ]
        };
        
        return menus[context] || menus['default'];
      },

      handleContextMenu(e) {
        // Determine context based on clicked element
        const target = e.target;
        let context = 'default';
        let contextData = null;
        
        // Check what was clicked
        if (target.closest('#videoPlayer') || target.closest('#videoContainer')) {
          context = 'video';
        } else if (target.closest('#timelineTrack') || target.closest('.timeline-track')) {
          context = 'timeline';
          // Get click position for timeline-specific actions
          const track = target.closest('#timelineTrack') || target.closest('.timeline-track');
          if (track) {
            const rect = track.getBoundingClientRect();
            const percent = (e.clientX - rect.left) / rect.width;
            const video = document.getElementById('videoPlayer');
            if (video && video.duration) {
              contextData = { time: percent * video.duration };
            }
          }
        } else if (target.closest('#audioTrack') || target.closest('.audio-track')) {
          context = 'audio';
        } else if (target.closest('.export-item')) {
          context = 'export';
          contextData = { path: target.closest('.export-item').dataset?.path };
        }
        
        // Store context data for actions
        this.contextData = contextData;
        
        // Show the appropriate menu
        this.showContextMenu(e.clientX, e.clientY, context);
        e.preventDefault();
      },

      showContextMenu(x, y, context) {
        const menu = document.getElementById('contextMenu');
        const menuItems = document.getElementById('contextMenuItems');
        const items = this.getContextMenuItems(context);
        
        // Build menu HTML
        let html = '';
        for (const item of items) {
          if (item.type === 'divider') {
            html += '<div class="context-menu-divider"></div>';
          } else if (item.type === 'header') {
            html += `<div class="context-menu-header">${item.label}</div>`;
          } else {
            const disabledClass = item.disabled ? 'disabled' : '';
            const dangerClass = item.danger ? 'danger' : '';
            html += `
              <div class="context-menu-item ${disabledClass} ${dangerClass}" data-action="${item.action}">
                <span class="context-menu-item-icon">${item.icon}</span>
                <span class="context-menu-item-label">${item.label}</span>
                ${item.shortcut ? `<span class="context-menu-item-shortcut">${item.shortcut}</span>` : ''}
              </div>
            `;
          }
        }
        
        menuItems.innerHTML = html;
        
        // Add click handlers
        menuItems.querySelectorAll('.context-menu-item').forEach(item => {
          item.addEventListener('click', (e) => {
            const action = item.dataset.action;
            if (action && !item.classList.contains('disabled')) {
              this.executeContextAction(action);
            }
            this.hideContextMenu();
          });
        });
        
        // Position menu
        menu.style.left = `${x}px`;
        menu.style.top = `${y}px`;
        menu.classList.add('visible');
        
        // Adjust if menu goes off screen
        requestAnimationFrame(() => {
          const rect = menu.getBoundingClientRect();
          if (rect.right > window.innerWidth) {
            menu.style.left = `${x - rect.width}px`;
          }
          if (rect.bottom > window.innerHeight) {
            menu.style.top = `${y - rect.height}px`;
          }
        });
      },

      hideContextMenu() {
        document.getElementById('contextMenu').classList.remove('visible');
      },

      executeContextAction(action) {
        const actions = {
          'togglePlay': () => this.togglePlay(),
          'skipBack': () => this.skipBack(),
          'skipForward': () => this.skipForward(),
          'toggleMute': () => this.toggleMute(),
          'setTrimStart': () => this.setTrimStart(),
          'setTrimEnd': () => this.setTrimEnd(),
          'setSpliceStart': () => this.setSpliceStart(),
          'setSpliceEnd': () => this.setSpliceEnd(),
          'resetTrim': () => this.resetTrimPoints(),
          'toggleAudioMute': () => this.toggleAudioMute(),
          'detachAudio': () => this.detachAudio(),
          'extractAudio': () => this.extractAudio(),
          'normalizeAudio': () => this.showToast('info', 'Audio normalization coming soon'),
          'captureFrame': () => this.captureCurrentFrame(),
          'openFile': () => this.openFile(),
          'showExportOptions': () => this.showExportOptions(),
          'openSettings': () => this.showToast('info', 'Settings coming soon'),
          'zoomIn': () => this.zoomIn(),
          'zoomOut': () => this.zoomOut(),
          'fitToView': () => this.fitToView(),
          'addMarker': () => this.addMarkerAtPlayhead(),
          'prevMarker': () => this.goToPrevMarker(),
          'nextMarker': () => this.goToNextMarker(),
          'trimHead': () => this.trimHeadAtPlayhead(),
          'trimTail': () => this.trimTailAtPlayhead(),
          'loadExport': () => {
            if (this.contextData?.path) this.loadVideo(this.contextData.path);
          },
          'revealExport': () => {
            if (this.contextData?.path) this.revealFile(this.contextData.path);
          },
          'deleteExport': () => {
            if (this.contextData?.path) this.showToast('info', 'Delete feature coming soon');
          },
        };
        
        if (actions[action]) {
          actions[action]();
        }
      },

      // Reset trim points
      resetTrimPoints() {
        const video = document.getElementById('videoPlayer');
        this.trimStart = 0;
        this.trimEnd = 0;
        this.trimActive = false;
        document.getElementById('trimStart').value = '00:00:00';
        document.getElementById('trimEnd').value = '00:00:00';
        this.updateTrimRegion();
        this.showToast('success', 'Trim region cleared');
      },

      // Trim head - remove everything before current playhead
      async trimHeadAtPlayhead() {
        if (!this.videoPath) return;
        
        const video = document.getElementById('videoPlayer');
        const currentTime = video.currentTime;
        
        if (currentTime < 0.5) {
          this.showToast('warning', 'Playhead is at the start - nothing to trim');
          return;
        }
        
        const duration = video.duration;
        const removeTime = currentTime;
        
        if (!confirm(`Trim HEAD: Remove ${this.formatTime(removeTime)} from the beginning?\n\nThis will create a new video starting at ${this.formatTime(currentTime)}.`)) {
          return;
        }
        
        this.showProgress('Trimming Head...', `Removing first ${this.formatTime(removeTime)}`);
        
        try {
          const result = await window.videoEditor.trim(this.videoPath, {
            startTime: currentTime,
            endTime: duration
          });
          
          this.hideProgress();
          
          if (result.error) {
            throw new Error(result.error);
          }
          
          this.showToast('success', `Trimmed ${this.formatTime(removeTime)} from head!`);
          this.loadExports();
        } catch (error) {
          this.hideProgress();
          this.showToast('error', 'Trim failed: ' + error.message);
        }
      },

      // Trim tail - remove everything after current playhead
      async trimTailAtPlayhead() {
        if (!this.videoPath) return;
        
        const video = document.getElementById('videoPlayer');
        const currentTime = video.currentTime;
        const duration = video.duration;
        
        if (currentTime > duration - 0.5) {
          this.showToast('warning', 'Playhead is at the end - nothing to trim');
          return;
        }
        
        const removeTime = duration - currentTime;
        
        if (!confirm(`Trim TAIL: Remove ${this.formatTime(removeTime)} from the end?\n\nThis will create a new video ending at ${this.formatTime(currentTime)}.`)) {
          return;
        }
        
        this.showProgress('Trimming Tail...', `Removing last ${this.formatTime(removeTime)}`);
        
        try {
          const result = await window.videoEditor.trim(this.videoPath, {
            startTime: 0,
            endTime: currentTime
          });
          
          this.hideProgress();
          
          if (result.error) {
            throw new Error(result.error);
          }
          
          this.showToast('success', `Trimmed ${this.formatTime(removeTime)} from tail!`);
          this.loadExports();
        } catch (error) {
          this.hideProgress();
          this.showToast('error', 'Trim failed: ' + error.message);
        }
      },

      // Capture current frame as image
      async captureCurrentFrame() {
        if (!this.videoPath) return;
        
        const video = document.getElementById('videoPlayer');
        const timestamp = this.formatTime(video.currentTime);
        
        try {
          const result = await window.videoEditor.generateThumbnail(this.videoPath, timestamp);
          if (result && !result.error) {
            this.showToast('success', 'Frame captured!');
          } else {
            throw new Error(result?.error || 'Failed to capture');
          }
        } catch (error) {
          this.showToast('error', 'Failed to capture frame: ' + error.message);
        }
      },

      // Open file dialog
      async openFile() {
        try {
          const result = await window.videoEditor.openFile();
          if (result && result.filePaths && result.filePaths.length > 0) {
            // Clear space tracking when opening a file directly
            this.spaceItemId = null;
            this.spaceItemName = null;
            this.transcriptSegments = null; // Clear transcript data
            this.updateSaveToSpaceButton();

            this.loadVideo(result.filePaths[0]);
          }
        } catch (error) {
          console.error('Error opening file:', error);
          this.showToast('error', 'Failed to open file');
        }
      },

      // Load video
      async loadVideo(filePath) {
        this.videoPath = filePath;
        
        // Clear waveform cache for new video
        this.clearWaveformCache();

        // Show loading
        document.getElementById('fileName').textContent = 'Loading...';
        
        try {
          // Get video info
          this.videoInfo = await window.videoEditor.getInfo(filePath);
          
          if (this.videoInfo.error) {
            throw new Error(this.videoInfo.error);
          }

          // Update UI
          const fileName = filePath.split('/').pop();
          document.getElementById('fileName').textContent = fileName;
          
          // Load video player
          const video = document.getElementById('videoPlayer');
          video.src = `file://${filePath}`;
          
          // Show video player, hide placeholder
          document.getElementById('videoPlaceholder').classList.add('hidden');
          video.classList.remove('hidden');
          document.getElementById('videoControls').classList.remove('hidden');
          document.getElementById('timeline').classList.remove('hidden');
          
          // Enable buttons
          document.getElementById('exportBtn').disabled = false;
          document.getElementById('trimBtn').disabled = false;
          document.getElementById('transcodeBtn').disabled = false;
          document.getElementById('extractAudioBtn').disabled = false;
          document.getElementById('compressBtn').disabled = false;
          document.getElementById('thumbnailBtn').disabled = false;
          document.getElementById('transcribeBtn').disabled = false;
          document.getElementById('applySpeedBtn').disabled = false;
          document.getElementById('reverseBtn').disabled = false;
          document.getElementById('spliceBtn').disabled = false;
          document.getElementById('setSpliceStartBtn').disabled = false;
          document.getElementById('setSpliceEndBtn').disabled = false;
          document.getElementById('addMarkerBtn').disabled = false;
          document.getElementById('prevMarkerBtn').disabled = false;
          document.getElementById('nextMarkerBtn').disabled = false;
          document.getElementById('markInBtn').disabled = false;
          document.getElementById('markOutBtn').disabled = false;
          
          // Reset splice
          document.getElementById('spliceStart').value = '00:00:00';
          document.getElementById('spliceEnd').value = '00:00:00';
          document.getElementById('splicePreview').style.display = 'none';
          this.spliceStart = 0;
          this.spliceEnd = 0;
          
          // Reset speed to 1x
          this.currentSpeed = 1.0;
          document.getElementById('speedSlider').value = 1;
          document.getElementById('speedValue').textContent = '1.00';
          document.querySelectorAll('.speed-btn').forEach(btn => {
            btn.classList.toggle('active', parseFloat(btn.dataset.speed) === 1);
          });
          
          // Update video info panel
          this.displayVideoInfo();
          
          // Generate timeline thumbnails
          this.loadTimelineThumbnails();
          
          // Update timeline ruler and reset zoom
          this.fitToView();
          this.updateTimelineRuler();
          
          // Only clear markers if NOT loading from a Space (Space scenes are set before loadVideo is called)
          if (!this.spaceItemId) {
            // Clear markers for new video (not from Space)
            this.markers = [];
            this.pendingRangeMarker = null;
            this.sceneThumbnails = {}; // Clear scene thumbnails cache
            document.getElementById('pendingRangeIndicator').classList.add('hidden');
            this.renderMarkers();
          } else {
            // Preserve Space scenes but clear pending marker
            this.pendingRangeMarker = null;
            document.getElementById('pendingRangeIndicator').classList.add('hidden');
            // Re-render markers after video is ready to ensure proper positioning
            this.renderMarkers();
          }
          
          this.showToast('success', 'Video loaded successfully');
          
          // Extract audio for Web Audio scrubbing (in background)
          this.loadScrubAudio(filePath);
        } catch (error) {
          console.error('Error loading video:', error);
          document.getElementById('fileName').textContent = 'Error loading video';
          this.showToast('error', 'Failed to load video: ' + error.message);
        }
      },

      // On video loaded
      async onVideoLoaded() {
        const video = document.getElementById('videoPlayer');
        // Don't set trim region by default - keep it hidden
        this.trimStart = 0;
        this.trimEnd = 0; // 0 means no active trim
        this.trimActive = false;

        document.getElementById('trimStart').value = '00:00:00';
        document.getElementById('trimEnd').value = '00:00:00';
        document.getElementById('duration').textContent = this.formatTime(video.duration);
        document.getElementById('timelineEnd').textContent = this.formatTime(video.duration);

        this.updateTrimRegion();
        
        // Create project if not exists
        if (!this.currentProject && this.videoPath) {
          await this.createProject(this.videoPath, this.selectedSpace);
        }

        // Reset audio state
        this.audioDetached = false;
        this.audioMuted = false;
        document.getElementById('audioTrack').classList.remove('detached');
        document.getElementById('detachAudioBtn').disabled = false;
        document.getElementById('detachAudioBtn').style.opacity = '1';
        document.getElementById('audioMuteBtn').textContent = '';
        document.getElementById('audioMuteBtn').classList.remove('muted');
        
        // Create approximate transcript segments if we have pending text
        // Now we have the correct video duration
        if (this.pendingTranscriptText && video.duration > 0) {
          console.log('[VideoEditor] Creating transcript segments with duration:', video.duration.toFixed(2) + 's');
          const words = this.pendingTranscriptText.split(/\s+/).filter(w => w.length > 0);
          const wordDuration = video.duration / words.length;
          
          this.transcriptSegments = words.map((word, i) => ({
            text: word,
            start: i * wordDuration,
            end: (i + 1) * wordDuration
          }));
          
          console.log('[VideoEditor] Created', this.transcriptSegments.length, 'segments,', 
                      (wordDuration * 1000).toFixed(0) + 'ms per word');
          
          // Clear pending text
          this.pendingTranscriptText = null;
          
          // Initialize teleprompter if visible
          if (this.teleprompterVisible) {
            this.initTeleprompter();
          }
        }

        // Generate audio waveform
        setTimeout(() => this.generateAudioWaveform(), 100);
      },

      // Display video info
      displayVideoInfo() {
        if (!this.videoInfo) return;
        
        const infoSection = document.getElementById('videoInfoSection');
        const infoGrid = document.getElementById('videoInfo');
        
        const info = this.videoInfo;
        let html = '';
        
        html += this.createInfoItem('Duration', info.durationFormatted);
        html += this.createInfoItem('Size', this.formatBytes(info.size));
        
        if (info.video) {
          html += this.createInfoItem('Resolution', `${info.video.width}${info.video.height}`);
          html += this.createInfoItem('Codec', info.video.codec);
          html += this.createInfoItem('FPS', Math.round(info.video.fps));
        }
        
        if (info.audio) {
          html += this.createInfoItem('Audio', `${info.audio.codec} ${info.audio.channels}ch`);
        }
        
        infoGrid.innerHTML = html;
        infoSection.style.display = 'block';
      },

      createInfoItem(label, value) {
        return `<div class="info-item"><span class="info-label">${label}</span><span class="info-value">${value}</span></div>`;
      },

      // Load timeline thumbnails
      async loadTimelineThumbnails() {
        if (!this.videoPath) return;
        
        const container = document.getElementById('timelineThumbnails');
        const scrollWrapper = document.getElementById('timelineScrollWrapper');
        if (!container || !scrollWrapper) return;
        
        try {
          // Show loading state
          container.classList.add('loading');
          
          // Calculate optimal thumbnail count based on timeline width and zoom
          // Base width available for thumbnails
          const baseWidth = scrollWrapper.clientWidth - 108; // Subtract track label width
          const zoomedWidth = baseWidth * this.timelineZoom;
          
          // Fixed thumbnail width for consistent appearance (80px is a good balance)
          const thumbWidth = 80;
          
          // Calculate how many thumbnails we need to fill the zoomed width
          // Minimum 5, maximum 50 for performance
          const optimalCount = Math.min(50, Math.max(5, Math.ceil(zoomedWidth / thumbWidth)));
          
          // Store the current count to check if we need new thumbnails
          const currentCount = container.querySelectorAll('.timeline-thumb').length;
          
          // Only regenerate if count changed significantly (more than 20% difference)
          if (currentCount > 0 && Math.abs(optimalCount - currentCount) / currentCount < 0.2) {
            container.classList.remove('loading');
            return;
          }
          
          const thumbnails = await window.videoEditor.getTimelineThumbnails(this.videoPath, { count: optimalCount });
          
          if (thumbnails && !thumbnails.error) {
            // Use flex-grow to distribute thumbnails evenly while maintaining aspect ratio
            container.innerHTML = thumbnails.map(thumb => 
              `<img src="file://${thumb}" class="timeline-thumb" style="flex: 1 1 ${thumbWidth}px;">`
            ).join('');
          }
        } catch (error) {
          console.error('Error loading timeline thumbnails:', error);
        } finally {
          container.classList.remove('loading');
        }
      },

      // Update time display
      updateTimeDisplay() {
        const video = document.getElementById('videoPlayer');
        const currentTime = video.currentTime;
        const duration = video.duration || 0;
        
        document.getElementById('currentTime').textContent = this.formatTime(currentTime);
        
        // Update playhead position
        const percent = (currentTime / duration) * 100;
        document.getElementById('playhead').style.left = `${percent}%`;
        document.getElementById('timelineProgress').style.width = `${percent}%`;
      },

      // Update trim region visualization
      updateTrimRegion() {
        const video = document.getElementById('videoPlayer');
        const duration = video.duration || this.videoInfo?.duration || 0;

        const region = document.getElementById('trimRegion');
        const startMarker = document.getElementById('trimMarkerStart');
        const endMarker = document.getElementById('trimMarkerEnd');
        
        // Update selected region and show action bar
        this.updateSelectedRegion();
        
        // Hide trim region if not active (trimEnd is 0 or equals duration with trimStart at 0)
        const noTrim = !this.trimActive || this.trimEnd === 0 || (this.trimStart === 0 && this.trimEnd >= duration);
        
        if (noTrim || duration === 0) {
          region.style.display = 'none';
          startMarker.style.display = 'none';
          endMarker.style.display = 'none';
          return;
        }
        
        region.style.display = 'block';
        startMarker.style.display = 'block';
        endMarker.style.display = 'block';
        
        const startPercent = (this.trimStart / duration) * 100;
        const endPercent = (this.trimEnd / duration) * 100;
        
        region.style.left = `${startPercent}%`;
        region.style.width = `${endPercent - startPercent}%`;
        startMarker.style.left = `${startPercent}%`;
        endMarker.style.left = `${endPercent}%`;
      },

      // Playback controls
      togglePlay() {
        const video = document.getElementById('videoPlayer');
        if (video.paused) {
          video.play();
        } else {
          video.pause();
        }
      },

      skipBack() {
        const video = document.getElementById('videoPlayer');
        video.currentTime = Math.max(0, video.currentTime - 10);
      },

      skipForward() {
        const video = document.getElementById('videoPlayer');
        video.currentTime = Math.min(video.duration, video.currentTime + 10);
      },

      toggleMute() {
        const video = document.getElementById('videoPlayer');
        video.muted = !video.muted;
        this.updateMuteIcon();
      },

      updateMuteIcon() {
        const video = document.getElementById('videoPlayer');
        const muteBtn = document.getElementById('muteBtn');
        if (video.muted || video.volume === 0) {
          muteBtn.textContent = '';
        } else if (video.volume < 0.5) {
          muteBtn.textContent = '';
        } else {
          muteBtn.textContent = '';
        }
      },

      // ============================================
      // AUDIO WAVEFORM - Web Audio API + ffmpeg.wasm
      // ============================================
      
      // Cache for waveform data to avoid regenerating
      waveformCache: null,
      waveformCachePath: null,
      audioContext: null,
      
      async generateAudioWaveform() {
        if (!this.videoPath) return;
        
        const canvas = document.getElementById('audioWaveform');
        const ctx = canvas.getContext('2d');
        
        // Set canvas size for retina
        canvas.width = canvas.offsetWidth * 2;
        canvas.height = canvas.offsetHeight * 2;
        ctx.scale(2, 2);
        
        const width = canvas.offsetWidth;
        const height = canvas.offsetHeight;
        const duration = this.videoInfo?.duration || 0;
        const numSamples = Math.floor(width / 4); // One bar per 4 pixels
        
        // Show loading state
        this.drawWaveformLoading(ctx, width, height, 'Analyzing audio...');
        
        try {
          let peaks = null;
          let method = 'unknown';
          
          // Check cache first
          if (this.waveformCache && this.waveformCachePath === this.videoPath) {
            peaks = this.waveformCache;
            method = 'cached';
            console.log('[Waveform] Using cached data');
          } else {
            // Try Web Audio API (primary method - fast & accurate)
            try {
              peaks = await this.extractAudioPeaksWebAudio(numSamples);
              method = 'webaudio';
              console.log('[Waveform] Web Audio API success:', peaks.length, 'samples');
            } catch (e) {
              console.warn('[Waveform] Web Audio failed:', e.message);
              
              // Fallback: Try extracting audio from video element directly
              try {
                peaks = await this.extractAudioPeaksFromVideo(numSamples);
                method = 'video-element';
                console.log('[Waveform] Video element extraction success');
              } catch (e2) {
                console.warn('[Waveform] Video element failed:', e2.message);
                
                // Final fallback: Backend FFmpeg
                const result = await window.videoEditor.getWaveform(this.videoPath, { samples: numSamples });
                if (result.error) throw new Error(result.error);
                peaks = result.peaks || [];
                method = 'ffmpeg';
              }
            }
            
            // Cache the result
            this.waveformCache = peaks;
            this.waveformCachePath = this.videoPath;
          }
          
          // Draw the waveform
          this.drawWaveform(ctx, width, height, peaks, duration, method);
          
        } catch (error) {
          console.error('[Waveform] All methods failed:', error);
          this.drawWaveformError(ctx, width, height, 'Could not analyze audio');
        }
      },
      
      // Extract audio peaks using Web Audio API
      // Also stores the AudioBuffer for scrubbing (share decode, don't decode twice!)
      async extractAudioPeaksWebAudio(numSamples) {
        const video = document.getElementById('videoPlayer');
        if (!video?.src) throw new Error('No video source');
        
        // Initialize shared audio context if needed
        await this.initAudioContext();
        
        try {
          // Fetch and decode the audio
          const response = await fetch(video.src);
          if (!response.ok) throw new Error('Fetch failed');
          
          const arrayBuffer = await response.arrayBuffer();
          const decodedBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
          
          console.log('[Waveform] Decoded audio:', {
            duration: decodedBuffer.duration.toFixed(2) + 's',
            sampleRate: decodedBuffer.sampleRate,
            channels: decodedBuffer.numberOfChannels
          });
          
          // IMPORTANT: Store for scrubbing - no need to decode again!
          this.audioBuffer = decodedBuffer;
          this.isAudioLoaded = true;
          console.log('[Scrub] Audio buffer shared from waveform decode');
          this.showToast('success', 'Audio scrubbing ready');
          
          // Get channel data (mono mix if stereo)
          let channelData;
          if (decodedBuffer.numberOfChannels === 1) {
            channelData = decodedBuffer.getChannelData(0);
          } else {
            // Mix stereo to mono
            const left = decodedBuffer.getChannelData(0);
            const right = decodedBuffer.getChannelData(1);
            channelData = new Float32Array(left.length);
            for (let i = 0; i < left.length; i++) {
              channelData[i] = (left[i] + right[i]) / 2;
            }
          }
          
          // Calculate peaks
          return this.calculatePeaks(channelData, numSamples);
          
        } catch (err) {
          console.error('[Waveform] Decode failed:', err);
          throw err;
        }
      },
      
      // Extract audio peaks directly from video element using MediaElementSourceNode
      async extractAudioPeaksFromVideo(numSamples) {
        const video = document.getElementById('videoPlayer');
        if (!video) throw new Error('No video element');
        
        return new Promise((resolve, reject) => {
          const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          const analyser = audioCtx.createAnalyser();
          analyser.fftSize = 2048;
          
          try {
            const source = audioCtx.createMediaElementSource(video);
            source.connect(analyser);
            analyser.connect(audioCtx.destination);
            
            const peaks = [];
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            
            const duration = video.duration;
            const interval = duration / numSamples;
            let currentSample = 0;
            
            const collectSample = () => {
              if (currentSample >= numSamples) {
                source.disconnect();
                audioCtx.close();
                resolve(peaks);
                return;
              }
              
              analyser.getByteTimeDomainData(dataArray);
              
              // Calculate peak from waveform data
              let max = 0;
              for (let i = 0; i < bufferLength; i++) {
                const val = Math.abs(dataArray[i] - 128) / 128;
                if (val > max) max = val;
              }
              
              peaks.push(max);
              currentSample++;
              
              video.currentTime = currentSample * interval;
            };
            
            video.addEventListener('seeked', collectSample, { once: false });
            video.currentTime = 0;
            
          } catch (e) {
            audioCtx.close();
            reject(e);
          }
        });
      },
      
      // Calculate peaks from raw audio data
      calculatePeaks(channelData, numSamples) {
        const samplesPerPeak = Math.floor(channelData.length / numSamples);
        const peaks = [];
        
        for (let i = 0; i < numSamples; i++) {
          const start = i * samplesPerPeak;
          const end = Math.min(start + samplesPerPeak, channelData.length);
          
          // Calculate RMS and peak
          let sum = 0;
          let max = 0;
          for (let j = start; j < end; j++) {
            const abs = Math.abs(channelData[j]);
            sum += abs * abs;
            if (abs > max) max = abs;
          }
          
          const rms = Math.sqrt(sum / (end - start));
          // Blend RMS (smoother) with peak (accurate) for natural look
          const blended = (rms * 0.6) + (max * 0.4);
          peaks.push(Math.min(1, blended * 1.8)); // Boost for visibility
        }
        
        return peaks;
      },
      
      // Draw the waveform visualization
      drawWaveform(ctx, width, height, peaks, duration, method) {
        ctx.clearRect(0, 0, width, height);
        
        const barWidth = 3;
        const gap = 1;
        const totalBarWidth = barWidth + gap;
        const numBars = Math.min(peaks.length, Math.floor(width / totalBarWidth));
        
        // Purple gradient
        const gradient = ctx.createLinearGradient(0, 0, 0, height);
        gradient.addColorStop(0, 'rgba(139, 92, 246, 0.9)');
        gradient.addColorStop(0.5, 'rgba(99, 102, 241, 0.85)');
        gradient.addColorStop(1, 'rgba(139, 92, 246, 0.9)');
        ctx.fillStyle = gradient;
        
        // Draw mirrored waveform bars
        for (let i = 0; i < numBars; i++) {
          const peakIndex = Math.floor(i * peaks.length / numBars);
          const peakValue = peaks[peakIndex] || 0;
          const barHeight = Math.max(2, peakValue * height * 0.85);
          const x = i * totalBarWidth;
          const y = (height - barHeight) / 2;
          
          ctx.beginPath();
          ctx.roundRect(x, y, barWidth, barHeight, 1);
          ctx.fill();
        }
        
        // Center line
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(0, height / 2);
        ctx.lineTo(width, height / 2);
        ctx.stroke();
        
        // Draw transcript words if available
        if (this.transcriptSegments?.length > 0 && duration > 0) {
          this.drawTranscriptOnWaveform(ctx, width, height, duration);
        }
        
        // Status indicator
        let statusText = '';
        if (this.transcriptSegments?.length > 0) {
          statusText = ` ${this.transcriptSegments.length} words`;
        } else {
          const methodLabels = {
            'webaudio': ' Web Audio',
            'video-element': ' Live',
            'cached': ' Cached',
            'ffmpeg': ' FFmpeg'
          };
          statusText = methodLabels[method] || '';
        }
        
        if (statusText) {
          ctx.fillStyle = 'rgba(16, 185, 129, 0.9)';
          ctx.font = 'bold 9px sans-serif';
          ctx.textAlign = 'right';
          ctx.fillText(statusText, width - 8, 12);
        }
      },
      
      // Draw loading state
      drawWaveformLoading(ctx, width, height, message) {
        ctx.clearRect(0, 0, width, height);
        ctx.fillStyle = 'rgba(99, 102, 241, 0.3)';
        ctx.fillRect(0, height * 0.4, width, height * 0.2);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
        ctx.font = '11px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(message, width / 2, height / 2 + 4);
      },
      
      // Draw error state
      drawWaveformError(ctx, width, height, message) {
        ctx.clearRect(0, 0, width, height);
        ctx.fillStyle = 'rgba(239, 68, 68, 0.3)';
        ctx.fillRect(0, height * 0.35, width, height * 0.3);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
        ctx.font = '11px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(message, width / 2, height / 2 + 4);
      },
      
      // Clear waveform cache (call when loading new video)
      clearWaveformCache() {
        this.waveformCache = null;
        this.waveformCachePath = null;
      },
      
      // Draw transcript words on the waveform
      drawTranscriptOnWaveform(ctx, width, height, duration) {
        if (!this.transcriptSegments || this.transcriptSegments.length === 0) return;
        
        ctx.save();
        
        // First, expand sentence segments into individual words if needed
        const words = this.expandTranscriptToWords(this.transcriptSegments);
        
        console.log('[VideoEditor] Drawing', words.length, 'words on waveform');
        
        // Settings for word display
        ctx.font = 'bold 10px system-ui, -apple-system, sans-serif';
        ctx.textBaseline = 'middle';
        
        // Track last word end to prevent overlap
        let lastWordEndX = -100;
        const minGap = 4; // Minimum pixels between words
        
        // Draw each word
        words.forEach((wordData, index) => {
          const startTime = wordData.start || 0;
          const endTime = wordData.end || (startTime + 0.3);
          const text = (wordData.text || '').trim();
          
          if (!text || text.length === 0) return;
          
          // Calculate position on the waveform
          const startX = (startTime / duration) * width;
          const endX = (endTime / duration) * width;
          const segmentWidth = Math.max(endX - startX, 20);
          
          // Skip if would overlap with previous word
          if (startX < lastWordEndX + minGap) return;
          
          // Measure text
          const textWidth = ctx.measureText(text).width;
          
          // Draw background pill for readability
          const padding = 4;
          const pillWidth = textWidth + padding * 2;
          const pillHeight = 14;
          const pillX = startX;
          const pillY = height - pillHeight - 3;
          
          // Alternate colors for visual rhythm
          const colors = [
            'rgba(99, 102, 241, 0.9)',   // indigo
            'rgba(139, 92, 246, 0.9)',   // purple
            'rgba(79, 70, 229, 0.9)',    // violet
          ];
          ctx.fillStyle = colors[index % colors.length];
          
          // Draw pill background
          ctx.beginPath();
          ctx.roundRect(pillX, pillY, pillWidth, pillHeight, 4);
          ctx.fill();
          
          // Draw the word text
          ctx.fillStyle = 'rgba(255, 255, 255, 1)';
          ctx.textAlign = 'left';
          ctx.fillText(text, pillX + padding, pillY + pillHeight / 2 + 1);
          
          // Update last word position
          lastWordEndX = pillX + pillWidth;
        });
        
        ctx.restore();
      },
      
      // Expand transcript segments into individual words with timing
      expandTranscriptToWords(segments) {
        const words = [];
        
        segments.forEach(segment => {
          const text = (segment.text || segment.word || '').trim();
          const startTime = segment.start || 0;
          const endTime = segment.end || (startTime + 1);
          
          // If this is already a single word (no spaces), use it directly
          if (!text.includes(' ')) {
            if (text.length > 0) {
              words.push({
                text: text,
                start: startTime,
                end: endTime
              });
            }
            return;
          }
          
          // Split sentence into words and distribute timing
          const segmentWords = text.split(/\s+/).filter(w => w.length > 0);
          const segmentDuration = endTime - startTime;
          const wordDuration = segmentDuration / segmentWords.length;
          
          segmentWords.forEach((word, i) => {
            words.push({
              text: word,
              start: startTime + (i * wordDuration),
              end: startTime + ((i + 1) * wordDuration)
            });
          });
        });
        
        return words;
      },

      // ============================================
      // TELEPROMPTER - Live transcript display
      // ============================================
      
      teleprompterVisible: false,
      teleprompterExpanded: false,
      teleprompterWords: [], // Cached expanded words with timing
      
      // Toggle teleprompter visibility
      toggleTeleprompter() {
        this.teleprompterVisible = !this.teleprompterVisible;
        const container = document.getElementById('teleprompterContainer');
        const toggleBtn = document.getElementById('teleprompterToggleBtn');
        
        if (this.teleprompterVisible) {
          container.classList.remove('hidden');
          toggleBtn?.classList.add('active');
          this.initTeleprompter();
        } else {
          container.classList.add('hidden');
          toggleBtn?.classList.remove('active');
        }
      },
      
      // Toggle teleprompter size
      toggleTeleprompterSize() {
        this.teleprompterExpanded = !this.teleprompterExpanded;
        const container = document.getElementById('teleprompterContainer');
        container.classList.toggle('expanded', this.teleprompterExpanded);
      },
      
      // Initialize teleprompter with transcript data
      initTeleprompter() {
        const wordsContainer = document.getElementById('teleprompterWords');
        
        // Check if we have transcript segments
        if (!this.transcriptSegments || this.transcriptSegments.length === 0) {
          wordsContainer.innerHTML = `
            <div class="teleprompter-empty">
              <p>No transcript available</p>
              <p style="font-size: 11px; margin-top: 4px; opacity: 0.7;">Load a video from Spaces with transcription, or transcribe markers</p>
              <button onclick="app.transcribeFullVideoForTeleprompter()"> Transcribe Video</button>
            </div>
          `;
          return;
        }
        
        // Expand segments to individual words
        this.teleprompterWords = this.expandTranscriptToWords(this.transcriptSegments);
        
        console.log('[Teleprompter] Loaded', this.teleprompterWords.length, 'words');
        
        // Render words
        this.renderTeleprompterWords();
        
        // Update highlighting for current time
        const video = document.getElementById('videoPlayer');
        if (video) {
          this.updateTeleprompterHighlight(video.currentTime);
        }
      },
      
      // Render teleprompter words
      renderTeleprompterWords() {
        const wordsContainer = document.getElementById('teleprompterWords');
        
        if (!this.teleprompterWords || this.teleprompterWords.length === 0) {
          wordsContainer.innerHTML = '<div class="teleprompter-empty">No words to display</div>';
          return;
        }
        
        wordsContainer.innerHTML = this.teleprompterWords.map((word, index) => `
          <span class="teleprompter-word" 
                data-index="${index}" 
                data-start="${word.start}" 
                data-end="${word.end}"
                onclick="app.seekToWord(${word.start})"
                title="${this.formatTime(word.start)}">${word.text}</span>
        `).join('');
      },
      
      // Update teleprompter word highlighting based on current time
      updateTeleprompterHighlight(currentTime) {
        if (!this.teleprompterVisible || !this.teleprompterWords) return;
        
        const words = document.querySelectorAll('.teleprompter-word');
        let currentWordElement = null;
        
        words.forEach((wordEl, index) => {
          const start = parseFloat(wordEl.dataset.start);
          const end = parseFloat(wordEl.dataset.end);
          
          // Remove all classes first
          wordEl.classList.remove('current', 'spoken', 'upcoming');
          
          if (currentTime >= start && currentTime < end) {
            // Current word being spoken
            wordEl.classList.add('current');
            currentWordElement = wordEl;
          } else if (currentTime >= end) {
            // Already spoken
            wordEl.classList.add('spoken');
          } else if (currentTime < start && currentTime >= start - 2) {
            // Upcoming (within 2 seconds)
            wordEl.classList.add('upcoming');
          }
        });
        
        // Scroll current word into view
        if (currentWordElement) {
          const container = document.getElementById('teleprompterContent');
          const wordRect = currentWordElement.getBoundingClientRect();
          const containerRect = container.getBoundingClientRect();
          
          // Check if word is outside visible area
          if (wordRect.top < containerRect.top || wordRect.bottom > containerRect.bottom) {
            currentWordElement.scrollIntoView({ 
              behavior: 'smooth', 
              block: 'center' 
            });
          }
        }
      },
      
      // Seek to a specific word's start time
      seekToWord(startTime) {
        const video = document.getElementById('videoPlayer');
        if (video) {
          video.currentTime = startTime;
          this.updateTeleprompterHighlight(startTime);
        }
      },
      
      // Transcribe full video for teleprompter
      async transcribeFullVideoForTeleprompter() {
        if (!this.videoPath) {
          this.showToast('error', 'No video loaded');
          return;
        }
        
        this.showProgress('Transcribing...', 'This may take a few minutes for longer videos');
        
        try {
          const result = await window.videoEditor.transcribeRange(this.videoPath, {
            startTime: 0,
            endTime: this.videoInfo?.duration || null,
            language: 'en'
          });
          
          this.hideProgress();
          
          if (result.error) {
            throw new Error(result.error);
          }
          
          if (result.transcription) {
            // Create segments from the transcription
            // Since we don't have word-level timing, distribute evenly
            const words = result.transcription.split(/\s+/).filter(w => w.length > 0);
            const duration = this.videoInfo?.duration || 60;
            const wordDuration = duration / words.length;
            
            this.transcriptSegments = words.map((word, i) => ({
              text: word,
              start: i * wordDuration,
              end: (i + 1) * wordDuration
            }));
            
            // Reinitialize teleprompter
            this.initTeleprompter();
            
            // Also update waveform
            this.generateAudioWaveform();
            
            this.showToast('success', `Transcribed ${words.length} words!`);
          }
          
        } catch (error) {
          this.hideProgress();
          this.showToast('error', 'Transcription failed: ' + error.message);
        }
      },

      updateAudioPlayhead() {
        const video = document.getElementById('videoPlayer');
        const playhead = document.getElementById('audioPlayhead');
        
        if (!video.duration) return;
        
        const percent = (video.currentTime / video.duration) * 100;
        playhead.style.left = `${percent}%`;
      },

      toggleAudioMute() {
        const video = document.getElementById('videoPlayer');
        const btn = document.getElementById('audioMuteBtn');
        
        this.audioMuted = !this.audioMuted;
        video.muted = this.audioMuted;
        
        btn.textContent = this.audioMuted ? '' : '';
        btn.classList.toggle('muted', this.audioMuted);
        
        // Also update main mute button
        this.updateMuteIcon();
        
        this.showToast(this.audioMuted ? 'warning' : 'success', 
          this.audioMuted ? 'Audio muted' : 'Audio unmuted');
      },

      async detachAudio() {
        if (!this.videoPath) {
          this.showToast('error', 'No video loaded');
          return;
        }
        
        if (this.audioDetached) {
          this.showToast('warning', 'Audio already detached');
          return;
        }
        
        this.showProgress('Extracting Audio...', 'Separating audio track from video');
        
        try {
          const result = await window.videoEditor.extractAudio(this.videoPath, {
            format: 'mp3',
            audioBitrate: '192k'
          });
          
          this.hideProgress();
          
          if (result.error) {
            throw new Error(result.error);
          }
          
          // Mark audio as detached
          this.audioDetached = true;
          document.getElementById('audioTrack').classList.add('detached');
          document.getElementById('detachAudioBtn').disabled = true;
          document.getElementById('detachAudioBtn').style.opacity = '0.5';
          
          this.showToast('success', `Audio extracted to: ${result.outputPath.split('/').pop()}`);
          this.loadExports();
        } catch (error) {
          this.hideProgress();
          this.showToast('error', 'Failed to extract audio: ' + error.message);
        }
      },

      // ==================== MULTI-TRACK SYSTEM ====================
      audioTracks: [
        { id: 'A1', type: 'original', name: 'Original', muted: false, solo: false, volume: 1.0, clips: [] }
      ],
      nextTrackId: 2,

      toggleAddTrackMenu(event) {
        event.stopPropagation();
        const menu = document.getElementById('addTrackMenu');
        menu.classList.toggle('visible');
        
        // Close menu when clicking outside
        const closeMenu = (e) => {
          if (!menu.contains(e.target)) {
            menu.classList.remove('visible');
            document.removeEventListener('click', closeMenu);
          }
        };
        
        setTimeout(() => {
          document.addEventListener('click', closeMenu);
        }, 10);
      },

      addAudioTrack(type) {
        const trackId = `A${this.nextTrackId++}`;
        const typeNames = {
          'voice': 'Voice',
          'music': 'Music',
          'sfx': 'SFX',
          'ambience': 'Ambience'
        };
        
        const track = {
          id: trackId,
          type: type,
          name: typeNames[type] || 'Audio',
          muted: false,
          solo: false,
          volume: 1.0,
          clips: []
        };
        
        this.audioTracks.push(track);
        this.renderAudioTrack(track);
        
        // Hide menu
        document.getElementById('addTrackMenu').classList.remove('visible');
        
        this.showToast('success', `Added ${track.name} track`);
      },

      renderAudioTrack(track) {
        const container = document.getElementById('audioTracksContainer');
        const addTrackRow = document.getElementById('addTrackRow');
        
        const trackEl = document.createElement('div');
        trackEl.className = 'timeline-row audio audio-track';
        trackEl.id = `track-${track.id}`;
        trackEl.dataset.trackId = track.id;
        
        const badgeClass = track.type === 'original' ? 'audio' : '';
        const typeBadgeClass = track.type !== 'original' ? `track-type-badge ${track.type}` : '';
        
        trackEl.innerHTML = `
          <div class="track-label">
            <div class="track-label-header">
              <span class="track-badge ${badgeClass}">${track.id}</span>
              ${track.type !== 'original' ? `<span class="${typeBadgeClass}">${track.type.toUpperCase()}</span>` : ''}
              <div class="track-info">
                <span class="track-name">${track.name}</span>
                <span class="track-clip-count">${track.clips.length} Clips</span>
              </div>
            </div>
            <div class="track-controls">
              <button class="track-action-btn ${track.muted ? 'muted' : ''}" 
                      onclick="app.toggleTrackMute('${track.id}')" 
                      title="Mute">M</button>
              <button class="track-action-btn ${track.solo ? 'solo' : ''}" 
                      onclick="app.toggleTrackSolo('${track.id}')" 
                      title="Solo">S</button>
              ${track.type !== 'original' ? `
              <button class="track-action-btn" 
                      onclick="app.removeTrack('${track.id}')" 
                      title="Delete Track" style="color: var(--error);"></button>
              ` : ''}
            </div>
          </div>
          <div class="timeline-track" id="trackContent-${track.id}" 
               ondragover="app.handleTrackDragOver(event, '${track.id}')"
               ondrop="app.handleTrackDrop(event, '${track.id}')"
               ondragleave="app.handleTrackDragLeave(event)"
               onclick="app.seekToPosition(event)">
            <div class="track-empty-state" id="trackEmpty-${track.id}">
              Drop audio files here or use AI to generate
            </div>
            <div class="track-drop-indicator" id="dropIndicator-${track.id}"></div>
          </div>
        `;
        
        // Insert before the add track row
        container.parentNode.insertBefore(trackEl, addTrackRow);
      },

      toggleTrackMute(trackId) {
        const track = this.audioTracks.find(t => t.id === trackId);
        if (!track) return;
        
        track.muted = !track.muted;
        
        // Update button UI
        const btn = document.querySelector(`#track-${trackId} .track-action-btn[title="Mute"]`) ||
                    document.getElementById('audioMuteBtn');
        if (btn) {
          btn.classList.toggle('muted', track.muted);
        }
        
        // If it's the original track, mute the video
        if (track.type === 'original') {
          const video = document.getElementById('videoPlayer');
          video.muted = track.muted;
          this.audioMuted = track.muted;
          this.updateMuteIcon();
        }
        
        this.showToast(track.muted ? 'warning' : 'success', 
          `${track.name} ${track.muted ? 'muted' : 'unmuted'}`);
      },

      toggleTrackSolo(trackId) {
        const track = this.audioTracks.find(t => t.id === trackId);
        if (!track) return;
        
        track.solo = !track.solo;
        
        // Update button UI
        const btn = document.querySelector(`#track-${trackId} .track-action-btn[title="Solo"]`);
        if (btn) {
          btn.classList.toggle('solo', track.solo);
        }
        
        // If solo is enabled, mute all other tracks
        if (track.solo) {
          this.audioTracks.forEach(t => {
            if (t.id !== trackId) {
              t.muted = true;
              const muteBtn = document.querySelector(`#track-${t.id} .track-action-btn[title="Mute"]`);
              if (muteBtn) muteBtn.classList.add('muted');
            }
          });
        } else {
          // If solo is disabled, unmute all tracks
          this.audioTracks.forEach(t => {
            t.muted = false;
            const muteBtn = document.querySelector(`#track-${t.id} .track-action-btn[title="Mute"]`);
            if (muteBtn) muteBtn.classList.remove('muted');
          });
        }
        
        // Update video mute state based on original track
        const originalTrack = this.audioTracks.find(t => t.type === 'original');
        if (originalTrack) {
          const video = document.getElementById('videoPlayer');
          video.muted = originalTrack.muted;
          this.audioMuted = originalTrack.muted;
          this.updateMuteIcon();
        }
        
        this.showToast('info', `${track.name} ${track.solo ? 'soloed' : 'unsolo'}`);
      },

      removeTrack(trackId) {
        const trackIndex = this.audioTracks.findIndex(t => t.id === trackId);
        if (trackIndex === -1) return;
        
        const track = this.audioTracks[trackIndex];
        if (track.type === 'original') {
          this.showToast('error', 'Cannot remove original audio track');
          return;
        }
        
        // Remove from DOM
        const trackEl = document.getElementById(`track-${trackId}`);
        if (trackEl) {
          trackEl.remove();
        }
        
        // Remove from array
        this.audioTracks.splice(trackIndex, 1);
        
        this.showToast('success', `Removed ${track.name} track`);
      },

      addClipToTrack(trackId, clip) {
        const track = this.audioTracks.find(t => t.id === trackId);
        if (!track) return;
        
        track.clips.push(clip);
        this.renderTrackClips(trackId);
      },

      renderTrackClips(trackId) {
        const track = this.audioTracks.find(t => t.id === trackId);
        if (!track) return;
        
        const container = document.getElementById(`trackContent-${trackId}`);
        const emptyState = document.getElementById(`trackEmpty-${trackId}`);
        
        if (!container) return;
        
        // Remove existing clips (but keep empty state and drop indicator)
        container.querySelectorAll('.audio-clip').forEach(el => el.remove());
        
        if (track.clips.length === 0) {
          if (emptyState) emptyState.style.display = 'flex';
          return;
        }
        
        if (emptyState) emptyState.style.display = 'none';
        
        // Render clips
        const duration = this.videoInfo?.duration || 100;
        
        track.clips.forEach((clip, index) => {
          const clipEl = document.createElement('div');
          clipEl.className = 'audio-clip';
          clipEl.dataset.clipIndex = index;
          clipEl.style.left = `${(clip.startTime / duration) * 100}%`;
          clipEl.style.width = `${((clip.endTime - clip.startTime) / duration) * 100}%`;
          clipEl.style.background = this.getTrackColor(track.type);
          
          clipEl.innerHTML = `
            <div class="audio-clip-name">${clip.name || 'Clip'}</div>
          `;
          
          container.appendChild(clipEl);
        });
        
        // Update clip count
        const countEl = document.querySelector(`#track-${trackId} .track-clip-count`);
        if (countEl) {
          countEl.textContent = `${track.clips.length} Clip${track.clips.length !== 1 ? 's' : ''}`;
        }
      },

      getTrackColor(type) {
        const colors = {
          'original': 'var(--accent-tertiary)',
          'voice': '#8b5cf6',
          'music': '#22c55e',
          'sfx': '#f97316',
          'ambience': '#06b6d4'
        };
        return colors[type] || 'var(--accent-secondary)';
      },

      handleTrackDragOver(event, trackId) {
        event.preventDefault();
        event.dataTransfer.dropEffect = 'copy';
        
        const track = document.getElementById(`trackContent-${trackId}`);
        if (track) {
          track.classList.add('drag-over');
          
          // Position drop indicator
          const rect = track.getBoundingClientRect();
          const x = event.clientX - rect.left;
          const indicator = document.getElementById(`dropIndicator-${trackId}`);
          if (indicator) {
            indicator.style.left = `${x}px`;
          }
        }
      },

      handleTrackDragLeave(event) {
        const track = event.currentTarget;
        if (track) {
          track.classList.remove('drag-over');
        }
      },

      handleTrackDrop(event, trackId) {
        event.preventDefault();
        
        const track = document.getElementById(`trackContent-${trackId}`);
        if (track) {
          track.classList.remove('drag-over');
        }
        
        // Handle dropped files
        const files = event.dataTransfer.files;
        if (files.length > 0) {
          for (const file of files) {
            if (file.type.startsWith('audio/')) {
              // Calculate start time based on drop position
              const rect = track.getBoundingClientRect();
              const x = event.clientX - rect.left;
              const percent = x / rect.width;
              const startTime = percent * (this.videoInfo?.duration || 0);
              
              this.addClipToTrack(trackId, {
                name: file.name,
                path: file.path,
                startTime: startTime,
                endTime: startTime + 10, // Default 10 second duration
                type: 'import'
              });
              
              this.showToast('success', `Added ${file.name} to track`);
            }
          }
        }
      },
      // ==================== END MULTI-TRACK SYSTEM ====================

      // ==================== TRANSLATION PANEL ====================
      translationSegments: [], // { id, start, end, status: 'empty'|'marked'|'working'|'approved', sourceText, translation, audioPath }
      currentSegmentIndex: -1,
      
      translationState: {
        isOpen: false,
        sourceText: '',
        translatedText: '',
        evaluation: null,
        iterations: [],
        currentIteration: 0,
        maxIterations: 5,
        segmentStart: 0,
        segmentEnd: 0,
        audioPath: null
      },

      markTranslationSegment(start, end) {
        const segment = {
          id: `seg-${this.translationSegments.length + 1}`,
          start: start,
          end: end,
          status: 'marked',
          sourceText: '',
          translation: null,
          audioPath: null
        };
        
        this.translationSegments.push(segment);
        this.renderTranslationSegments();
        this.currentSegmentIndex = this.translationSegments.length - 1;
        
        return segment;
      },

      renderTranslationSegments() {
        // Add visual overlay on timeline showing segments
        let container = document.getElementById('translationSegmentsLayer');
        if (!container) {
          container = document.createElement('div');
          container.id = 'translationSegmentsLayer';
          container.className = 'translation-segments-layer';
          
          const timelineTrack = document.getElementById('timelineTrack');
          if (timelineTrack) {
            timelineTrack.appendChild(container);
          }
        }
        
        const duration = this.videoInfo?.duration || 0;
        if (duration === 0) return;
        
        container.innerHTML = '';
        
        this.translationSegments.forEach((segment, index) => {
          const segEl = document.createElement('div');
          segEl.className = `translation-segment ${segment.status}`;
          segEl.style.left = `${(segment.start / duration) * 100}%`;
          segEl.style.width = `${((segment.end - segment.start) / duration) * 100}%`;
          
          let label = '';
          if (segment.status === 'approved') label = '';
          else if (segment.status === 'working') label = '...';
          else if (segment.status === 'marked') label = (index + 1).toString();
          
          segEl.innerHTML = `<span class="translation-segment-label">${label}</span>`;
          container.appendChild(segEl);
        });
      },

      navigateToSegment(direction) {
        if (this.translationSegments.length === 0) return;
        
        if (direction === 'next') {
          this.currentSegmentIndex = Math.min(
            this.currentSegmentIndex + 1,
            this.translationSegments.length - 1
          );
        } else if (direction === 'prev') {
          this.currentSegmentIndex = Math.max(this.currentSegmentIndex - 1, 0);
        }
        
        const segment = this.translationSegments[this.currentSegmentIndex];
        if (segment) {
          // Seek to segment
          const video = document.getElementById('videoPlayer');
          if (video) {
            video.currentTime = segment.start;
          }
          
          // Open translation panel for this segment
          this.openTranslationPanel(segment.sourceText, segment.start, segment.end);
        }
      },

      openTranslationPanel(sourceText = '', startTime = 0, endTime = 0) {
        this.translationState.sourceText = sourceText;
        this.translationState.segmentStart = startTime;
        this.translationState.segmentEnd = endTime;
        this.translationState.iterations = [];
        this.translationState.currentIteration = 0;
        this.translationState.translatedText = '';
        this.translationState.evaluation = null;
        this.translationState.audioPath = null;

        // Update UI
        document.getElementById('translationSourceText').textContent = sourceText || 'Select a region on the timeline to translate';
        document.getElementById('translationOutput').textContent = 'Click "Translate" to generate';
        document.getElementById('translationIteration').textContent = 'Iteration 0/5';
        document.getElementById('qualitySection').style.display = 'none';
        document.getElementById('audioSection').style.display = 'none';
        document.getElementById('applySection').style.display = 'none';
        document.getElementById('improvementSuggestions').style.display = 'none';
        document.getElementById('audioPreviewSection').style.display = 'none';
        document.getElementById('retryTranslateBtn').disabled = true;
        
        // Show panel
        document.getElementById('translationPanel').classList.add('open');
        this.translationState.isOpen = true;
      },

      closeTranslationPanel() {
        document.getElementById('translationPanel').classList.remove('open');
        this.translationState.isOpen = false;
      },

      async startTranslation() {
        const sourceText = document.getElementById('translationSourceText').textContent.trim();
        if (!sourceText || sourceText === 'Select a region on the timeline to translate') {
          this.showToast('error', 'No text to translate');
          return;
        }

        const sourceLanguage = document.getElementById('sourceLanguage').value;
        const targetLanguage = document.getElementById('targetLanguage').value;
        const duration = this.translationState.segmentEnd - this.translationState.segmentStart;

        // Update segment status to working
        const segment = this.translationSegments[this.currentSegmentIndex];
        if (segment) {
          segment.status = 'working';
          this.renderTranslationSegments();
        }

        document.getElementById('translateBtn').disabled = true;
        document.getElementById('translateBtn').textContent = ' Translating...';

        try {
          const result = await window.videoEditor.translateWithQuality(sourceText, {
            sourceLanguage,
            targetLanguage,
            sourceDuration: duration > 0 ? duration : null,
            videoContext: 'professional video',
            maxIterations: 5,
            qualityThreshold: 9.0
          });

          if (result.success || result.translation) {
            this.translationState.translatedText = result.translation;
            this.translationState.evaluation = result.evaluation;
            this.translationState.iterations = result.iterations || [];
            this.translationState.currentIteration = result.iterations?.length || 1;

            // Update UI
            document.getElementById('translationOutput').textContent = result.translation;
            document.getElementById('translationIteration').textContent = 
              `Iteration ${this.translationState.currentIteration}/${this.translationState.maxIterations}`;

            // Show quality scores
            this.updateQualityScores(result.evaluation);
            document.getElementById('qualitySection').style.display = 'block';

            // Show audio section if score is good enough
            if (result.evaluation.composite >= 8.0) {
              document.getElementById('audioSection').style.display = 'block';
            }

            // Show improvements if not passing
            if (!result.evaluation.pass && result.evaluation.improvements?.length > 0) {
              this.showImprovementSuggestions(result.evaluation.improvements);
            }

            this.showToast('success', `Translation complete! Score: ${result.evaluation.composite}/10`);
          } else {
            throw new Error(result.error || 'Translation failed');
          }
        } catch (error) {
          this.showToast('error', 'Translation failed: ' + error.message);
          console.error('[Translation] Error:', error);
        } finally {
          document.getElementById('translateBtn').disabled = false;
          document.getElementById('translateBtn').textContent = ' Translate';
          document.getElementById('retryTranslateBtn').disabled = false;
        }
      },

      updateQualityScores(evaluation) {
        if (!evaluation || !evaluation.scores) return;

        const scores = evaluation.scores;
        
        // Update score bars and values
        const updateScore = (id, score) => {
          const value = score?.score || 0;
          const percent = (value / 10) * 100;
          const fill = document.getElementById(id);
          const valEl = document.getElementById(id + 'Val');
          if (fill) {
            fill.style.width = `${percent}%`;
            fill.style.background = value >= 9 ? 'var(--success)' : value >= 7 ? 'var(--warning)' : 'var(--error)';
          }
          if (valEl) valEl.textContent = value.toFixed(1);
        };

        updateScore('scoreAccuracy', scores.accuracy);
        updateScore('scoreFluency', scores.fluency);
        updateScore('scoreAdequacy', scores.adequacy);
        updateScore('scoreCultural', scores.cultural_fit);
        updateScore('scoreTiming', scores.timing_fit);

        // Update composite
        const composite = document.getElementById('compositeScore');
        if (composite) {
          composite.textContent = evaluation.composite.toFixed(1);
          composite.style.color = evaluation.composite >= 9 ? 'var(--success)' : 
                                  evaluation.composite >= 7 ? 'var(--warning)' : 'var(--error)';
        }
      },

      showImprovementSuggestions(improvements) {
        const container = document.getElementById('suggestionsList');
        const section = document.getElementById('improvementSuggestions');
        
        if (container && improvements.length > 0) {
          container.innerHTML = improvements.map((imp, i) => 
            `<div style="margin-bottom: 4px;"> ${imp}</div>`
          ).join('');
          section.style.display = 'block';
        } else {
          section.style.display = 'none';
        }
      },

      async retryTranslation() {
        if (this.translationState.currentIteration >= this.translationState.maxIterations) {
          this.showToast('warning', 'Maximum iterations reached');
          return;
        }
        await this.startTranslation();
      },

      applyImprovements() {
        // The improvements are already applied in the retry
        this.retryTranslation();
      },

      skipImprovements() {
        // Show audio section even without perfect score
        document.getElementById('audioSection').style.display = 'block';
        document.getElementById('improvementSuggestions').style.display = 'none';
        this.showToast('info', 'Proceeding with current translation');
      },

      async generateTranslationAudio() {
        const text = this.translationState.translatedText;
        if (!text) {
          this.showToast('error', 'No translation to generate audio for');
          return;
        }

        const voice = document.getElementById('voiceSelect').value;
        const speed = parseFloat(document.getElementById('voiceSpeed').value);

        this.showToast('info', 'Generating audio with ElevenLabs...');

        try {
          // Use existing ElevenLabs integration
          const result = await window.videoEditor.replaceAudioWithElevenLabs(this.videoPath, {
            text: text,
            voiceId: voice,
            startTime: this.translationState.segmentStart,
            endTime: this.translationState.segmentEnd,
            speed: speed,
            previewOnly: true // Just generate, don't replace yet
          });

          if (result.success && result.audioPath) {
            this.translationState.audioPath = result.audioPath;
            
            // Show preview
            const audio = document.getElementById('translationAudioPreview');
            audio.src = `file://${result.audioPath}`;
            document.getElementById('audioPreviewSection').style.display = 'block';

            // Update duration info
            const sourceDuration = this.translationState.segmentEnd - this.translationState.segmentStart;
            document.getElementById('sourceDuration').textContent = sourceDuration.toFixed(1) + 's';
            
            audio.onloadedmetadata = () => {
              const genDuration = audio.duration;
              document.getElementById('generatedDuration').textContent = genDuration.toFixed(1) + 's';
              const delta = genDuration - sourceDuration;
              document.getElementById('durationDelta').textContent = 
                (delta >= 0 ? '+' : '') + delta.toFixed(1) + 's';
            };

            // Show apply button
            document.getElementById('applySection').style.display = 'block';
            
            this.showToast('success', 'Audio generated! Preview and apply.');
          } else {
            throw new Error(result.error || 'Audio generation failed');
          }
        } catch (error) {
          this.showToast('error', 'Audio generation failed: ' + error.message);
          console.error('[Translation] Audio error:', error);
        }
      },

      async applyTranslationToTimeline() {
        if (!this.translationState.audioPath) {
          this.showToast('error', 'No audio to apply');
          return;
        }

        const timingFix = document.querySelector('input[name="timingFix"]:checked')?.value || 'none';

        // Update segment status to approved
        const segment = this.translationSegments[this.currentSegmentIndex];
        if (segment) {
          segment.status = 'approved';
          segment.translation = this.translationState.translatedText;
          segment.audioPath = this.translationState.audioPath;
          this.renderTranslationSegments();
          this.updateSegmentNav();
        }

        // Add to the voice track
        const voiceTrack = this.audioTracks.find(t => t.type === 'voice');
        if (!voiceTrack) {
          // Create a voice track if none exists
          this.addAudioTrack('voice');
        }

        const track = this.audioTracks.find(t => t.type === 'voice') || this.audioTracks[1];
        
        if (track) {
          this.addClipToTrack(track.id, {
            name: 'Translation',
            path: this.translationState.audioPath,
            startTime: this.translationState.segmentStart,
            endTime: this.translationState.segmentEnd,
            type: 'translation',
            timingFix: timingFix,
            sourceText: this.translationState.sourceText,
            translatedText: this.translationState.translatedText,
            score: this.translationState.evaluation?.composite
          });
        }

        this.closeTranslationPanel();
        this.showToast('success', 'Translation applied to timeline!');
        
        // Auto-advance to next segment if available
        if (this.currentSegmentIndex < this.translationSegments.length - 1) {
          setTimeout(() => {
            this.navigateToSegment('next');
          }, 500);
        }
      },
      // ==================== END TRANSLATION PANEL ====================

      // ==================== AI VIDEO REPLACEMENT PANEL ====================
      aiVideoState: {
        isOpen: false,
        segmentStart: 0,
        segmentEnd: 0,
        description: '',
        generatedPrompt: '',
        uploadedVideoPath: null
      },

      openAIVideoPanel(startTime = 0, endTime = 0) {
        this.aiVideoState.segmentStart = startTime;
        this.aiVideoState.segmentEnd = endTime;
        this.aiVideoState.uploadedVideoPath = null;
        
        // Update UI with segment info
        const duration = endTime - startTime;
        document.getElementById('aiVideoRegion').textContent = 
          `${this.formatTime(startTime)} - ${this.formatTime(endTime)}`;
        document.getElementById('aiVideoDuration').textContent = duration.toFixed(1) + 's';
        
        // Get resolution from video info
        if (this.videoInfo) {
          document.getElementById('aiVideoResolution').textContent = 
            `${this.videoInfo.width}${this.videoInfo.height}`;
        }
        
        // Reset form
        document.getElementById('aiVideoDescription').value = '';
        document.getElementById('aiVideoPrompt').textContent = 'Enter a description above, then click "Generate Prompt"';
        document.getElementById('aiVideoPreviewSection').style.display = 'none';
        
        // Show panel
        document.getElementById('aiVideoPanel').classList.add('open');
        this.aiVideoState.isOpen = true;
      },

      closeAIVideoPanel() {
        document.getElementById('aiVideoPanel').classList.remove('open');
        this.aiVideoState.isOpen = false;
      },

      async generateVideoPrompt() {
        const description = document.getElementById('aiVideoDescription').value.trim();
        if (!description) {
          this.showToast('error', 'Please enter a description first');
          return;
        }

        const duration = this.aiVideoState.segmentEnd - this.aiVideoState.segmentStart;
        const resolution = this.videoInfo ? `${this.videoInfo.width}x${this.videoInfo.height}` : '1920x1080';
        const aspectRatio = this.videoInfo ? (this.videoInfo.width / this.videoInfo.height).toFixed(2) : '16:9';

        // Generate optimized prompt using AI
        try {
          const settingsPath = await window.videoEditor.getInfo(this.videoPath); // Just to check API access
          
          // For now, create a structured prompt based on best practices
          const optimizedPrompt = this.createOptimizedVideoPrompt(description, duration, resolution, aspectRatio);
          
          document.getElementById('aiVideoPrompt').textContent = optimizedPrompt;
          this.aiVideoState.generatedPrompt = optimizedPrompt;
          
          this.showToast('success', 'Prompt generated! Copy and use in your preferred AI service.');
        } catch (error) {
          // If AI is not available, use template-based prompt
          const optimizedPrompt = this.createOptimizedVideoPrompt(description, duration, resolution, aspectRatio);
          document.getElementById('aiVideoPrompt').textContent = optimizedPrompt;
          this.aiVideoState.generatedPrompt = optimizedPrompt;
        }
      },

      createOptimizedVideoPrompt(description, duration, resolution, aspectRatio) {
        // Enhance the user's description with technical specs and style hints
        const durationHint = duration < 5 ? '3-5 seconds' : 
                            duration < 10 ? '7-10 seconds' : 
                            duration < 20 ? '15-20 seconds' : '25-30 seconds';
        
        const styleHints = [
          'cinematic quality',
          'professional video style',
          'smooth camera movement',
          'high production value'
        ].join(', ');

        return `${description}, ${styleHints}, ${aspectRatio === '16:9' ? 'widescreen 16:9 aspect ratio' : `${aspectRatio} aspect ratio`}, ${resolution} resolution, ${durationHint} duration, seamless loop-friendly`;
      },

      copyVideoPrompt() {
        const prompt = this.aiVideoState.generatedPrompt || document.getElementById('aiVideoPrompt').textContent;
        
        if (prompt && prompt !== 'Enter a description above, then click "Generate Prompt"') {
          navigator.clipboard.writeText(prompt).then(() => {
            this.showToast('success', 'Prompt copied to clipboard!');
          }).catch(() => {
            this.showToast('error', 'Failed to copy prompt');
          });
        } else {
          this.showToast('error', 'No prompt to copy');
        }
      },

      openVideoService(service) {
        // Copy prompt to clipboard first
        const prompt = this.aiVideoState.generatedPrompt;
        if (prompt) {
          navigator.clipboard.writeText(prompt).catch(() => {});
        }

        const services = {
          'kling': 'https://klingai.com/',
          'veo': 'https://deepmind.google/technologies/veo/',
          'runway': 'https://runwayml.com/',
          'pika': 'https://pika.art/',
          'luma': 'https://lumalabs.ai/dream-machine',
          'sora': 'https://openai.com/sora'
        };

        const url = services[service];
        if (url && window.electron) {
          window.electron.openExternal(url);
          this.showToast('info', `Opening ${service}... Prompt copied to clipboard!`);
        }
      },

      handleAIVideoDragOver(event) {
        event.preventDefault();
        event.dataTransfer.dropEffect = 'copy';
        document.getElementById('aiVideoUploadZone').classList.add('drag-over');
      },

      handleAIVideoDragLeave(event) {
        document.getElementById('aiVideoUploadZone').classList.remove('drag-over');
      },

      handleAIVideoDrop(event) {
        event.preventDefault();
        document.getElementById('aiVideoUploadZone').classList.remove('drag-over');
        
        const files = event.dataTransfer.files;
        if (files.length > 0) {
          const file = files[0];
          if (file.type.startsWith('video/')) {
            this.processUploadedVideo(file);
          } else {
            this.showToast('error', 'Please drop a video file');
          }
        }
      },

      handleAIVideoUpload(event) {
        const file = event.target.files[0];
        if (file) {
          this.processUploadedVideo(file);
        }
      },

      processUploadedVideo(file) {
        // Show preview
        const preview = document.getElementById('aiVideoPreview');
        const url = URL.createObjectURL(file);
        preview.src = url;
        
        this.aiVideoState.uploadedVideoPath = file.path || url;
        this.aiVideoState.uploadedFileName = file.name;
        
        document.getElementById('aiVideoPreviewSection').style.display = 'block';
        
        this.showToast('success', `Loaded: ${file.name}`);
      },

      cancelAIVideoUpload() {
        document.getElementById('aiVideoPreviewSection').style.display = 'none';
        document.getElementById('aiVideoPreview').src = '';
        this.aiVideoState.uploadedVideoPath = null;
      },

      async applyAIVideoToTimeline() {
        if (!this.aiVideoState.uploadedVideoPath) {
          this.showToast('error', 'No video uploaded');
          return;
        }

        // In a full implementation, this would:
        // 1. Copy the video to the project assets folder
        // 2. Add it as a clip to the video track
        // 3. Potentially adjust timing to match the segment
        
        this.showToast('success', 'Video applied to timeline!');
        this.closeAIVideoPanel();
        
        // TODO: Actually splice the video into the timeline
        // This would require significant timeline management logic
      },
      // ==================== END AI VIDEO REPLACEMENT PANEL ====================

      // ==================== STORY BEATS SYSTEM ====================
      beats: [],
      nextBeatId: 1,
      selectedBeatId: null,
      beatsCurrentTab: 'list',

      switchBeatsTab(tab) {
        this.beatsCurrentTab = tab;
        
        // Update tab buttons
        document.querySelectorAll('.beats-sidebar-tab').forEach(btn => {
          btn.classList.toggle('active', btn.dataset.tab === tab);
        });
        
        // Show/hide content
        document.getElementById('beatsListTab').style.display = tab === 'list' ? 'block' : 'none';
        document.getElementById('beatsGraphTab').style.display = tab === 'graph' ? 'block' : 'none';
        document.getElementById('beatsDeployTab').style.display = tab === 'deploy' ? 'block' : 'none';
        
        if (tab === 'graph') {
          this.renderBeatGraph();
        }
      },

      addNewBeat() {
        // Get current selection from timeline if any
        const inTime = this.trimStart || 0;
        const outTime = this.trimEnd || (this.videoInfo?.duration || 0);
        
        const beat = {
          id: `beat-${this.nextBeatId++}`,
          name: `Beat ${this.beats.length + 1}`,
          inTime: inTime,
          outTime: outTime,
          description: '',
          transcription: '',
          tags: [],
          links: []
        };
        
        this.beats.push(beat);
        this.renderBeatList();
        this.selectBeat(beat.id);
        
        this.showToast('success', 'Beat added! Fill in the details.');
      },

      renderBeatList() {
        const container = document.getElementById('beatList');
        
        if (this.beats.length === 0) {
          container.innerHTML = `
            <div class="beat-inspector-empty">
              <p>No beats marked yet.</p>
              <p style="font-size: 11px; margin-top: 8px;">Select a region on the timeline and click "Add Beat"</p>
            </div>
          `;
          return;
        }
        
        container.innerHTML = this.beats.map(beat => `
          <div class="beat-item ${beat.id === this.selectedBeatId ? 'selected' : ''}" 
               onclick="app.selectBeat('${beat.id}')">
            <div class="beat-item-header">
              <span class="beat-item-name">${beat.name}</span>
              <span class="beat-item-time">${this.formatTime(beat.inTime)} - ${this.formatTime(beat.outTime)}</span>
            </div>
            ${beat.description ? `<div class="beat-item-description">${beat.description}</div>` : ''}
            ${beat.links.length > 0 ? `
              <div class="beat-item-links">
                ${beat.links.map(link => `<span class="beat-link-badge">${link.relationship}</span>`).join('')}
              </div>
            ` : ''}
          </div>
        `).join('');
      },

      selectBeat(beatId) {
        this.selectedBeatId = beatId;
        const beat = this.beats.find(b => b.id === beatId);
        
        if (!beat) return;
        
        // Update list selection
        this.renderBeatList();
        
        // Show inspector
        document.getElementById('beatInspectorPanel').style.display = 'block';
        
        // Populate fields
        document.getElementById('beatName').value = beat.name;
        document.getElementById('beatInTime').value = this.formatTime(beat.inTime);
        document.getElementById('beatOutTime').value = this.formatTime(beat.outTime);
        document.getElementById('beatDescription').value = beat.description || '';
        document.getElementById('beatTranscription').value = beat.transcription || '';
        
        // Render tags
        this.renderBeatTags(beat.tags);
        
        // Render links
        this.renderBeatLinks(beat.links);
        
        // Seek video to beat start
        const video = document.getElementById('videoPlayer');
        if (video) {
          video.currentTime = beat.inTime;
        }
      },

      renderBeatTags(tags) {
        const container = document.getElementById('beatTagsContainer');
        const input = document.getElementById('beatTagInput');
        
        // Clear existing tags (keep input)
        container.querySelectorAll('.beat-tag').forEach(el => el.remove());
        
        // Add tags
        tags.forEach(tag => {
          const tagEl = document.createElement('span');
          tagEl.className = 'beat-tag';
          tagEl.innerHTML = `${tag} <button class="beat-tag-remove" onclick="app.removeBeatTag('${tag}')"></button>`;
          container.insertBefore(tagEl, input);
        });
      },

      handleBeatTagKeydown(event) {
        if (event.key === 'Enter' || event.key === ',') {
          event.preventDefault();
          const input = event.target;
          const tag = input.value.trim().replace(',', '');
          
          if (tag && this.selectedBeatId) {
            const beat = this.beats.find(b => b.id === this.selectedBeatId);
            if (beat && !beat.tags.includes(tag)) {
              beat.tags.push(tag);
              this.renderBeatTags(beat.tags);
            }
            input.value = '';
          }
        }
      },

      removeBeatTag(tag) {
        if (!this.selectedBeatId) return;
        const beat = this.beats.find(b => b.id === this.selectedBeatId);
        if (beat) {
          beat.tags = beat.tags.filter(t => t !== tag);
          this.renderBeatTags(beat.tags);
        }
      },

      renderBeatLinks(links) {
        const container = document.getElementById('beatLinksList');
        
        if (links.length === 0) {
          container.innerHTML = '<div style="font-size: 11px; color: var(--text-muted);">No links yet</div>';
          return;
        }
        
        container.innerHTML = links.map((link, i) => {
          const targetBeat = this.beats.find(b => b.id === link.targetBeatId);
          return `
            <div class="beat-link-item">
              <div class="beat-link-info">
                <span class="beat-link-type">${link.relationship}</span>
                <span>${targetBeat?.name || link.targetVideoId || 'Unknown'}</span>
              </div>
              <button class="btn btn-ghost" onclick="app.removeBeatLink(${i})" style="padding: 4px; color: var(--error);"></button>
            </div>
          `;
        }).join('');
      },

      addBeatLink() {
        if (!this.selectedBeatId) return;
        
        // Show a simple dialog to select target and relationship
        const beat = this.beats.find(b => b.id === this.selectedBeatId);
        if (!beat) return;
        
        // For now, just add a placeholder link
        const otherBeats = this.beats.filter(b => b.id !== this.selectedBeatId);
        if (otherBeats.length === 0) {
          this.showToast('info', 'Add more beats to create links');
          return;
        }
        
        beat.links.push({
          targetBeatId: otherBeats[0].id,
          relationship: 'leads_to',
          targetVideoId: null
        });
        
        this.renderBeatLinks(beat.links);
        this.showToast('info', 'Link added - edit to customize');
      },

      removeBeatLink(index) {
        if (!this.selectedBeatId) return;
        const beat = this.beats.find(b => b.id === this.selectedBeatId);
        if (beat) {
          beat.links.splice(index, 1);
          this.renderBeatLinks(beat.links);
        }
      },

      saveBeat() {
        if (!this.selectedBeatId) return;
        const beat = this.beats.find(b => b.id === this.selectedBeatId);
        if (!beat) return;
        
        beat.name = document.getElementById('beatName').value;
        beat.inTime = this.parseTime(document.getElementById('beatInTime').value);
        beat.outTime = this.parseTime(document.getElementById('beatOutTime').value);
        beat.description = document.getElementById('beatDescription').value;
        beat.transcription = document.getElementById('beatTranscription').value;
        
        this.renderBeatList();
        this.showToast('success', 'Beat saved');
      },

      deleteBeat() {
        if (!this.selectedBeatId) return;
        
        this.beats = this.beats.filter(b => b.id !== this.selectedBeatId);
        this.selectedBeatId = null;
        
        document.getElementById('beatInspectorPanel').style.display = 'none';
        this.renderBeatList();
        this.showToast('success', 'Beat deleted');
      },

      async transcribeBeat() {
        if (!this.selectedBeatId || !this.videoPath) return;
        const beat = this.beats.find(b => b.id === this.selectedBeatId);
        if (!beat) return;
        
        this.showToast('info', 'Transcribing...');
        
        try {
          const result = await window.videoEditor.transcribeRange(this.videoPath, {
            startTime: beat.inTime,
            endTime: beat.outTime
          });
          
          if (result.transcription) {
            beat.transcription = result.transcription;
            document.getElementById('beatTranscription').value = result.transcription;
            this.showToast('success', 'Transcription complete');
          } else {
            throw new Error(result.error || 'Transcription failed');
          }
        } catch (error) {
          this.showToast('error', 'Transcription failed: ' + error.message);
        }
      },

      // Beat Graph Rendering
      renderBeatGraph() {
        const canvas = document.getElementById('beatGraphCanvas');
        if (!canvas) return;
        
        // Clear existing
        canvas.innerHTML = '';
        
        if (this.beats.length === 0) {
          const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          text.setAttribute('x', '50%');
          text.setAttribute('y', '50%');
          text.setAttribute('text-anchor', 'middle');
          text.setAttribute('fill', '#5c5c5c');
          text.setAttribute('font-size', '12');
          text.textContent = 'Add beats to see graph';
          canvas.appendChild(text);
          return;
        }
        
        // Position beats in a layout
        const containerWidth = canvas.clientWidth || 400;
        const containerHeight = canvas.clientHeight || 300;
        const nodeWidth = 100;
        const nodeHeight = 40;
        
        // Simple horizontal layout
        const spacing = containerWidth / (this.beats.length + 1);
        
        this.beats.forEach((beat, i) => {
          beat._x = spacing * (i + 1) - nodeWidth / 2;
          beat._y = containerHeight / 2 - nodeHeight / 2;
        });
        
        // Draw links first (so they appear behind nodes)
        this.beats.forEach(beat => {
          beat.links.forEach(link => {
            const targetBeat = this.beats.find(b => b.id === link.targetBeatId);
            if (targetBeat) {
              const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
              const startX = beat._x + nodeWidth;
              const startY = beat._y + nodeHeight / 2;
              const endX = targetBeat._x;
              const endY = targetBeat._y + nodeHeight / 2;
              
              // Curved line
              const midX = (startX + endX) / 2;
              line.setAttribute('d', `M ${startX} ${startY} Q ${midX} ${startY - 30} ${endX} ${endY}`);
              line.setAttribute('stroke', '#4a9eff');
              line.setAttribute('stroke-width', '2');
              line.setAttribute('fill', 'none');
              line.setAttribute('marker-end', 'url(#arrowhead)');
              canvas.appendChild(line);
              
              // Link label
              const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
              label.setAttribute('x', midX);
              label.setAttribute('y', startY - 35);
              label.setAttribute('text-anchor', 'middle');
              label.setAttribute('fill', '#909090');
              label.setAttribute('font-size', '10');
              label.textContent = link.relationship;
              canvas.appendChild(label);
            }
          });
        });
        
        // Draw nodes
        this.beats.forEach(beat => {
          const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
          g.setAttribute('class', 'beat-graph-node');
          g.setAttribute('data-beat-id', beat.id);
          g.style.cursor = 'pointer';
          g.onclick = () => this.selectBeat(beat.id);
          
          const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
          rect.setAttribute('x', beat._x);
          rect.setAttribute('y', beat._y);
          rect.setAttribute('width', nodeWidth);
          rect.setAttribute('height', nodeHeight);
          rect.setAttribute('rx', '6');
          rect.setAttribute('fill', beat.id === this.selectedBeatId ? '#232323' : '#1e1e1e');
          rect.setAttribute('stroke', beat.id === this.selectedBeatId ? '#e84c3d' : '#4a9eff');
          rect.setAttribute('stroke-width', '2');
          g.appendChild(rect);
          
          const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          text.setAttribute('x', beat._x + nodeWidth / 2);
          text.setAttribute('y', beat._y + nodeHeight / 2 + 4);
          text.setAttribute('text-anchor', 'middle');
          text.setAttribute('fill', '#d4d4d4');
          text.setAttribute('font-size', '12');
          text.textContent = beat.name.length > 12 ? beat.name.substring(0, 12) + '...' : beat.name;
          g.appendChild(text);
          
          canvas.appendChild(g);
        });
        
        // Add arrowhead marker
        const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
        defs.innerHTML = `
          <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
            <polygon points="0 0, 10 3.5, 0 7" fill="#4a9eff" />
          </marker>
        `;
        canvas.insertBefore(defs, canvas.firstChild);
      },

      zoomBeatGraph(factor) {
        // TODO: Implement graph zoom
        this.showToast('info', 'Zoom coming soon');
      },

      resetBeatGraphView() {
        this.renderBeatGraph();
      },

      // Deploy Functions
      async testInPlayer() {
        if (this.beats.length === 0) {
          this.showToast('error', 'Add some beats first');
          return;
        }
        
        if (!this.videoPath) {
          this.showToast('error', 'No video loaded');
          return;
        }
        
        try {
          // Save beats first
          await this.exportProjectToSpace();
          
          // Create player config with beats
          const playerConfig = {
            videoPath: this.videoPath,
            beats: this.beats.map(beat => ({
              id: beat.id,
              name: beat.name,
              timeIn: this.formatTime(beat.inTime),
              timeOut: this.formatTime(beat.outTime),
              description: beat.description,
              transcription: beat.transcription,
              tags: beat.tags,
              links: beat.links
            })),
            mode: 'test'
          };
          
          // Open player window
          const playerWindow = window.open(
            'agentic-player/index.html',
            'AgenticPlayer',
            'width=1200,height=800'
          );
          
          // Send config when loaded
          if (playerWindow) {
            playerWindow.addEventListener('load', () => {
              playerWindow.postMessage({
                type: 'load-beats',
                config: playerConfig
              }, '*');
            });
            
            this.showToast('success', 'Player opened!');
          }
        } catch (error) {
          console.error('[Deploy] Test player error:', error);
          this.showToast('error', 'Failed to open player');
        }
      },

      generateEmbedCode() {
        if (this.beats.length === 0) {
          this.showToast('error', 'Add some beats first');
          return;
        }
        
        const embedCode = `<iframe src="https://player.onereach.ai/embed/${Date.now()}" 
  width="800" height="450" frameborder="0" 
  allow="autoplay; fullscreen" allowfullscreen>
</iframe>`;
        
        navigator.clipboard.writeText(embedCode).then(() => {
          this.showToast('success', 'Embed code copied!');
        });
        
        document.getElementById('embedCodeBox').textContent = embedCode;
        document.getElementById('embedCodeSection').style.display = 'block';
      },

      async exportPlayerPackage() {
        if (this.beats.length === 0) {
          this.showToast('error', 'Add some beats first');
          return;
        }
        
        if (!this.videoPath) {
          this.showToast('error', 'No video loaded');
          return;
        }
        
        try {
          this.showToast('info', 'Creating player package...');
          
          // Create package structure
          const packageData = {
            beats: this.exportBeatsJSON(),
            config: {
              videoPath: this.videoPath.split('/').pop(),
              title: this.currentProject?.name || 'Video Player',
              autoplay: false,
              controls: true
            },
            readme: this.generatePlayerReadme()
          };
          
          // Download beats.json
          this.downloadJSON(JSON.stringify(packageData.beats, null, 2), 'beats.json');
          
          // Download config.json
          this.downloadJSON(JSON.stringify(packageData.config, null, 2), 'config.json');
          
          // Download README
          const readmeBlob = new Blob([packageData.readme], { type: 'text/markdown' });
          const readmeUrl = URL.createObjectURL(readmeBlob);
          const readmeLink = document.createElement('a');
          readmeLink.href = readmeUrl;
          readmeLink.download = 'README.md';
          readmeLink.click();
          URL.revokeObjectURL(readmeUrl);
          
          this.showToast('success', 'Player package exported! Copy agentic-player folder and add your video file.');
          
          // Show instructions
          setTimeout(() => {
            alert(`Player Package Created!\n\n` +
                  `Files downloaded:\n` +
                  `- beats.json (story beats metadata)\n` +
                  `- config.json (player configuration)\n` +
                  `- README.md (setup instructions)\n\n` +
                  `Next steps:\n` +
                  `1. Copy the agentic-player/ folder from your app\n` +
                  `2. Add these files to that folder\n` +
                  `3. Add your video file (${this.videoPath.split('/').pop()})\n` +
                  `4. Host on any web server or open index.html locally\n\n` +
                  `See README.md for detailed instructions.`);
          }, 1000);
        } catch (error) {
          console.error('[Deploy] Export package error:', error);
          this.showToast('error', 'Export failed');
        }
      },

      generatePlayerReadme() {
        return `# Agentic Video Player - Self-Hosted Package

This package contains everything needed to host your interactive video player.

## Package Contents

- \`index.html\` - Player HTML
- \`player.js\` - Player JavaScript
- \`styles.css\` - Player styles
- \`beats.json\` - Story beats metadata
- \`config.json\` - Player configuration
- \`${this.videoPath.split('/').pop()}\` - Your video file (add this)

## Setup Instructions

### Option 1: Local Testing

1. Place all files in a folder
2. Add your video file: \`${this.videoPath.split('/').pop()}\`
3. Open \`index.html\` in a modern browser

### Option 2: Web Hosting

1. Upload all files to your web server
2. Ensure video file is accessible
3. Navigate to \`https://yourdomain.com/player/\`

### Option 3: CDN + Hosting

1. Upload video to CDN (e.g., Cloudflare, AWS S3)
2. Update \`config.json\` with CDN URL
3. Host player files on any static host

## Configuration

Edit \`config.json\` to customize:

\`\`\`json
{
  "videoPath": "your-video.mp4",  // Local or CDN URL
  "title": "Your Video Title",
  "autoplay": false,
  "controls": true
}
\`\`\`

## Story Beats

The \`beats.json\` file contains all your marked story beats with:
- Time codes (in/out points)
- Transcriptions
- Descriptions
- Tags
- Links to other beats

The player uses this to enable:
- Smart navigation
- Beat-to-beat jumping
- Graph-based playback
- Interactive storytelling

## Requirements

- Modern browser (Chrome, Firefox, Safari, Edge)
- Video codec support (H.264/VP9)
- HTTPS recommended for production

## Troubleshooting

**Video won't play:**
- Check video path in config.json
- Ensure video format is web-compatible (MP4/WebM)
- Check browser console for errors

**Beats not loading:**
- Verify beats.json is valid JSON
- Check file path and permissions
- Ensure all beat time codes are valid

## Support

For issues or questions, refer to the main Onereach.ai documentation.

---

Generated by Onereach Video Editor
${new Date().toLocaleDateString()}
`;
      },

      // Export beats to JSON
      exportBeatsJSON() {
        return {
          videoId: this.spaceItemId || 'local',
          videoPath: this.videoPath,
          duration: this.videoInfo?.duration || 0,
          beats: this.beats.map(beat => ({
            id: beat.id,
            name: beat.name,
            inTime: beat.inTime,
            outTime: beat.outTime,
            transcription: beat.transcription,
            description: beat.description,
            tags: beat.tags,
            links: beat.links
          })),
          crossVideoIndex: {}
        };
      },
      // ==================== END STORY BEATS SYSTEM ====================

      // ==================== AUDIO SWEETENING PANEL ====================
      recentAudioFiles: [],

      openAudioSweeteningPanel() {
        document.getElementById('audioSweeteningPanel').classList.add('open');
        this.loadRecentAudioFiles();
      },

      closeAudioSweeteningPanel() {
        document.getElementById('audioSweeteningPanel').classList.remove('open');
      },

      async searchElevenLabsSFX(event) {
        const query = event.target.value.trim();
        if (query.length < 2) return;
        
        // TODO: Integrate with ElevenLabs SFX API when available
        console.log('[AudioSweetening] Searching for:', query);
      },

      async addSFXToTrack(sfxType) {
        // For now, show placeholder
        this.showToast('info', `Generating ${sfxType} sound effect with ElevenLabs...`);
        
        // TODO: Actually call ElevenLabs API to generate the sound
        // For now, create a placeholder entry
        const video = document.getElementById('videoPlayer');
        const currentTime = video?.currentTime || 0;
        
        // Find or create SFX track
        let sfxTrack = this.audioTracks.find(t => t.type === 'sfx');
        if (!sfxTrack) {
          this.addAudioTrack('sfx');
          sfxTrack = this.audioTracks.find(t => t.type === 'sfx');
        }
        
        if (sfxTrack) {
          this.addClipToTrack(sfxTrack.id, {
            name: sfxType,
            path: `elevenlabs://sfx/${sfxType}`,
            startTime: currentTime,
            endTime: currentTime + 1, // 1 second duration
            type: 'elevenlabs-sfx'
          });
          
          this.showToast('success', `Added ${sfxType} SFX to timeline`);
        }
      },

      handleAudioDragOver(event) {
        event.preventDefault();
        event.dataTransfer.dropEffect = 'copy';
        event.currentTarget.classList.add('drag-over');
      },

      handleAudioDragLeave(event) {
        event.currentTarget.classList.remove('drag-over');
      },

      handleAudioDrop(event) {
        event.preventDefault();
        event.currentTarget.classList.remove('drag-over');
        
        const files = Array.from(event.dataTransfer.files).filter(f => f.type.startsWith('audio/'));
        if (files.length > 0) {
          this.importAudioFiles(files);
        }
      },

      handleAudioImport(event) {
        const files = Array.from(event.target.files);
        if (files.length > 0) {
          this.importAudioFiles(files);
        }
        event.target.value = ''; // Reset input
      },

      importAudioFiles(files) {
        const video = document.getElementById('videoPlayer');
        const currentTime = video?.currentTime || 0;
        
        files.forEach(file => {
          // Add to recent files
          this.recentAudioFiles.unshift({
            name: file.name,
            path: file.path || URL.createObjectURL(file),
            size: file.size,
            type: file.type,
            addedAt: Date.now()
          });
          
          // Keep only last 10
          this.recentAudioFiles = this.recentAudioFiles.slice(0, 10);
          
          // Determine track type based on filename
          let trackType = 'sfx';
          const name = file.name.toLowerCase();
          if (name.includes('music') || name.includes('song') || name.includes('track')) {
            trackType = 'music';
          } else if (name.includes('ambient') || name.includes('background')) {
            trackType = 'ambience';
          }
          
          // Find or create appropriate track
          let track = this.audioTracks.find(t => t.type === trackType);
          if (!track) {
            this.addAudioTrack(trackType);
            track = this.audioTracks.find(t => t.type === trackType);
          }
          
          if (track) {
            this.addClipToTrack(track.id, {
              name: file.name,
              path: file.path || URL.createObjectURL(file),
              startTime: currentTime,
              endTime: currentTime + 10, // Default duration, will be updated when loaded
              type: 'import'
            });
          }
        });
        
        this.loadRecentAudioFiles();
        this.showToast('success', `Imported ${files.length} audio file${files.length > 1 ? 's' : ''}`);
      },

      loadRecentAudioFiles() {
        const container = document.getElementById('recentAudioList');
        if (!container) return;
        
        if (this.recentAudioFiles.length === 0) {
          container.innerHTML = `
            <div style="font-size: 11px; color: var(--text-muted); padding: 8px; text-align: center;">
              No recent audio files
            </div>
          `;
          return;
        }
        
        container.innerHTML = this.recentAudioFiles.map(file => `
          <div style="display: flex; align-items: center; gap: 8px; padding: 6px; background: var(--bg-surface); border-radius: 4px; cursor: pointer;"
               onclick="app.addRecentAudioToTrack('${file.name}')">
            <span style="font-size: 14px;"></span>
            <div style="flex: 1; min-width: 0;">
              <div style="font-size: 11px; font-weight: 500; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
                ${file.name}
              </div>
              <div style="font-size: 10px; color: var(--text-muted);">
                ${this.formatFileSize(file.size)}
              </div>
            </div>
            <button class="btn btn-ghost" style="padding: 4px; font-size: 10px;" onclick="event.stopPropagation(); app.addRecentAudioToTrack('${file.name}')">
              +
            </button>
          </div>
        `).join('');
      },

      addRecentAudioToTrack(fileName) {
        const file = this.recentAudioFiles.find(f => f.name === fileName);
        if (!file) return;
        
        this.importAudioFiles([{
          name: file.name,
          path: file.path,
          size: file.size,
          type: file.type
        }]);
      },

      formatFileSize(bytes) {
        if (bytes < 1024) return bytes + ' B';
        if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
        return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
      },
      // ==================== END AUDIO SWEETENING PANEL ====================

      // ==================== TIMELINE ACTION BAR ====================
      selectedRegion: { start: 0, end: 0, active: false },

      showTimelineActions() {
        // Show action buttons when a region is selected
        const actionBar = document.getElementById('timelineActionBar');
        if (actionBar && this.selectedRegion.active) {
          actionBar.style.display = 'flex';
          
          // Position it near the selected region
          const duration = this.selectedRegion.end - this.selectedRegion.start;
          const durationText = document.getElementById('regionDurationText');
          if (durationText) {
            durationText.textContent = `${this.formatTime(this.selectedRegion.start)} - ${this.formatTime(this.selectedRegion.end)} (${duration.toFixed(1)}s)`;
          }
        } else if (actionBar) {
          actionBar.style.display = 'none';
        }
      },

      updateSelectedRegion() {
        // Update selected region based on trim markers
        if (this.trimStart !== this.trimEnd) {
          this.selectedRegion = {
            start: this.trimStart,
            end: this.trimEnd,
            active: true
          };
          this.showTimelineActions();
        } else {
          this.selectedRegion.active = false;
          this.showTimelineActions();
        }
      },

      openTranslationForRegion() {
        if (!this.selectedRegion.active) {
          this.showToast('error', 'Select a region on the timeline first');
          return;
        }
        
        // Mark this as a translation segment
        const segment = this.markTranslationSegment(
          this.selectedRegion.start,
          this.selectedRegion.end
        );
        
        // Get transcription for this region if available
        let sourceText = '';
        if (this.transcriptSegments) {
          const segments = this.transcriptSegments.filter(seg => 
            seg.start >= this.selectedRegion.start && seg.end <= this.selectedRegion.end
          );
          sourceText = segments.map(s => s.text).join(' ');
        }
        
        segment.sourceText = sourceText;
        
        // Update segment nav
        this.updateSegmentNav();
        
        this.openTranslationPanel(sourceText, this.selectedRegion.start, this.selectedRegion.end);
      },

      updateSegmentNav() {
        const navEl = document.getElementById('segmentNav');
        if (!navEl) return;
        
        if (this.translationSegments.length > 0) {
          navEl.style.display = 'flex';
          
          const approved = this.translationSegments.filter(s => s.status === 'approved').length;
          document.getElementById('segmentNavText').textContent = 
            `Segment ${this.currentSegmentIndex + 1} of ${this.translationSegments.length}`;
          document.getElementById('approvedSegmentsCount').textContent = approved;
        } else {
          navEl.style.display = 'none';
        }
      },

      openAIVideoForRegion() {
        if (!this.selectedRegion.active) {
          this.showToast('error', 'Select a region on the timeline first');
          return;
        }
        
        this.openAIVideoPanel(this.selectedRegion.start, this.selectedRegion.end);
      },
      // ==================== END TIMELINE ACTION BAR ====================

      // ==================== PROJECT MANAGEMENT ====================
      currentProject: null,
      autoSaveInterval: null,

      async createProject(videoPath, spaceId) {
        const projectId = `proj-${Date.now()}`;
        const projectName = videoPath.split('/').pop().replace(/\.[^.]+$/, '');
        
        this.currentProject = {
          id: projectId,
          name: projectName,
          spaceId: spaceId || 'default',
          sourceVideo: videoPath,
          createdAt: new Date().toISOString(),
          modifiedAt: new Date().toISOString()
        };
        
        // Save initial project
        await this.saveProject();
        
        // Start auto-save
        this.startAutoSave();
        
        console.log('[ProjectManager] Created project:', projectId);
        return this.currentProject;
      },

      async saveProject() {
        if (!this.currentProject) return;
        
        try {
          const projectData = {
            ...this.currentProject,
            modifiedAt: new Date().toISOString(),
            tracks: this.audioTracks,
            beats: this.beats,
            translations: this.exportTranslations(),
            timeline: {
              zoom: this.timelineZoom,
              scroll: this.timelineScrollOffset
            }
          };
          
          // Save to localStorage for now (TODO: integrate with Space storage)
          localStorage.setItem(`project-${this.currentProject.id}`, JSON.stringify(projectData));
          
          console.log('[ProjectManager] Project saved');
          return { success: true };
        } catch (error) {
          console.error('[ProjectManager] Save error:', error);
          return { success: false, error: error.message };
        }
      },

      async loadProject(projectId) {
        try {
          const data = localStorage.getItem(`project-${projectId}`);
          if (!data) {
            throw new Error('Project not found');
          }
          
          const projectData = JSON.parse(data);
          this.currentProject = projectData;
          
          // Restore state
          if (projectData.sourceVideo) {
            // Load the video
            // await this.loadVideo(projectData.sourceVideo); // TODO
          }
          
          if (projectData.tracks) {
            this.audioTracks = projectData.tracks;
            // Re-render tracks
            this.audioTracks.forEach(track => {
              if (track.type !== 'original') {
                this.renderAudioTrack(track);
              }
            });
          }
          
          if (projectData.beats) {
            this.beats = projectData.beats;
            this.renderBeatList();
          }
          
          if (projectData.timeline) {
            this.timelineZoom = projectData.timeline.zoom || 1;
            this.timelineScrollOffset = projectData.timeline.scrollOffset || 0;
          }
          
          this.startAutoSave();
          this.showToast('success', 'Project loaded');
          
          console.log('[ProjectManager] Project loaded:', projectId);
          return { success: true, project: this.currentProject };
        } catch (error) {
          console.error('[ProjectManager] Load error:', error);
          this.showToast('error', 'Failed to load project');
          return { success: false, error: error.message };
        }
      },

      startAutoSave() {
        // Clear existing interval
        if (this.autoSaveInterval) {
          clearInterval(this.autoSaveInterval);
        }
        
        // Auto-save every 30 seconds
        this.autoSaveInterval = setInterval(() => {
          if (this.currentProject) {
            this.saveProject();
          }
        }, 30000);
      },

      stopAutoSave() {
        if (this.autoSaveInterval) {
          clearInterval(this.autoSaveInterval);
          this.autoSaveInterval = null;
        }
      },

      exportTranslations() {
        // Export translation data for project save
        return this.audioTracks
          .filter(t => t.type === 'voice')
          .flatMap(t => t.clips.filter(c => c.type === 'translation'))
          .map(clip => ({
            regionStart: clip.startTime,
            regionEnd: clip.endTime,
            sourceText: clip.sourceText,
            translatedText: clip.translatedText,
            audioPath: clip.path,
            score: clip.score,
            timingFix: clip.timingFix
          }));
      },

      async exportProjectToSpace() {
        if (!this.currentProject) {
          this.showToast('error', 'No project to export');
          return;
        }
        
        try {
          // Export beats.json
          const beatsData = this.exportBeatsJSON();
          const beatsJSON = JSON.stringify(beatsData, null, 2);
          
          // Export edit-session.json
          const sessionData = {
            projectId: this.currentProject.id,
            sourceVideo: this.currentProject.sourceVideo,
            tracks: this.audioTracks,
            translations: this.exportTranslations(),
            modifiedAt: new Date().toISOString()
          };
          const sessionJSON = JSON.stringify(sessionData, null, 2);
          
          // For now, download as files (TODO: integrate with Space)
          this.downloadJSON(beatsJSON, `beats-${this.currentProject.id}.json`);
          this.downloadJSON(sessionJSON, `edit-session-${this.currentProject.id}.json`);
          
          this.showToast('success', 'Project exported');
        } catch (error) {
          console.error('[ProjectManager] Export error:', error);
          this.showToast('error', 'Export failed');
        }
      },

      downloadJSON(jsonString, filename) {
        const blob = new Blob([jsonString], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.click();
        URL.revokeObjectURL(url);
      },
      // ==================== END PROJECT MANAGEMENT ====================

      // Splice Functions
      spliceStart: 0,
      spliceEnd: 0,

      setSpliceStart() {
        const video = document.getElementById('videoPlayer');
        this.spliceStart = video.currentTime;
        document.getElementById('spliceStart').value = this.formatTime(video.currentTime);
        this.updateSplicePreview();
        this.showToast('success', 'Splice IN point set');
      },

      setSpliceEnd() {
        const video = document.getElementById('videoPlayer');
        this.spliceEnd = video.currentTime;
        document.getElementById('spliceEnd').value = this.formatTime(video.currentTime);
        this.updateSplicePreview();
        this.showToast('success', 'Splice OUT point set');
      },

      updateSplicePreview() {
        const startInput = document.getElementById('spliceStart').value;
        const endInput = document.getElementById('spliceEnd').value;
        
        this.spliceStart = this.parseTime(startInput);
        this.spliceEnd = this.parseTime(endInput);
        
        const video = document.getElementById('videoPlayer');
        const duration = video.duration || 0;
        
        const preview = document.getElementById('splicePreview');
        
        if (this.spliceStart > 0 || this.spliceEnd > 0) {
          const removeTime = Math.max(0, this.spliceEnd - this.spliceStart);
          const resultTime = Math.max(0, duration - removeTime);
          
          document.getElementById('spliceRemoveTime').textContent = this.formatTime(removeTime);
          document.getElementById('spliceResultTime').textContent = this.formatTime(resultTime);
          preview.style.display = 'block';
        } else {
          preview.style.display = 'none';
        }
      },

      async spliceVideo() {
        if (!this.videoPath) {
          this.showToast('error', 'No video loaded');
          return;
        }
        
        const startInput = document.getElementById('spliceStart').value;
        const endInput = document.getElementById('spliceEnd').value;
        
        const cutStart = this.parseTime(startInput);
        const cutEnd = this.parseTime(endInput);
        
        if (cutStart >= cutEnd) {
          this.showToast('error', 'Cut start must be before cut end');
          return;
        }
        
        const removeTime = cutEnd - cutStart;
        this.showProgress('Splicing Video...', `Removing ${this.formatTime(removeTime)} from video`);
        
        try {
          const result = await window.videoEditor.splice(this.videoPath, {
            cutStart: cutStart,
            cutEnd: cutEnd
          });
          
          this.hideProgress();
          
          if (result.error) {
            throw new Error(result.error);
          }
          
          this.showToast('success', `Removed ${this.formatTime(removeTime)} - new duration: ${this.formatTime(result.newDuration)}`);
          this.loadExports();
          
          // Reset splice inputs
          document.getElementById('spliceStart').value = '00:00:00';
          document.getElementById('spliceEnd').value = '00:00:00';
          document.getElementById('splicePreview').style.display = 'none';
          this.spliceStart = 0;
          this.spliceEnd = 0;
        } catch (error) {
          this.hideProgress();
          this.showToast('error', 'Failed to splice: ' + error.message);
        }
      },

      // Speed Control Functions
      setSpeedPreset(speed) {
        this.currentSpeed = speed;
        document.getElementById('speedSlider').value = speed;
        document.getElementById('speedValue').textContent = speed.toFixed(2);
        
        // Update active button
        document.querySelectorAll('.speed-btn').forEach(btn => {
          btn.classList.toggle('active', parseFloat(btn.dataset.speed) === speed);
        });
        
        // Preview speed (change video playback rate)
        const video = document.getElementById('videoPlayer');
        video.playbackRate = speed;
      },

      updateSpeedValue(value) {
        const speed = parseFloat(value);
        this.currentSpeed = speed;
        document.getElementById('speedValue').textContent = speed.toFixed(2);
        
        // Update button states
        document.querySelectorAll('.speed-btn').forEach(btn => {
          btn.classList.toggle('active', parseFloat(btn.dataset.speed) === speed);
        });
        
        // Preview speed
        const video = document.getElementById('videoPlayer');
        video.playbackRate = speed;
      },

      async applySpeed() {
        if (!this.videoPath) {
          this.showToast('error', 'No video loaded');
          return;
        }
        
        if (this.currentSpeed === 1.0) {
          this.showToast('warning', 'Speed is already 1x (no change needed)');
          return;
        }
        
        const speedLabel = this.currentSpeed > 1 ? `${this.currentSpeed}x faster` : `${this.currentSpeed}x slower`;
        this.showProgress('Changing Speed...', `Making video ${speedLabel}`);
        
        try {
          const result = await window.videoEditor.changeSpeed(this.videoPath, {
            speed: this.currentSpeed
          });
          
          this.hideProgress();
          
          if (result.error) {
            throw new Error(result.error);
          }
          
          this.showToast('success', `Video speed changed to ${this.currentSpeed}x!`);
          this.loadExports();
        } catch (error) {
          this.hideProgress();
          this.showToast('error', 'Failed to change speed: ' + error.message);
        }
      },

      async reverseVideo() {
        if (!this.videoPath) {
          this.showToast('error', 'No video loaded');
          return;
        }
        
        this.showProgress('Reversing Video...', 'Playing video backwards');
        
        try {
          const result = await window.videoEditor.reverse(this.videoPath, {
            includeAudio: true
          });
          
          this.hideProgress();
          
          if (result.error) {
            throw new Error(result.error);
          }
          
          this.showToast('success', 'Video reversed successfully!');
          this.loadExports();
        } catch (error) {
          this.hideProgress();
          this.showToast('error', 'Failed to reverse video: ' + error.message);
        }
      },

      // Set trim points
      setTrimStart() {
        const video = document.getElementById('videoPlayer');
        this.trimStart = video.currentTime;
        document.getElementById('trimStart').value = this.formatTime(video.currentTime);
        this.updateTrimRegion();
        this.showToast('success', 'Trim start set');
      },

      setTrimEnd() {
        const video = document.getElementById('videoPlayer');
        this.trimEnd = video.currentTime;
        document.getElementById('trimEnd').value = this.formatTime(video.currentTime);
        this.updateTrimRegion();
        this.showToast('success', 'Trim end set');
      },

      // Audio scrubbing state
      isScrubbing: false,
      scrubAudioEnabled: true,
      lastScrubTime: 0,
      scrubTimeout: null,
      wasPlaying: false,

      // Seek to position on timeline click
      seekToPosition(event) {
        // Don't seek if we're in the middle of scrubbing (handled by scrub logic)
        if (this.isScrubbing) return;
        
        const track = document.getElementById('timelineTrack');
        const video = document.getElementById('videoPlayer');
        if (!track || !video || !video.duration) return;
        
        const rect = track.getBoundingClientRect();
        const percent = Math.max(0, Math.min(1, (event.clientX - rect.left) / rect.width));
        video.currentTime = percent * video.duration;
        
        // Trigger audio scrub on click
        if (this.scrubAudioEnabled && !video.muted) {
          this.playAudioScrub();
        }
        
        this.updateTimeDisplay();
      },

      // Setup timeline scrubbing with audio
      setupTimelineScrubbing() {
        const track = document.getElementById('timelineTrack');
        const audioTrack = document.getElementById('audioTrack');
        const video = document.getElementById('videoPlayer');
        
        if (!track) return;

        const startScrub = (e) => {
          if (!this.videoPath || !video.duration) return;
          this.isScrubbing = true;
          this.wasPlaying = !video.paused;
          video.pause();
          document.body.style.cursor = 'ew-resize';
          this.handleScrubMove(e);
        };

        const moveScrub = (e) => {
          if (!this.isScrubbing) return;
          this.handleScrubMove(e);
        };

        const endScrub = () => {
          if (!this.isScrubbing) return;
          this.isScrubbing = false;
          document.body.style.cursor = '';
          video.pause(); // Ensure paused after scrub
          
          // Resume if was playing
          if (this.wasPlaying) {
            video.play();
          }
        };

        // Mouse events
        track.addEventListener('mousedown', startScrub);
        if (audioTrack) audioTrack.addEventListener('mousedown', startScrub);
        document.addEventListener('mousemove', moveScrub);
        document.addEventListener('mouseup', endScrub);

        // Touch events for mobile
        track.addEventListener('touchstart', (e) => {
          e.preventDefault();
          startScrub(e.touches[0]);
        });
        document.addEventListener('touchmove', (e) => {
          if (this.isScrubbing) {
            e.preventDefault();
            moveScrub(e.touches[0]);
          }
        });
        document.addEventListener('touchend', endScrub);
      },

      handleScrubMove(e) {
        const track = document.getElementById('timelineTrack');
        const video = document.getElementById('videoPlayer');
        
        if (!track || !video || !video.duration) return;

        const rect = track.getBoundingClientRect();
        const scrubPercent = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
        const newTime = scrubPercent * video.duration;

        // Update video position
        video.currentTime = newTime;
        
        // Play audio scrub using Web Audio API (smooth, sample-accurate)
        if (this.isAudioLoaded) {
          // Use word-aligned scrubbing if transcript available
          if (this.transcriptSegments && this.transcriptSegments.length > 0) {
            this.playWordAtTime(newTime);
          } else {
            // Fallback: only play if moved enough (reduces choppy overlapping)
            const timeDiff = Math.abs(newTime - (this.lastScrubTime || 0));
            if (timeDiff > 0.05) {
              this.playScrubAudio(newTime, 0.2, 1.0);
              this.lastScrubTime = newTime;
            }
          }
        }
        
        // Update display
        this.updateTimeDisplay();
        
        // Update teleprompter highlight during scrub
        this.updateTeleprompterHighlight(newTime);
        
        // Update playhead position
        const playheadPercent = (newTime / video.duration) * 100;
        document.getElementById('playhead').style.left = `${playheadPercent}%`;
      },

      // Word-aligned audio scrubbing - plays entire words for clear syllables
      playWordAtTime(time) {
        if (!this.transcriptSegments || !this.audioBuffer) {
          console.log('[Scrub] playWordAtTime - missing:', {
            hasSegments: !!this.transcriptSegments,
            hasAudioBuffer: !!this.audioBuffer
          });
          // Fallback to regular scrub
          this.playScrubAudio(time, 0.2, 1.0);
          return;
        }
        
        // Find the word segment at or near this time
        const word = this.transcriptSegments.find(seg => 
          time >= seg.start && time <= seg.end
        );
        
        // If not inside a word, find the nearest upcoming word
        const nearestWord = word || this.transcriptSegments.find(seg => seg.start > time);
        
        if (nearestWord && nearestWord !== this.lastPlayedWord) {
          this.lastPlayedWord = nearestWord;
          
          // Play from word start to word end (the whole word)
          const wordDuration = nearestWord.end - nearestWord.start;
          
          // Add small padding for natural sound
          const startTime = Math.max(0, nearestWord.start - 0.02);
          const duration = Math.min(wordDuration + 0.04, 0.8); // Cap at 800ms for long words
          
          console.log('[Scrub] Playing word:', nearestWord.text, 'at', startTime.toFixed(2), 'for', duration.toFixed(2) + 's');
          this.playScrubAudio(startTime, duration, 1.0);
        }
      },

      // Legacy playAudioScrub - now uses Web Audio
      playAudioScrub() {
        // Use Web Audio instead - this is now handled in handleScrubMove
        const video = document.getElementById('videoPlayer');
        if (!video || !this.isAudioLoaded) return;
        this.playScrubAudio(video.currentTime, 0.1, 1.0);
      },

      // Clean up old timeout-based scrub stop (kept for compatibility)
      stopLegacyScrub() {
        if (this.scrubTimeout) {
          clearTimeout(this.scrubTimeout);
          this.scrubTimeout = null;
        }
      },

      // Toggle audio scrubbing
      toggleAudioScrub() {
        this.scrubAudioEnabled = !this.scrubAudioEnabled;
        this.showToast('info', `Audio scrubbing ${this.scrubAudioEnabled ? 'enabled' : 'disabled'}`);
      },

      // Processing functions
      async trimVideo() {
        if (!this.videoPath) return;
        
        this.showProgress('Trimming Video...', 'Cutting your selected segment');
        
        try {
          const result = await window.videoEditor.trim(this.videoPath, {
            startTime: this.trimStart,
            endTime: this.trimEnd
          });
          
          this.hideProgress();
          
          if (result.error) {
            throw new Error(result.error);
          }
          
          this.showToast('success', 'Video trimmed successfully!');
          this.loadExports();
        } catch (error) {
          this.hideProgress();
          this.showToast('error', 'Trim failed: ' + error.message);
        }
      },

      async transcodeVideo() {
        if (!this.videoPath) return;
        
        const format = document.getElementById('outputFormat').value;
        const resolution = document.getElementById('resolution').value;
        
        this.showProgress('Converting Video...', `Converting to ${format.toUpperCase()}`);
        
        try {
          const qualitySettings = {
            'high': { crf: 18, preset: 'slow' },
            'medium': { crf: 23, preset: 'medium' },
            'low': { crf: 28, preset: 'fast' },
            'custom': { crf: 23, preset: 'medium' }
          };
          
          const settings = qualitySettings[this.quality];
          
          const result = await window.videoEditor.transcode(this.videoPath, {
            format: format,
            resolution: resolution || null,
            ...settings
          });
          
          this.hideProgress();
          
          if (result.error) {
            throw new Error(result.error);
          }
          
          this.showToast('success', 'Video converted successfully!');
          this.loadExports();
        } catch (error) {
          this.hideProgress();
          this.showToast('error', 'Conversion failed: ' + error.message);
        }
      },

      async extractAudio() {
        if (!this.videoPath) return;
        
        this.showProgress('Extracting Audio...', 'Creating audio file from video');
        
        try {
          const result = await window.videoEditor.extractAudio(this.videoPath, {
            format: 'mp3',
            audioBitrate: '192k'
          });
          
          this.hideProgress();
          
          if (result.error) {
            throw new Error(result.error);
          }
          
          this.showToast('success', 'Audio extracted successfully!');
          this.loadExports();
        } catch (error) {
          this.hideProgress();
          this.showToast('error', 'Extraction failed: ' + error.message);
        }
      },

      async compressVideo() {
        if (!this.videoPath) return;
        
        this.showProgress('Compressing Video...', 'Reducing file size');
        
        try {
          const result = await window.videoEditor.compress(this.videoPath, {
            quality: 'medium'
          });
          
          this.hideProgress();
          
          if (result.error) {
            throw new Error(result.error);
          }
          
          this.showToast('success', 'Video compressed successfully!');
          this.loadExports();
        } catch (error) {
          this.hideProgress();
          this.showToast('error', 'Compression failed: ' + error.message);
        }
      },

      async transcribeVideo() {
        if (!this.videoPath) return;
        
        this.showProgress('Transcribing...', 'Using AI to transcribe audio');
        
        try {
          const result = await window.videoEditor.transcribeRange(this.videoPath, {
            startTime: 0,
            endTime: this.videoInfo?.duration || null,
            language: 'en'
          });
          
          this.hideProgress();
          
          if (result.error) {
            throw new Error(result.error);
          }
          
          // Show transcription in a toast and copy to clipboard
          this.showToast('success', 'Transcription complete! Copied to clipboard.');
          if (result.transcription) {
            navigator.clipboard.writeText(result.transcription);
            console.log('Transcription:', result.transcription);
          }
        } catch (error) {
          this.hideProgress();
          this.showToast('error', 'Transcription failed: ' + error.message);
        }
      },

      async generateThumbnails() {
        if (!this.videoPath) return;
        
        this.showProgress('Generating Thumbnails...', 'Creating preview images');
        
        try {
          const result = await window.videoEditor.generateThumbnails(this.videoPath, {
            count: 5,
            size: '640x360'
          });
          
          this.hideProgress();
          
          if (result.error) {
            throw new Error(result.error);
          }
          
          this.showToast('success', `Generated ${result.length} thumbnails!`);
        } catch (error) {
          this.hideProgress();
          this.showToast('error', 'Thumbnail generation failed: ' + error.message);
        }
      },

      // Progress modal
      showProgress(title, subtitle) {
        document.getElementById('progressTitle').textContent = title;
        document.getElementById('progressSubtitle').textContent = subtitle;
        document.getElementById('progressFill').style.width = '0%';
        document.getElementById('progressPercent').textContent = '0%';
        document.getElementById('progressStatus').textContent = 'Starting...';
        document.getElementById('progressModal').classList.add('visible');
      },

      updateProgress(progress) {
        const percent = Math.round(progress.percent || 0);
        document.getElementById('progressFill').style.width = `${percent}%`;
        document.getElementById('progressPercent').textContent = `${percent}%`;
        document.getElementById('progressStatus').textContent = progress.timemark || 'Processing...';
        this.currentJobId = progress.jobId;
      },

      hideProgress() {
        document.getElementById('progressModal').classList.remove('visible');
        this.currentJobId = null;
      },

      async cancelJob() {
        if (this.currentJobId) {
          await window.videoEditor.cancelJob(this.currentJobId);
          this.hideProgress();
          this.showToast('warning', 'Operation cancelled');
        }
      },

      // Tab switching
      switchTab(tabName) {
        this.currentTab = tabName;
        
        document.querySelectorAll('.sidebar-tab').forEach(tab => {
          tab.classList.toggle('active', tab.dataset.tab === tabName);
        });
        
        document.getElementById('editTab').classList.toggle('hidden', tabName !== 'edit');
        document.getElementById('scenesTab').classList.toggle('hidden', tabName !== 'scenes');
        document.getElementById('spacesTab').classList.toggle('hidden', tabName !== 'spaces');
        document.getElementById('exportsTab').classList.toggle('hidden', tabName !== 'exports');
        
        // Render scenes list when switching to scenes tab
        if (tabName === 'scenes') {
          this.renderScenesList();
        }
      },

      // Load spaces
      async loadSpaces() {
        try {
          if (!window.spaces) {
            document.getElementById('spacesList').innerHTML = '<p style="color: var(--text-muted); font-size: 13px;">Spaces not available</p>';
            return;
          }

          const spaces = await window.spaces.getAll();
          const list = document.getElementById('spacesList');

          if (!spaces || spaces.length === 0) {
            list.innerHTML = '<p style="color: var(--text-muted); font-size: 13px;">No spaces found</p>';
            return;
          }

          list.innerHTML = spaces.map(space => `
            <div class="space-item" onclick="app.selectSpace('${space.id}', '${space.name}')" data-space-id="${space.id}">
              <div class="space-icon"></div>
              <div class="space-info">
                <div class="space-name">${space.name}</div>
                <div class="space-count">${space.itemCount || 0} items</div>
              </div>
            </div>
          `).join('');
        } catch (error) {
          console.error('Error loading spaces:', error);
        }
      },

      async selectSpace(spaceId, spaceName) {
        this.selectedSpace = { id: spaceId, name: spaceName };
        
        // Update active state
        document.querySelectorAll('.space-item').forEach(item => {
          item.classList.toggle('active', item.dataset.spaceId === spaceId);
        });
        
        // Load videos from space
        try {
          const items = await window.spaces.getItems(spaceId);
          const videos = items.filter(item => 
            item.fileType === 'video' || 
            (item.fileName && this.isVideoFile(item.fileName))
          );
          
          const section = document.getElementById('spaceVideosSection');
          const container = document.getElementById('spaceVideos');
          
          if (videos.length === 0) {
            container.innerHTML = '<p style="color: var(--text-muted); font-size: 13px;">No videos in this space</p>';
          } else {
            container.innerHTML = videos.map(video => `
              <div class="video-item" onclick="app.loadVideoFromSpace('${video.id}')" data-video-id="${video.id}">
                <div class="video-thumb"></div>
                <div class="video-info">
                  <div class="video-name">${video.fileName || video.name}</div>
                  <div class="video-meta">${this.formatBytes(video.fileSize || video.size)}</div>
                </div>
              </div>
            `).join('');
          }
          
          section.style.display = 'block';
        } catch (error) {
          console.error('Error loading space videos:', error);
        }
      },

      async loadVideoFromSpace(videoId) {
        if (!videoId) {
          this.showToast('error', 'Invalid video ID');
          return;
        }
        
        try {
          // Get the actual file path from the backend
          console.log('[VideoEditor] Getting path for video:', videoId);
          const result = await window.spaces.getVideoPath(videoId);
          
          if (!result.success || !result.filePath) {
            this.showToast('error', result.error || 'Video file not found');
            return;
          }
          
          console.log('[VideoEditor] Loading video from path:', result.filePath);
          
          // Track that this video is from a Space (for Save to Space feature)
          this.spaceItemId = videoId;
          this.spaceItemName = result.fileName || 'Video';
          
          // Load existing scenes if any
          if (result.scenes && result.scenes.length > 0) {
            console.log('[VideoEditor] Loading existing scenes:', result.scenes.length);
            this.loadScenesFromSpace(result.scenes);
          }
          
          // Load transcription segments for waveform word display and teleprompter
          this.transcriptSegments = null; // Reset first
          this.pendingTranscriptText = null; // Store raw text for deferred segment creation
          try {
            const transcriptResult = await window.clipboard.getTranscription(videoId);
            console.log('[VideoEditor] Transcription result:', {
              success: transcriptResult?.success,
              hasTranscription: !!transcriptResult?.transcription,
              source: transcriptResult?.source,
              hasSegments: !!transcriptResult?.segments,
              transcriptLength: transcriptResult?.transcription?.length
            });
            
            if (transcriptResult?.success && transcriptResult.transcription) {
              // First check if segments are returned directly from getTranscription
              let segments = transcriptResult.segments;
              
              // If no segments, check metadata
              if (!segments) {
                const metadataResult = await window.clipboard.getMetadata(videoId);
                segments = metadataResult?.transcriptSegments ||
                           metadataResult?.transcript?.segments ||
                           metadataResult?.words ||
                           null;
              }
              
              if (segments && segments.length > 0) {
                this.transcriptSegments = segments;
                console.log('[VideoEditor] Loaded', segments.length, 'timed transcript segments');
                if (this.teleprompterVisible) {
                  this.initTeleprompter();
                }
              } else {
                // No timed segments - store the raw text to create segments after video loads
                // This ensures we have the correct video duration
                console.log('[VideoEditor] No timed segments, deferring segment creation until video loads');
                this.pendingTranscriptText = transcriptResult.transcription;
              }
            }
          } catch (e) {
            console.log('[VideoEditor] Could not load transcript segments:', e.message);
          }
          
          this.loadVideo(result.filePath);
          this.switchTab('edit');
          
          // Show save button
          this.updateSaveToSpaceButton();
        } catch (error) {
          console.error('[VideoEditor] Error loading video from space:', error);
          this.showToast('error', 'Failed to load video: ' + error.message);
        }
      },
      
      // Load scenes from space metadata into markers
      loadScenesFromSpace(scenes) {
        // Clear existing markers
        this.markers = [];
        this.nextMarkerId = 1;
        
        scenes.forEach(scene => {
          this.markers.push({
            id: this.nextMarkerId++,
            type: 'range',
            name: scene.name || `Scene ${scene.id}`,
            time: scene.inTime,
            timeIn: scene.inTime,
            timeOut: scene.outTime,
            color: this.markerColors[(scene.id - 1) % this.markerColors.length],
            description: scene.description || '',
            transcription: scene.transcription || '',
            tags: scene.tags || [],
            notes: scene.notes || '',
            created: scene.created || new Date().toISOString(),
            modified: new Date().toISOString()
          });
        });
        
        this.renderMarkers();
        this.updateMarkersPanel();
      },
      
      // Update the Save to Space button visibility
      updateSaveToSpaceButton() {
        const saveBtn = document.getElementById('saveToSpaceBtn');
        if (saveBtn) {
          saveBtn.style.display = this.spaceItemId ? 'inline-flex' : 'none';
          saveBtn.disabled = !this.spaceItemId;
        }
      },

      // Load exports
      async loadExports() {
        try {
          const exports = await window.videoEditor.getExports();
          const list = document.getElementById('exportsList');
          
          if (!exports || exports.length === 0) {
            list.innerHTML = '<p style="color: var(--text-muted); font-size: 13px;">No exports yet</p>';
            return;
          }
          
          list.innerHTML = exports.slice(0, 20).map(file => `
            <div class="export-item">
              <div class="export-icon"></div>
              <div class="export-info">
                <div class="export-name">${file.name}</div>
                <div class="export-size">${this.formatBytes(file.size)}</div>
              </div>
              <div class="export-actions">
                <button class="export-action-btn" onclick="app.loadVideo('${file.path}')" title="Load"></button>
                <button class="export-action-btn" onclick="app.revealFile('${file.path}')" title="Show in Finder"></button>
              </div>
            </div>
          `).join('');
        } catch (error) {
          console.error('Error loading exports:', error);
        }
      },

      async revealFile(filePath) {
        try {
          await window.videoEditor.revealFile(filePath);
        } catch (error) {
          console.error('Error revealing file:', error);
        }
      },

      async openExportFolder() {
        try {
          const dir = await window.videoEditor.getOutputDir();
          await window.videoEditor.revealFile(dir);
        } catch (error) {
          console.error('Error opening export folder:', error);
        }
      },

      showExportOptions() {
        // For now, just use transcode
        this.transcodeVideo();
      },

      // Utility functions
      formatTime(seconds) {
        if (!seconds || isNaN(seconds)) return '00:00:00';
        const hrs = Math.floor(seconds / 3600);
        const mins = Math.floor((seconds % 3600) / 60);
        const secs = Math.floor(seconds % 60);
        return `${hrs.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
      },

      parseTime(timeStr) {
        if (typeof timeStr === 'number') return timeStr;
        const parts = timeStr.split(':').map(Number);
        if (parts.length === 3) {
          return parts[0] * 3600 + parts[1] * 60 + parts[2];
        } else if (parts.length === 2) {
          return parts[0] * 60 + parts[1];
        }
        return parseFloat(timeStr) || 0;
      },

      formatBytes(bytes) {
        if (!bytes) return '0 B';
        const sizes = ['B', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(1024));
        return `${(bytes / Math.pow(1024, i)).toFixed(1)} ${sizes[i]}`;
      },

      // Toast notifications
      showToast(type, message) {
        const container = document.getElementById('toastContainer');
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        
        const icons = {
          success: '',
          error: '',
          warning: ''
        };
        
        toast.innerHTML = `
          <span class="toast-icon">${icons[type]}</span>
          <span class="toast-message">${message}</span>
        `;
        
        container.appendChild(toast);
        
        setTimeout(() => toast.classList.add('visible'), 10);
        
        setTimeout(() => {
          toast.classList.remove('visible');
          setTimeout(() => toast.remove(), 300);
        }, 4000);
      }
    };

    // Initialize on load
    document.addEventListener('DOMContentLoaded', () => {
      app.init();
      
      // Add event listener to transcription textarea to update ElevenLabs button
      const transcriptionField = document.getElementById('markerTranscription');
      if (transcriptionField) {
        transcriptionField.addEventListener('input', () => {
          app.updateElevenLabsButton();
        });
      }
    });
  </script>

  <!-- Translation Panel (Slide-in) -->
  <div class="translation-panel" id="translationPanel">
    <div class="translation-panel-header">
      <div class="translation-panel-title">Translate Segment</div>
      <button class="translation-panel-close" onclick="app.closeTranslationPanel()">
        <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M18 6L6 18M6 6l12 12"/>
        </svg>
      </button>
    </div>
    
    <div class="translation-panel-content">
      <!-- Segment Info -->
      <div class="translation-step">
        <div class="translation-step-header">
          <div class="translation-step-number">1</div>
          <div class="translation-step-title">Source Text</div>
        </div>
        <div class="translation-text-box" id="translationSourceText" contenteditable="true">
          Select a region on the timeline to translate
        </div>
        <div style="display: flex; gap: 8px; margin-top: 8px;">
          <select class="form-select" id="sourceLanguage" style="flex: 1;">
            <option value="auto">Auto-detect</option>
            <option value="uk">Ukrainian</option>
            <option value="ru">Russian</option>
            <option value="es">Spanish</option>
            <option value="fr">French</option>
            <option value="de">German</option>
            <option value="zh">Chinese</option>
            <option value="ja">Japanese</option>
            <option value="ko">Korean</option>
          </select>
          <span style="padding: 8px; color: var(--text-muted);"></span>
          <select class="form-select" id="targetLanguage" style="flex: 1;">
            <option value="en">English</option>
            <option value="es">Spanish</option>
            <option value="fr">French</option>
            <option value="de">German</option>
            <option value="pt">Portuguese</option>
            <option value="it">Italian</option>
            <option value="nl">Dutch</option>
            <option value="pl">Polish</option>
            <option value="ja">Japanese</option>
            <option value="zh">Chinese</option>
          </select>
        </div>
      </div>

      <!-- Translation Output -->
      <div class="translation-step">
        <div class="translation-step-header">
          <div class="translation-step-number">2</div>
          <div class="translation-step-title">Translation</div>
          <span id="translationIteration" style="margin-left: auto; font-size: 11px; color: var(--text-muted);">Iteration 0/5</span>
        </div>
        <div class="translation-text-box" id="translationOutput" contenteditable="true">
          Click "Translate" to generate
        </div>
        <div style="display: flex; gap: 8px; margin-top: 8px;">
          <button class="btn btn-secondary" onclick="app.startTranslation()" id="translateBtn" style="flex: 1;">
             Translate
          </button>
          <button class="btn btn-ghost" onclick="app.retryTranslation()" id="retryTranslateBtn" style="flex: 1;" disabled>
             Retry
          </button>
        </div>
      </div>

      <!-- Quality Scores -->
      <div class="translation-step" id="qualitySection" style="display: none;">
        <div class="translation-step-header">
          <div class="translation-step-number">3</div>
          <div class="translation-step-title">Quality Check</div>
        </div>
        <div class="translation-score-grid">
          <div class="translation-score-item">
            <span>Accuracy</span>
            <div class="translation-score-bar"><div class="translation-score-fill" id="scoreAccuracy" style="width: 0%"></div></div>
            <span class="translation-score-value" id="scoreAccuracyVal">-</span>
          </div>
          <div class="translation-score-item">
            <span>Fluency</span>
            <div class="translation-score-bar"><div class="translation-score-fill" id="scoreFluency" style="width: 0%"></div></div>
            <span class="translation-score-value" id="scoreFluencyVal">-</span>
          </div>
          <div class="translation-score-item">
            <span>Adequacy</span>
            <div class="translation-score-bar"><div class="translation-score-fill" id="scoreAdequacy" style="width: 0%"></div></div>
            <span class="translation-score-value" id="scoreAdequacyVal">-</span>
          </div>
          <div class="translation-score-item">
            <span>Cultural</span>
            <div class="translation-score-bar"><div class="translation-score-fill" id="scoreCultural" style="width: 0%"></div></div>
            <span class="translation-score-value" id="scoreCulturalVal">-</span>
          </div>
          <div class="translation-score-item">
            <span>Timing</span>
            <div class="translation-score-bar"><div class="translation-score-fill" id="scoreTiming" style="width: 0%"></div></div>
            <span class="translation-score-value" id="scoreTimingVal">-</span>
          </div>
        </div>
        <div class="translation-composite-score">
          <span class="translation-composite-value" id="compositeScore">-</span>
          <span class="translation-composite-label">/ 10</span>
        </div>
        
        <!-- Improvement Suggestions -->
        <div id="improvementSuggestions" style="margin-top: 16px; display: none;">
          <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 8px;"> Suggestions:</div>
          <div id="suggestionsList" style="font-size: 12px; color: var(--text-muted);"></div>
          <div style="display: flex; gap: 8px; margin-top: 8px;">
            <button class="btn btn-ghost" onclick="app.applyImprovements()" style="flex: 1;">Apply & Retry</button>
            <button class="btn btn-ghost" onclick="app.skipImprovements()" style="flex: 1;">Keep As-Is</button>
          </div>
        </div>
      </div>

      <!-- Generate Audio -->
      <div class="translation-step" id="audioSection" style="display: none;">
        <div class="translation-step-header">
          <div class="translation-step-number">4</div>
          <div class="translation-step-title">Generate Voice</div>
        </div>
        <div style="display: flex; gap: 8px; margin-bottom: 12px;">
          <select class="form-select" id="voiceSelect" style="flex: 1;">
            <option value="rachel">Rachel (Female)</option>
            <option value="adam">Adam (Male)</option>
            <option value="sarah">Sarah (Female)</option>
            <option value="josh">Josh (Male)</option>
            <option value="emily">Emily (Female)</option>
          </select>
          <select class="form-select" id="voiceSpeed" style="width: 80px;">
            <option value="0.8">0.8x</option>
            <option value="0.9">0.9x</option>
            <option value="1.0" selected>1.0x</option>
            <option value="1.1">1.1x</option>
            <option value="1.2">1.2x</option>
          </select>
        </div>
        <button class="btn btn-secondary" onclick="app.generateTranslationAudio()" style="width: 100%;">
           Generate Audio
        </button>
        
        <!-- Audio Preview -->
        <div id="audioPreviewSection" style="margin-top: 12px; display: none;">
          <audio id="translationAudioPreview" controls style="width: 100%; height: 32px;"></audio>
          <div style="display: flex; justify-content: space-between; margin-top: 8px; font-size: 11px; color: var(--text-muted);">
            <span>Source: <span id="sourceDuration">0.0s</span></span>
            <span>Generated: <span id="generatedDuration">0.0s</span></span>
            <span>: <span id="durationDelta">0.0s</span></span>
          </div>
          <div style="margin-top: 8px; font-size: 11px;">
            <span style="color: var(--text-secondary);">Timing fix:</span>
            <label style="margin-left: 8px;"><input type="radio" name="timingFix" value="none" checked> As-is</label>
            <label style="margin-left: 8px;"><input type="radio" name="timingFix" value="stretch_audio"> Stretch audio</label>
            <label style="margin-left: 8px;"><input type="radio" name="timingFix" value="speed_video"> Speed video</label>
          </div>
        </div>
      </div>

      <!-- Apply to Timeline -->
      <div class="translation-step" id="applySection" style="display: none;">
        <button class="btn btn-primary" onclick="app.applyTranslationToTimeline()" style="width: 100%;">
           Apply to Timeline
        </button>
      </div>
    </div>
  </div>

  <!-- Audio Sweetening Panel -->
  <div class="translation-panel" id="audioSweeteningPanel" style="width: 400px;">
    <div class="translation-panel-header">
      <div class="translation-panel-title"> Audio Sweetening</div>
      <button class="translation-panel-close" onclick="app.closeAudioSweeteningPanel()">
        <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M18 6L6 18M6 6l12 12"/>
        </svg>
      </button>
    </div>
    
    <div class="translation-panel-content">
      <!-- ElevenLabs SFX Section -->
      <div class="translation-step">
        <div class="translation-step-header">
          <div class="translation-step-title">ElevenLabs Sound Effects</div>
        </div>
        <input type="text" 
               class="beat-field-input" 
               id="sfxSearchInput" 
               placeholder="Search sound effects..."
               onkeyup="app.searchElevenLabsSFX(event)">
        
        <div id="sfxResults" style="margin-top: 12px; max-height: 200px; overflow-y: auto;">
          <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px;">
            <button class="btn btn-ghost" onclick="app.addSFXToTrack('whoosh')" style="justify-content: flex-start;">
              <span> Whoosh</span>
            </button>
            <button class="btn btn-ghost" onclick="app.addSFXToTrack('click')" style="justify-content: flex-start;">
              <span> Click</span>
            </button>
            <button class="btn btn-ghost" onclick="app.addSFXToTrack('notification')" style="justify-content: flex-start;">
              <span> Notification</span>
            </button>
            <button class="btn btn-ghost" onclick="app.addSFXToTrack('transition')" style="justify-content: flex-start;">
              <span> Transition</span>
            </button>
            <button class="btn btn-ghost" onclick="app.addSFXToTrack('applause')" style="justify-content: flex-start;">
              <span> Applause</span>
            </button>
            <button class="btn btn-ghost" onclick="app.addSFXToTrack('error')" style="justify-content: flex-start;">
              <span> Error</span>
            </button>
            <button class="btn btn-ghost" onclick="app.addSFXToTrack('success')" style="justify-content: flex-start;">
              <span> Success</span>
            </button>
            <button class="btn btn-ghost" onclick="app.addSFXToTrack('swoosh')" style="justify-content: flex-start;">
              <span> Swoosh</span>
            </button>
          </div>
        </div>

        <div style="margin-top: 12px;">
          <audio id="sfxPreviewAudio" controls style="width: 100%; height: 32px; display: none;"></audio>
        </div>
      </div>

      <div style="margin: 16px 0; border-top: 1px solid var(--border-color);"></div>

      <!-- Import Audio Section -->
      <div class="translation-step">
        <div class="translation-step-header">
          <div class="translation-step-title">Import Audio Files</div>
        </div>
        
        <div class="ai-video-upload-zone" 
             onclick="document.getElementById('audioImportInput').click()"
             ondragover="app.handleAudioDragOver(event)"
             ondragleave="app.handleAudioDragLeave(event)"
             ondrop="app.handleAudioDrop(event)"
             style="padding: 24px; margin-bottom: 12px;">
          <div style="font-size: 32px; margin-bottom: 8px;"></div>
          <div style="font-size: 12px; color: var(--text-secondary);">Drop audio here or click to browse</div>
          <div style="font-size: 10px; color: var(--text-muted); margin-top: 4px;">MP3, WAV, M4A, OGG</div>
        </div>
        <input type="file" 
               id="audioImportInput" 
               accept="audio/*" 
               multiple
               style="display: none;"
               onchange="app.handleAudioImport(event)">

        <!-- Recent Files -->
        <div id="recentAudioFiles" style="margin-top: 12px;">
          <div style="font-size: 11px; color: var(--text-muted); margin-bottom: 8px;">RECENT</div>
          <div id="recentAudioList" style="display: flex; flex-direction: column; gap: 4px;">
            <div style="font-size: 11px; color: var(--text-muted); padding: 8px; text-align: center;">
              No recent audio files
            </div>
          </div>
        </div>
      </div>

      <div style="margin: 16px 0; padding: 12px; background: var(--bg-surface); border-radius: 8px; font-size: 11px; color: var(--text-secondary);">
         Tip: Drop audio files directly on timeline tracks to add them at a specific position
      </div>
    </div>
  </div>

  <!-- AI Video Replacement Panel -->
  <div class="ai-video-panel" id="aiVideoPanel">
    <div class="ai-video-panel-header">
      <div class="ai-video-panel-title">
        <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/>
          <circle cx="12" cy="13" r="4"/>
        </svg>
        AI Video Replacement
      </div>
      <button class="ai-video-panel-close" onclick="app.closeAIVideoPanel()">
        <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M18 6L6 18M6 6l12 12"/>
        </svg>
      </button>
    </div>

    <div class="ai-video-panel-content">
      <!-- Segment Info -->
      <div class="ai-video-info-bar">
        <div class="ai-video-info-item">
          <span class="ai-video-info-label">Region</span>
          <span class="ai-video-info-value" id="aiVideoRegion">00:15.00 - 00:22.50</span>
        </div>
        <div class="ai-video-info-item">
          <span class="ai-video-info-label">Duration</span>
          <span class="ai-video-info-value" id="aiVideoDuration">7.5s</span>
        </div>
        <div class="ai-video-info-item">
          <span class="ai-video-info-label">Resolution</span>
          <span class="ai-video-info-value" id="aiVideoResolution">19201080</span>
        </div>
      </div>

      <!-- Description Input -->
      <div class="ai-video-section">
        <div class="ai-video-section-title">What should this segment show?</div>
        <textarea class="ai-video-description" id="aiVideoDescription" placeholder="Describe the video you want to generate...

Example: A modern office with people collaborating around a digital whiteboard, bright natural lighting, camera slowly panning left to right"></textarea>
      </div>

      <!-- Generated Prompt -->
      <div class="ai-video-section">
        <div class="ai-video-section-title">Optimized Prompt</div>
        <div class="ai-video-prompt-box" id="aiVideoPromptBox">
          <span id="aiVideoPrompt">Enter a description above, then click "Generate Prompt"</span>
        </div>
        <div class="ai-video-prompt-actions">
          <button class="btn btn-secondary" onclick="app.generateVideoPrompt()">
             Generate Prompt
          </button>
          <button class="btn btn-ghost" onclick="app.copyVideoPrompt()">
             Copy
          </button>
        </div>
      </div>

      <!-- External Services -->
      <div class="ai-video-section">
        <div class="ai-video-section-title">Generate Video At</div>
        <div class="ai-video-services">
          <button class="ai-video-service-btn" onclick="app.openVideoService('kling')">
            <span class="service-icon"></span>
            <span class="service-name">Kling.ai</span>
          </button>
          <button class="ai-video-service-btn" onclick="app.openVideoService('veo')">
            <span class="service-icon"></span>
            <span class="service-name">Google Veo</span>
          </button>
          <button class="ai-video-service-btn" onclick="app.openVideoService('runway')">
            <span class="service-icon"></span>
            <span class="service-name">Runway</span>
          </button>
          <button class="ai-video-service-btn" onclick="app.openVideoService('pika')">
            <span class="service-icon"></span>
            <span class="service-name">Pika Labs</span>
          </button>
          <button class="ai-video-service-btn" onclick="app.openVideoService('luma')">
            <span class="service-icon"></span>
            <span class="service-name">Luma Dream</span>
          </button>
          <button class="ai-video-service-btn" onclick="app.openVideoService('sora')">
            <span class="service-icon"></span>
            <span class="service-name">OpenAI Sora</span>
          </button>
        </div>
        <p style="font-size: 11px; color: var(--text-muted); margin-top: 12px; text-align: center;">
          Opens in browser with prompt copied to clipboard
        </p>
      </div>

      <div class="ai-video-divider">or upload your video</div>

      <!-- Upload Zone -->
      <div class="ai-video-section">
        <div class="ai-video-upload-zone" 
             id="aiVideoUploadZone"
             onclick="document.getElementById('aiVideoUploadInput').click()"
             ondragover="app.handleAIVideoDragOver(event)"
             ondragleave="app.handleAIVideoDragLeave(event)"
             ondrop="app.handleAIVideoDrop(event)">
          <div class="ai-video-upload-icon"></div>
          <div class="ai-video-upload-text">Drop video here or click to browse</div>
          <div class="ai-video-upload-hint">Accepts MP4, MOV, WebM  Max 500MB</div>
        </div>
        <input type="file" 
               class="ai-video-upload-input" 
               id="aiVideoUploadInput" 
               accept="video/*"
               onchange="app.handleAIVideoUpload(event)">
      </div>

      <!-- Preview Section (shown after upload) -->
      <div class="ai-video-section" id="aiVideoPreviewSection" style="display: none;">
        <div class="ai-video-section-title">Preview</div>
        <video id="aiVideoPreview" controls style="width: 100%; border-radius: 8px; background: #000;"></video>
        <div style="display: flex; gap: 8px; margin-top: 12px;">
          <button class="btn btn-ghost" onclick="app.cancelAIVideoUpload()" style="flex: 1;">
            Cancel
          </button>
          <button class="btn btn-primary" onclick="app.applyAIVideoToTimeline()" style="flex: 1;">
            Apply to Timeline
          </button>
        </div>
      </div>
    </div>
  </div>
</body>
</html>

